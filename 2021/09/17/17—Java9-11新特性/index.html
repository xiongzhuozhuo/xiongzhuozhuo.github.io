<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","images":"/images","scheme":"Gemini","version":"8.2.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="Java9-11新特性">
<meta property="og:type" content="article">
<meta property="og:title" content="17-Java9-11新特性">
<meta property="og:url" content="https://github.com/xiongzhuozhuo/xiongzhuozhuo.github.io/2021/09/17/17%E2%80%94Java9-11%E6%96%B0%E7%89%B9%E6%80%A7/index.html">
<meta property="og:site_name" content="XiongZhuo">
<meta property="og:description" content="Java9-11新特性">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108080917519.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108080941534.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108080957522.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108080957918.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081013971.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081043772.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081043200.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081036316.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081048714.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081053467.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081050436.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081053129.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081104251.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081107445.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081108538.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081122668.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081125124.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081131794.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081148488.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081156419.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081157689.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081157245.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081158219.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081204031.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081204464.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081206960.png">
<meta property="og:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081206006.png">
<meta property="article:published_time" content="2021-09-16T17:27:14.975Z">
<meta property="article:modified_time" content="2021-08-16T14:18:22.661Z">
<meta property="article:author" content="软糖豆人">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108080917519.png">


<link rel="canonical" href="https://github.com/xiongzhuozhuo/xiongzhuozhuo.github.io/2021/09/17/17%E2%80%94Java9-11%E6%96%B0%E7%89%B9%E6%80%A7/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>17-Java9-11新特性 | XiongZhuo</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="XiongZhuo" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>
  
<a href="https://github.com/xiongzhuozhuo" class="github-corner" aria-label="View source on GitHub">
<svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
<path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
<path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
</svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>


  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">XiongZhuo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#17%E2%80%94Java9%E2%80%9411%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.</span> <span class="nav-text">17—Java9—11新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Java9%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">1. Java9的特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-1-JDK9%E7%9A%84%E5%8F%91%E5%B8%83"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1 JDK9的发布</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-Java9%E4%B8%AD%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 Java9中新特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-JDK%E5%92%8CJRE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E7%9A%84%E6%94%B9%E5%8F%98"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3 JDK和JRE目录结构的改变</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-4-%E6%A8%A1%E5%9D%97%E5%8C%96%E7%B3%BB%E7%BB%9F%EF%BC%9AJigsaw-gt-Modularity"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.4 模块化系统：Jigsaw -&gt; Modularity</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-Java%E7%9A%84REPL%E5%B7%A5%E5%85%B7%EF%BC%9AjShell%E5%91%BD%E4%BB%A4"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.5 Java的REPL工具：jShell命令</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-6-%E8%AF%AD%E6%B3%95%E6%94%B9%E8%BF%9B%EF%BC%9A"><span class="nav-number">1.1.6.</span> <span class="nav-text">1.6 语法改进：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-7-String%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E5%8F%98%E6%9B%B4"><span class="nav-number">1.1.7.</span> <span class="nav-text">1.7 String存储结构变更</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-8-%E9%9B%86%E5%90%88%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E5%8F%AA%E8%AF%BB%E9%9B%86%E5%90%88"><span class="nav-number">1.1.8.</span> <span class="nav-text">1.8 集合工厂方法：快速创建只读集合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-9-InputStream%E5%8A%A0%E5%BC%BA"><span class="nav-number">1.1.9.</span> <span class="nav-text">1.9 InputStream加强</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-%E5%A2%9E%E5%BC%BA%E7%9A%84-Stream-API"><span class="nav-number">1.1.10.</span> <span class="nav-text">1.10 增强的 Stream API</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#takeWhile-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.1.10.1.</span> <span class="nav-text">takeWhile()的使用</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-11-Javascript%E5%BC%95%E6%93%8E%E5%8D%87%E7%BA%A7%EF%BC%9ANashorn"><span class="nav-number">1.1.11.</span> <span class="nav-text">1.11 Javascript引擎升级：Nashorn</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Java10%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">2. Java10的新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1 局部变量类型推断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-%E9%9B%86%E5%90%88%E6%96%B0%E5%A2%9E%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2 集合新增创建不可变集合的方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Java11%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.3.</span> <span class="nav-text">3. Java11的新特性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-%E6%96%B0%E5%A2%9E%E4%BA%86%E4%B8%80%E7%B3%BB%E5%88%97%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1 新增了一系列字符串处理方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-Optional%E5%8A%A0%E5%BC%BA"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2 Optional加强</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD%E5%8D%87%E7%BA%A7"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3 局部变量类型推断升级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-4-%E5%85%A8%E6%96%B0%E7%9A%84HTTP-%E5%AE%A2%E6%88%B7%E7%AB%AFAPI"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4 全新的HTTP 客户端API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-5-%E6%9B%B4%E7%AE%80%E5%8C%96%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.5 更简化的编译运行程序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-6-%E5%BA%9F%E5%BC%83Nashorn%E5%BC%95%E6%93%8E"><span class="nav-number">1.3.6.</span> <span class="nav-text">3.6 废弃Nashorn引擎</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-7-ZGC"><span class="nav-number">1.3.7.</span> <span class="nav-text">3.7 ZGC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-8-%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number">1.3.8.</span> <span class="nav-text">3.8 其他新特性</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="软糖豆人"
      src="/images/candy.png">
  <p class="site-author-name" itemprop="name">软糖豆人</p>
  <div class="site-description" itemprop="description">网站分享</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/xiongzhuozhuo" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xiongzhuozhuo"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:xiongzhuo@outlook.com" title="E-Mail → mailto:xiongzhuo@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.bilibili.com/video/BV1TA411q75f" title="https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1TA411q75f" rel="noopener" target="_blank">Git学习教程</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.bilibili.com/video/BV16W411t7mq?p=1" title="https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV16W411t7mq?p&#x3D;1" rel="noopener" target="_blank">Hexo搭建博客</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.kuangstudy.com/" title="https:&#x2F;&#x2F;www.kuangstudy.com" rel="noopener" target="_blank">Java学习教程</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/xiongzhuozhuo/xiongzhuozhuo.github.io/2021/09/17/17%E2%80%94Java9-11%E6%96%B0%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/candy.png">
      <meta itemprop="name" content="软糖豆人">
      <meta itemprop="description" content="网站分享">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XiongZhuo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          17-Java9-11新特性
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-09-17 01:27:14" itemprop="dateCreated datePublished" datetime="2021-09-17T01:27:14+08:00">2021-09-17</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-08-16 22:18:22" itemprop="dateModified" datetime="2021-08-16T22:18:22+08:00">2021-08-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%BC%96%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">编程</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Changyan：</span>
    
    
      <a title="changyan" href="/2021/09/17/17%E2%80%94Java9-11%E6%96%B0%E7%89%B9%E6%80%A7/#SOHUCS" itemprop="discussionUrl">
        <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2021/09/17/17—Java9-11新特性/" itemprop="commentCount"></span>
      </a>
    
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>19k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>17 分钟</span>
    </span>
</div>

            <div class="post-description">Java9-11新特性</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <span id="more"></span>

<h3 id="17—Java9—11新特性"><a href="#17—Java9—11新特性" class="headerlink" title="17—Java9—11新特性"></a>17—Java9—11新特性</h3><h4 id="1-Java9的特性"><a href="#1-Java9的特性" class="headerlink" title="1. Java9的特性"></a>1. Java9的特性</h4><h5 id="1-1-JDK9的发布"><a href="#1-1-JDK9的发布" class="headerlink" title="1.1 JDK9的发布"></a>1.1 JDK9的发布</h5><p>经过4次跳票，历经曲折的Java 9 终于终于在2017年9月21日发布。从Java 9 这个版本开始，Java 的计划发布周期是 6 个月，下一个 Java 的主版 本将于 2018 年 3 月发布，命名为 Java 18.3，紧接着再过六个月将发布 Java  18.9。这意味着Java的更新从传统的以特性驱动的发布周期，转变为以时间驱动的 （6 个月为周期）发布模式，并逐步的将 Oracle JDK 原商业特性进行开源。针对企业客户的需求，Oracle 将以三年为周期发布长期支持版本（long term  support）。Java 9 提供了超过150项新功能特性，包括备受期待的模块化系统、可交互 的 REPL 工具：jshell，JDK 编译工具，Java 公共 API 和私有代码，以及安 全增强、扩展提升、性能管理改善等。可以说Java 9是一个庞大的系统工程， 完全做了一个整体改变。</p>
<h5 id="1-2-Java9中新特性"><a href="#1-2-Java9中新特性" class="headerlink" title="1.2 Java9中新特性"></a>1.2 Java9中新特性</h5><p>①模块化系统</p>
<p>②jShell命令</p>
<p>③多版本兼容jar包</p>
<p>④接口的私有方法</p>
<p>⑤钻石操作符的升级使用</p>
<p>⑥语法改进：try语句</p>
<p>⑦String存储结构变更</p>
<p>⑧便利的集合特性：of()</p>
<p>⑨增强的Stream API</p>
<p>⑩全新的HTTP客户端API</p>
<p>其他：javadoc的HTML 5支持、Javascript引擎升级：Nashorn、java的动态编译器</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-C23AFD78-C777-460B-8ACE-58BE5EA681F6">官方提供的新特性列表</a></p>
<p><a target="_blank" rel="noopener" href="http://openjdk.java.net/projects/jdk9/">JDK 9 (java.net)</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/9/">Oracle JDK 9 Documentation</a></p>
<h5 id="1-3-JDK和JRE目录结构的改变"><a href="#1-3-JDK和JRE目录结构的改变" class="headerlink" title="1.3 JDK和JRE目录结构的改变"></a>1.3 JDK和JRE目录结构的改变</h5><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108080917519.png" alt="JDK_HOME(JDK8)" style="zoom: 33%;" />

<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bin目录</td>
<td>包括命令行开发和调试工具，如javac,jar和javadoc</td>
</tr>
<tr>
<td>include目录</td>
<td>包含在编译本地代码时使用的C/C++头文件</td>
</tr>
<tr>
<td>lib目录</td>
<td>包含JDK的几个JAR和其他类型的文件。他有一个tools.jar文件，其中包含javac编译器的Java类</td>
</tr>
<tr>
<td>jre/bin目录</td>
<td>包含基本命令，如java命令。在Windows平台上，他包含系统的运行时动态链接库(DLL)</td>
</tr>
<tr>
<td>jre/lib目录</td>
<td>包含用户可编辑的配置文件，如.properties和.policy文件。包含了几个JAR。rt.jar文件包含运行时的Java类和资源文件</td>
</tr>
</tbody></table>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108080941534.png" alt="JDK_HOME(JDK9)" style="zoom:33%;" />

<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bin目录</td>
<td>包含所有命令。 在Windows平台上，它继续包含系统的运行时动态链接库。</td>
</tr>
<tr>
<td>conf 目录</td>
<td>包含用户可编辑的配置文件，例如以前位于jre\lib目录中的.properties和.policy文件</td>
</tr>
<tr>
<td>include 目录</td>
<td>包含要在以前编译本地代码时使用的C/C++头文件。 它只存在于JDK中</td>
</tr>
<tr>
<td>jmods 目录</td>
<td>包含JMOD格式的平台模块。 创建自定义运行时映像时需要它。 它只存在于JDK中</td>
</tr>
<tr>
<td>legal 目录</td>
<td>包含法律声明</td>
</tr>
<tr>
<td>lib 目录</td>
<td>包含非Windows平台上的动态链接本地库。 其子目录和文件不应由开发人员直接编辑或使用</td>
</tr>
</tbody></table>
<h5 id="1-4-模块化系统：Jigsaw-gt-Modularity"><a href="#1-4-模块化系统：Jigsaw-gt-Modularity" class="headerlink" title="1.4 模块化系统：Jigsaw -&gt; Modularity"></a>1.4 模块化系统：Jigsaw -&gt; Modularity</h5><ul>
<li>谈到 Java 9 大家往往第一个想到的就是 Jigsaw 项目。众所周知，Java 已经发展超过 20 年（95 年最初发布），Java 和相关生态在不断丰富的同时也越 来越暴露出一些问题：<ul>
<li>Java 运行环境的膨胀和臃肿。每次JVM启动的时候，至少会有30～60MB的内存加载，主要原因是JVM需要加载rt.jar，不管其中的类是否被classloader加载，第 一步整个jar都会被JVM加载到内存当中去（而模块化可以根据模块的需要加载程 序运行需要的class）</li>
<li>当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的 增长。不同版本的类库交叉依赖导致让人头疼的问题，这些都阻碍了 Java 开发和运行效率的提升。</li>
<li>很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间的依赖关系有个明确的概念。每一个公共类都可以被类路径之下任何其它的公共 类所访问到，这样就会导致无意中使用了并不想被公开访问的 API。</li>
</ul>
</li>
<li>本质上讲也就是说，用模块来管理各个package，通过声明某个package 暴露，，模块(module)的概念，其实就是package外再裹一层，不声明默 认就是隐藏。因此，模块化使得代码组织上更安全，因为它可以指定哪 些部分可以暴露，哪些部分隐藏。</li>
<li>实现目标<ul>
<li>模块化的主要目的在于减少内存的开销</li>
<li>只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的开 发和维护</li>
<li>改进 Java SE 平台，使其可以适应不同大小的计算设备</li>
<li>改进其安全性，可维护性，提高性能</li>
</ul>
</li>
</ul>
<p>模块将由通常的类和新的模块声明文件（module-info.java）组成。该文件是位于 java代码结构的顶层，该模块描述符明确地定义了我们的模块需要什么依赖关系， 以及哪些模块被外部使用。在exports子句中未提及的所有包默认情况下将封装在 模块中，不能在外部使用。</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108080957522.png" alt="image-20210808095732377"></p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108080957918.png" alt="image-20210808095749411"></p>
<p>要想在java9demo模块中调用java9test模块下包中的结构，需要在java9test 的module-info.java中声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> java9test &#123;</span><br><span class="line">	<span class="comment">//package we export</span></span><br><span class="line">	<span class="keyword">exports</span> com.atguigui.bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exports：控制着哪些包可以被其它模块访问到。所有不被导出的包默认 都被封装在模块里面。对应在java 9demo 模块的src 下创建module-info.java文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> java9demo &#123;</span><br><span class="line">	<span class="keyword">requires</span> java9test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>requires：指明对其它模块的依赖。</p>
<h5 id="1-5-Java的REPL工具：jShell命令"><a href="#1-5-Java的REPL工具：jShell命令" class="headerlink" title="1.5 Java的REPL工具：jShell命令"></a>1.5 Java的REPL工具：jShell命令</h5><ul>
<li><p>产生背景</p>
<p>像Python 和 Scala 之类的语言早就有交互式编程环境 REPL (read - evaluate - print - loop)了，以交互式的方式对语句和表达式进行求值。开发者只需要输入一些代码， 就可以在编译前获得对程序的反馈。而之前的Java版本要想执行代码，必须创建文 件、声明类、提供测试方法方可实现。</p>
</li>
<li><p>设计理念</p>
<p>即写即得、快速运行</p>
</li>
<li><p>实现目标</p>
<ul>
<li>Java 9 中终于拥有了 REPL工具：jShell。让Java可以像脚本语言一样运行，从 控制台启动jShell，利用jShell在没有创建类的情况下直接声明变量，计算表达式， 执行语句。即开发时可以在命令行里直接运行Java的代码，而无需创建Java文 件，无需跟人解释”public static void main(String[] args)”这句废话。</li>
<li>jShell也可以从文件中加载语句或者将语句保存到文件中。</li>
<li>jShell也可以是tab键进行自动补全和自动添加分号。</li>
</ul>
</li>
<li><p>调出jShell、获取帮助</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081013971.png" alt="image-20210808101348839"></p>
</li>
<li><p>基本使用</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081043772.png" alt="image-20210808104328412"></p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081043200.png" alt="image-20210808104353880"></p>
</li>
<li><p>列出当前session里所有有效的代码片段</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081036316.png" alt="image-20210808103614357"></p>
</li>
<li><p>查看当前session下所有创建过的变量和方法</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081048714.png" alt="image-20210808104838265"></p>
</li>
<li><p>使用外部代码编辑器来编写Java代码</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081053467.png" alt="image-20210808105331336"></p>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081050436.png" alt="image-20210808105026135" style="zoom: 67%;" />

<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081053129.png" alt="image-20210808105301293" style="zoom:67%;" />
</li>
<li><p>使用/open命令调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGUET</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello,GUET!&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloGUET.main(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081104251.png" alt="image-20210808110426385"></p>
</li>
<li><p>没有受检异常</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081107445.png" alt="image-20210808110710663"></p>
<p>说明：本来应该强迫我们捕获一个IOException，但却没有出现。因为jShell在 后台为我们隐藏了。</p>
</li>
<li><p>退出jShell</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081108538.png" alt="image-20210808110759934"></p>
</li>
</ul>
<h5 id="1-6-语法改进："><a href="#1-6-语法改进：" class="headerlink" title="1.6 语法改进："></a>1.6 语法改进：</h5><p><strong>接口的私有方法</strong></p>
<p>Java 8中规定接口中的方法除了抽象方法之外，还可以定义静态方法 和默认的方法。一定程度上，扩展了接口的功能，此时的接口更像是 一个抽象类。</p>
<p>在Java 9中，接口更加的灵活和强大，连方法的访问权限修饰符都可 以声明为private的了，此时方法将不会成为你对外暴露的API的一部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">normalInterfaceMethod</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	init();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// This method is not part of the public API exposed by MyInterface</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;默认方法中的通用操作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">normalInterfaceMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;实现接口的方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyInterfaceImpl impl = <span class="keyword">new</span> MyInterfaceImpl();</span><br><span class="line">		impl.methodDefault1();</span><br><span class="line">		<span class="comment">// impl.init();//不能调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>钻石操作符升级使用</strong></p>
<p>我们能够与匿名实现类共同使用钻石操作符（diamond operator）在Java 8中如下的操作是会报错的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Object&gt; com = <span class="keyword">new</span> Comparator&lt;&gt;()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译报错信息：Cannot use “&lt;&gt;” with anonymous inner classes.</p>
<p>Java 9中如下操作可以正常执行通过：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// anonymous classes can now use type inference</span></span><br><span class="line">Comparator&lt;Object&gt; com = <span class="keyword">new</span> Comparator&lt;&gt;()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>try语法</strong></p>
<p>Java 8 中，可以实现资源的自动关闭，但是要求执行后必须关闭的所有资源必 须在try子句中初始化，否则编译不通过。如下例所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in))&#123;</span><br><span class="line">	<span class="comment">//读取数据细节省略</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 9 中，用资源语句编写try将更容易，我们可以在try子句中使用已经初始 化过的资源，此时的资源是final的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(System.out);</span><br><span class="line"><span class="keyword">try</span> (reader; writer) &#123;</span><br><span class="line">	<span class="comment">//reader是final的，不可再被赋值</span></span><br><span class="line">	<span class="comment">//reader = null;</span></span><br><span class="line">	<span class="comment">//具体读写操作省略</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-7-String存储结构变更"><a href="#1-7-String存储结构变更" class="headerlink" title="1.7 String存储结构变更"></a>1.7 String存储结构变更</h5><p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081122668.png" alt="image-20210808112226517"></p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081125124.png" alt="image-20210808112513884"></p>
<h5 id="1-8-集合工厂方法：快速创建只读集合"><a href="#1-8-集合工厂方法：快速创建只读集合" class="headerlink" title="1.8 集合工厂方法：快速创建只读集合"></a>1.8 集合工厂方法：快速创建只读集合</h5><p>要创建一个只读、不可改变的集合，必须构造和分配它，然后添加元素，最后 包装成一个不可修改的集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; namesList = <span class="keyword">new</span> ArrayList &lt;&gt;();</span><br><span class="line">namesList.add(<span class="string">&quot;Joe&quot;</span>);</span><br><span class="line">namesList.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">namesList.add(<span class="string">&quot;Bill&quot;</span>);</span><br><span class="line">namesList = Collections.unmodifiableList(namesList);</span><br><span class="line">System.out.println(namesList);</span><br></pre></td></tr></table></figure>

<p>缺点：我们一下写了五行。即：它不能表达为单个表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.unmodifiableList(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line">Set&lt;String&gt; set = Collections.unmodifiableSet(<span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, </span><br><span class="line"><span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)));</span><br><span class="line"><span class="comment">// 如下操作不适用于jdk 8 及之前版本,适用于jdk 9</span></span><br><span class="line">Map&lt;String, Integer&gt; map = Collections.unmodifiableMap(<span class="keyword">new</span> HashMap&lt;&gt;() &#123;</span><br><span class="line">&#123;</span><br><span class="line">	put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">	put(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">	put(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">map.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;:&quot;</span> + v));</span><br></pre></td></tr></table></figure>

<p>Java 9因此引入了方便的方法，这使得类似的事情更容易表达。</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081131794.png" alt="image-20210808113143689"></p>
<p>List firsnamesList = List.of(“Joe”,”Bob”,”Bill”); 调用集合中静态方法of()，可以将不同数量的参数传输到此工厂方法中。此功能 可用于Set和List，也可用于Map的类似形式。此时得到的集合，是不可变的：在 创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。 由于Java 8中接口方法的实现，可以直接在List，Set和Map的接口内定义这些方法， 便于调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Set&lt;String&gt; set = Set.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map1 = Map.of(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="number">21</span>, <span class="string">&quot;Lilei&quot;</span>, <span class="number">33</span>, </span><br><span class="line"><span class="string">&quot;HanMeimei&quot;</span>, <span class="number">18</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map2 = Map.ofEntries(Map.entry(<span class="string">&quot;Tom&quot;</span>, <span class="number">89</span>), </span><br><span class="line">Map.entry(<span class="string">&quot;Jim&quot;</span>, <span class="number">78</span>), Map.entry(<span class="string">&quot;Tim&quot;</span>, <span class="number">98</span>));</span><br></pre></td></tr></table></figure>

<h5 id="1-9-InputStream加强"><a href="#1-9-InputStream加强" class="headerlink" title="1.9 InputStream加强"></a>1.9 InputStream加强</h5><p>InputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接 传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下 示例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader cl = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line"><span class="keyword">try</span> (InputStream is = cl.getResourceAsStream(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">	OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src\\hello1.txt&quot;</span>)) &#123;</span><br><span class="line">	is.transferTo(os); <span class="comment">// 把输入流中的所有数据直接自动地复制到输出流中</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-10-增强的-Stream-API"><a href="#1-10-增强的-Stream-API" class="headerlink" title="1.10 增强的 Stream API"></a>1.10 增强的 Stream API</h5><ul>
<li>Java 的 Steam API 是java标准库最好的改进之一，让开发者能够快速运算， 从而能够有效的利用数据并行计算。Java 8 提供的 Steam 能够利用多核架构 实现声明式的数据处理。</li>
<li>在 Java 9 中，Stream API 变得更好，Stream 接口中添加了 4 个新的方法： takeWhile, dropWhile, ofNullable，还有个 iterate 方法的新重载方法，可以 让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。</li>
<li>除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。 现在可以通过 Optional 的新方法 stream() 将一个 Optional 对象转换为一个 (可能是空的) Stream 对象。</li>
</ul>
<h6 id="takeWhile-的使用"><a href="#takeWhile-的使用" class="headerlink" title="takeWhile()的使用"></a><strong>takeWhile()的使用</strong></h6><p>用于从 Stream 中获取一部分数据，接收一个 Predicate 来进行选择。在有序的 Stream 中，takeWhile 返回从开头开始的尽量多的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>);</span><br><span class="line">list.stream().takeWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line">list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">list.stream().takeWhile(x -&gt; x &lt; <span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><strong>dropWhile()的使用</strong></p>
<p>dropWhile 的行为与 takeWhile 相反，返回剩余的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>);</span><br><span class="line">list.stream().dropWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line">list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">list.stream().dropWhile(x -&gt; x &lt; <span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><strong>ofNullable()的使用</strong></p>
<p>Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方 法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报NullPointerException</span></span><br><span class="line"><span class="comment">// Stream&lt;Object&gt; stream1 = Stream.of(null);</span></span><br><span class="line"><span class="comment">// System.out.println(stream1.count());</span></span><br><span class="line"><span class="comment">// 不报异常，允许通过</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">System.out.println(stringStream.count());<span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 不报异常，允许通过</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">list.add(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(list.stream().count());<span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ofNullable()：允许值为null</span></span><br><span class="line">Stream&lt;Object&gt; stream1 = Stream.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(stream1.count());<span class="comment">// 0</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.ofNullable(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">System.out.println(stream.count());<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><strong>iterator()重载使用</strong></p>
<p>这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什 么时候结束迭代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的控制终止方式：</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 现在的终止方式：</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i &lt; <span class="number">100</span>, i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Optional类中stream()的使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">Optional&lt;List&lt;String&gt;&gt; optional = Optional.ofNullable(list);</span><br><span class="line">Stream&lt;List&lt;String&gt;&gt; stream = optional.stream();</span><br><span class="line">stream.flatMap(x -&gt; x.stream()).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h5 id="1-11-Javascript引擎升级：Nashorn"><a href="#1-11-Javascript引擎升级：Nashorn" class="headerlink" title="1.11 Javascript引擎升级：Nashorn"></a>1.11 Javascript引擎升级：Nashorn</h5><ul>
<li>Nashorn 项目在 JDK 9 中得到改进，它为 Java 提供轻量级的 Javascript 运行时。 Nashorn 项目跟随 Netscape 的 Rhino 项目，目的是为了在 Java 中实现一个高 性能但轻量级的 Javascript 运行时。Nashorn 项目使得 Java 应用能够嵌入 Javascript。它在 JDK 8 中为 Java 提供一个 Javascript 引擎。</li>
<li>JDK 9 包含一个用来解析 Nashorn 的 ECMAScript 语法树的 API。这个 API 使得 IDE 和服务端框架不需要依赖 Nashorn 项目的内部实现类，就能够分析 ECMAScript 代码。</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081148488.png" alt="image-20210808114855330"></li>
</ul>
<h4 id="2-Java10的新特性"><a href="#2-Java10的新特性" class="headerlink" title="2. Java10的新特性"></a>2. Java10的新特性</h4><p>2018年3月21日，Oracle官方宣布Java10正式发布。需要注意的是 Java 9 和 Java 10 都不是 LTS (Long-Term-Support) 版本。和 过去的 Java 大版本升级不同，这两个只有半年左右的开发和维护期。而未 来的 Java 11，也就是 18.9 LTS，才是 Java 8 之后第一个 LTS 版本。JDK10一共定义了109个新特性，其中包含12个JEP（对于程序员来讲，真 正的新特性其实就一个），还有一些新API和JVM规范以及JAVA语言规范上 的改动。JDK10的12个JEP（JDK Enhancement Proposal特性加强提议）参阅官方 文档：<a target="_blank" rel="noopener" href="http://openjdk.java.net/projects/jdk/10/">http://openjdk.java.net/projects/jdk/10/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">286</span>: Local-Variable Type Inference 局部变量类型推断</span><br><span class="line"><span class="number">296</span>: Consolidate the JDK Forest into a Single Repository JDK库的合并</span><br><span class="line"><span class="number">304</span>: Garbage-Collector Interface 统一的垃圾回收接口</span><br><span class="line"><span class="number">307</span>: Parallel Full GC <span class="keyword">for</span> G1 为G1提供并行的Full GC</span><br><span class="line"><span class="number">310</span>: Application Class-Data Sharing 应用程序类数据（AppCDS）共享</span><br><span class="line"><span class="number">312</span>: Thread-Local Handshakes ThreadLocal握手交互</span><br><span class="line"><span class="number">313</span>: Remove the Native-<span class="function">Header Generation <span class="title">Tool</span> <span class="params">(javah)</span> 移除JDK中附带的javah工具</span></span><br><span class="line"><span class="function">314: Additional Unicode Language-Tag Extensions 使用附加的Unicode语言标记扩展</span></span><br><span class="line"><span class="function">316: Heap Allocation on Alternative Memory Devices 能将堆内存占用分配给用户指定</span></span><br><span class="line"><span class="function">的备用内存设备</span></span><br><span class="line"><span class="function">317: Experimental Java-Based JIT Compiler 使用基于Java的JIT编译器</span></span><br><span class="line"><span class="function">319: Root Certificates 根证书</span></span><br><span class="line"><span class="function">322: Time-Based Release Versioning 基于时间的发布版本</span></span><br></pre></td></tr></table></figure>

<h5 id="2-1-局部变量类型推断"><a href="#2-1-局部变量类型推断" class="headerlink" title="2.1 局部变量类型推断"></a>2.1 局部变量类型推断</h5><ul>
<li><p>产生背景</p>
<p>开发者经常抱怨Java中引用代码的程度。局部变量的显示类型声明，常常被认为 是不必须的，给一个好听的名字经常可以很清楚的表达出下面应该怎样继续。</p>
</li>
<li><p>好处</p>
<p>减少了啰嗦和形式的代码，避免了信息冗余，而且对齐了变量名，更容易阅读！</p>
</li>
<li><p>举例如下：</p>
<ul>
<li><p>场景一：类实例化时</p>
<p>作为 Java开发者，在声明一个变量时，我们总是习惯了敲打两次变量类型，第 一次用于声明变量类型，第二次用于构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedHashSet&lt;Integer&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>场景二：返回值类型含复杂泛型结构</p>
<p>变量的声明类型书写复杂且较长，尤其是加上泛型的使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator();</span><br></pre></td></tr></table></figure>
</li>
<li><p>场景三：</p>
<p>我们也经常声明一种变量，它只会被使用一次，而且是用在下一行代码中， 比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.atguigu.com&quot;</span>);</span><br><span class="line">URLConnection connection = url.openConnection();</span><br><span class="line">Reader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span></span><br><span class="line">InputStreamReader(connection.getInputStream()));</span><br></pre></td></tr></table></figure>

<p>尽管 IDE可以帮我们自动完成这些代码，但当变量总是跳来跳去的时候，可读 性还是会受到影响，因为变量类型的名称由各种不同长度的字符组成。而且， 有时候开发人员会尽力避免声明中间变量，因为太多的类型声明只会分散注意 力，不会带来额外的好处。</p>
</li>
</ul>
</li>
</ul>
<p><strong>适用于以下情况</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.局部变量的初始化</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//2.增强for循环中的索引</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> v : list) &#123;</span><br><span class="line">	System.out.println(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.传统for循环中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在局部变量中使用时，如下情况不适用</strong></p>
<p>初始值为null</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081156419.png" alt="image-20210808115641177"></p>
<p>Lambda表达式</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081157689.png" alt="image-20210808115720405"></p>
<p>方法引用</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081157245.png" alt="image-20210808115752683"></p>
<p>为静态数组初始化</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081158219.png" alt="image-20210808115845045"></p>
<p><strong>不适用于以下的结构中</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 情况1：没有初始化的局部变量声明</span><br><span class="line"> 情况2：方法的返回类型</span><br><span class="line"> 情况3：方法的参数类型</span><br><span class="line"> 情况4：构造器的参数类型</span><br><span class="line"> 情况5：属性</span><br><span class="line"> 情况6：catch块</span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong></p>
<p>在处理 var时，编译器先是查看表达式右边部分，并根据右边变量值的类型进行 推断，作为左边变量的类型，然后将该类型写入字节码当中。</p>
<p><strong>注意</strong></p>
<ul>
<li><p>var不是一个关键字</p>
<p>你不需要担心变量名或方法名会与 var发生冲突，因为 var实际上并不是一个关键字， 而是一个类型名，只有在编译器需要知道类型的地方才需要用到它。除此之外，它 就是一个普通合法的标识符。也就是说，除了不能用它作为类名，其他的都可以， 但极少人会用它作为类名。</p>
</li>
<li><p>这不是JavaScript</p>
<p>首先我要说明的是，var并不会改变Java是一门静态类型语言的事实。编译器负责推 断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。 下面是使用 IntelliJ（实际上是 Fernflower的反编译器）反编译器反编译出的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> connection = url.openConnection();</span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line"><span class="keyword">new</span> InputStreamReader(connection.getInputStream()));</span><br></pre></td></tr></table></figure>

<p>反编译后</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">URLConnection connection = url.openConnection();</span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line"><span class="keyword">new</span> InputStreamReader(connection.getInputStream()));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>从代码来看，就好像之前已经声明了这些类型一样。事实上，这一特性只发 生在编译阶段，与运行时无关，所以对运行时的性能不会产生任何影响。所 以请放心，这不是 JavaScript。</p>
</blockquote>
</li>
</ul>
<h5 id="2-2-集合新增创建不可变集合的方法"><a href="#2-2-集合新增创建不可变集合的方法" class="headerlink" title="2.2 集合新增创建不可变集合的方法"></a>2.2 集合新增创建不可变集合的方法</h5><p>自 Java 9 开始，Jdk 里面为集合（List / Set / Map）都添加了 of (jdk9新增)和 copyOf (jdk10新增)方法，它们两个都用来创建不可变的集合，来看下它们的 使用和区别。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例1：</span></span><br><span class="line"><span class="keyword">var</span> list1 = List.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> copy1 = List.copyOf(list1);</span><br><span class="line">System.out.println(list1 == copy1); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//示例2：</span></span><br><span class="line"><span class="keyword">var</span> list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">var</span> copy2 = List.copyOf(list2);</span><br><span class="line">System.out.println(list2 == copy2); <span class="comment">// false</span></span><br><span class="line"><span class="comment">//示例1和2代码基本一致，为什么一个为true,一个为false?</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从源码分析 ,可以看出 copyOf 方法会判断来源集合是不是 AbstractImmutableList 类型的，如果是，就直接返回，如果不是，则调用 of 创 建一个新的集合。 示例2因为用的 new 创建的集合，不属于不可变 AbstractImmutableList 类的子类， 所以 copyOf 方法又创建了一个新的实例，所以为false。 注意：使用of和copyOf创建的集合为不可变集合，不能进行添加、删除、替换、 排序等操作，不然会报 java.lang.UnsupportedOperationException 异常。 上面演示了 List 的 of 和 copyOf 方法，Set 和 Map 接口都有。</p>
<h4 id="3-Java11的新特性"><a href="#3-Java11的新特性" class="headerlink" title="3. Java11的新特性"></a>3. Java11的新特性</h4><p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081204031.png" alt="image-20210808120416252"></p>
<p>JDK 11 将是一个 企业不可忽视的版本。从时间节点来看，JDK 11 的发布正 好处在 JDK 8 免费更新到期的前夕，同时 JDK 9、10 也陆续成为“历史版 本” ，下面是 Oracle JDK 支持路线图：</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081204464.png" alt="image-20210808120443550"></p>
<p><strong>JDK 11 是一个长期支持版本（LTS, Long-Term-Support）</strong></p>
<ul>
<li><p>对于企业来说，选择 11 将意味着长期的、可靠的、可预测的技术路线图。 其中免费的OpenJDK11 确定将得到 OpenJDK 社区的长期支持， LTS 版本将 是可以放心选择的版本。</p>
</li>
<li><p>从 JVM GC 的角度，JDK11 引入了两种新的 GC，其中包括也许是划时代意义 的 ZGC，虽然其目前还是实验特性，但是从能力上来看，这是 JDK 的一个巨 大突破，为特定生产环境的苛刻需求提供了一个可能的选择。例如，对部 分企业核心存储等产品，如果能够保证不超过 10ms 的 GC 暂停，可靠性会 上一个大的台阶，这是过去我们进行 GC 调优几乎做不到的，是能与不能的问题</p>
<p>按照官方的说法，新的发布周 期会严格遵循时间点，将于每 年的3月份和9月份发布。所 以 Java 11 的版本号是 18.9(LTS)。</p>
<p>不过与 Java 9 和 Java 10 这 两个被称为“功能性的版本” 不同（两者均只提供半年的技 术支持），Java 11 不仅提供 了长期支持服务，还将作为 Java 平台的参考实现。 Oracle 直到2023年9月都会为 Java 11 提供技术支持，而补 丁和安全警告等扩展支持将持 续到2026年。</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081206960.png" alt="image-20210808120618484"></p>
</li>
</ul>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081206006.png" alt="image-20210808120638010"></p>
<blockquote>
<p>新的长期支持版本每三年发布一次，根据后续的发布计划，下一 个长期支持版 Java 17 将于2021年发布。</p>
</blockquote>
<p><strong>官网公开的 17 个 JEP（JDK Enhancement Proposal 特性增强提议）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">181</span>: Nest-Based Access Control（基于嵌套的访问控制）</span><br><span class="line"><span class="number">309</span>: Dynamic Class-File Constants（动态的类文件常量）</span><br><span class="line"><span class="number">315</span>: Improve Aarch64 Intrinsics（改进 Aarch64 Intrinsics）</span><br><span class="line"><span class="number">318</span>: Epsilon: A No-Op Garbage Collector（Epsilon 垃圾回收器，又被称为<span class="string">&quot;No-Op（无操作）&quot;</span>回收器）</span><br><span class="line"><span class="number">320</span>: Remove the Java EE and CORBA Modules（移除 Java EE 和 CORBA 模块，JavaFX 也已被移除）</span><br><span class="line"><span class="number">321</span>: <span class="function">HTTP <span class="title">Client</span> <span class="params">(Standard)</span></span></span><br><span class="line"><span class="function">323: Local-Variable Syntax <span class="keyword">for</span> Lambda Parameters（用于 Lambda 参数的局部变量语法）</span></span><br><span class="line"><span class="function">324: Key Agreement with Curve25519 and Curve448（采用Curve25519和Curve448 算法实现的密钥协议）</span></span><br><span class="line"><span class="function">327: Unicode 10</span></span><br><span class="line"><span class="function">328: Flight Recorder（飞行记录仪）</span></span><br><span class="line"><span class="function">329: ChaCha20 and Poly1305 Cryptographic Algorithms（实现 ChaCha20 和 Poly1305 加密算法）</span></span><br><span class="line"><span class="function">330: Launch Single-File Source-Code Programs（启动单个 Java 源代码文件的程序）</span></span><br><span class="line"><span class="function">331: Low-Overhead Heap Profiling（低开销的堆分配采样方法）</span></span><br><span class="line"><span class="function">332: Transport Layer <span class="title">Security</span> <span class="params">(TLS)</span> 1.3（对 TLS 1.3 的支持）</span></span><br><span class="line"><span class="function">333: ZGC: A Scalable Low-Latency Garbage <span class="title">Collector</span> <span class="params">(Experimental)</span>（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）</span></span><br><span class="line"><span class="function">335: Deprecate the Nashorn JavaScript Engine（弃用 Nashorn JavaScript 引擎）</span></span><br><span class="line"><span class="function">336: Deprecate the Pack200 Tools and API（弃用 Pack200 工具及其 API）</span></span><br></pre></td></tr></table></figure>

<h5 id="3-1-新增了一系列字符串处理方法"><a href="#3-1-新增了一系列字符串处理方法" class="headerlink" title="3.1 新增了一系列字符串处理方法"></a>3.1 新增了一系列字符串处理方法</h5><table>
<thead>
<tr>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>判断字符串是否为空白</td>
<td>“ “.isBlank(); // true</td>
</tr>
<tr>
<td>去除首尾空白</td>
<td>“ Javastack “.strip(); // “Javastack”</td>
</tr>
<tr>
<td>去除尾部空格</td>
<td>“ Javastack “.stripTrailing(); // “ Javastack”</td>
</tr>
<tr>
<td>去除首部空格</td>
<td>“ Javastack “.stripLeading(); // “Javastack “</td>
</tr>
<tr>
<td>复制字符串</td>
<td>“Java”.repeat(3);// “JavaJavaJava”</td>
</tr>
<tr>
<td>行数统计</td>
<td>“A\nB\nC”.lines().count(); // 3</td>
</tr>
</tbody></table>
<h5 id="3-2-Optional加强"><a href="#3-2-Optional加强" class="headerlink" title="3.2 Optional加强"></a>3.2 Optional加强</h5><p>Optional 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换 成一个 Stream, 或者当一个空 Optional 时给它一个替代的。</p>
<table>
<thead>
<tr>
<th>新增方法</th>
<th>描述</th>
<th>新增的版本</th>
</tr>
</thead>
<tbody><tr>
<td>boolean isEmpty()</td>
<td>判断value是否为空</td>
<td>JDK 11</td>
</tr>
<tr>
<td>ifPresentOrElse(Consumer &lt;? super T&gt;action, Runnable emptyAction)</td>
<td>value非空，执行参数1功能；如果value 为空，执行参数2功能</td>
<td>JDK 9</td>
</tr>
<tr>
<td>Optional<T> or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</td>
<td>value非空，返回对应的Optional； value为空，返回形参封装的Optional</td>
<td>JDK 9</td>
</tr>
<tr>
<td>Stream<T> stream()</td>
<td>value非空，返回仅包含此value的 Stream；否则，返回一个空的Stream</td>
<td>JDK 9</td>
</tr>
<tr>
<td>T orElseThrow()</td>
<td>value非空，返回value；否则抛异常 NoSuchElementException</td>
<td>JDK 10</td>
</tr>
</tbody></table>
<h5 id="3-3-局部变量类型推断升级"><a href="#3-3-局部变量类型推断升级" class="headerlink" title="3.3 局部变量类型推断升级"></a>3.3 局部变量类型推断升级</h5><p>在var上添加注解的语法格式，在jdk10中是不能实现的。在JDK11中加入了这样 的语法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的形式: 必须要有类型, 可以加上var</span></span><br><span class="line"><span class="comment">//Consumer&lt;String&gt; con1 = (@Deprecated t) -&gt; </span></span><br><span class="line">System.out.println(t.toUpperCase());</span><br><span class="line"><span class="comment">//正确的形式:</span></span><br><span class="line"><span class="comment">//使用var的好处是在使用lambda表达式时给参数加上注解。</span></span><br><span class="line">Consumer&lt;String&gt; con2 = (<span class="meta">@Deprecated</span> <span class="keyword">var</span> t) -&gt; System.out.println(t.toUpperCase());</span><br></pre></td></tr></table></figure>

<h5 id="3-4-全新的HTTP-客户端API"><a href="#3-4-全新的HTTP-客户端API" class="headerlink" title="3.4 全新的HTTP 客户端API"></a>3.4 全新的HTTP 客户端API</h5><ul>
<li><p>HTTP，用于传输网页的协议，早在1997年就被采用在目前的1.1版本中。直 到2015年，HTTP2才成为标准。</p>
</li>
<li><p>HTTP/1.1和HTTP/2的主要区别是如何在客户端和服务器之间构建和传输数据。 HTTP/1.1依赖于请求/响应周期。 HTTP/2允许服务器“push”数据：它可以发 送比客户端请求更多的数据。这使得它可以优先处理并发送对于首先加载 网页至关重要的数据。</p>
</li>
<li><p>这是 Java 9 开始引入的一个处理 HTTP 请求的的 HTTP Client API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在 java.net 包中找到这个 API。</p>
</li>
<li><p>它 将 替 代 仅 适 用 于 blocking 模式的 HttpURLConnection （HttpURLConnection是在HTTP 1.0的时代创建的，并使用了协议无关的 方法），并提供对WebSocket 和 HTTP/2的支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">HttpRequest request = </span><br><span class="line">HttpRequest.newBuilder(URI.create(<span class="string">&quot;http://127.0.0.1:8080/test/&quot;</span>)).build();</span><br><span class="line">BodyHandler&lt;String&gt; responseBodyHandler = BodyHandlers.ofString();</span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, responseBodyHandler);</span><br><span class="line">String body = response.body();</span><br><span class="line">System.out.println(body);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">HttpRequest request = </span><br><span class="line">HttpRequest.newBuilder(URI.create(<span class="string">&quot;http://127.0.0.1:8080/test/&quot;</span>)).build();</span><br><span class="line">BodyHandler&lt;String&gt; responseBodyHandler = BodyHandlers.ofString();</span><br><span class="line">CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; sendAsync = </span><br><span class="line">client.sendAsync(request, responseBodyHandler);</span><br><span class="line">sendAsync.thenApply(t -&gt; t.body()).thenAccept(System.out::println);</span><br><span class="line"><span class="comment">//HttpResponse&lt;String&gt; response = sendAsync.get();</span></span><br><span class="line"><span class="comment">//String body = response.body();</span></span><br><span class="line"><span class="comment">//System.out.println(body);</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="3-5-更简化的编译运行程序"><a href="#3-5-更简化的编译运行程序" class="headerlink" title="3.5 更简化的编译运行程序"></a>3.5 更简化的编译运行程序</h5><p>看下面的代码。<br>// 编译<br>javac Javastack.java<br>// 运行<br>java Javastack<br>在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。 而在未来的 Java 11 版本中，通过一个 java 命令就直接搞定了，如以下所示： java Javastack.java</p>
<p> 一个命令编译运行源代码的注意点：</p>
<ul>
<li>执行源文件中的第一个类, 第一个类必须包含主方法。</li>
<li>并且不可以使用其它源文件中的自定义类, 本文件中的自定义类是可以使用的。</li>
</ul>
<h5 id="3-6-废弃Nashorn引擎"><a href="#3-6-废弃Nashorn引擎" class="headerlink" title="3.6 废弃Nashorn引擎"></a>3.6 废弃Nashorn引擎</h5><p>废除Nashorn javascript引擎，在后续版本准备移除掉，有需要的 可以考虑使用GraalVM。</p>
<h5 id="3-7-ZGC"><a href="#3-7-ZGC" class="headerlink" title="3.7 ZGC"></a>3.7 ZGC</h5><ul>
<li>GC是java主要优势之一。 然而, 当GC停顿太长, 就会开始影响应用的响应时 间。消除或者减少GC停顿时长, java将对更广泛的应用场景是一个更有吸引力 的平台。此外, 现代系统中可用内存不断增长,用户和程序员希望JVM能够以高 效的方式充分利用这些内存, 并且无需长时间的GC暂停时间。</li>
<li>ZGC, A Scalable Low-Latency Garbage Collector(Experimental) ZGC, 这应该是JDK11最为瞩目的特性, 没有之一。 但是后面带了Experimental, 说明这还不建议用到生产环境。</li>
<li>ZGC是一个并发, 基于region, 压缩型的垃圾收集器, 只有root扫描阶段会 STW(stop the world), 因此GC停顿时间不会随着堆的增长和存活对象的增长 而变长。</li>
<li>优势：<ul>
<li>GC暂停时间不会超过10ms</li>
<li>既能处理几百兆的小堆, 也能处理几个T的大堆(OMG)</li>
<li>和G1相比, 应用吞吐能力不会下降超过15%</li>
<li>为未来的GC功能和利用colord指针以及Load barriers优化奠定基础</li>
<li>初始只支持64位系统</li>
</ul>
</li>
<li>ZGC的设计目标是：支持TB级内存容量，暂停时间低（&lt;10ms），对整个 程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人 兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存）， 或压缩堆。</li>
</ul>
<h5 id="3-8-其他新特性"><a href="#3-8-其他新特性" class="headerlink" title="3.8 其他新特性"></a>3.8 其他新特性</h5><ul>
<li>Unicode 10</li>
<li>Deprecate the Pack200 Tools and API</li>
<li>新的Epsilon垃圾收集器</li>
<li>完全支持Linux容器（包括Docker）</li>
<li>支持G1上的并行完全垃圾收集</li>
<li>最新的HTTPS安全协议TLS 1.3</li>
<li>Java Flight Recorder</li>
</ul>
<p><strong>在当前JDK中看不到什么？</strong></p>
<p><strong>一个标准化和轻量级的JSON API</strong></p>
<p>一个标准化和轻量级的JSON API被许多Java开发人员所青睐。但是由于资金问 题无法在Java当前版本中见到，但并不会削减掉。Java平台首席架构师Mark Reinhold在JDK 9邮件列中说：“这个JEP将是平台上的一个有用的补充，但是在 计划中，它并不像Oracle资助的其他功能那么重要，可能会重新考虑JDK 10或 更高版本中实现。 ”</p>
<p><strong>新的货币 API</strong></p>
<ul>
<li><p>对许多应用而言货币价值都是一个关键的特性，但JDK对此却几乎没有任何支持。 严格来讲，现有的java.util.Currency类只是代表了当前ISO 4217货币的一个数据结构， 但并没有关联的值或者自定义货币。JDK对货币的运算及转换也没有内建的支持， 更别说有一个能够代表货币值的标准类型了。</p>
</li>
<li><p>此前，Oracle 公布的JSR 354定义了一套新的Java货币API：JavaMoney，计划会在Java 9中正式引入。但是目前没有出现在JDK 新特性 中。</p>
</li>
<li><p>不过，如果你用的是Maven的话，可以做如下的添加，即可使用相关的API处理货币：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.javamoney&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;moneta&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>展望</strong></p>
<ul>
<li>随着云计算和 AI 等技术浪潮，当前的计算模式和场景正在发生翻天覆地的变 化，不仅对 Java 的发展速度提出了更高要求，也深刻影响着 Java 技术的发展 方向。传统的大型企业或互联网应用，正在被云端、容器化应用、模块化的微 服务甚至是函数(FaaS， Function-as-a-Service)所替代。</li>
<li>Java虽然标榜面向对象编程，却毫不顾忌的加入面向接口编程思想，又扯出匿 名对象之概念，每增加一个新的东西，对Java的根本所在的面向对象思想的一 次冲击。反观Python，抓住面向对象的本质，又能在函数编程思想方面游刃有 余。Java对标C/C++，以抛掉内存管理为卖点，却又陷入了JVM优化的噩梦。选 择比努力更重要，选择Java的人更需要对它有更清晰的认识。</li>
<li>Java 需要在新的计算场景下，改进开发效率。这话说的有点笼统，我谈一些自 己的体会，Java 代码虽然进行了一些类型推断等改进，更易用的集合 API 等， 但仍然给开发者留下了过于刻板、形式主义的印象，这是一个长期的改进方向</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div></div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.JPG" alt="软糖豆人 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.JPG" alt="软糖豆人 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="followme">
  <span>欢迎关注我的其它发布渠道</span>

  <div class="social-list">

      <div class="social-item">
        <a target="_blank" class="social-link" href="/images/wechat_channel.jpg">
          <span class="icon">
            <i class="fab fa-weixin"></i>
          </span>

          <span class="label">WeChat</span>
        </a>
      </div>

      <div class="social-item">
        <a target="_blank" class="social-link" href="/atom.xml">
          <span class="icon">
            <i class="fa fa-rss"></i>
          </span>

          <span class="label">RSS</span>
        </a>
      </div>
  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/09/17/16%E2%80%94Java8%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7/" rel="prev" title="16-Java8的其他新特性">
                  <i class="fa fa-chevron-left"></i> 16-Java8的其他新特性
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/09/17/Git%20%E5%91%BD%E4%BB%A4%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA/" rel="next" title="Git原理动画演示">
                  Git原理动画演示 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="SOHUCS"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">软糖豆人</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">543k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:14</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





  <script>
  NexT.utils.loadComments('#SOHUCS', () => {
    NexT.utils.getScript('https://changyan.sohu.com/upload/changyan.js', () => {
      window.changyan.api.config({
        appid: 'cyvkmiP62',
        conf : 'f835963bde21c00f5de8da387f64e40a'
      });
    });
  });
  </script>
  <script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
