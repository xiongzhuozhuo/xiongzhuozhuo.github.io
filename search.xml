<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01-Java语言概述</title>
    <url>/2021/09/17/01%E2%80%94Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><span id="more"></span>
<h3 id="01-Java语言概述"><a href="#01-Java语言概述" class="headerlink" title="01-Java语言概述"></a>01-Java语言概述</h3><p><strong>Java基础知识图解</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108140854557.png" alt="Java基础知识图解"></p>
<h4 id="1-软件开发介绍"><a href="#1-软件开发介绍" class="headerlink" title="1. 软件开发介绍"></a>1. 软件开发介绍</h4><ul>
<li><p>软件开发</p>
<p>软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。</p>
</li>
<li><p>人机交互方式</p>
<ul>
<li>图形化界面(Graphical User Interface GUI)这种方式简单直观，使用者易于接受，容易上手操作。</li>
<li>命令行方式(Command Line Interface CLI)：需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些命令。</li>
</ul>
</li>
<li><p>常用Dos命令</p>
<ul>
<li>dir：列出当前目录下的文件以及文件夹</li>
<li>md：创建目录</li>
<li>rd：删除目录</li>
<li>cd：进入指定目录</li>
<li>cd..：退回到上一级目录</li>
<li>cd\：回到根目录</li>
<li>del：删除文件</li>
<li>exit：退出dos命令行<ul>
<li>补充：echo javase&gt;1.doc</li>
</ul>
</li>
</ul>
</li>
<li><p>常用快捷键</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108140954873.png" alt="image-20210814095451964" style="zoom: 67%;" /> 

</li>
</ul>
<h4 id="2-计算机编程语言介绍"><a href="#2-计算机编程语言介绍" class="headerlink" title="2. 计算机编程语言介绍"></a>2. 计算机编程语言介绍</h4><ul>
<li><p>什么是计算机语言</p>
<ul>
<li><p>语言：是人与人之间用于沟通的一种方式。例如：中国人与中国人用普通话沟通。而中国人要和英国人交流，就要学习英语。</p>
</li>
<li><p>计算机语言：人与计算机交流的方式</p>
<p>如果人要与计算机交流，那么就要学习计算机语言。</p>
<p>计算机语言有很多种。如：C ,C++ ,Java ,PHP , Kotlin，Python，Scala等。</p>
</li>
</ul>
</li>
<li><p>第一代语言</p>
<ul>
<li>机器语言。指令以二进制代码形式存在</li>
</ul>
</li>
<li><p>第二代语言</p>
<ul>
<li><p>汇编语言。使用助记符表示一条机器指令</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108140958142.png" alt="image-20210814095801122"></p>
</li>
</ul>
</li>
<li><p>第三代语言：高级语言</p>
<ul>
<li>C、Pascal、Fortran面向过程的语言</li>
<li>C++面向过程/面向对象</li>
<li>Java跨平台的纯面向对象的语言</li>
<li>.NET跨语言的平台</li>
<li>Pyton、Scala…</li>
</ul>
</li>
<li><p>从市场需求来看<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141003345.png" alt="image-20210814100355030"></p>
<p><a href="https://www.tiobe.com/tiobe-index/">index | TIOBE - The Software Quality Company</a></p>
</li>
</ul>
<h4 id="3-Java语言概述"><a href="#3-Java语言概述" class="headerlink" title="3. Java语言概述"></a>3. Java语言概述</h4><ul>
<li><p>是SUN(Stanford University Network，斯坦福大学网络公司 ) 1995年推出的一 门高级编程语言。</p>
</li>
<li><p>是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以 在Web浏览器中运行。这些Java程序被称为Java小程序（applet）。applet使 用现代的图形用户界面与Web用户进行交互。 applet内嵌在HTML代码中。</p>
</li>
<li><p>随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。</p>
<p>后台开发：Java、PHP、Python、Go、Node.js</p>
</li>
<li><p>Java简史</p>
<ul>
<li>1991年 Green项目，开发语言最初命名为Oak (橡树)</li>
<li>1994年，开发组意识到Oak 非常适合于互联网</li>
<li>1996年，发布JDK 1.0，约8.3万个网页应用Java技术来制作</li>
<li>1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最</li>
<li>1998年，发布JDK 1.2，同年发布企业平台J2EE</li>
<li>1999年，Java分成J2SE、J2EE和J2ME，JSP/Servlet技术诞生</li>
<li>2004年，发布里程碑式版本：JDK 1.5，为突出此版本的重要性，更名为JDK 5.0</li>
<li>2005年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE，J2ME -&gt; JavaME</li>
<li>2009年，Oracle公司收购SUN，交易价格74亿美元</li>
<li>2011年，发布JDK 7.0</li>
<li>2014年，发布JDK 8.0，是继JDK 5.0以来变化最大的版本</li>
<li>2017年，发布JDK 9.0，最大限度实现模块化</li>
<li>2018年3月，发布JDK 10.0，版本号也称为18.3</li>
<li>2018年9月，发布JDK 11.0，版本号也称为18.9</li>
</ul>
</li>
<li><p>Java技术体系平台</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108161446986.png" alt="image-20210816144620850"></p>
</li>
<li><p>Java再各领域的应用</p>
<ul>
<li>从Java的应用领域来分，Java语言的应用方向主要表现在以下几个方面：<ul>
<li>企业级应用：主要指复杂的大企业的软件系统、各种类型的网站。Java的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。</li>
<li>Android平台应用：Android应用程序使用Java语言编写。Android开发水平的高低 很大程度上取决于Java语言核心能力是否扎实。</li>
<li>大数据平台开发：各类框架有Hadoop，spark，storm，flink等，就这类技术生态圈来讲，还有各种中间件如flume，kafka，sqoop等等 ，这些框架以及工具大多数是用Java编写而成，但提供诸如Java，scala，Python，R等各种语言API供编程。</li>
<li>移动领域应用：主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括手机、PDA、机顶盒、汽车通信设备等。</li>
</ul>
</li>
</ul>
</li>
<li><p>Java语言的诞生</p>
<p>​         java之父James Gosling团队在开发”Green”项目时，发现C缺少垃圾回收系统，还有可移植的安全性、分布程序设计和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。<br>​         Java确实是从C语言和C++语言继承了许多成份，甚至可以将Java看成是类C语言发展和衍生的产物。比如Java语言的变量声明，操作符形式，参数传递，流程控制等方面和C语言、C++语言完全相同。但同时，Java是一个纯粹的面向对象的程序设计语言，它继承了C++语言面向对象技术的核心。Java舍弃了C语言中容易引起错误的指针（以引用取代）、运算符重载（operator overloading）、多重继承 （以接口取代）等特性，增加了垃圾回收器功能用于回收不再被引用 的对象所占据的内存空间。JDK1.5又引入了泛型编程（Generic  Programming）、类型安全的枚举、不定长参数和自动装/拆箱</p>
</li>
<li><p>主要特性</p>
<ul>
<li>Java语言是易学的。Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用Java。</li>
<li>Java语言是强制面向对象的。Java语言提供类、接口和继承等原语，为了简单起见， 只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制 （关键字为implements）。</li>
<li>Java语言是分布式的。Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类 库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程 方法激活）机制也是开发分布式应用的重要手段。</li>
<li>Java语言是健壮的。Java的强类型机制、异常处理、垃圾的自动收集等是Java程序 健壮性的重要保证。对指针的丢弃是Java的明智选择。</li>
<li>Java语言是安全的。Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。如：安全防范机制（类ClassLoader），如分配不同的 名字空间以防替代本地的同名类、字节代码检查。</li>
<li>Java语言是体系结构中立的。Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个 Java平台的任何系统中运行。</li>
<li>Java语言是解释型的。如前所述，Java程序在Java平台上被编译为字节码格式， 然后可以在实现这个Java平台的任何系统的解释器中运行。</li>
<li>Java是性能略高的。与那些解释型的高级脚本语言相比，Java的性能还是较优的。</li>
<li>Java语言是原生支持多线程的。在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。</li>
</ul>
</li>
</ul>
<h4 id="4-运行机制及运行过程"><a href="#4-运行机制及运行过程" class="headerlink" title="4. 运行机制及运行过程"></a>4. 运行机制及运行过程</h4><ul>
<li>Java语言的特点<ul>
<li>特点一：面向对象<ul>
<li>两个基本概念：类、对象</li>
<li>三大特性：封装、继承、多态</li>
</ul>
</li>
<li>特点二：健壮性<ul>
<li>吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制</li>
</ul>
</li>
<li>特点三：跨平台性<ul>
<li>跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write  once , Run Anywhere”<ul>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141017944.png" alt="image-20210814101734807"></li>
</ul>
</li>
<li>原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java  Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。</li>
</ul>
</li>
</ul>
</li>
<li>Java的两种核心机制<ul>
<li>Java虚拟机 (Java Virtal Machine)</li>
<li>垃圾收集机制 (Garbage Collection)</li>
</ul>
</li>
<li>核心机制—Java虚拟机<ul>
<li>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。</li>
<li>对于不同的平台，有不同的虚拟机。</li>
<li>只有某平台提供了对应的java虚拟机，java程序才可在此平台运行</li>
<li>Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”</li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141019425.png" alt="image-20210814101933458"></li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141021496.png" alt="image-20210814102128856" style="zoom:80%;" /> </li>
</ul>
</li>
<li>核心机制—垃圾回收<ul>
<li>不再使用的内存空间应回收—— 垃圾回收。<ul>
<li>在C/C++等语言中，由程序员负责回收无用内存。</li>
<li>Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。</li>
<li>垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。</li>
</ul>
</li>
<li>Java程序还会出现内存泄漏和内存溢出问题吗？Yes!</li>
</ul>
</li>
</ul>
<h4 id="5-Java的环境搭建"><a href="#5-Java的环境搭建" class="headerlink" title="5. Java的环境搭建"></a>5. Java的环境搭建</h4><ul>
<li><p>明确什么是JDK, JRE</p>
</li>
<li><p>下载 JDK</p>
</li>
<li><p>安装 JDK</p>
</li>
<li><p>配置环境变量</p>
<ul>
<li>path：windows系统执行命令时要搜寻的路径。</li>
</ul>
</li>
<li><p>验证是否成功：javac java</p>
</li>
<li><p>选择合适的文本编辑器或 IDE 开发</p>
</li>
<li><p>什么是JDK,JRE</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141026886.png" alt="image-20210814102648748" style="zoom:80%;" />
</li>
<li><p>JDK、JRE、JVM关系</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141030638.png" alt="image-20210814103016502"  /> 

<p><a href="https://docs.oracle.com/javase/8/docs/">Java Platform Standard Edition 8 Documentation (oracle.com)</a></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141031010.png" alt="image-20210814103148629" style="zoom:80%;" />
</li>
<li><p>官方网址：</p>
<ul>
<li><a href="http://www.oracle.com/">www.oracle.com</a></li>
<li>java.sun.com</li>
</ul>
</li>
<li><p>安装JDK</p>
<ul>
<li>傻瓜式安装，下一步即可。</li>
<li>建议：安装路径不要有中文或者空格等特殊符号。</li>
<li>如果操作系统是64位的，软件尽量选择支持64位的（除非软件本身不区分）。</li>
<li>当提示安装 JRE 时，正常在JDK安装时已经装过了，但是为了后续使用Eclipse等开发 工具不报错，建议也根据提示安装JRE。</li>
</ul>
</li>
<li><p>配置环境变量path</p>
<ul>
<li><p>在dos命令行中敲入javac，出现错误</p>
</li>
<li><p>错误原因：当前执行的程序在当前目录下如果不存在，windows系统会在系 统中已有的一个名为path的环境变量指定的目录中查找。如果仍未找到，会 出现以上的错误提示。所以进入到 jdk安装路径\bin目录下，执行javac，会看到javac参数提示信息。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141036210.png" alt="image-20210814103637239"></p>
<p>每次执行 java 的工具都要进入到bin目录下，是非常麻烦的。可不可以在任何目 录下都可以执行java的工具呢？</p>
</li>
<li><p>根据windows系统在查找可执行程序的原理，可以将java工具所在路径定义到 path 环境变量中，让系统帮我们去找运行执行的程序。</p>
</li>
<li><p>配置方法</p>
<ul>
<li>我的电脑–属性–高级系统设置–环境变量</li>
<li>编辑 path 环境变量，在变量值开始处加上java工具所在目录，后面用 “ ; ”和其他值分隔 开即可。</li>
<li>打开DOS命令行，任意目录下敲入javac。如果出现javac 的参数信息，配置成功。</li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141045807.png" alt="image-20210814104346438"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-开发体验—HelloWord"><a href="#6-开发体验—HelloWord" class="headerlink" title="6. 开发体验—HelloWord"></a>6. 开发体验—HelloWord</h4><ul>
<li><p>步骤</p>
<ol>
<li><p>将 Java 代码编写到扩展名为 .java 的文件中。</p>
</li>
<li><p>通过 javac 命令对该 java 文件进行编译。</p>
</li>
<li><p>通过 java 命令对生成的 class 文件进行运行。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141105182.png" alt="image-20210814110554841"></p>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>02-Java基本语法（下）</title>
    <url>/2021/09/17/02%E2%80%94Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="02—Java基本语法（下）：程序流程控制"><a href="#02—Java基本语法（下）：程序流程控制" class="headerlink" title="02—Java基本语法（下）：程序流程控制"></a>02—Java基本语法（下）：程序流程控制</h3><h4 id="1-程序流程控制"><a href="#1-程序流程控制" class="headerlink" title="1. 程序流程控制"></a>1. 程序流程控制</h4><ul>
<li>流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组合成能完成一定功能的小逻辑模块。</li>
<li>其流程控制方式采用结构化程序设计中规定的三种基本流程结构，即：<ul>
<li>顺序结构<ul>
<li>程序从上到下逐行地执行，中间没有任何判断和跳转。</li>
</ul>
</li>
<li>分支结构<ul>
<li>根据条件，选择性地执行某段代码。</li>
<li>有if…else和switch-case两种分支语句。</li>
</ul>
</li>
<li>循环结构<ul>
<li>根据循环条件，重复性的执行某段代码。</li>
<li>有while、do…while、for三种循环语句。</li>
<li>注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-顺序结构"><a href="#2-顺序结构" class="headerlink" title="2. 顺序结构"></a>2. 顺序结构</h4><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141315615.png" alt="image-20210814131528560"> </p>
<h4 id="3-分支结构"><a href="#3-分支结构" class="headerlink" title="3. 分支结构"></a>3. 分支结构</h4><h5 id="3-1-if-else结构"><a href="#3-1-if-else结构" class="headerlink" title="3.1 if-else结构"></a>3.1 if-else结构</h5><p>if语句三种格式：</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141316077.png" alt="image-20210814131652242"> <img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141318452.png" alt="屏幕截图 2021-08-14 131738" style="zoom:80%;" /></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141319828.png" alt="屏幕截图 2021-08-14 131909"></p>
<h5 id="3-2-switch-case结构"><a href="#3-2-switch-case结构" class="headerlink" title="3.2 switch-case结构"></a>3.2 switch-case结构</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">			语句<span class="number">1</span>;</span><br><span class="line">		<span class="comment">// break;</span></span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">			语句<span class="number">2</span>;</span><br><span class="line">		<span class="comment">// break;</span></span><br><span class="line">		… …</span><br><span class="line">	<span class="keyword">case</span> 常量N:</span><br><span class="line">			语句N;</span><br><span class="line">		<span class="comment">// break;</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		语句;</span><br><span class="line">		<span class="comment">// break;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141322212.png" alt="image-20210814132242055"></p>
<p>switch语句有关规则</p>
<ul>
<li>switch(表达式)中表达式的值必须是下述几种类型之一：byte，short， char，int，枚举 (jdk 5.0)，String (jdk 7.0)；</li>
<li>case子句中的值必须是常量，不能是变量名或不确定的表达式值；</li>
<li>同一个switch语句，所有case子句中的常量值互不相同；</li>
<li>break语句用来在执行完一个case分支后使程序跳出switch语句块；如果没有break，程序会顺序执行到switch结尾</li>
<li>default子句是可任选的。同时，位置也是灵活的。当没有匹配的case时， 执行default</li>
</ul>
<h4 id="4-循环结构"><a href="#4-循环结构" class="headerlink" title="4.循环结构"></a>4.循环结构</h4><h5 id="4-1-for循环"><a href="#4-1-for循环" class="headerlink" title="4.1 for循环"></a>4.1 for循环</h5><ul>
<li><p>语法格式</p>
<p>for (①初始化部分; ②循环条件部分; ④迭代部分)｛ </p>
<p>​         ③循环体部分; </p>
<p>｝</p>
</li>
<li><p>执行过程：</p>
<p>①-②-③-④-②-③-④-②-③-④-…..-②</p>
</li>
<li><p>说明：</p>
<ul>
<li><p>②循环条件部分为boolean类型表达式，当值为false时，退出循环</p>
</li>
<li><p>①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔</p>
</li>
<li><p>④可以有多个变量更新，用逗号分隔</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141928696.png" alt="image-20210814192817184" style="zoom:80%;" />

</li>
</ul>
</li>
</ul>
<h5 id="4-2-while循环"><a href="#4-2-while循环" class="headerlink" title="4.2 while循环"></a>4.2 while循环</h5><ul>
<li><p>语法格式</p>
<p>①初始化部分 </p>
<p>while(②循环条件部分)｛ </p>
<p>​             ③循环体部分; </p>
<p>​             ④迭代部分;</p>
<p> }</p>
</li>
<li><p>执行过程：</p>
<p>①-②-③-④-②-③-④-②-③-④-…-②</p>
</li>
<li><p>说明：</p>
<ul>
<li>注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。</li>
<li>for循环和while循环可以相互转换</li>
</ul>
</li>
</ul>
<h5 id="4-3-do-while循环"><a href="#4-3-do-while循环" class="headerlink" title="4.3 do-while循环"></a>4.3 do-while循环</h5><ul>
<li><p>语法格式</p>
<p>①初始化部分; </p>
<p>do{ </p>
<p>​        ③循环体部分 </p>
<p>​        ④迭代部分 }while(②循环条件部分);</p>
</li>
<li><p>执行过程：①-③-④-②-③-④-②-③-④-…②</p>
</li>
<li><p>说明：do-while循环至少执行一次循环体。</p>
</li>
</ul>
<h4 id="5-特殊关键字的使用：-break、continue"><a href="#5-特殊关键字的使用：-break、continue" class="headerlink" title="5. 特殊关键字的使用： break、continue"></a>5. 特殊关键字的使用： break、continue</h4><h5 id="5-1-特殊流程控制语句1"><a href="#5-1-特殊流程控制语句1" class="headerlink" title="5.1 特殊流程控制语句1"></a>5.1 特殊流程控制语句1</h5><ul>
<li><p>break 语句</p>
<ul>
<li><p>break语句用于终止某个语句块的执行 </p>
<p>{ …… </p>
<p>​    break; </p>
<p>​    …… </p>
<p>}</p>
</li>
<li><p>break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块</p>
<p>label1: { …… </p>
<p>label2:         { …… </p>
<p>label3:                 { …… </p>
<p>​                                    break label2; </p>
<p>​                                    …… </p>
<p>​                                }</p>
<p>​                         } </p>
<p>​                 }</p>
</li>
</ul>
</li>
</ul>
<h5 id="5-2-特殊流程控制语句2"><a href="#5-2-特殊流程控制语句2" class="headerlink" title="5.2 特殊流程控制语句2"></a>5.2 特殊流程控制语句2</h5><ul>
<li>continue 语句<ul>
<li>continue只能使用在循环结构中</li>
<li>continue语句用于跳过其所在循环语句块的一次执行，继续下一次循环</li>
<li>continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环</li>
</ul>
</li>
</ul>
<h5 id="5-3-特殊流程控制语句3"><a href="#5-3-特殊流程控制语句3" class="headerlink" title="5.3 特殊流程控制语句3"></a>5.3 特殊流程控制语句3</h5><ul>
<li>return：并非专门用于结束循环的，它的功能是结束一个方法。 当一个方法执行到一个return语句时，这个方法将被结束。</li>
<li>与break和continue不同的是，return直接结束整个方法，不管这个return处于多少层循环之内</li>
<li>break只能用于switch语句和循环语句中。</li>
<li>continue 只能用于循环语句中。</li>
<li>二者功能类似，但continue是终止本次循环，break是终止本层循环。</li>
<li>break、continue之后不能有其他的语句，因为程序永远不会执行其后的语句。</li>
<li>标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。</li>
<li>很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条 语句上，然后执行它。但使程序容易出错。Java中的break和continue是不同 于goto的。</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>02-Java基本语法（上）</title>
    <url>/2021/09/17/02%E2%80%94Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><span id="more"></span>

<h3 id="02-Java基本语法（上）：变量与运算符"><a href="#02-Java基本语法（上）：变量与运算符" class="headerlink" title="02-Java基本语法（上）：变量与运算符"></a>02-Java基本语法（上）：变量与运算符</h3><h4 id="1-关键字和保留字"><a href="#1-关键字和保留字" class="headerlink" title="1. 关键字和保留字"></a>1. 关键字和保留字</h4><ul>
<li>关键字(keyword)的定义和特点 <ul>
<li>定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</li>
<li>特点：关键字中所有字母都为小写</li>
<li>官方地址： <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a></li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141129301.png" alt="image-20210814112941844" style="zoom:150%;" /></li>
<li>保留字(reserved word)<ul>
<li>Java保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使 用。自己命名标识符时要避免使用这些保留字 goto 、const</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2. 标识符"></a>2. 标识符</h4><ul>
<li>标识符：<ul>
<li>Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符</li>
<li>技巧：凡是自己可以起名字的地方都叫标识符。</li>
</ul>
</li>
<li>定义合法标识符规则：<ul>
<li>由26个英文字母大小写，0-9 ，_或 $ 组成</li>
<li>数字不可以开头。</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字。</li>
<li>Java中严格区分大小写，长度无限制。</li>
<li>标识符不能包含空格。</li>
</ul>
</li>
<li>Java中的名称规范<ul>
<li>包名：多个单词组成时，所有字母都小写：xxxyyyzzz</li>
<li>类名、接口名：多单词组成时，所有单词的首字母都大写：XxxYyyZzz</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</li>
<li>常量名：所有字母都大写。多个单词时每个单词用下划线链接：XXX_YYY_ZZZ</li>
</ul>
</li>
</ul>
<h4 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h4><ul>
<li><p>变量的概念：</p>
<ul>
<li>内存中的一个存储区域</li>
<li>该区域的数据可以在同一类型范围内不断变化</li>
<li>变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值</li>
</ul>
</li>
<li><p>变量的作用：</p>
<ul>
<li>用于在内存中保存数据</li>
</ul>
</li>
<li><p>使用变量注意：</p>
<ul>
<li>Java中的每个变量必须先声明，后使用</li>
<li>使用变量名来访问这块区域的数据</li>
<li>变量的作用域：其定义所在的一对{}内</li>
<li>变量只在其作用域内才有效</li>
<li>同一个作用域内不能定义重名的变量</li>
</ul>
</li>
<li><p>声明变量</p>
<ul>
<li>语法：&lt;数据类型&gt;&lt;变量名&gt;</li>
<li>例如：int var</li>
</ul>
</li>
<li><p>变量的赋值</p>
<ul>
<li>语法：&lt;变量名称&gt; = &lt;值&gt;</li>
<li>例如：var = 10;</li>
</ul>
</li>
<li><p>声明和赋值变量</p>
<ul>
<li>语法： &lt;数据类型&gt; &lt;变量名&gt; = &lt;初始化值&gt;</li>
<li>例如：int var = 10;</li>
</ul>
</li>
<li><p>变量的分类</p>
<ul>
<li><p>按数据类型：对于每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分配了不同大小的内存空间。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141215072.png" alt="image-20210814121537925"></p>
</li>
<li><p>按声明的位置的不同</p>
<p>在方法体外，类体内声明的变量称为成员变量。在方法体内部声明的变量称为局部变量。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141217923.png" alt="image-20210814121706483"></p>
<p>注意：二者在初始化值方面的异同:同：都有生命周期 异：局部变量除形参外，需显式初始化。</p>
</li>
<li><p>整数类型：byte、short、int、long</p>
<ul>
<li><p>Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保 证java程序的可移植性。</p>
</li>
<li><p>java的整型常量默认为 int 型，声明long型常量须后加‘l’或‘L’</p>
</li>
<li><p>java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long</p>
<table>
<thead>
<tr>
<th>类 型</th>
<th>占用存储空间</th>
<th>表数范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1字节=8bit位</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>-2^15^ ~2^15^ -1</td>
</tr>
<tr>
<td>int</td>
<td>4字节</td>
<td>-2^31^ ~ 2^31^ -1 (约21亿)</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>-2^63^ ~ 2^63^ -1</td>
</tr>
</tbody></table>
<p>500MB 1MB = 1024KB 1KB= 1024B B= byte ? bit? bit: 计算机中的最小存储单位。byte:计算机中基本存储单元。</p>
</li>
</ul>
</li>
<li><p>浮点类型：float、double</p>
<ul>
<li><p>与整数类型类似，Java 浮点类型也有固定的表数范围和字段长度，不受具体操作 系统的影响。</p>
</li>
<li><p>浮点型常量有两种表示形式：</p>
<ul>
<li>十进制数形式：如：5.12 512.0f .512 (必须有小数点）</li>
<li>科学计数法形式:如：5.12e2 512E2 100E-2</li>
</ul>
</li>
<li><p>float:单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。 double:双精度，精度是float的两倍。通常采用此类型。</p>
</li>
<li><p>Java 的浮点型常量默认为double型，声明float型常量，须后加‘f’或‘F’。</p>
<table>
<thead>
<tr>
<th>类 型</th>
<th>占用存储空间</th>
<th>表数范围</th>
</tr>
</thead>
<tbody><tr>
<td>单精度float</td>
<td>4字节</td>
<td>-3.403E38 ~ 3.403E38</td>
</tr>
<tr>
<td>双精度double</td>
<td>8字节</td>
<td>-1.798E308 ~ 1.798E308</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>字符类型：char</p>
<ul>
<li><p>char 型数据用来表示通常意义上“字符”(2字节)</p>
</li>
<li><p>Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。</p>
</li>
<li><p>字符型变量的三种表现形式：</p>
<ul>
<li><p>字符常量是用单引号(‘ ’)括起来的单个字符。例如：char c1 = ‘a’; char c2  = ‘中’; char c3 = ‘9’;</p>
</li>
<li><p>Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。 例如：char c3 = ‘\n’; // ‘\n’表示换行符</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\b</td>
<td>退格键</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\“</td>
<td>双引号</td>
</tr>
<tr>
<td>\‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\\</td>
<td>反斜线</td>
</tr>
</tbody></table>
</li>
<li><p>直接使用 Unicode 值来表示字符型常量：‘\uXXXX’。其中，XXXX代表 一个十六进制整数。如：\u000a 表示 \n。</p>
</li>
<li><p>char类型是可以进行运算的。因为它都对应有Unicode码。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>布尔类型：boolean</p>
<ul>
<li>boolean 类型用来判断逻辑条件，一般用于程序流程控制：<ul>
<li>if条件控制语句；</li>
<li>while循环控制语句；</li>
<li>do-while循环控制语句；</li>
<li>for循环控制语句；</li>
</ul>
</li>
<li>boolean类型数据只允许取值true和false，无null。<ul>
<li>不可以使用0或非 0 的整数替代false和true，这点和C语言不同。</li>
<li>Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的 boolean值，在编译之后都使用java虚拟机中的int数据类型来代替：true用1表示，false 用0表示。———《java虚拟机规范 8版》</li>
</ul>
</li>
</ul>
</li>
<li><p>基本数据类型转换</p>
<ul>
<li><p>自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容 量大小排序为：</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141234328.png" alt="image-20210814123431947"></p>
</li>
<li><p>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的 那种数据类型，然后再进行计算。</p>
</li>
<li><p>byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。</p>
</li>
<li><p>boolean类型不能与其它数据类型运算。</p>
</li>
<li><p>当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型。</p>
</li>
</ul>
</li>
<li><p>字符串类型：String</p>
<ul>
<li><p>String不是基本数据类型，属于引用数据类型</p>
</li>
<li><p>使用方式与基本数据类型一致。例如：String str = “abcd”;</p>
</li>
<li><p>一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str = str + “xyz” ; </span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">str = str + n;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>强制类型转换</p>
<ul>
<li>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。</li>
<li>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。</li>
<li>如： String a = “43”; int i = Integer.parseInt(a);</li>
<li>boolean类型不可以转换为其它的数据类型。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h4><ul>
<li><p>算数运算符<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141250720.png" alt="image-20210814125009358"></p>
<ul>
<li>算术运算符的注意问题<ul>
<li>如果对负数取模，可以把模数负号忽略不记，如：5%-2=1。 但被模数是负数则不可忽略。此外，取模运算的结果不一定总是整数。</li>
<li>对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只 保留整数部分而舍弃小数部分。 例如：int x=3510;x=x/1000*1000; </li>
<li>“+”除字符串相加功能外，还能把非字符串转换成字符串.例如： System.out.println(“5+5=”+5+5); //打印结果是？ 5+5=55 ?</li>
</ul>
</li>
</ul>
</li>
<li><p>赋值运算符：=</p>
<ul>
<li>符号：=<ul>
<li>当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制 类型转换原则进行处理。</li>
<li>支持连续赋值。</li>
</ul>
</li>
<li>扩展赋值运算符： +=, -=, *=, /=, %=</li>
</ul>
</li>
<li><p>比较运算符<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141255040.png" alt="image-20210814125537627"></p>
<p>比较运算符的结果都是boolean型，也就是要么是true，要么是false。</p>
<p>比较运算符“==”不能误写成“=” 。</p>
</li>
<li><p>逻辑运算符</p>
<p>&amp;—逻辑与     | —逻辑或     ！—逻辑非     &amp;&amp; —短路与     || —短路或     ^ —逻辑异或</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141256722.png" alt="image-20210814125656753"></p>
<ul>
<li>逻辑运算符用于连接布尔型表达式，在Java中不可以写成3&lt;x&lt;3 ,应该写成x&gt;3 &amp; x&lt;6 。</li>
<li>“&amp;”和“&amp;&amp;”的区别：<ul>
<li>单&amp;时，左边无论真假，右边都进行运算；</li>
<li>双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。</li>
</ul>
</li>
<li>“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。</li>
<li>异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。</li>
</ul>
</li>
<li><p>位运算符<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141259463.png" alt="image-20210814125946801"></p>
<ul>
<li>位运算是直接对整数的二进制进行的运算</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141301684.png" alt="image-20210814130103547"></p>
</li>
<li><p>三元运算符</p>
<ul>
<li>格式：<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141302892.png" alt="image-20210814130208344"></li>
<li>表达式1和表达式2为同种类型</li>
<li>三元运算符与if-else的联系与区别：<ul>
<li>三元运算符可简化if-else语句</li>
<li>三元运算符要求必须返回一个结果。</li>
<li>if后的代码块可有多个语句</li>
</ul>
</li>
</ul>
</li>
<li><p>运算符优先级</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141507310.png" alt="image-20210814150746972"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>03-数组</title>
    <url>/2021/09/17/03%E2%80%94%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="03—数组"><a href="#03—数组" class="headerlink" title="03—数组"></a>03—数组</h3><h4 id="1-数组的概述"><a href="#1-数组的概述" class="headerlink" title="1. 数组的概述"></a>1. 数组的概述</h4><ul>
<li>数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</li>
<li>数组的常见概念<ul>
<li>数组名</li>
<li>下标(或索引)</li>
<li>元素</li>
<li>数组的长度</li>
</ul>
</li>
<li>数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型。</li>
<li>创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址。</li>
<li>数组的长度一旦确定，就不能修改。</li>
<li>我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快。</li>
<li>数组的分类：<ul>
<li>按照维度：一维数组、二维数组、三维数组、…</li>
<li>按照元素的数据类型分：基本数据类型元素的数组、引用数据类型元素的数组(即对象数组)</li>
</ul>
</li>
</ul>
<h4 id="2-一维数组"><a href="#2-一维数组" class="headerlink" title="2. 一维数组"></a>2. 一维数组</h4><h5 id="2-1-声明"><a href="#2-1-声明" class="headerlink" title="2.1 声明"></a>2.1 声明</h5><ul>
<li>一维数组的声明方式： type var[] 或 type[] var；<ul>
<li>例如<ul>
<li>int a[]; </li>
<li>int[] a1; </li>
<li>double b[]; </li>
<li>String[] c; //引用类型变量数组</li>
</ul>
</li>
</ul>
</li>
<li>Java语言中声明数组时不能指定其长度(数组中元素的数)， 例如： int a[5]; //非法</li>
</ul>
<h5 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h5><ul>
<li><p>动态初始化：数组声明且为数组元素分配空间与赋值的操作分开进行</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142020501.png" alt="image-20210814202012456"></p>
</li>
<li><p>静态初始化：在定义数组的同时就为数组元素分配空间并赋值。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142022292.png" alt="image-20210814202203908"></p>
</li>
</ul>
<h5 id="2-3-数组元素的引用"><a href="#2-3-数组元素的引用" class="headerlink" title="2.3 数组元素的引用"></a>2.3 数组元素的引用</h5><ul>
<li><p>定义并用运算符new为之分配空间后，才可以引用数组中的每个元素；</p>
</li>
<li><p>数组元素的引用方式：数组名[数组元素下标]</p>
<ul>
<li>数组元素下标可以是整型常量或整型表达式。如a[3] , b[i] , c[6*i];</li>
<li>数组元素下标从0开始；长度为n的数组合法下标取值范围: 0 —&gt;n-1；如int a[]=new  int[3]; 可引用的数组元素为a[0]、a[1]、a[2]</li>
</ul>
</li>
<li><p>每个数组都有一个属性length指明它的长度，例如：a.length 指明数组a的长度(元素个数)</p>
<ul>
<li>数组一旦初始化，其长度是不可变的</li>
</ul>
</li>
<li><p>数组是引用类型，它的元素相当于类的成员变量，因此数组一经分配空间，其中的每个元素也被按照成员变量同样的方式被隐式初始化。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a[]= <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">		System.out.println(a[<span class="number">3</span>]); <span class="comment">//a[3]的默认值为0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对于基本数据类型而言，默认初始化值各有不同</p>
</li>
<li><p>对于引用数据类型而言，默认初始化值为null(注意与0不同！)</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142045181.png" alt="image-20210814204510834"></p>
</li>
</ul>
</li>
</ul>
<h5 id="2-4-一维数组的使用"><a href="#2-4-一维数组的使用" class="headerlink" title="2.4 一维数组的使用"></a>2.4 一维数组的使用</h5><ul>
<li><p>Java中使用关键字new来创建数组</p>
</li>
<li><p>如下是创建基本数据类型元素的一维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] s;<span class="comment">//⭐</span></span><br><span class="line">		s = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ ) &#123;</span><br><span class="line">			s[i] =<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">			System.out.println(s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142055841.png" alt="image-20210814205542408"> </p>
</li>
<li><p>创建基本数据类型数组 (2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] s;</span><br><span class="line">		s = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//⭐</span></span><br><span class="line">		<span class="comment">//int[] s=new int[10];</span></span><br><span class="line">		<span class="comment">//基本数据类型数组在显式赋值之前，</span></span><br><span class="line">		<span class="comment">//Java会自动给他们赋默认值。</span></span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ ) &#123;</span><br><span class="line">			s[i] =<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">			System.out.println(s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142101509.png" alt="image-20210814210132161"></p>
</li>
<li><p>创建基本数据类型数组 (3)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] s;</span><br><span class="line">		s = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ ) &#123;</span><br><span class="line">			s[i] =<span class="number">2</span>*i+<span class="number">1</span>;<span class="comment">//⭐</span></span><br><span class="line">			System.out.println(s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109121034507.png" alt="image-20210912103404977" style="zoom: 50%;" />

<p><strong>内存结构</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142105646.png" alt="image-20210814210534290"></p>
<p><strong>一维数组内存解析</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142114758.png" alt="屏幕截图 2021-08-14 211401"></p>
</li>
</ul>
<h4 id="3-多维数组的使用"><a href="#3-多维数组的使用" class="headerlink" title="3. 多维数组的使用"></a>3. 多维数组的使用</h4><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142116543.png" alt="image-20210814211605498"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142116877.png" alt="image-20210814211632843"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142117692.png" alt="image-20210814211737151"></p>
<p><strong>二维数组内存解析</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142118788.png" alt="image-20210814211812263"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142121628.png" alt="image-20210814212133388"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142121935.png" alt="image-20210814212153112"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142122194.png" alt="image-20210814212212578"></p>
<h4 id="4-Arrys工具类的使用"><a href="#4-Arrys工具类的使用" class="headerlink" title="4. Arrys工具类的使用"></a>4. Arrys工具类的使用</h4><p>java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142140195.png" alt="image-20210814213814165"></p>
<ul>
<li><p>java.util.Arrays类的sort()方法提供了数组元素排序功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> [] numbers = &#123;<span class="number">5</span>,<span class="number">900</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">77</span>,<span class="number">30</span>,<span class="number">64</span>,<span class="number">700</span>&#125;;</span><br><span class="line">		Arrays.sort(numbers);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">			System.out.println(numbers[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-数组使用中的常见异常"><a href="#5-数组使用中的常见异常" class="headerlink" title="5. 数组使用中的常见异常"></a>5. 数组使用中的常见异常</h4><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142148445.png" alt="image-20210814214839629"></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git原理动画演示</title>
    <url>/2021/09/17/Git%20%E5%91%BD%E4%BB%A4%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="相见恨晚的-Git-命令动画演示，一看就懂！"><a href="#相见恨晚的-Git-命令动画演示，一看就懂！" class="headerlink" title="相见恨晚的 Git 命令动画演示，一看就懂！"></a><a href="https://www.cnblogs.com/mq0036/p/14372507.html">相见恨晚的 Git 命令动画演示，一看就懂！</a></h2><p>虽然 Git 是一个强大的工具，但是我觉得大部分人都会同意我说的：它也可以是一个……噩梦！</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232042676.gif"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232111261.png" alt="img"></p>
<p>我一直觉得，使用 Git 的时候把操作过程在脑海里视觉化会非常有用：当我执行某个命令的时候，分支之间是如何交互的？又是如何影响提交历史的？当我在<code>master</code>分支执行<code>hard reset</code>、<code>force push</code>到 <code>origin</code>、在<code>.git</code>文件夹执行<code>rimraf</code>的时候，为什么我的同事都哭了？</p>
<p>我认为创建一些最常见、最实用的命令的可视化示例是最佳使用指南！接下来介绍的这些命令，很多都有可选参数，用于改变命令的行为。文中的示例只讨论命令的默认行为，不会涉及太多的配置选项。这些命令包括 <code>merge</code>，<code>rebase</code>，<code>reset</code>， <code>revert</code>，<code>cherry-pick</code>，<code>fetch</code>，<code>pull</code>，<code>reflog</code> 等。</p>
<hr>
<h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>多分支可以非常方便地将新的改动互相隔离，并确保你不会意外地将未经批准或破坏性的变更推到生产环境。一旦变更被批准，我们就能在生产分支中得到这些变更。</p>
<p>从一个分支获取变更到另一个分支的方式之一是执行<code>git merge</code>命令。Git 有两类合并操作：**<code>fast-forward</code>** 和**<code>no-fast-forward</code>**。</p>
<p>这么说你可能没什么概念，我们来看看区别吧。</p>
<h3 id="fast-forward-ff"><a href="#fast-forward-ff" class="headerlink" title="fast-forward (--ff)"></a>fast-forward (<code>--ff</code>)</h3><p>如果当前分支与即将合并过来的分支相比，没有额外的提交，这种就是<code>fast-forward</code>合并。Git 很会偷懒，它会首先尝试最简单的方案，即<code>fast-forward</code>。这种合并方式不会创建新的提交，只是把另一个分支的提交记录直接合并到当前分支。<br><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232112326.gif" alt="fast-forward"></p>
<p>没毛病！现在我们在<code>master</code>分支上有了<code>dev</code>分支上的所有变更。那么，<code>no-fast-forward</code> 又是什么呢？</p>
<h3 id="no-fast-foward-no-ff"><a href="#no-fast-foward-no-ff" class="headerlink" title="no-fast-foward (--no-ff)"></a>no-fast-foward (<code>--no-ff</code>)</h3><p>跟即将合并过来的分支比较，当前分支如果没有额外的提交，这固然很好，但实际情况往往不是这样！如果我们在当前分支上也提交了一些改动，那么 Git 就会执行<code>no-fast-forward</code>合并。</p>
<p>对于 <code>no-fast-forward</code> 合并，Git 会在当前分支上创建一个新的<strong>合并提交</strong>。该提交的父提交同时指向当前分支和合并过来的分支。<br><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232112426.gif" alt="no-fast-forward"></p>
<p>也没毛病！现在<code>master</code>分支上有了我们在<code>dev</code>分支上做的所有变更。</p>
<h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>虽然 Git 擅长决定如何合并分支和更改文件，但它也不是总能自己做出决定。当我们试图合并的两个分支在同一文件的同一行上都有改动时，或者一个分支删除了文件，另一个分支又修改了它，都可能发生这种情况。</p>
<p>这种情况下，Git 会要求你帮助决定要保留哪边的改动。假设在两个分支上，我们都编辑了<code>README.md</code>文件的第一行：<br><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232113211.png" alt="img"></p>
<p>如果把<code>dev</code>合并到<code>master</code>，会导致合并冲突：你是要 <code>Hello!</code>呢，还是要 <code>Hey!</code>？</p>
<p>合并分支时，Git 会显示冲突的位置。我们可以手动删除不想保留的改动，然后保存，再添加改动后的文件（<code>git add</code>）并提交。<br><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232118399.gif" alt="合并冲突"></p>
<p>大功告成！合并冲突虽然很烦人，但也是合理的：Git 不应该自作主张保留哪边的改动。</p>
<hr>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>刚刚我们看到了如何通过执行<code>git merge</code>将一个分支的改动应用到另一个分支。另一种方式是使用<code>git rebase</code>。</p>
<p><code>git rebase</code> 命令复制当前分支的提交，然后把这些提交放到指定分支之上。<br><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232119869.gif" alt="git rebase"></p>
<p>现在<code>master</code>分支上的所有改动都跑到<code>dev</code>分支上了！</p>
<p>与<code>merge</code>相比，最大的区别是 Git 不会去找出哪些文件需要保留，哪些文件不需要保留。我们要<code>rebase</code>的分支总是包含了我们想要保留的最新改动。这种方式不会有合并冲突，并且保持了良好的线性 Git 历史记录。</p>
<p>这个例子演示了在 <code>master</code>分支上执行<code>rebase</code>。不过，在大项目里你可能不会这么做。 <code>git rebase</code>命令会修改项目历史记录，因为复制的提交会产生新的 hash。</p>
<p>当你在特性分支上开发时，<code>master</code>分支有更新的时候，<code>rebase</code> 很有用。这样你在当前分支就能拿到所有更新，避免了将来可能的合并冲突。</p>
<h3 id="交互式-rebase"><a href="#交互式-rebase" class="headerlink" title="交互式 rebase"></a>交互式 rebase</h3><p>在 <code>rebase</code> 之前，我们还可以修改！这是通过<em>交互式 rebase</em> 实现的。交互式 rebase 也可以用于当前正在处理的分支，在希望修改某些提交的时候。<br>对于即将 rebase 的提交，可以执行 6 种操作：</p>
<ul>
<li><code>reword</code>：修改提交说明</li>
<li><code>edit</code>：修改提交内容（amend）</li>
<li><code>squash</code>：将该提交合并到前一个提交</li>
<li><code>fixup</code>: 将该提交合并到前一个提交，不保留提交的日志消息</li>
<li><code>exec</code>: 在想要 rebase 的每一个提交上执行命令</li>
<li><code>drop</code>: 删除提交</li>
</ul>
<p>666！这样，我们就能完全控制提交记录了。如果想删除某个提交，只要 <code>drop</code>它就行了。<br><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232119454.gif" alt="Alt Text"></p>
<p>或者，如果我们想要把多个提交合并到一起，这样历史记录会更清晰，也没问题！</p>
<p>交互式 rebase 给了你对想要 rebase 的提交很多控制权，哪怕是当前的活动分支。</p>
<hr>
<h2 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h2><p>有时候我们提交了一些改动，后来又不想要了。有可能是<code>WIP</code>提交，也可能是某个引入了 bug 的提交。这种情况，我们可以执行<code>git reset</code>。</p>
<p><code>git reset</code>会丢弃当前所有暂存的文件，并让我们决定 <code>HEAD</code> 应该指向哪里。</p>
<h3 id="soft-reset"><a href="#soft-reset" class="headerlink" title="soft reset"></a>soft reset</h3><p><em>soft reset</em> 将<code>HEAD</code> 移动到指定的提交（或者相对于<code>HEAD</code> 的位置索引），同时不会丢弃这些提交带来的改动。</p>
<p>假设我们不想保留添加了<code>style.css</code>文件的提交<code>9e78i</code>，也不想保留添加了<code>index.js</code>文件的提交<code>035cc</code> 。但是，我们却想要保留新增的<code>style.css</code>和<code>index.js</code> 文件。这里用 soft reset 就非常合适。<br><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232119371.gif" alt="image"></p>
<p>执行<code>git status</code>，你会看到我们依然能够查看之前提交所做的改动。这很有用，因为这样我们就能继续修改文件内容，后续再次提交了。</p>
<h3 id="hard-reset"><a href="#hard-reset" class="headerlink" title="hard reset"></a>hard reset</h3><p>有时候，我们不想保留某些提交带来的改动。跟 soft reset 不一样，我们不再需要访问这些变动了。Git 应该简单地重置到指定的提交，并且会重置工作区和暂存区的文件。<br><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232119356.gif" alt="Alt Text"></p>
<p>Git 已经丢弃了<code>9e78i</code> 和 <code>035cc</code> 两个提交引起的改动，并把状态重置到了提交<code>ec5be</code>的位置。</p>
<hr>
<h3 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h3><p>撤销改动的另一种方式是执行<code>git revert</code>。复原某个提交后，会创建一个新的提交，包含了恢复后的改动。</p>
<p>假设提交 <code>ec5be</code>添加了一个<code>index.js</code>文件。随后，我们发现实际上不再需要这个改动了，就可以恢复<code>ec5be</code>这个提交。<br><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232120222.gif" alt="Alt Text"></p>
<p>提交<code>9e78i</code>恢复了<code>ec5be</code> 这个提交带来的改动。执行 <code>git revert</code>对于撤销某个提交非常有用，同时又不会修改分支的历史。</p>
<hr>
<h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p>当活动分支需要某个分支的某个提交包含的改动时，我们可以用<code>cherry-pick</code>命令。通过<code>cherry-pick</code>某个提交，在当前活动分支上会创建一个新提交，包含了前者带来的改动。</p>
<p>假设 <code>dev</code> 分支上的提交<code>76d12</code>改动了<code>index.js</code>文件，我们在<code>master</code>分支上也需要。我们不需要整个分支上的改动，只要这个提交。<br><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232120706.gif" alt="Alt Text"></p>
<p>666，<code>master</code>分支现在也包含了<code>76d12</code>提交的改动了。</p>
<hr>
<h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>如果存在远程分支，远程分支可能有些提交是当前的本地分支没有的。有可能是其他分支合并过去了，或者你的同事推送了某些改动，等等。</p>
<p>我们可以用 <code>git fetch</code> 把这些改动获取到本地。这不会影响本地分支，<code>fetch</code>只是下载数据。<br><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232120905.gif" alt="Alt Text"></p>
<p>现在就可以看到从最近一次推送以来的所有变动。本地有了这些新数据，我们就可以决定如何使用了。</p>
<hr>
<h2 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h2><p>除了用<code>git fetch</code> 获取远程分支信息外，还可以用<code>git pull</code>。<code>git pull</code>实际上是两个命令合而为一：<code>git fetch</code>和<code>git merge</code>。当我们从 origin 拉取改动时，先是像<code>git fetch</code>一样获取所有数据，然后最新改动会自动合并到本地分支。<br><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232120535.gif" alt="Alt Text"></p>
<p>这样就跟远程分支保持同步了，包含了所有的最新改动。</p>
<hr>
<h2 id="reflog"><a href="#reflog" class="headerlink" title="reflog"></a>reflog</h2><p>每个人都会犯错误，这完全没有关系！有时候你可能觉得自己把仓库搞得一团糟，只想把它删了完事。</p>
<p><code>git reflog</code>是个非常有用的命令，可以显示所有操作的日志。包括 <code>merge</code>，<code>reset</code>，<code>revert</code> 等，基本上包括了对分支的任何更改。<br><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232120762.gif" alt="Alt Text"></p>
<p>如果出错了，你可以根据<code>reflog</code>提供的信息通过重置<code>HEAD</code> 来撤销改动。</p>
<p>比如，我们实际上并不想合并分支。当我们执行 <code>git reflog</code>命令时，我们看到在合并前仓库位于 <code>HEAD@&#123;1&#125;</code>。我们执行下<code>git reset</code>命令，让 HEAD 重新指回原来的<code>HEAD@&#123;1&#125;</code>位置。<br><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232121831.gif" alt="Alt Text"></p>
<p>我们可以看到，最新的操作也记录到<code>reflog</code>里了。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(00)—数据库和SQL</title>
    <url>/2021/09/17/MySQL(00)%E2%80%94%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8CSQL/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="数据库和SQL"><a href="#数据库和SQL" class="headerlink" title="数据库和SQL"></a>数据库和SQL</h3><h4 id="1-数据库的好处"><a href="#1-数据库的好处" class="headerlink" title="1. 数据库的好处"></a>1. 数据库的好处</h4><p>保存数据的容器：数组、集合、文件……</p>
<p>实现数据持久化，使用完整的管理系统统一管理，易于查询</p>
<h4 id="2-数据库概念"><a href="#2-数据库概念" class="headerlink" title="2. 数据库概念"></a>2. 数据库概念</h4><p><strong>DB：</strong></p>
<p>数据库(database)：存储数据的“仓库”。它保存了一系列有组织的数据</p>
<p><strong>DBMS：</strong></p>
<p>数据库管理系统(Database Management System)：数据库是通过DBMS创建和操作的容器</p>
<p><strong>SQL：</strong></p>
<p>结构化查询语言(Structure Query Language)：专门用来与数据库通信的语言</p>
<h4 id="3-数据库管理系统"><a href="#3-数据库管理系统" class="headerlink" title="3. 数据库管理系统"></a>3. 数据库管理系统</h4><p>常见的数据库管理系统：MySQL、Oracle、DB2、SqlServer等</p>
<h4 id="4-SQL语言概述"><a href="#4-SQL语言概述" class="headerlink" title="4. SQL语言概述"></a>4. SQL语言概述</h4><p>SQL的优点：</p>
<ol>
<li>不是某个特定数据库供应商专有的语言，几乎所有DBMS都支持SQL</li>
<li>简单易学</li>
<li>虽然简单，但实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。</li>
</ol>
<h4 id="5-SQL语言分类"><a href="#5-SQL语言分类" class="headerlink" title="5. SQL语言分类"></a>5. SQL语言分类</h4><ol>
<li>DML(Data Manipulation Languaage)：数据操纵语言，用于添加、删除、修改、查询数据库记录，并检查数据完整性</li>
<li>DDL(Data Definition Language)：数据定义语言，用于库和表的创建、修改、删除</li>
<li>DCL(Data Control Language)：数据控制语言，用于定义用户的访问权限和安全级别</li>
</ol>
<h5 id="5-1-DML"><a href="#5-1-DML" class="headerlink" title="5.1 DML"></a>5.1 DML</h5><p>DML用于查询与修改数据记录，包括如下SQL语句：</p>
<ul>
<li>INSERT：添加数据到数据库中</li>
<li>UPDATE：修改数据库中的数据</li>
<li>DELETE：删除数据库中的数据</li>
<li>SELECT：选择(查询)数据<ul>
<li>SELECT是SQL语言的基础，最为重要</li>
</ul>
</li>
</ul>
<h5 id="5-2-DDL"><a href="#5-2-DDL" class="headerlink" title="5.2 DDL"></a>5.2 DDL</h5><p>DDL用于定义数据库的结构，比如创建、修改或删除数据库对象，包括如下SQL语句：</p>
<ul>
<li>CREAT TABLE：创建数据库表</li>
<li>ALTER TABLE：更改表结构、添加、删除、修改列长度</li>
<li>DROP TABLE：删除表</li>
<li>CREATE INDEX：在表上建立索引</li>
<li>DROP INDEX：删除索引</li>
</ul>
<h5 id="5-3-DCL"><a href="#5-3-DCL" class="headerlink" title="5.3 DCL"></a>5.3 DCL</h5><p>DCL用来控制数据库的访问，包括如下SQL语句：</p>
<ul>
<li>GRANT：授予访问权限</li>
<li>REVOKE：撤销访问权限</li>
<li>COMMIT：提交事务处理</li>
<li>ROLLBACK：事务处理回退</li>
<li>SAVEPOINT：设置保存点</li>
<li>LOCK：对数据库的特定部分进行锁定</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(03)—常见函数</title>
    <url>/2021/09/17/MySQL(03)%E2%80%94%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h3><h4 id="1-字符函数"><a href="#1-字符函数" class="headerlink" title="1. 字符函数"></a>1. 字符函数</h4><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108182038721.png" alt="image-20210818203807288"></p>
<h5 id="1-1-大小写控制函数"><a href="#1-1-大小写控制函数" class="headerlink" title="1.1 大小写控制函数"></a>1.1 大小写控制函数</h5><p>这类函数改变字符的大小写</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>LOWER(‘SQL Course’)</td>
<td>sql course</td>
</tr>
<tr>
<td>UPPER(‘SQL Course’)</td>
<td>SQL COURSE</td>
</tr>
</tbody></table>
<h5 id="1-2-字符控制函数"><a href="#1-2-字符控制函数" class="headerlink" title="1.2 字符控制函数"></a>1.2 字符控制函数</h5><table>
<thead>
<tr>
<th>函数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>CONCAT(‘Hello’,’World’)</td>
<td>HelloWorld</td>
</tr>
<tr>
<td>SUBSTR(‘HelloWorld’,1,5)</td>
<td>Hello</td>
</tr>
<tr>
<td>LENGTH(‘HelloWorld’)</td>
<td>10</td>
</tr>
<tr>
<td>INSTR(‘HelloWorld’,’W’)</td>
<td>6</td>
</tr>
<tr>
<td>LPAD(salary,10,’*’)</td>
<td>*****24000</td>
</tr>
<tr>
<td>RPAD(salary,10,’*’)</td>
<td>24000*****</td>
</tr>
<tr>
<td>TRIM(‘H’FROM’HelloWorld’)</td>
<td>elloWorld</td>
</tr>
<tr>
<td>REPLACE(‘abcd’,’b’,’m’)</td>
<td>amcd</td>
</tr>
</tbody></table>
<h4 id="2-数字函数"><a href="#2-数字函数" class="headerlink" title="2 数字函数"></a>2 数字函数</h4><ul>
<li><p>ROUND：四舍五入</p>
<p>ROUND(45.926,2) ——&gt; 45.93</p>
</li>
<li><p>TRUNCATE：截断</p>
<p>TRUNC(45.926,2) ——&gt; 45.92</p>
</li>
<li><p>MOD：求余</p>
<p>MOD(1600,300) ——&gt; 100</p>
</li>
</ul>
<h4 id="3-日期函数"><a href="#3-日期函数" class="headerlink" title="3. 日期函数"></a>3. 日期函数</h4><ul>
<li><p>now：获取当前日期</p>
</li>
<li><p>str_to_date：将日期格式的字符转换成指定格式的日期</p>
<p>str_to_date(‘9-13-1999’,’%m-%d-%Y’)              1993-09-13</p>
</li>
<li><p>date_format：将日期转化成字符</p>
<p>date_format(‘2021/6/6’,’%Y年%m月%d日’)     2021年6月6日</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>序号</th>
<th>格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>%Y</td>
<td>四位的年份</td>
</tr>
<tr>
<td>2</td>
<td>%y</td>
<td>2位的年份</td>
</tr>
<tr>
<td>3</td>
<td>%m</td>
<td>月份(01，02….11，12)</td>
</tr>
<tr>
<td>4</td>
<td>%c</td>
<td>月份(1,2…11,12)</td>
</tr>
<tr>
<td>5</td>
<td>%d</td>
<td>日(01，02)</td>
</tr>
<tr>
<td>6</td>
<td>%H</td>
<td>小时(24小时制)</td>
</tr>
<tr>
<td>7</td>
<td>%h</td>
<td>小时(12小时制)</td>
</tr>
<tr>
<td>8</td>
<td>%i</td>
<td>分钟(00,01….59)</td>
</tr>
<tr>
<td>9</td>
<td>%s</td>
<td>秒(00,01…..59)</td>
</tr>
</tbody></table>
<h4 id="4-其他函数"><a href="#4-其他函数" class="headerlink" title="4. 其他函数"></a>4. 其他函数</h4><h4 id="5-流程控制函数"><a href="#5-流程控制函数" class="headerlink" title="5. 流程控制函数"></a>5. 流程控制函数</h4><h5 id="5-1-条件表达式"><a href="#5-1-条件表达式" class="headerlink" title="5.1 条件表达式"></a>5.1 条件表达式</h5><ul>
<li><p>在SQL语句中使用IF-THEN-ELSE逻辑</p>
</li>
<li><p>使用方法</p>
<p>—CASE表达式</p>
<p>在本需要使用IF-THEN-ELSE逻辑时</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CASE expr WHEN comparison_expr1 THEN return_expr1</span><br><span class="line">[WHEN comparison_expr2 THEN return_expr2</span><br><span class="line">WHEN comparison_exprn THEN return_exprn</span><br><span class="line">ELSE else_expr]</span><br><span class="line">END</span><br></pre></td></tr></table></figure>
</li>
<li><pre><code class="mysql">SELECT last_name, job_id, salary,
    CASE job_id WHEN &#39;IT_PROG&#39; THEN 1.10*salary
                WHEN &#39;ST_CLERK&#39; THEN 1.15*salary
                WHEN &#39;SA_REP&#39; THEN 1.20*salary
    ELSE salary END &quot;REVISED_SALARY&quot;
FROM employees;
</code></pre>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108190911003.png" alt="image-20210819091115579"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(04)—常见函数</title>
    <url>/2021/09/17/MySQL(04)%E2%80%94%E5%AD%90%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>概念：出现在其他语句内部的select语句，称为子 查询或内查询；内部嵌套其他select语句的查询，称为外查询或主 查询<br>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select first_name </span><br><span class="line">from employees </span><br><span class="line">where department_id in(</span><br><span class="line">	select department_id </span><br><span class="line">    from departments</span><br><span class="line">	where location_id&#x3D;1700</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li><p>子查询要包含在括号内</p>
</li>
<li><p>将子查询放在比较条件的右侧</p>
</li>
<li><p>单行操作符对象单行子查询，多行操作符对应多行子查询</p>
</li>
<li><p>单行子查询</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108190927328.png" alt="image-20210819092714187"></p>
</li>
<li><p>多行子查询</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108190928644.png" alt="image-20210819092801406"></p>
</li>
</ul>
<h4 id="1-单行子查询"><a href="#1-单行子查询" class="headerlink" title="1. 单行子查询"></a>1. 单行子查询</h4><p>只返回一行，使用单行比较操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>Equal to</td>
</tr>
<tr>
<td>&gt;</td>
<td>Greater than</td>
</tr>
<tr>
<td>&gt;=</td>
<td>Greater than or equal to</td>
</tr>
<tr>
<td>&lt;</td>
<td>Less than</td>
</tr>
<tr>
<td>&lt;=</td>
<td>Less than or equal to</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>Not equal to</td>
</tr>
</tbody></table>
<p>子查询语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT select_list</span><br><span class="line">FROM table</span><br><span class="line">WHERE expr operator</span><br><span class="line">	(SELECT select_list</span><br><span class="line">	  FROM table);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子查询 (内查询) 在主查询之前一次执行完成。 子查询的结果被主查询(外查询)使用 。</p>
<p>使用子查询解决问题</p>
<p>谁的工资比Abel高？</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108190936564.png" alt="image-20210819093644144"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &gt;(SELECT salary</span><br><span class="line">				FROM employees</span><br><span class="line">				WHERE last_name &#x3D; &#39;Abel&#39;);</span><br></pre></td></tr></table></figure>

<img src="../../../../Users/xiong/AppData/Roaming/Typora/typora-user-images/image-20210819094032607.png" alt="image-20210819094032607" style="zoom:50%;" /> 

<ol>
<li><p>执行单行子查询</p>
<p>返回job_id与141号员工相同，salary比143号员工多的员工的姓名，job_id和工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select last_name,job_id,salary</span><br><span class="line">from employees</span><br><span class="line">where job_id &#x3D; (select job_id </span><br><span class="line">                from employees </span><br><span class="line">                where employee_id &#x3D; 141)</span><br><span class="line">and salary &gt; (select salary</span><br><span class="line">             from employees</span><br><span class="line">             where employee_id &#x3D; 143);</span><br></pre></td></tr></table></figure>

<img src="../../../../Users/xiong/AppData/Roaming/Typora/typora-user-images/image-20210819095441015.png" alt="image-20210819095441015" style="zoom: 50%;" /> 
</li>
<li><p>在子查询中使用组函数</p>
<p>返回公司工资最少的员工的last_name，job_id和salary</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select last_name,job_id,salary</span><br><span class="line">from employees</span><br><span class="line">where salary &#x3D; (select min(salary)</span><br><span class="line">    from employees</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108191041825.png" alt="image-20210819101029244" style="zoom: 50%;" /> 
</li>
<li><p>子查询中的HAVING子句</p>
<p>首先执行子查询，向主查询中的HAVING子句返回结果</p>
<p>查询最低工资大于50号部门最低工资的部门id和其最低工资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select department_id,min(salary)</span><br><span class="line">from employees</span><br><span class="line">group by department_id</span><br><span class="line">having min(salary) &gt; (select min(salary) </span><br><span class="line">                      from employees </span><br><span class="line">                      where department_id &#x3D; 50);</span><br></pre></td></tr></table></figure>

<img src="../../../../Users/xiong/AppData/Roaming/Typora/typora-user-images/image-20210819105231528.png" alt="image-20210819105231528" style="zoom:50%;" /> 

</li>
</ol>
<h4 id="2-多行子查询"><a href="#2-多行子查询" class="headerlink" title="2. 多行子查询"></a>2. 多行子查询</h4><p>返回多行，使用多行比较操作符</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>IN/NOT IN</td>
<td>等于列表中的任意一个</td>
</tr>
<tr>
<td>ANY | SOME</td>
<td>和子查询返回的某一个值比较</td>
</tr>
<tr>
<td>ALL</td>
<td>和子查询返回的所有值比较</td>
</tr>
</tbody></table>
<p>体会any和all的区别</p>
<ol>
<li><p>使用IN操作符</p>
<p>返回location_id是1400或1700的部门中的所有员工姓名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select last_name</span><br><span class="line">from employeesleft join locations</span><br><span class="line">on location_id in (1400,1700);</span><br></pre></td></tr></table></figure>

<img src="../../../../Users/xiong/AppData/Roaming/Typora/typora-user-images/image-20210819124909755.png" alt="image-20210819124909755" style="zoom:50%;" /> 
</li>
<li><p>在多行子查询中使用ANY操作符</p>
<p>返回其他部门中比job_id为’IT_PROG’部门<u>任意某一</u>工资低的员工的员工号、姓名、job_id以及salary</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select employee_id,last_name,job_id,salary</span><br><span class="line">from employees</span><br><span class="line">where salary &lt; any(select salary</span><br><span class="line">                  from employees</span><br><span class="line">                  where job_id &#x3D; &#39;IT_PROG&#39;)</span><br><span class="line">                  and job_id &lt;&gt; &#39;IT_PROG&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108191257996.png" alt="image-20210819125713691"></p>
</li>
<li><p>在多行子查询中使用ALL操作符</p>
<p>返回其它部门中比job_id为‘IT_PROG’部门<u>所有</u>工资都低的员工 的员工号、姓名、job_id 以及salary</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select employee_id,last_name,job_id,salary</span><br><span class="line">from employees</span><br><span class="line">where salary &lt; all(select salary</span><br><span class="line">                  from employees</span><br><span class="line">                  where job_id &#x3D; &#39;IT_PROG&#39;)</span><br><span class="line">                  and job_id &lt;&gt; &#39;IT_PROG&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108191300990.png" alt="image-20210819130023721"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(05)—数据处理之增删改</title>
    <url>/2021/09/17/MySQL(05)%E2%80%94%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E5%A2%9E%E5%88%A0%E6%94%B9/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="数据处理之增删改"><a href="#数据处理之增删改" class="headerlink" title="数据处理之增删改"></a>数据处理之增删改</h3><h4 id="1-数据操纵语言"><a href="#1-数据操纵语言" class="headerlink" title="1. 数据操纵语言"></a>1. 数据操纵语言</h4><ul>
<li>DML(Data Manipulation Language — 数据操纵语言)可以在下列条件下执行<ul>
<li>向表中插入数据</li>
<li>修改现存数据</li>
<li>删除现存数据</li>
</ul>
</li>
<li>事务是由完成若干项工作的DML语言组成的</li>
</ul>
<h4 id="2-插入数据"><a href="#2-插入数据" class="headerlink" title="2. 插入数据"></a>2. 插入数据</h4><p>INSERT语句语法</p>
<p>一次向表中插入一条数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO table [(column [, column...])]</span><br><span class="line">VALUES (value [, value...]);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>为每一列添加一个新值，按列的默认顺序列出各个列的值。在INSERT子句中随意列出列名和他们的值，字符和日期型数据应包含在单引号中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO</span><br><span class="line">employees(employee_id,last_name,email,hiredate,job_id)</span><br><span class="line">VALUES (300,&#39;Tom&#39;,&#39;tom@126.com&#39;,str_to_date(&#39;2021-3-21&#39;,&#39;%Y-%m-%d&#39;),&#39;SA_REP&#39;);</span><br><span class="line"></span><br><span class="line">[2021-08-19 17:56:28] 1 row affected in 14 ms</span><br></pre></td></tr></table></figure>
</li>
<li><p>向表中插入空值</p>
<p>隐式方式：在列名表中省略该值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into departments (department_id,department_name)</span><br><span class="line">values(280,&#39;Sel&#39;);</span><br><span class="line"></span><br><span class="line">[2021-08-19 18:03:01] 1 row affected in 11 ms</span><br></pre></td></tr></table></figure>

<p>显示方式：在VALUES子句集中指定空值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into departments</span><br><span class="line">values(290,&#39;Fri&#39;,null,null);</span><br><span class="line"></span><br><span class="line">[2021-08-19 18:04:56] 1 row affected in 18 ms</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入指定的值</p>
<p>NOW()函数：记录当前系统的日期和时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert into employees(employee_id,</span><br><span class="line">                      first_name,</span><br><span class="line">                      last_name,</span><br><span class="line">                      email,</span><br><span class="line">                      phone_number,</span><br><span class="line">                      hiredate,</span><br><span class="line">                      job_id,</span><br><span class="line">                      salary,</span><br><span class="line">                      commission_pct,</span><br><span class="line">                      manager_id,</span><br><span class="line">                      department_id)</span><br><span class="line">values(207, </span><br><span class="line">&#39;Louis&#39;, &#39;Popp&#39;, </span><br><span class="line">&#39;LPOPP&#39;, &#39;515.124.4567&#39;, </span><br><span class="line">NOW(), &#39;AC_ACCOUNT&#39;, 6900, </span><br><span class="line">NULL, 205, 100);</span><br><span class="line"></span><br><span class="line">[2021-08-19 20:25:18] 1 row affected in 18 ms</span><br></pre></td></tr></table></figure>
</li>
<li><p>从其他表中拷贝数据</p>
<p>在INSERT语句中加入子查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myemployees&gt; insert into employees_test</span><br><span class="line">             select *</span><br><span class="line">             from employees</span><br><span class="line">             where department_id &#x3D; 110</span><br><span class="line">[2021-08-20 10:04:48] 2 rows affected in 12 ms</span><br></pre></td></tr></table></figure>

<p>不必书写 VALUES 子句,子查询中的值列表应与 INSERT 子句中的列名对应</p>
</li>
</ol>
<h4 id="3-更新数据"><a href="#3-更新数据" class="headerlink" title="3. 更新数据"></a>3. 更新数据</h4><p>UPDATE语句语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE table</span><br><span class="line">SET column &#x3D; value [, column &#x3D; value, ...]</span><br><span class="line">[WHERE condition]</span><br></pre></td></tr></table></figure>

<p>可以一次更新多条数据。如果需要回滚数据，需要保证在DML前，进行设置：SET AUTOCOMMIT = FALSE;</p>
<ol>
<li><p>使用WHERE子句指定需要更新的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update employees</span><br><span class="line">set department_id &#x3D; 70</span><br><span class="line">where employee_id &#x3D; 113;</span><br><span class="line"></span><br><span class="line">[2021-08-20 10:10:44] 1 row affected in 0 ms</span><br></pre></td></tr></table></figure>

<p>如果省略 WHERE 子句，则表中的所有数据都将被更新</p>
</li>
</ol>
<h4 id="4-删除数据"><a href="#4-删除数据" class="headerlink" title="4. 删除数据"></a>4. 删除数据</h4><p>DELETE语句语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM table</span><br><span class="line">[WHERE 		condition];</span><br></pre></td></tr></table></figure>

<ol>
<li><p>使用WHERE子句删除指定的记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE FROM departments</span><br><span class="line">WHERE department_name &#x3D; &#39;Finance&#39;;</span><br><span class="line"></span><br><span class="line">[2021-08-20 10:15:32] completed in 5 ms</span><br></pre></td></tr></table></figure>

<p>如果省略 WHERE 子句，则表中的全部数据将被删除</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(06)—创建和管理表</title>
    <url>/2021/09/17/MySQL(06)%E2%80%94%E5%88%9B%E5%BB%BA%E5%92%8C%E7%AE%A1%E7%90%86%E8%A1%A8/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="创建和管理表"><a href="#创建和管理表" class="headerlink" title="创建和管理表"></a>创建和管理表</h3><h4 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1. 创建数据库"></a>1. 创建数据库</h4><ul>
<li><p>创建一个保存员工信息的数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database employee_date;</span><br><span class="line"></span><br><span class="line">[2021-08-20 10:57:37] 1 row affected in 16 ms</span><br></pre></td></tr></table></figure>
</li>
<li><p>相关其他命令</p>
<p><code>show database</code>：查看当前数据库</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108201139802.png" alt="image-20210820105850350" style="zoom:50%;" /> 

<p><code>use employees</code>：“使用”一个数据库，使其作为当前数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myemployees&gt; use employee_date</span><br><span class="line">[2021-08-20 11:00:02] completed in 0 ms</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="1-1-命名规则"><a href="#1-1-命名规则" class="headerlink" title="1.1 命名规则"></a>1.1 命名规则</h5><p>数据库名不得超过30个字符，变量名限制为29个，必须只能包含A-Z,a-z,0-9,_共63个字符。不能在对象名的字符间留空格，必须不能和用户定义的其他对象重名，必须保证你的字段没有和和保留字、数据库系统或常用 方法冲突 •。保持字段名和类型的一致性,在命名字段并为其指定数 据类型的时候一定要保证一致性。假如数据类型在一 个表里是整数,那在另一个表里可就别变成字符型了</p>
<h4 id="2-创建表"><a href="#2-创建表" class="headerlink" title="2. 创建表"></a>2. 创建表</h4><p>CREAT TABLE语句</p>
<p>必须具备：</p>
<ul>
<li><p>CREATE TABLE 权限</p>
</li>
<li><p>存储空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE [schema.]table (column datatype [DEFAULT expr][,...]);</span><br></pre></td></tr></table></figure>

<p>必须指定：</p>
<p>表名；列名，数据类型，尺寸</p>
</li>
</ul>
<h5 id="2-1-创建表"><a href="#2-1-创建表" class="headerlink" title="2.1. 创建表"></a>2.1. 创建表</h5><p>语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE dept(deptno INT(2),</span><br><span class="line">                 dname	 VARCHAR(14),</span><br><span class="line">                 loc	 VARCHAR(13));</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108201138414.png" alt="image-20210820110459757" style="zoom:50%;" /> <img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108201139294.png" alt="image-20210820110527288" style="zoom: 33%;" /></p>
<p>确认</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESCRIBE dept</span><br></pre></td></tr></table></figure>

<h4 id="3-描述各种数据类型"><a href="#3-描述各种数据类型" class="headerlink" title="3. 描述各种数据类型"></a>3. 描述各种数据类型</h4><h5 id="3-1-常用数据类型"><a href="#3-1-常用数据类型" class="headerlink" title="3.1 常用数据类型"></a>3.1 常用数据类型</h5><table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>INT</td>
<td>使用4个字节保存整数数据</td>
</tr>
<tr>
<td>CHAR(size)</td>
<td>指定字符数据。若未指定，则默认一个字符，最大长度255</td>
</tr>
<tr>
<td>VARCHAR(size)</td>
<td>可变长字符数据，根据字符串实际长度保存，必须指定长度</td>
</tr>
<tr>
<td>FLOAT(M,D)</td>
<td>单精度，M=整数位+小数位，D=小数位。D&lt;=M&lt;=255，0&lt;=D&lt;=30,默认M+D&lt;=6</td>
</tr>
<tr>
<td>DOUBLE(M,D)</td>
<td>双精度。D&lt;=M&lt;=255,0&lt;=D&lt;=30,默认M+D&lt;=15</td>
</tr>
<tr>
<td>DATE</td>
<td>日期型数据，格式’YYYY-MM-DD’</td>
</tr>
<tr>
<td>BLOB</td>
<td>二进制形式的长文本数据，最大可达4G</td>
</tr>
<tr>
<td>TEXT</td>
<td>长文本数据，最大可达4G</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#创建表</span><br><span class="line">CREATE TABLE emp(</span><br><span class="line">	#int类型，自增</span><br><span class="line">	emp_id 		INT 	AUTO_INCREMENT,</span><br><span class="line">	#最多保存2个中英文字符</span><br><span class="line">	emp_name 	CHAR(20),</span><br><span class="line">	#总位数不超过15位</span><br><span class="line">	salary		DOUBLE,</span><br><span class="line">    #日期类型</span><br><span class="line">    birthday	DATE,</span><br><span class="line">    #主键</span><br><span class="line">    PRIMARY KEY(emp_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="4-2-使用子查询创建表"><a href="#4-2-使用子查询创建表" class="headerlink" title="4.2 使用子查询创建表"></a>4.2 使用子查询创建表</h5><p>使用AS subquery选项，将创建表和插入数据结合起来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table [(column,column...)]</span><br><span class="line">AS subquery;</span><br></pre></td></tr></table></figure>

<p>指定的列和子查询中的列要一一对应，通过列名和默认值定义列</p>
<ol>
<li><p>复制现有表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table emp1 as select* from employees;</span><br><span class="line">create table emp2 as select* from employees [where ...];</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE dept80</span><br><span class="line">	AS </span><br><span class="line">		SELECT employee_id, last_name, </span><br><span class="line">			   salary*12 ANNSAL, </span><br><span class="line">               hire_date</span><br><span class="line">        FROM employees</span><br><span class="line">        WHERE department_id &#x3D; 80;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108201138385.png" alt="image-20210820111043990" style="zoom:50%;" /> <img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108201111597.png" alt="image-20210820111132924"></p>
</li>
</ol>
<h4 id="4-修改表的定义"><a href="#4-修改表的定义" class="headerlink" title="4. 修改表的定义"></a>4. 修改表的定义</h4><p>ALTER TABLE语句</p>
<ul>
<li>向已有表中添加列</li>
<li>修改现有表中的列</li>
<li>删除现有表中的列</li>
<li>重命名现有表中的列</li>
</ul>
<ol>
<li><p>追加一个新列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table dept80</span><br><span class="line">add job_id varchar(15);</span><br><span class="line"></span><br><span class="line">[2021-08-20 11:12:51] completed in 28 ms</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108201113602.png" alt="image-20210820111326187"></p>
</li>
<li><p>修改一个列</p>
<p>可以修改列的数据类型，尺寸和默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table dept80</span><br><span class="line">modify last_name varchar(30) default &#39;null_name&#39;;</span><br></pre></td></tr></table></figure>

<p>对默认值的修改只影响今后对表的修改</p>
</li>
<li><p>删除一个列</p>
<p>使用DROP COLUMN子句删除不在需要的列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table dept80</span><br><span class="line">drop column job_id;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108201138188.png" alt="image-20210820112733644" style="zoom:50%;" /> 
</li>
<li><p>重命名一个列</p>
<p>使用CHANGE old_column new_column dataType子句重命名列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table dept80</span><br><span class="line">change hiredate hire_date datetime;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108201130946.png" alt="image-20210820113037400" style="zoom:50%;" /> 

</li>
</ol>
<h4 id="5-删除，重命名和清空表"><a href="#5-删除，重命名和清空表" class="headerlink" title="5. 删除，重命名和清空表"></a>5. 删除，重命名和清空表</h4><h5 id="5-1-删除表"><a href="#5-1-删除表" class="headerlink" title="5.1 删除表"></a>5.1 删除表</h5><p>数据和结构都被删除，所有正在运行的相关事务被提交，所有相关索引被删除，DROP TABLE语句不能回滚</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop table dept;</span><br><span class="line"></span><br><span class="line">[2021-08-20 11:32:43] completed in 46 ms</span><br></pre></td></tr></table></figure>

<h5 id="5-2-清空表"><a href="#5-2-清空表" class="headerlink" title="5.2 清空表"></a>5.2 清空表</h5><ul>
<li><p>TRUNCATE TABLE语句</p>
<p>删除表中所有的数据，释放表的存储空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">truncate table dept;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>TRUNCATE语句不能回滚 </p>
</li>
<li><p>可以使用 DELETE 语句删除数据,可以回滚 </p>
</li>
<li><p>对比：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from emp2;</span><br><span class="line">select * from emp2;</span><br><span class="line">rollback;</span><br><span class="line">select * from emp2;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="5-3-改变对象的名称"><a href="#5-3-改变对象的名称" class="headerlink" title="5.3 改变对象的名称"></a>5.3 改变对象的名称</h5><p>执行RENAME语句改变表，视图的名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table dept80</span><br><span class="line">rename to detail_dept;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108201138292.png" alt="image-20210820113816843" style="zoom:50%;" /> 



]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(07)—常见的数据类型</title>
    <url>/2021/09/17/MySQL(07)%E2%80%94%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="常见的数据类型"><a href="#常见的数据类型" class="headerlink" title="常见的数据类型"></a>常见的数据类型</h3><h4 id="1-数值类型"><a href="#1-数值类型" class="headerlink" title="1. 数值类型"></a>1. 数值类型</h4><h5 id="1-1-整型"><a href="#1-1-整型" class="headerlink" title="1.1 整型"></a>1.1 整型</h5><table>
<thead>
<tr>
<th>整数类型</th>
<th>字节</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>Tinyint</td>
<td>1</td>
<td>有符号：-128<del>127 无符号：0</del>255</td>
</tr>
<tr>
<td>Smallint</td>
<td>2</td>
<td>有符号：-32768<del>32767 无符号：0</del>65535</td>
</tr>
<tr>
<td>Mediumint</td>
<td>3</td>
<td>有符号：-8388608<del>8388607 无符号：0</del>1677215</td>
</tr>
<tr>
<td>Int、integer</td>
<td>4</td>
<td>有符号：- 2147483648<del>2147483647 无符号：0</del>4294967295</td>
</tr>
<tr>
<td>Bigint</td>
<td>8</td>
<td>有符号： -9223372036854775808 <del>9223372036854775807 <br />无符号：0</del> 9223372036854775807*2+1</td>
</tr>
</tbody></table>
<h5 id="1-2-小数"><a href="#1-2-小数" class="headerlink" title="1.2 小数"></a>1.2 小数</h5><table>
<thead>
<tr>
<th>浮点数类型</th>
<th>字节</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4</td>
<td>±1.75494351E-38~±3.402823466E+38</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>±2.2250738585072014E-308~ ±1.7976931348623157E+308</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>定点数类型</th>
<th>字节</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>DEC(M,D) DECIMAL(M,D)</td>
<td>M+2</td>
<td>最大取值范围与double相同，给定decimal的有效取值范围由M和D 决定</td>
</tr>
</tbody></table>
<h5 id="1-3-位类型"><a href="#1-3-位类型" class="headerlink" title="1.3 位类型"></a>1.3 位类型</h5><table>
<thead>
<tr>
<th>位类型</th>
<th>字节</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>Bit(M)</td>
<td>1~8</td>
<td>Bit(1)~bit(8)</td>
</tr>
</tbody></table>
<h4 id="2-字符类型"><a href="#2-字符类型" class="headerlink" title="2. 字符类型"></a>2. 字符类型</h4><h5 id="2-1-char和varchar类型"><a href="#2-1-char和varchar类型" class="headerlink" title="2.1 char和varchar类型"></a>2.1 char和varchar类型</h5><p>说明：用来保存MySQL中比较短的字符串</p>
<table>
<thead>
<tr>
<th>字符串类型</th>
<th>最多字符数</th>
<th>描述以及存储需求</th>
</tr>
</thead>
<tbody><tr>
<td>char(M)</td>
<td>M</td>
<td>M为0-255之间的整数</td>
</tr>
<tr>
<td>varchar(M)</td>
<td>M</td>
<td>M为0-65535之间的整数</td>
</tr>
</tbody></table>
<h5 id="2-2-binary和varbinary类型"><a href="#2-2-binary和varbinary类型" class="headerlink" title="2.2 binary和varbinary类型"></a>2.2 binary和varbinary类型</h5><p>说明：类似于char和varvchar，不同的是他们包含二进制字符串而不包括非二进制字符串</p>
<h5 id="2-3-Enum类型"><a href="#2-3-Enum类型" class="headerlink" title="2.3 Enum类型"></a>2.3 Enum类型</h5><p>说明：又称为枚举类型，要求插入的值必须属于列表中指定的值之一</p>
<p>如果列表成员为1-255，则需要1字节存储</p>
<p>如果列表成员为25-65535，则需要2字节存储，最多需要65535个成员！</p>
<h5 id="2-4-Set类型"><a href="#2-4-Set类型" class="headerlink" title="2.4 Set类型"></a>2.4 Set类型</h5><p>说明：和Enum类型相似，里面可以保存0-64个成员。和Enum类型最大的区别是：SET类型一次可以选取多个成员，而Enum只能选一个，根据成员个数不同，存储所占字节也不相同</p>
<table>
<thead>
<tr>
<th>成员数</th>
<th>字节数</th>
</tr>
</thead>
<tbody><tr>
<td>1-8</td>
<td>1</td>
</tr>
<tr>
<td>9-16</td>
<td>2</td>
</tr>
<tr>
<td>17-24</td>
<td>3</td>
</tr>
<tr>
<td>25-32</td>
<td>4</td>
</tr>
<tr>
<td>33-64</td>
<td>8</td>
</tr>
</tbody></table>
<h4 id="3-日期类型"><a href="#3-日期类型" class="headerlink" title="3. 日期类型"></a>3. 日期类型</h4><table>
<thead>
<tr>
<th>日期和时间类型</th>
<th>字节</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>date</td>
<td>4</td>
<td>1000-01-01</td>
<td>9999-12-31</td>
</tr>
<tr>
<td>datetime</td>
<td>8</td>
<td>1000-01-01 00:00:00</td>
<td>9999-12-31 23:59:59</td>
</tr>
<tr>
<td>timestamp</td>
<td>4</td>
<td>19700101080001</td>
<td>2038年的某个时刻</td>
</tr>
<tr>
<td>time</td>
<td>3</td>
<td>-838:59:59</td>
<td>838:59:59</td>
</tr>
<tr>
<td>year</td>
<td>1</td>
<td>1901</td>
<td>2155</td>
</tr>
</tbody></table>
<ol>
<li>Timestamp支持的时间范围较小，取值范围： 19700101080001——2038年的某个时间 Datetime的取值范围：1000-1-1 ——9999—12-31</li>
<li>timestamp和实际时区有关，更能反映实际的日期，而datetime则只能反映出插入时的当地时区</li>
<li>timestamp的属性受Mysql版本和SQLMode的影响很大</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(08)—约束和分页</title>
    <url>/2021/09/17/MySQL(08)%E2%80%94%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="约束和分页"><a href="#约束和分页" class="headerlink" title="约束和分页"></a>约束和分页</h3><h4 id="1-描述约束"><a href="#1-描述约束" class="headerlink" title="1. 描述约束"></a>1. 描述约束</h4><h5 id="1-1-什么是约束"><a href="#1-1-什么是约束" class="headerlink" title="1.1 什么是约束"></a>1.1 什么是约束</h5><p>为了保证数据的一致性和完整性，SQL规范以约束的方式对表数据进行额外的条件限制。 约束是表级的强制规定 。可以在创建表时规定约束（通过 CREATE  TABLE 语句），或者在表创建之后也可以（通过 ALTER TABLE 语句）</p>
<ul>
<li>有以下六种约束<ul>
<li>NOT NULL 非空约束，规定某个字段不能为空</li>
<li>UNIQUE 唯一约束，规定某个字符在整个表中是唯一的</li>
<li>PRIMARY KEY 主键（非空且唯一）</li>
<li>FOREIGN KEY 外键</li>
<li>CHECK 检查约束</li>
<li>DEFAULT 默认值</li>
</ul>
</li>
</ul>
<p>MySQL不支持check约束，但可以使用check约束，而没有任何效果；具体细节可以参阅W3Cschool手册</p>
<ul>
<li>根据约束数据列的限制，约束可以分为：<ul>
<li>单列约束：每个约束只约束一列</li>
<li>多列约束：每个约束可以约束多列</li>
</ul>
</li>
<li>根据约束的作用范围，约束可以分为：<ul>
<li>列级约束只能作用在一列上，跟在列的定义后面</li>
<li>表级约束可以作用在多个列上，不与列一起，而是单独定义</li>
</ul>
</li>
</ul>
<h4 id="2-创建和维护约束"><a href="#2-创建和维护约束" class="headerlink" title="2. 创建和维护约束"></a>2. 创建和维护约束</h4><h5 id="2-1-NOT-NULL约束"><a href="#2-1-NOT-NULL约束" class="headerlink" title="2.1 NOT NULL约束"></a>2.1 NOT NULL约束</h5><ul>
<li>非空约束用于确保当权列的值不为空值，非空约束只能出现在表对象的列上</li>
<li>NULL类型特征：<ul>
<li>所有的类型的值都可以是null，包括int,float等数据类型</li>
<li>空字符串””不等于null，0也不等于null</li>
</ul>
</li>
</ul>
<ol>
<li><p>创建not null约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table emp(</span><br><span class="line">id int(10) not null,</span><br><span class="line">name varchar(20) not null default &#39;abc&#39;,</span><br><span class="line">sex char null</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加not null约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table emp</span><br><span class="line">modify sex varchar(30) not null;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消not null约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table emp</span><br><span class="line">modify sex varchar(30) null;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取消not null约束，增加默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table emp</span><br><span class="line">modify name varchar(15) default &#39;abc&#39; null;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-2-UNIQUE约束"><a href="#2-2-UNIQUE约束" class="headerlink" title="2.2 UNIQUE约束"></a>2.2 UNIQUE约束</h5><ul>
<li><p>同一个表可以有多个唯一约束，多个列组合的约束。在创建唯一约束的时候，如果不给唯一约束名称，就默认和列名相同。</p>
</li>
<li><p>MySQL回给唯一约束的列默认创建一个唯一的索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table user(</span><br><span class="line">	id int not null,</span><br><span class="line">    name varchar(25),</span><br><span class="line">    password varchar(16),</span><br><span class="line">    #使用表级约束语法</span><br><span class="line">    constraint uk_name_pwd unique(name,password)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>表示用户名和密码组合不能重复</p>
</li>
</ul>
<ol>
<li><p>添加唯一约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table user</span><br><span class="line">add unique(name,password);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table user</span><br><span class="line">add constraint uk_name_pwd unique(name,password);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table user</span><br><span class="line">modify name varchar(20) unique;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table user</span><br><span class="line">drop index uk_name_pwd;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-3-PRIMARY-KEY约束"><a href="#2-3-PRIMARY-KEY约束" class="headerlink" title="2.3 PRIMARY KEY约束"></a>2.3 PRIMARY KEY约束</h5><p>​         主键约束相当于唯一约束+非空约束的组合，主键约束列不允许重复，也不允许出现空值；如果是多列组合的主键约束，那么这些列都不允许重复；每个表最多只允许一个主键，建立主键约束可以在列级别创建，也可以在表级别创建；MySQL的主键名总是PRIMARY，当创建主键约束时，系统默认会在所在的列和列组合上<u><strong>建立唯一索引</strong></u></p>
<p><strong>列级模式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table emp4(</span><br><span class="line">	id int auto_increment primary key;</span><br><span class="line">    name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>表级模式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table emp5(</span><br><span class="line">	id int not null auto_increment,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    pwd varchar(15),</span><br><span class="line">    constraint emp5_id_pk primary key(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>组合模式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table emp6(</span><br><span class="line">	id int not null,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    pwd varchar(15),</span><br><span class="line">    constraint emp6_pk primary key(name,pwd)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>删除主键约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table emp5</span><br><span class="line">drop primary key;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加主键约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table emp5</span><br><span class="line">add primary key(name,pwd);</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主键约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table emp5</span><br><span class="line">modify id int primary key;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-4-FOREIGN-KEY约束"><a href="#2-4-FOREIGN-KEY约束" class="headerlink" title="2.4 FOREIGN KEY约束"></a>2.4 FOREIGN KEY约束</h5><p>​          外键约束是保证一个或两个表之间的参照完整性，外键是构建于一个表的两个字段或是两个表的两个字段之间的参照关系。从表的外键值必须在主表中能找到或者为空。当主表的记录被从表参照时，主表的记录将不允许删除， 如果要删除数据，需要先删除从表中依赖该记录的数据，然后才可以删除主表的数据。还有一种就是级联删除子表数据。注意：外键约束的参照列，在主表中引用的只能是主键或唯一键约束的列，同一个表可以有多个外键约束</p>
<ol>
<li><p>创建外键约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#主表</span><br><span class="line">create table dept(</span><br><span class="line">	dept_id int auto_increment primary key,</span><br><span class="line">    dept_name varchar(20)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#从表</span><br><span class="line">create table emp(</span><br><span class="line">	emp_id into auto_increment primary key,</span><br><span class="line">    last_name varchar(15),</span><br><span class="line">    dept_id int,</span><br><span class="line">    constraint emp_dept_id_fk foreign key(dept_id) </span><br><span class="line">    references dept(dept_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建多列外键组合，必须使用表级约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#主表</span><br><span class="line">create table calsses(</span><br><span class="line">	id int,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    number int,</span><br><span class="line">    primary key(name,number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#从表</span><br><span class="line">create table student(</span><br><span class="line">	id int auto_increment primary key,</span><br><span class="line">    classes_name varchar(20),</span><br><span class="line">    classes_number int,</span><br><span class="line">    foreign key(classes_name,classes_number)</span><br><span class="line">    references classes(name,number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除外键约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table emp</span><br><span class="line">drop foreign key emp_dept_id_fk;</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加外键约束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter table emp</span><br><span class="line">add [constraint emp_dept_id_fk] foreign key(dept_id)</span><br><span class="line">references dept(dept_id);</span><br></pre></td></tr></table></figure>
</li>
<li><p>FOREIGN KEY约束的关键字</p>
<p>FOREIGN KEY：在表级指定子表中的列</p>
<p>REFERENCES：标示在父表中的列</p>
<p>ON DELETE CASCADE(级联删除)：当父表中的列被删除时，子表中相对应的列也被删除</p>
<p>ON DELETE SET NULL(级联置空)：子表中相应的列置空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table student(</span><br><span class="line">	id int auto_increment primary key,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    classes_name varchar(20),</span><br><span class="line">    classes_number int,</span><br><span class="line">    #表级别联合外键</span><br><span class="line">    foreign key(classes_name,classes_number)</span><br><span class="line">    references classes(name,number)</span><br><span class="line">    on delete cascade</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="2-5-CHECK约束"><a href="#2-5-CHECK约束" class="headerlink" title="2.5 CHECK约束"></a>2.5 CHECK约束</h5><p>MySQL可以使用check约束，但check约束对数据验证没有任何作用，添加数据时，没有任何错误或警告</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table temp(</span><br><span class="line">	id int auto_increment,</span><br><span class="line">    name varchar(20),</span><br><span class="line">    age int check(age &gt; 20),</span><br><span class="line">    primary key(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>



<h4 id="3-数据库分页"><a href="#3-数据库分页" class="headerlink" title="3. 数据库分页"></a>3. 数据库分页</h4><ul>
<li>背景<ul>
<li>查询返回的记录太多，查看起来不方便</li>
</ul>
</li>
<li>分页原理<ul>
<li>所谓分页显示，就是将数据库中的结果集，一段一段显示出来需要的条件</li>
</ul>
</li>
</ul>
<h5 id="3-1-使用limit实现分页"><a href="#3-1-使用limit实现分页" class="headerlink" title="3.1 使用limit实现分页"></a>3.1 使用limit实现分页</h5><ul>
<li><p>怎么分段，当前在第几段（每页有几条，当前在第几页）</p>
<ul>
<li>前10条记录：SELECT * FROM table LIMIT 0,10; </li>
<li>第11至20条记录：SELECT * FROM table LIMIT 10,10; </li>
<li>第21至30条记录： SELECT * FROM table LIMIT 20,10;</li>
</ul>
</li>
<li><p>公式：（当前页数-1）*每页条数，每页条数</p>
<p>SELECT * FROM table LIMIT(PageNo - 1)*PageSize,PageSize;</p>
</li>
<li><p>注意：</p>
<ul>
<li>limit子句必须放在整个查询语句的最后</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(09)—事务</title>
    <url>/2021/09/17/MySQL(09)%E2%80%94%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="1-事务的概念和特性"><a href="#1-事务的概念和特性" class="headerlink" title="1. 事务的概念和特性"></a>1. 事务的概念和特性</h4><h5 id="1-1-事务的概念"><a href="#1-1-事务的概念" class="headerlink" title="1.1 事务的概念"></a>1.1 事务的概念</h5><ul>
<li>事务：事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态；如果单元中的所 有SQL语句均执行成功，则事物被顺利执行。</li>
</ul>
<h5 id="1-2-MySQL中的存储引擎"><a href="#1-2-MySQL中的存储引擎" class="headerlink" title="1.2 MySQL中的存储引擎"></a>1.2 MySQL中的存储引擎</h5><ol>
<li>概念：在mysql中的数据用各种不同的技术存储 在文件（或内存）中。</li>
<li>通过show engines；来查看mysql支持的存储引 擎。</li>
<li>在mysql中用的最多的存储引擎有：innodb， myisam ,memory 等。其中innodb支持事务，而 myisam、memory等不支持事务</li>
</ol>
<h5 id="1-3-事务的特点"><a href="#1-3-事务的特点" class="headerlink" title="1.3 事务的特点"></a>1.3 事务的特点</h5><ul>
<li><p>事务的ACID(acid)属性</p>
<ul>
<li><p>原子性(Atomicity)</p>
<p>原子性是指事务是一个不可分割的工作单位，事务中的操作要么 都发生，要么都不发生。</p>
</li>
<li><p>一致性(Consistency)</p>
<p>事务必须使数据库从一个一致性状态变换到另外一个一致性状态 。</p>
</li>
<li><p>隔离性(Isolation)</p>
<p>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p>
</li>
<li><p>持久性(Durability)</p>
<p>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响</p>
</li>
</ul>
</li>
</ul>
<h5 id="1-4-事务的使用"><a href="#1-4-事务的使用" class="headerlink" title="1.4 事务的使用"></a>1.4 事务的使用</h5><ul>
<li>以第一个DML语句的执行作为开始</li>
<li>以下面的其中之一作为结束<ul>
<li>commit或rollback语句</li>
<li>DDL或DCL语句（自动提交）</li>
<li>用户会话正常结束</li>
<li>系统异常终了</li>
</ul>
</li>
</ul>
<h4 id="2-事物的隔离级别"><a href="#2-事物的隔离级别" class="headerlink" title="2. 事物的隔离级别"></a>2. 事物的隔离级别</h4><ul>
<li><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p>
<ul>
<li>脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li>
<li>不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段。之后, T1再次读取同一个字段, 值就不同了。</li>
<li>幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插 入了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li>
</ul>
</li>
<li><p>数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力,  使它们不会相互影响, 避免各种并发问题。</p>
</li>
<li><p>一个事务与其他事务隔离的程度称为隔离级别。 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱。</p>
</li>
<li><p>数据库提供的4种事务隔离级别</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>READ UNCOMMITTED(读未提交数据)</td>
<td>允许事务读取未被其他事务提交的变更，脏读，不可重复读和幻读的问题都会出现</td>
</tr>
<tr>
<td>READ COMMITED(读已提交数据)</td>
<td>只允许事务读取已被其他事务提交的变更，可以避免脏读，但是不可重复读和幻读问题仍可能出现</td>
</tr>
<tr>
<td>REPEATABLE READ(可重复读)</td>
<td>确保事务可以多次从一个字段中读取相同的值。在这个事务持续期间，禁止其他事务对这个字段进行更新，可以避免脏读和不可重复读，但幻读的问题仍然存在</td>
</tr>
<tr>
<td>SERIALIZABLE(串行化)</td>
<td>确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入，更新和删除操作，所有并发都能避免，但性能十分低下</td>
</tr>
</tbody></table>
<p>Oracle 支持的 2 种事务隔离级别：READ COMMITED,  SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ  COMMITED；Mysql 支持 4 种事务隔离级别. Mysql 默认的事务隔离级别 为: REPEATABLE READ</p>
</li>
</ul>
<h4 id="3-事务的案例演示"><a href="#3-事务的案例演示" class="headerlink" title="3. 事务的案例演示"></a>3. 事务的案例演示</h4><h5 id="3-1-在-MySql-中设置隔离级别"><a href="#3-1-在-MySql-中设置隔离级别" class="headerlink" title="3.1 在 MySql 中设置隔离级别"></a>3.1 在 MySql 中设置隔离级别</h5><ul>
<li>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别</li>
<li>查看当前的隔离级别: SELECT @@tx_isolation;</li>
<li>设置当前 mySQL 连接的隔离级别:<ul>
<li>set transaction isolation level read committed;</li>
</ul>
</li>
<li>设置数据库系统的全局的隔离级别: <ul>
<li>set global transaction isolation level read committed；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(11)—存储过程和函数</title>
    <url>/2021/09/17/MySQL(11)%E2%80%94%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h3><h4 id="1-什么是存储过程和函数"><a href="#1-什么是存储过程和函数" class="headerlink" title="1. 什么是存储过程和函数"></a>1. 什么是存储过程和函数</h4><p>存储过程和函数： 事先经过编译并存储在数据库中的一段sql语句的集合。 </p>
<h4 id="2-使用存储过程和函数的好处"><a href="#2-使用存储过程和函数的好处" class="headerlink" title="2. 使用存储过程和函数的好处"></a>2. 使用存储过程和函数的好处</h4><p>使用好处：<br> 1、简化应用开发人员的很多工作<br>2、减少数据在数据库和应用服务器之间的传输<br>3、提高了数据处理的效率</p>
<h4 id="3-创建存储过程和函数"><a href="#3-创建存储过程和函数" class="headerlink" title="3. 创建存储过程和函数"></a>3. 创建存储过程和函数</h4><ul>
<li><p>创建存储过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure 存储过程名 ([proc_parameter[,…]])</span><br><span class="line">[characteristic…]routine_body</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create function 函数名([func_parameter[,…]])</span><br><span class="line">returns type</span><br><span class="line">[characteristic…]routine_body</span><br></pre></td></tr></table></figure>
</li>
<li><p>proc_parameter: [in|out|inout] param_name type</p>
</li>
<li><p>Func_paramter: param_name type</p>
</li>
<li><p>Type: 任何有效的mysql数据类型</p>
</li>
<li><p>Characteristic: </p>
<p>language sql(默认，且推荐) </p>
<p>|[not] deterministic </p>
<p>|{contains sql|no sql</p>
<p>​                       |reads sql data</p>
<p>​                       |modifies sql data} </p>
<p>|sql security{definer|invoker} </p>
<p>|comment ‘string’</p>
</li>
<li><p>Rountine_body: 有效的sql 过程语句</p>
</li>
</ul>
<h4 id="4-修改存储过程和函数"><a href="#4-修改存储过程和函数" class="headerlink" title="4. 修改存储过程和函数"></a>4. 修改存储过程和函数</h4><ul>
<li><p>修改存储过程： <code>alter procedure 存储过程名 [charactristic…]</code></p>
</li>
<li><p>修改函数： <code>alter function 函数名 [charactristic…]</code></p>
<p> characteristic: </p>
<p>​             {contains sql|no sql|reads sql data|modifies sql data}<br>​             |sql security{definer|invoker}<br>​             |comment ‘string’</p>
</li>
</ul>
<h4 id="5-调用存储过程和函数"><a href="#5-调用存储过程和函数" class="headerlink" title="5. 调用存储过程和函数"></a>5. 调用存储过程和函数</h4><p>• 调用存储过程： call 存储过程名(参数列表) </p>
<p>• 调用函数： Select 函数名(参数列表)</p>
<p><strong>案例</strong></p>
<ul>
<li>查询员工名为king的所有记录 </li>
<li>根据输入的员工名，查询部门名 </li>
<li>根据指定的员工编号，返回工资 </li>
<li>根据指定的员工编号，返回工资和部门号 </li>
<li>将输入的a和b都翻倍并返回</li>
</ul>
<h4 id="6-修改存储过程或函数"><a href="#6-修改存储过程或函数" class="headerlink" title="6. 修改存储过程或函数"></a>6. 修改存储过程或函数</h4><p>说明：一次只能删除一个存储过程或者函数，并且要求有该 过程或函数的alter routine 权限 删除存储过程： <code>drop procedure [if exists] 存储过程名</code><br>删除函数： <code>drop function [if exists] 函数名</code></p>
<h4 id="7-查看存储过程和函数"><a href="#7-查看存储过程和函数" class="headerlink" title="7. 查看存储过程和函数"></a>7. 查看存储过程和函数</h4><ol>
<li><p>查看存储过程或函数的状态： </p>
<p><code>show &#123;procedure|function&#125; status like 存储过程或函数名</code></p>
</li>
<li><p>查看存储过程或函数的定义：</p>
<p><code> show create &#123;procedure|function&#125; 存储过程或函数名</code></p>
</li>
<li><p>通过查看information_schema.routines了解存储过程和函数的 信息（了解） </p>
<p><code>select * from rountines where rounine_name =存储过程名|函数名</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(10)—视图</title>
    <url>/2021/09/17/MySQL(10)%E2%80%94%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><h4 id="1-什么是视图"><a href="#1-什么是视图" class="headerlink" title="1. 什么是视图"></a>1. 什么是视图</h4><ul>
<li><p>视图：MySQL从5.0.1版本开始提供视图功能。一种虚拟存在的表，行和列的数据来自定义视图的查询中使用的表 ，并且是在使用视图时动态生成的，只保存了sql逻辑，不保存查询结果 </p>
</li>
<li><p>应用场景： </p>
<ul>
<li>– 多个地方用到同样的查询结果 </li>
<li>– 该查询结果使用的sql语句较复杂</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create view my_v1</span><br><span class="line">as</span><br><span class="line">select studentname,majorname</span><br><span class="line">from student s</span><br><span class="line">inner join major m</span><br><span class="line">on s.majorid &#x3D; m.majorid</span><br><span class="line">where s.majorid &#x3D; 1;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="1-1-常见题目"><a href="#1-1-常见题目" class="headerlink" title="1.1 常见题目"></a>1.1 常见题目</h5><ol>
<li>查询邮箱中包含a字符的员工名、部门名和工种信息</li>
<li>查询各部门的平均工资级别</li>
<li>查询平均工资最低的部门信息</li>
<li>查询平均工资最低的部门名和工资</li>
</ol>
<h5 id="1-2-视图的好处"><a href="#1-2-视图的好处" class="headerlink" title="1.2 视图的好处"></a>1.2 视图的好处</h5><p>• 重用sql语句 </p>
<p>• 简化复杂的sql操作，不必知道它的查询细节 </p>
<p>• 保护数据，提高安全性</p>
<h4 id="2-创建或修改视图"><a href="#2-创建或修改视图" class="headerlink" title="2 创建或修改视图"></a>2 创建或修改视图</h4><ul>
<li><p>创建视图的语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create [or replace] view view_name</span><br><span class="line">as select_statement</span><br><span class="line">[with | cascaded | local | check option]</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改视图的语法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">alter view view_name</span><br><span class="line">as select_statement</span><br><span class="line">[with | cascaded | local | check option]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>视图的可更新性和视图中查询的定义有关系，以下类型的视图是不能更新的。</p>
<ul>
<li>包含以下关键字的sql语句：分组函数、distinct、group by 、having、union或者union all</li>
<li>常量视图</li>
<li>Select中包含子查询 </li>
<li>join </li>
<li>from一个不能更新的视图 </li>
<li>where子句的子查询引用了from子句中的表</li>
</ul>
<h4 id="3-删除视图"><a href="#3-删除视图" class="headerlink" title="3. 删除视图"></a>3. 删除视图</h4><ul>
<li><p>删除视图的语法</p>
<p>用户可以一次删除一个或者多个视图，前提是必须有该视 图的drop权限。 </p>
<p><code>drop view [if exists] view_name,view_name …[restrict|cascade]</code></p>
</li>
</ul>
<h4 id="4-查看视图"><a href="#4-查看视图" class="headerlink" title="4. 查看视图"></a>4. 查看视图</h4><ul>
<li><p>查看视图的语法： </p>
<p>show tables; 如果需要查询某个视图的定义，可以使用show create view 命令进行查看： <code>show create view view_name \G</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(12)—流程控制结构</title>
    <url>/2021/09/17/MySQL(12)%E2%80%94%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h3><h4 id="1-case结构——作为表达式"><a href="#1-case结构——作为表达式" class="headerlink" title="1. case结构——作为表达式"></a>1. case结构——作为表达式</h4><table>
<thead>
<tr>
<th></th>
<th>语法</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>情况一</td>
<td>case 表达式<br />when 值1 then 值1<br />when 值2 then 值2<br />…<br />else 值n<br />end;</td>
<td>Begin end中<br /> Begin end外面</td>
</tr>
<tr>
<td>情况二</td>
<td>case <br />when 条件1 then 值1<br />when 条件2 then 值2<br />…<br />else 值n<br />end;</td>
<td>Begin end中 <br />Begin end外面</td>
</tr>
</tbody></table>
<h4 id="2-case结构——作为独立的语句"><a href="#2-case结构——作为独立的语句" class="headerlink" title="2. case结构——作为独立的语句"></a>2. case结构——作为独立的语句</h4><table>
<thead>
<tr>
<th></th>
<th>语法</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>情况一</td>
<td>case <br />when 值1 then 语句1<br />when 值2 then 语句2<br />…<br />else 值n<br />end case;</td>
<td>Begin end中</td>
</tr>
<tr>
<td>情况二</td>
<td>case <br />when 值1 then 语句1<br />when 值2 then 语句2<br />…<br />else 值n<br />end case;</td>
<td>Begin end中</td>
</tr>
</tbody></table>
<h4 id="3-循环结构"><a href="#3-循环结构" class="headerlink" title="3. 循环结构"></a>3. 循环结构</h4><table>
<thead>
<tr>
<th>名称</th>
<th>语法</th>
<th>特点</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>while</td>
<td>Label: while loop_condition<br />do<br />      loop_list<br />End while label;</td>
<td>先判断后执行</td>
<td>Begin end中</td>
</tr>
<tr>
<td>repeat</td>
<td>Label: repeat<br />              loop_list<br />Until end_condition<br />end repeat label;</td>
<td>先执行后判断</td>
<td>Begin end中</td>
</tr>
<tr>
<td>loop</td>
<td>Label: loop<br />              loop_list<br />End loop label;</td>
<td>没有条件的死循环</td>
<td>Begin end中</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>个人分享平台构建（前导篇）——Markdown基础语法</title>
    <url>/2021/09/17/%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB%E5%B9%B3%E5%8F%B0%E6%9E%84%E5%BB%BA(%E5%89%8D%E5%AF%BC%E7%AF%87)%E2%80%94%E2%80%94Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305161628.png" alt="个人分享平台构建"></p>
<h1 id="MarkDown常用语法"><a href="#MarkDown常用语法" class="headerlink" title="MarkDown常用语法"></a>MarkDown常用语法</h1><p><a href="https://www.bilibili.com/video/av87982836#reply2366896129">基础视频讲解链接</a><br><a href="https://www.bilibili.com/video/av88551739/">画图视频讲解链接</a></p>
<span id="more"></span>
<p>本篇为前导教程，帮助大家了解Markdown的基础语法 ，Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。<br>由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。了解Markdown语法规则有利于大家后期个人博客的撰写。</p>
<h2 id="语块及标识"><a href="#语块及标识" class="headerlink" title="语块及标识"></a>语块及标识</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```语言名称</span></span><br><span class="line"><span class="code">```(英文输入法下输入)</span></span><br></pre></td></tr></table></figure>
<h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">`行内代码`</span><br></pre></td></tr></table></figure>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;一级引用</span><br><span class="line">&gt;&gt;二级引用</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">***  或  ---  或  ___</span><br></pre></td></tr></table></figure>
<h2 id="文字效果"><a href="#文字效果" class="headerlink" title="文字效果"></a>文字效果</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 标题名字 （#个数代表标题级数）</span><br></pre></td></tr></table></figure>
<h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**文本**  或  __文本__</span><br><span class="line">__(英文输入法下 Shift + -)</span><br></pre></td></tr></table></figure>
<h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*文本*  或  _文本_</span><br></pre></td></tr></table></figure>
<h3 id="加粗斜体"><a href="#加粗斜体" class="headerlink" title="加粗斜体"></a>加粗斜体</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">***文本***  或  ___文本___</span><br></pre></td></tr></table></figure>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;文本&lt;/u&gt;</span><br></pre></td></tr></table></figure>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">~~文字~~</span><br></pre></td></tr></table></figure>
<h3 id="在Typora下需勾选扩展语法的效果"><a href="#在Typora下需勾选扩展语法的效果" class="headerlink" title="在Typora下需勾选扩展语法的效果"></a>在Typora下需勾选扩展语法的效果</h3><h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">==文本== （Typora下需勾选扩展语法)</span><br></pre></td></tr></table></figure>
<h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">水 H~<span class="number">2</span>~O</span><br><span class="line">双氧水 H~<span class="number">2</span>~O~<span class="number">2</span>~</span><br></pre></td></tr></table></figure>
<h4 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">面积 m^<span class="number">2</span>^</span><br><span class="line">体积 m^<span class="number">3</span>^</span><br></pre></td></tr></table></figure>
<h3 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h3><p>😁😀 （win标 + ;)</p>
<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><h3 id="外部跳转"><a href="#外部跳转" class="headerlink" title="外部跳转"></a>外部跳转</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[描述](网址)</span><br></pre></td></tr></table></figure>
<h3 id="内部跳转"><a href="#内部跳转" class="headerlink" title="内部跳转"></a>内部跳转</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[描述]（#标题）</span><br></pre></td></tr></table></figure>
<h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;网址&gt;</span><br></pre></td></tr></table></figure>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h3 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">![图片描述](图片本地地址)</span><br></pre></td></tr></table></figure>
<h3 id="网络图片"><a href="#网络图片" class="headerlink" title="网络图片"></a>网络图片</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">![图片描述](图片网络地址)</span><br></pre></td></tr></table></figure>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序表"><a href="#无序表" class="headerlink" title="无序表"></a>无序表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 可以使用“*”作为标记</span><br><span class="line">+ 也可以使用“+”</span><br><span class="line">- 或者“-”</span><br></pre></td></tr></table></figure>
<h4 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数字.空格</span><br><span class="line"><span class="number">1.</span> 有序表以数字和<span class="string">&#x27;.&#x27;</span>开始</span><br><span class="line"><span class="number">4.</span> 数字序列不会影响生成序列</span><br><span class="line"><span class="number">5</span>\. 数字\. 取消显示为列表</span><br></pre></td></tr></table></figure>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用|来分隔不同单元格，使用-来分隔表头和其他行,使用:来设置对齐</span><br><span class="line">姓名 | 年龄</span><br><span class="line">-- | --</span><br><span class="line">张三 | <span class="number">12</span></span><br><span class="line">李四 | <span class="number">23</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>办公技能</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>个人分享平台构建(工具篇)——Typora + PicGo + Gitee</title>
    <url>/2021/09/17/%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB%E5%B9%B3%E5%8F%B0%E6%9E%84%E5%BB%BA(%E5%B7%A5%E5%85%B7%E7%AF%87)%E2%80%94%E2%80%94Typora+PicGo+Gitee/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305161628.png" alt="个人分享平台构建"></p>
<span id="more"></span>
<h3 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h3><h4 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a><a href="https://www.typora.io/">Typora</a></h4><p>​    <strong>Typora</strong>是一个所见即所得的Markdown格式文本编辑器，支持Windows、macOS和GNU/Linux操作系统，包括对GitHub Flavored Markdown扩展格式的支持、拼写检查、自定义CSS样式、数学公式渲染（通过MathJax）等特性，<a href="https://www.typora.io/">点击跳转下载</a>，软件截图如下：</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305140341.png" alt="image-20210305140336396" style="zoom: 50%;" />

<h4 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a><a href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.0-beta.4">PicGo</a></h4><p>​    我们在写作、写 Markdown、博客时，经常都要插入图片。然而要贴图 (上传图片) 时还得登录图床网站/服务器去手工上传和复制链接，操作比较繁琐。</p>
<p>​    <strong>PicGo</strong> 是一款开源跨平台的免费图片上传工具以及图床相册管理软件，它能帮你快速地将图片上传到微博、又拍云、阿里云 OSS、腾讯云 COS、七牛、GitHub、sm.ms、Imgur 等常见的免费图床网站或云存储服务上，并自动复制图片的链接到剪贴板里，使用上非常高效便捷。<a href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.0-beta.4">点击跳转下载</a>，软件截图如下：</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305140622.png" alt="image-20210305140621282" style="zoom: 50%;" />

<h4 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a><a href="https://gitee.com/">Gitee</a></h4><p>​    <strong>Gitee</strong>是深圳市奥思网络科技有限公司推出的代码托管平台，支持Git和SVN，提供免费的私有仓库托管。目前开发者超过500万，托管项目超过1000万，汇聚几乎所有本土原创开源项目，并于2016年推出企业版，提供企业级代码托管服务。<a href="https://gitee.com/">点击跳转官网</a>进行Gitee账户注册。</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305141040.png" alt="image-20210305141038648" style="zoom: 25%;" />

<h3 id="工具配置"><a href="#工具配置" class="headerlink" title="工具配置"></a>工具配置</h3><p>​    Typora作为一款Markdown编辑器，搭配图床工具PicGo以及托管平台Gitee，能够简洁高效的编写图文并茂的博客。按照链接==<strong>下载好Typora、PicGo并注册Gitee账号后</strong>==，下面进入配置环节。</p>
<h4 id="1-配置Gitee"><a href="#1-配置Gitee" class="headerlink" title="1.配置Gitee"></a>1.配置Gitee</h4><p>【创建仓库】</p>
<p>​    点击头像右侧“+”，【新建仓库】——填写【仓库名称】——是否开源选择【公开】（如果不公开，PicGo上传之后的图片无法在Typora中通过网络地址进行显示）——【创建】</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305144104.png" alt="image-20210305144102602" style="zoom: 67%;" />

<p>【生成私人令牌】</p>
<p>​    点击头像，【设置】——【私人令牌】——【生成新令牌】——填写令牌描述【提交】，复制令牌</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305145414.png" alt="image-20210305145412307"></p>
<h4 id="2-配置PicGo"><a href="#2-配置PicGo" class="headerlink" title="2.配置PicGo"></a>2.配置PicGo</h4><p><a href="https://nodejs.org/zh-cn/">点击下载node.js</a>，为安装插件做准备</p>
<p>【插件设置】——下载gitee插件</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305145931.png" alt="image-20210305145929348" style="zoom: 50%;" />

<p>【PicGo设置】——开启Gitee图床——开启【时间戳重命名】</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305150117.png" alt="image-20210305150114651" style="zoom:50%;" />

<p>【图床设置】——Gitee图床设置</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305150333.png" alt="image-20210305150331034" style="zoom:50%;" />

<h4 id="3-配置Typora"><a href="#3-配置Typora" class="headerlink" title="3.配置Typora"></a>3.配置Typora</h4><p>【文件】——【偏好设置】——【图像】，PicGo路径为当前电脑安装路径</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305151539.png" alt="image-20210305151537874" style="zoom:50%;" />

<p>【验证图片上传选项】</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305151955.png" alt="image-20210305151953065" style="zoom: 67%;" />

<h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>​    运行PicGo，运行Typora，插入图片进行测试。右键插入的图片，点击【上传图片】，上传成功，并能正确显示，完成测试</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305152932.png" style="zoom:25%;" />



]]></content>
      <categories>
        <category>办公技能</category>
      </categories>
      <tags>
        <tag>Typora + PicGo + Gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>语音技巧</title>
    <url>/2021/09/17/%E8%AF%AD%E9%9F%B3%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="语音技巧"><a href="#语音技巧" class="headerlink" title="语音技巧"></a>语音技巧</h2><h3 id="1-连音-狭义连读"><a href="#1-连音-狭义连读" class="headerlink" title="1. 连音(狭义连读)"></a>1. 连音(狭义连读)</h3><p><strong>连音 Catenation / Liaison</strong></p>
<p>单词(<code>辅音</code>结尾) + 单词(<code>元音</code>开头)</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109040945270.png" alt="image-20210904094528520"></p>
<h4 id="1-1-连音造成的最大困扰？"><a href="#1-1-连音造成的最大困扰？" class="headerlink" title="1.1 连音造成的最大困扰？"></a>1.1 连音造成的最大困扰？</h4><p>连音给咱们很多中国人造成的困扰就是很难区分单词的界限，尤其是咱们中国人很习惯把句子“断句”为一个个以辅音开头元音结尾的词，因为大多数中文汉字都是这样，于是当你听到几个词，然后断句如下时：</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109040954180.png" alt="image-20210904095424392"></p>
<p>实际上说话者报的是</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109040955561.png" alt="image-20210904095534100" style="zoom:80%;" /> 

<h4 id="1-2-忽略连音会造成"><a href="#1-2-忽略连音会造成" class="headerlink" title="1.2 忽略连音会造成"></a>1.2 忽略连音会造成</h4><p><strong>听力问题</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109040957325.png" alt="image-20210904095659026" style="zoom:80%;" /> 

<p><strong>口语问题</strong></p>
<p>not at all = 闹特 艾特 奥</p>
<p>take it easy = ta课 伊特 一sy</p>
<p>in an instant = 音 安 instan特</p>
<h4 id="1-3-说英文不要按中文习惯划分单词界限"><a href="#1-3-说英文不要按中文习惯划分单词界限" class="headerlink" title="1.3 说英文不要按中文习惯划分单词界限"></a>1.3 说英文不要按中文习惯划分单词界限</h4><ul>
<li>以辅音结尾的单词的结尾辅音要发到位，不要加上不存在的元音<ul>
<li>take it easy：take的结尾加不存在的元音，不要说成ta课，it不要说成伊特</li>
<li>in an instant：in和an的结尾鼻音发到位</li>
</ul>
</li>
<li>意识到英文和中文发音习惯不同，比如鼻音<ul>
<li>i<code>n</code>,a<code>n</code>  vs.  mia<code>n</code> ao   棉袄</li>
<li>all of it /ɔː<code>l</code> əv ɪt/  vs.  嗷嗷福伊特</li>
</ul>
</li>
</ul>
<h3 id="2-加音-intrusion"><a href="#2-加音-intrusion" class="headerlink" title="2. 加音(intrusion)"></a>2. 加音(intrusion)</h3><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041020963.png" alt="image-20210904102032228" style="zoom:50%;" /> 

<p><strong>英语：元音 + 元音 = 容易“糊”</strong></p>
<p>人工干预：①a -&gt; an  ②加音</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041050124.png" alt="加音"></p>
<h3 id="3-同化-assimilation-amp-异化-dissimilation"><a href="#3-同化-assimilation-amp-异化-dissimilation" class="headerlink" title="3.同化(assimilation) &amp; 异化(dissimilation)"></a>3.同化(assimilation) &amp; 异化(dissimilation)</h3><h4 id="3-1-同化"><a href="#3-1-同化" class="headerlink" title="3.1 同化"></a>3.1 同化</h4><p>一前一后的两个音碰到一起时，互相影响，改变原来的发音，可以分为三种主要情况</p>
<h5 id="3-1-1-逆行同化-前面的音受后面音的影响-Regressive-Assimilation"><a href="#3-1-1-逆行同化-前面的音受后面音的影响-Regressive-Assimilation" class="headerlink" title="3.1.1 逆行同化(前面的音受后面音的影响)(Regressive Assimilation)"></a>3.1.1 逆行同化(前面的音受后面音的影响)(Regressive Assimilation)</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041250988.png" alt="同化1"></p>
<h5 id="3-1-2-顺行同化-后面的音受前面音的影响-Progressive-Assimilation"><a href="#3-1-2-顺行同化-后面的音受前面音的影响-Progressive-Assimilation" class="headerlink" title="3.1.2 顺行同化(后面的音受前面音的影响)(Progressive Assimilation)"></a>3.1.2 顺行同化(后面的音受前面音的影响)(Progressive Assimilation)</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041316242.png" alt="同化2"></p>
<h5 id="3-1-3-前后音相互作用"><a href="#3-1-3-前后音相互作用" class="headerlink" title="3.1.3 前后音相互作用"></a>3.1.3 前后音相互作用</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041326436.png" alt="同化3"></p>
<h4 id="3-2-异化"><a href="#3-2-异化" class="headerlink" title="3.2 异化"></a>3.2 异化</h4><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041333399.png" alt="异化"></p>
<h3 id="4-省音-吞音-elision"><a href="#4-省音-吞音-elision" class="headerlink" title="4. 省音(吞音)(elision)"></a>4. 省音(吞音)(elision)</h3><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041551106.png" alt="省音"></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041551170.png" alt="image-20210904155141906" style="zoom:67%;" /> 

<h3 id="5-缩读"><a href="#5-缩读" class="headerlink" title="5. 缩读"></a>5. 缩读</h3><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041556668.png" alt="image-20210904155617547" style="zoom:67%;" /> 

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041557911.png" alt="image-20210904155743165" style="zoom:67%;" /> 

 <img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041558229.png" alt="image-20210904155834730" style="zoom:67%;" />

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041600952.png" alt="image-20210904160019811" style="zoom:67%;" /> 

<h3 id="6-弱读-reduction-weak-forms"><a href="#6-弱读-reduction-weak-forms" class="headerlink" title="6. 弱读(reduction / weak forms)"></a>6. 弱读(reduction / weak forms)</h3><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041603775.png" alt="image-20210904160316914" style="zoom:50%;" /> 

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041608436.png" alt="image-20210904160849609" style="zoom: 50%;" />

<p><strong>英语以下词一般会弱读</strong></p>
<p>常用的，少音节的虚词，如介词，代词，连词 ，他们弱读时，中间的元音一般都会变成中央元音/ə/</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041621325.png" alt="image-20210904162148896" style="zoom:80%;" />

<p>不过有些词的弱读，元音/iː/会变成/ɪ/，比如he,me,she</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041623464.png" alt="image-20210904162310850" style="zoom:80%;" />

<p><strong>以下情况一般不弱读</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041625812.png" alt="image-20210904162459252" style="zoom:67%;" /> 

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041625833.png" alt="image-20210904162521943" style="zoom:67%;" />

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041625853.png" alt="image-20210904162552357" style="zoom:67%;" />

<h3 id="7-节奏"><a href="#7-节奏" class="headerlink" title="7. 节奏"></a>7. 节奏</h3><h4 id="7-1-重音规律"><a href="#7-1-重音规律" class="headerlink" title="7.1 重音规律"></a>7.1 重音规律</h4><h5 id="7-1-1-等时性-isochrony"><a href="#7-1-1-等时性-isochrony" class="headerlink" title="7.1.1 等时性(isochrony)"></a>7.1.1 等时性(isochrony)</h5><p>普通话：基本上每个字就是一个音节，“音节等时”（<code>音节时长基本相等</code>）</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041638471.png" alt="image-20210904163838545" style="zoom:50%;" /> 

<p>英语并非如此：单词中有重读音节和非重读音节，“重音等时”(<code>重读音节之间的时长基本相等</code>)</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041636861.png" alt="image-20210904163603033" style="zoom:50%;" /> 

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041636890.png" alt="image-20210904163633683" style="zoom:50%;" /> 

<h5 id="7-1-2-音节等时-vs-重音等时"><a href="#7-1-2-音节等时-vs-重音等时" class="headerlink" title="7.1.2 音节等时 vs. 重音等时"></a>7.1.2 音节等时 vs. 重音等时</h5><p><strong>音节等时</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041640492.png" alt="image-20210904164018288" style="zoom:50%;" /> 

<blockquote>
<p>中文因为每个字，也就是每个音节时长基本相同，长句子自然更花时间</p>
</blockquote>
<p><strong>重音等时</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041641562.png" alt="image-20210904164153966" style="zoom:67%;" />

<blockquote>
<p>英语虽然句子变长了，可是重度音节的数量却并没有增加，英文句中词语所花的时间并非由音节数量的总数决定，而是由重读音节数量决定</p>
</blockquote>
<p><strong>中国人常见错误</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041653713.png" alt="image-20210904165300991"></p>
<p><strong>正确发音</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041654245.png" alt="image-20210904165407687"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041655393.png" alt="image-20210904165525865"></p>
<h4 id="7-2-英语的节奏-amp-弱读"><a href="#7-2-英语的节奏-amp-弱读" class="headerlink" title="7.2 英语的节奏 &amp; 弱读"></a>7.2 英语的节奏 &amp; 弱读</h4><p>很多不同的元音在句中都会弱化为中央元音/ə/</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041659604.png" alt="image-20210904165917001"></p>
<h3 id="8-语调"><a href="#8-语调" class="headerlink" title="8. 语调"></a>8. 语调</h3><h4 id="8-1-地道自然的英语"><a href="#8-1-地道自然的英语" class="headerlink" title="8.1 地道自然的英语"></a>8.1 地道自然的英语</h4><h5 id="8-1-1-语音"><a href="#8-1-1-语音" class="headerlink" title="8.1.1 语音"></a>8.1.1 语音</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041709333.png" alt="image-20210904170940565" style="zoom:67%;" /> 

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041710749.png" alt="image-20210904171012265" style="zoom: 50%;" /> 

<h5 id="8-1-2-节奏"><a href="#8-1-2-节奏" class="headerlink" title="8.1.2 节奏"></a>8.1.2 节奏</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041711115.png" alt="image-20210904171103551" style="zoom:67%;" /> 

<h5 id="8-1-3-断句-amp-停顿"><a href="#8-1-3-断句-amp-停顿" class="headerlink" title="8.1.3 断句 &amp; 停顿"></a>8.1.3 断句 &amp; 停顿</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041712905.png" alt="image-20210904171240702" style="zoom:67%;" /> 

<h5 id="8-1-4-强调-amp-响度-≠-节奏"><a href="#8-1-4-强调-amp-响度-≠-节奏" class="headerlink" title="8.1.4 强调 &amp; 响度 ≠ 节奏"></a>8.1.4 强调 &amp; 响度 ≠ 节奏</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041714302.png" alt="image-20210904171433105" style="zoom: 80%;" /> 

<h5 id="8-1-5-语气（说话方式）"><a href="#8-1-5-语气（说话方式）" class="headerlink" title="8.1.5 语气（说话方式）"></a>8.1.5 语气（说话方式）</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041717144.png" alt="image-20210904171717544" style="zoom: 67%;" /> 

<h5 id="8-1-6-“狭义”语调"><a href="#8-1-6-“狭义”语调" class="headerlink" title="8.1.6 “狭义”语调"></a>8.1.6 “狭义”语调</h5><p>音调/音高(pitch)的改变</p>
<p><strong>英语的语调</strong></p>
<p>语句中的某一处，或某几处，高音持平，或者升高，或者降低，或者先升高再降低，或者先降低再升高</p>
<p><strong>音高的变化</strong></p>
<p>声调：tone<br>语调：intonation</p>
<p>汉字的声调就是由音高的改变来实现的，比如普通话的阳平（也就是“第二声”）就是低音升到高音，而去声（也就是“第四声”）则是高音降到低音</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041724426.png" alt="image-20210904172453652" style="zoom:50%;" /> 

<p><strong>英语的“声调”</strong></p>
<p>英语理论上是没有“声调”的概念的</p>
<p><strong>英语语调的作用</strong></p>
<p>汉字“自带声调”不易“走形”，英语单词没有“声调”，易“发挥”</p>
<h4 id="8-2-英语语调的作用"><a href="#8-2-英语语调的作用" class="headerlink" title="8.2 英语语调的作用"></a>8.2 英语语调的作用</h4><ol>
<li><p>表达态度/情感</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041735277.png" alt="image-20210904173525410" style="zoom:50%;" /> 

 <img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041736375.png" alt="image-20210904173616908" style="zoom:50%;" />

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041737059.png" alt="image-20210904173704400" style="zoom:50%;" /> 

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041737163.png" alt="image-20210904173732645" style="zoom:50%;" /> 

 <img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109041738619.png" alt="image-20210904173800635" style="zoom:50%;" />

</li>
</ol>
<blockquote>
<p>英语：虽然有不同语气，但是<code>语调</code>也起了很大作用<br>中文：更加依赖<code>语气</code>，而不是语调</p>
</blockquote>
<ol start="2">
<li><p>表示陈述/疑问</p>
<p>中文：陈述句降调，问句升调（+“吗”，“啊”，“吧”…）</p>
<p>英文：升降调和陈述/疑问往往不对应</p>
<p>This way, please↗.</p>
<p>I didn&#39;t do it because I don’t want to↗.</p>
<p>What time is it ↘?</p>
<p>Do you understand ↘?</p>
</li>
<li><p>强调</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109042022189.png" alt="image-20210904202151314" style="zoom: 67%;" /> 
</li>
<li><p>帮助解释语句中成分的关系</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109042023681.png" alt="image-20210904202318163" style="zoom: 67%;" /> 
</li>
<li><p>社会/行为因素</p>
<p>下级对上级用升调，上级对下级用降调</p>
</li>
</ol>
<h4 id="8-3-英语的升调"><a href="#8-3-英语的升调" class="headerlink" title="8.3 英语的升调"></a>8.3 英语的升调</h4><ol>
<li><p>“一般疑问句”(yes/no问题)</p>
<p>Did the rabbit eat the carrot ↗?</p>
<p>Are there relly black rabbits ↗?</p>
</li>
<li><p>陈述形式的疑问</p>
<p>Rabbits eat carrots ↗?</p>
</li>
<li><p>反义疑问句中的附加问句</p>
<p>Rabbits eat carrots, don’t they ↗?</p>
<p>Rabbits are white, aren’t they ↗?</p>
</li>
<li><p>列举中，最有一个元素之前的元素</p>
<p>Rabbits like to eat ↗, play ↗,sleep↗and run.</p>
<p>The rabbit ran around ↗,rest ↗,ate some carrots ↗,and fell asleep.</p>
<p>Are rabbits red ↗, yellow ↗, blue ↗,green ↗,or white?</p>
</li>
<li><p>礼貌的请求，建议或问题</p>
<p>Tell me, please ↗.</p>
<p>Take a seat ↗.</p>
<p>This way ↗.</p>
<p>Nice to meet you. What’s your name ↗?</p>
</li>
<li><p>句子中未完成的部分</p>
<p>The rabbit ate a carrot ↗ and then slept.</p>
</li>
</ol>
<h4 id="8-4-英语的降调"><a href="#8-4-英语的降调" class="headerlink" title="8.4 英语的降调"></a>8.4 英语的降调</h4><ol>
<li><p>“特殊疑问句”(非yes/no问题)</p>
<p>What is the color of the rabbit ↘?</p>
</li>
<li><p>陈述事实或回答问题</p>
<p>I see a white rabbit ↘.</p>
<p>What is the color of this rabbit? Withe ↘.</p>
</li>
<li><p>感叹</p>
<p>What a cute rabbit ↘!</p>
</li>
<li><p>命令</p>
<p>Put the rabbit down ↘!</p>
</li>
<li><p>列举中，最后一个元素</p>
<p>Rabbits like to eat, play, sleep and run ↘.</p>
<p>The tabbit ran around, rest, ate some carrots, and fell asleep ↘.</p>
<p>Are rabbits red, yellow, bule, green, or white ↘.</p>
</li>
<li><p>反义疑问句前一部分</p>
<p>Rabbits eat carrots ↘, don’t they?</p>
</li>
<li><p>作为回答/附和/确认的问句形式</p>
<p>The rabbit ate all the carrots.<br>Did it ↘?</p>
<p>I went to the park just now.<br>Did you ↘?</p>
</li>
<li><p>已知道提问的答案</p>
<p>Can you call me at 6 ↘?</p>
<p>Can you hold this for a second ↘?</p>
<p>Are you going now ↘? See ya!</p>
</li>
<li><p>问句形式表礼貌，并非真的再问问题</p>
<p>Would you pass me the salt ↘?</p>
<p>Would you follow me, please ↘?</p>
</li>
<li><p>不满，愤怒</p>
<p>Is that what you think ↘?!</p>
<p>Do you understand that ↘?!</p>
<p>Would you sit down and shut up ↘?!</p>
<p>Are you going now↘?! Are you kidding me ↘?!</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109042120143.png" alt="image-20210904212052381" style="zoom:80%;" /> 











]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>IPA</tag>
      </tags>
  </entry>
  <entry>
    <title>DJ音标表</title>
    <url>/2021/09/17/%E9%9F%B3%E6%A0%87%E8%A1%A8/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="音标表"><a href="#音标表" class="headerlink" title="音标表"></a>音标表</h2><table>
<thead>
<tr>
<th align="center"><a href="https://en-yinbiao.xiao84.com/study/24568.html">元音</a></th>
<th align="center"><a href="https://en-yinbiao.xiao84.com/study/24557.html">单元音</a></th>
<th align="center"><a href="https://en-yinbiao.xiao84.com/study/24554.html">前元音</a></th>
<th>/iː/</th>
<th>/ɪ/</th>
<th>/e/</th>
<th>/æ/</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24555.html">中元音</a></td>
<td>/ɜː/</td>
<td>/ə/</td>
<td>/ʌ/</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24556.html">后元音</a></td>
<td>/uː/</td>
<td>/ʊ/</td>
<td>/ɔː/</td>
<td>/ɒ/</td>
<td>/ɑː/</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24560.html">双元音</a></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24558.html">开合双元音</a></td>
<td>/eɪ/</td>
<td>/aɪ/</td>
<td>/ɔɪ/</td>
<td>/aʊ/</td>
<td>/əʊ/</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24559.html">集中双元音</a></td>
<td>/ɪə/</td>
<td>/eə/</td>
<td>/ʊə/</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24569.html">辅音</a></td>
<td align="center">爆破音</td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24561.html">清辅音</a></td>
<td>/p/</td>
<td>/t/</td>
<td>/k/</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24562.html">浊辅音</a></td>
<td>/b/</td>
<td>/d/</td>
<td>/ɡ/</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">摩擦音</td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24561.html">清辅音</a></td>
<td>/f/</td>
<td>/s/</td>
<td>/ʃ/</td>
<td>/θ/</td>
<td>/h/</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24562.html">浊辅音</a></td>
<td>/v/</td>
<td>/z/</td>
<td>/ʒ/</td>
<td>/ð/</td>
<td>/r/</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">破擦音</td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24561.html">清辅音</a></td>
<td>/tʃ/</td>
<td>/tr/</td>
<td>/ts/</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24562.html">浊辅音</a></td>
<td>/dʒ/</td>
<td>/dr/</td>
<td>/dz/</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">鼻音</td>
<td align="center">（浊辅音）</td>
<td>/m/</td>
<td>/n/</td>
<td>/ŋ/</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">舌则音</td>
<td align="center">（浊辅音）</td>
<td>/l/</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">半元音</td>
<td align="center">（浊辅音）</td>
<td>/j/</td>
<td>/w/</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108271627621.png" alt="音标"></p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>IPA</tag>
      </tags>
  </entry>
  <entry>
    <title>04-面向对象编程（上）</title>
    <url>/2021/09/17/04%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="04—面向对象编程（上）"><a href="#04—面向对象编程（上）" class="headerlink" title="04—面向对象编程（上）"></a>04—面向对象编程（上）</h3><h4 id="1-面向过程与面向对象"><a href="#1-面向过程与面向对象" class="headerlink" title="1. 面向过程与面向对象"></a>1. 面向过程与面向对象</h4><ul>
<li><p>面向过程(POP) 与 面向对象(OOP)</p>
<ul>
<li>二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li>
<li>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。</li>
</ul>
</li>
<li><p>面向对象的三大特征</p>
<ul>
<li>封装 (Encapsulation)</li>
<li>继承 (Inheritance)</li>
<li>多态 (Polymorphism)</li>
</ul>
</li>
<li><p>例子：人把大象放进冰箱</p>
<ul>
<li><p>面向过程</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108150936761.png" alt="image-20210815093603375"> </p>
</li>
<li><p>面向对象</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108150939430.png" alt="屏幕截图 2021-08-15 093901" style="zoom:80%;" /> 



</li>
</ul>
</li>
</ul>
<h4 id="2-Java基本元素：类和对象"><a href="#2-Java基本元素：类和对象" class="headerlink" title="2. Java基本元素：类和对象"></a>2. Java基本元素：类和对象</h4><h5 id="2-1-面向对象的思想概述"><a href="#2-1-面向对象的思想概述" class="headerlink" title="2.1 面向对象的思想概述"></a>2.1 面向对象的思想概述</h5><ul>
<li>类(Class)和对象(Object)是面向对象的核心概念。<ul>
<li>类是对一类事物的描述，是抽象的、概念上的定义</li>
<li>对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。</li>
</ul>
</li>
<li>“万事万物皆对象”</li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108150943559.png" alt="image-20210815094356070"><ul>
<li>可以理解为：类 = 抽象概念的人；对象 = 实实在在的某个人</li>
<li>面向对象程序设计的重点是类的设计</li>
<li>类的设计，其实就是类的成员的设计</li>
</ul>
</li>
</ul>
<h5 id="2-2-Java类及类的成员"><a href="#2-2-Java类及类的成员" class="headerlink" title="2.2 Java类及类的成员"></a>2.2 Java类及类的成员</h5><ul>
<li><p>常见的类的成员有：</p>
<ul>
<li><p>属 性：对应类中的成员变量</p>
</li>
<li><p>行 为：对应类中的成员方法</p>
<p><code>Field = 属性 = 成员变量</code></p>
<p><code>Method = (成员)方法 = 函数</code></p>
</li>
</ul>
</li>
<li><p>类的语法格式</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108150947934.png" alt="image-20210815094719516" style="zoom:80%;" /> 

</li>
</ul>
<h4 id="3-对象的创建和使用"><a href="#3-对象的创建和使用" class="headerlink" title="3. 对象的创建和使用"></a>3. 对象的创建和使用</h4><ul>
<li><p>创建对象语法： 类名 对象名 = new 类名();</p>
</li>
<li><p>使用“对象名.对象成员”的方式访问对象成员（包括属性和方法）</p>
</li>
<li><p>Java中类与对象</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108150949686.png" alt="image-20210815094919592"></p>
</li>
<li><p>类的访问机制：</p>
<ul>
<li>在一个类中的访问机制：类中的方法可以直接访问类中的成员变量。 （例外：static方法访问非static，编译不通过。）</li>
<li>在不同类中的访问机制：先创建要访问类的对象，再用对象访问类中定义的成员。</li>
</ul>
</li>
</ul>
<h5 id="3-1-对象的产生"><a href="#3-1-对象的产生" class="headerlink" title="3.1 对象的产生"></a>3.1 对象的产生</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(“oh,my god! I am ” + age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person p1 = new Person();执行完后的内存状态。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108150952839.png" alt="image-20210815095240586"></p>
<h5 id="3-2-对象的使用"><a href="#3-2-对象的使用" class="headerlink" title="3.2 对象的使用"></a>3.2 对象的使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//程序运行的内存布局如下图</span></span><br><span class="line">		Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">		Person p2 =<span class="keyword">new</span> Person();</span><br><span class="line">		p1.age = -<span class="number">30</span>;</span><br><span class="line">		p1.shout();</span><br><span class="line">		p2.shout();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151015625.png" alt="image-20210815101522210"></p>
<h5 id="3-3-对象的生命周期"><a href="#3-3-对象的生命周期" class="headerlink" title="3.3 对象的生命周期"></a>3.3 对象的生命周期</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151020380.png" alt="屏幕截图 2021-08-15 101937"></p>
<h5 id="3-5-内存解析"><a href="#3-5-内存解析" class="headerlink" title="3.5 内存解析"></a>3.5 内存解析</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151022640.png" alt="屏幕截图 2021-08-15 102212"  /> 

<ul>
<li><p>堆（Heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在 Java虚拟机规范中的描述是：<u>所有的对象实例以及数组都要在堆上分配。</u></p>
</li>
<li><p>通常所说的栈（Stack），是指虚拟机栈。虚拟机栈用于存储局部变量等。 局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、 char 、 short 、 int 、 float 、 long 、 double）、对象引用（reference类型， 它不等同于对象本身，是对象在堆内存的首地址）。 方法执行完，自动释放。</p>
</li>
<li><p>方法区（Method Area），用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151028888.png" alt="屏幕截图 2021-08-15 102810"></p>
</li>
</ul>
<h5 id="3-6-匿名对象"><a href="#3-6-匿名对象" class="headerlink" title="3.6 匿名对象"></a>3.6 匿名对象</h5><ul>
<li>我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。 如：new Person().shout();</li>
<li>使用情况<ul>
<li>如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。</li>
<li>我们经常将匿名对象作为实参传递给一个方法调用。</li>
</ul>
</li>
</ul>
<h4 id="4-类的成员之一：属性"><a href="#4-类的成员之一：属性" class="headerlink" title="4. 类的成员之一：属性"></a>4. 类的成员之一：属性</h4><ul>
<li><p>语法格式：</p>
<p>修饰符 数据类型 属性名 = 初始化值 ; </p>
<ul>
<li>说明1: 修饰符<ul>
<li>常用的权限修饰符有：private、缺省、protected、public</li>
<li>其他修饰符：static、final (暂不考虑)</li>
</ul>
</li>
<li>说明2：数据类型 <ul>
<li> 任何基本数据类型(如int、Boolean) 或任何引用数据类型。</li>
</ul>
</li>
<li>说明3：属性名<ul>
<li>属于标识符，符合命名规则和规范即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4-1-变量的分类"><a href="#4-1-变量的分类" class="headerlink" title="4.1 变量的分类"></a>4.1 变量的分类</h5><ul>
<li><p>在方法体外，类体内声明的变量称为成员变量。</p>
</li>
<li><p>在方法体内部声明的变量称为局部变量。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151118952.png" alt="image-20210815111824780"></p>
</li>
<li><p>注意：二者在初始化值方面的异同:</p>
<ul>
<li>同：都有生命周期</li>
<li>异：局部变量除形参外，均需显式初始化。</li>
</ul>
</li>
<li><p>成员变量（属性）和局部变量的区别</p>
<table>
<thead>
<tr>
<th></th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>声明的位置</td>
<td>直接声名在类中</td>
<td>方法形参或内部、代码块内、构造器内</td>
</tr>
<tr>
<td>修饰符</td>
<td>private、public、static、final等</td>
<td>不能用权限修饰符修饰，可以用final修饰</td>
</tr>
<tr>
<td>初始化值</td>
<td>有默认化初始值</td>
<td>没有默认初始值，必须显示赋值，方可使用</td>
</tr>
<tr>
<td>内存加载位置</td>
<td>堆空间或静态域内</td>
<td>栈空间</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151124615.png" alt="屏幕截图 2021-08-15 112430"></p>
</li>
</ul>
<h4 id="5-类的成员之二：方法"><a href="#5-类的成员之二：方法" class="headerlink" title="5. 类的成员之二：方法"></a>5. 类的成员之二：方法</h4><h5 id="5-1-什么是方法-method、函数"><a href="#5-1-什么是方法-method、函数" class="headerlink" title="5.1 什么是方法(method、函数):"></a>5.1 什么是方法(method、函数):</h5><ul>
<li><p>方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中也称为函数或过程。</p>
</li>
<li><p>将功能封装为方法的目的是，可以实现代码重用，简化代码</p>
</li>
<li><p>Java里的方法不能独立存在，所有的方法必须定义在类里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="comment">//声明方法getAge()</span></span><br><span class="line">		<span class="keyword">return</span> age; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">//声明方法setAge</span></span><br><span class="line">		age = i; <span class="comment">//将参数i的值赋给类的成员变量age</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="5-2-方法的声明格式："><a href="#5-2-方法的声明格式：" class="headerlink" title="5.2 方法的声明格式："></a>5.2 方法的声明格式：</h5><p>修饰符 返回值类型 方法名（参数类型 形参1, 参数类型 形参2, ….）｛ </p>
<p>​    方法体程序代码 </p>
<p>​    return 返回值; </p>
<p>｝</p>
<ul>
<li>其中： <ul>
<li>修饰符：public,缺省,private, protected等 </li>
<li>返回值类型：<ul>
<li>没有返回值：void。</li>
<li>有返回值，声明出返回值的类型。与方法体中“return 返回值”搭配使用</li>
</ul>
</li>
<li>方法名：<ul>
<li>属于标识符，命名时遵循标识符命名规则和规范，“见名知意” 形参列表：可以包含零个，一个或多个参数。多个参数时，中间用“,”隔开 返回值：方法在执行完毕后返还给调用它的程序的数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="5-3-方法的调用"><a href="#5-3-方法的调用" class="headerlink" title="5.3 方法的调用"></a>5.3 方法的调用</h5><p>方法通过方法名被调用，且只有被调用才会执行</p>
<ul>
<li><p>方法调用的过程分析</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151130960.png" alt="image-20210815113046780"></p>
</li>
<li><p>注意</p>
<ul>
<li>方法被调用一次，就会执行一次</li>
<li>没有具体返回值的情况，返回值类型用关键字void表示，那么方法体中可以不必使用return语句。如果使用，仅用来结束方法。</li>
<li>定义方法时，方法的结果应该返回给调用者，交由调用者处理。</li>
<li>方法中只能调用方法或属性，不可以在方法内部定义方法。</li>
</ul>
</li>
</ul>
<h5 id="5-4-对象数组的内存解析"><a href="#5-4-对象数组的内存解析" class="headerlink" title="5.4 对象数组的内存解析"></a>5.4 对象数组的内存解析</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151132396.png" alt="image-20210815113221217"></p>
<h4 id="6-再谈方法"><a href="#6-再谈方法" class="headerlink" title="6. 再谈方法"></a>6. 再谈方法</h4><h5 id="6-1-方法的重载"><a href="#6-1-方法的重载" class="headerlink" title="6.1 方法的重载"></a>6.1 方法的重载</h5><ul>
<li><p>重载的概念</p>
<p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p>
</li>
<li><p>重载的特点：</p>
<p>与返回值类型无关，<u>只看参数列表</u>，且参数列表必须不同。(参数个数或参数类型)。调用时，根据方法参数列表的不同来区别。</p>
</li>
<li><p>重载示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回两个整数的和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line"><span class="comment">//返回三个整数的和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;<span class="keyword">return</span> x+y+z;&#125;</span><br><span class="line"><span class="comment">//返回两个小数的和</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="6-2-可变个数的形参"><a href="#6-2-可变个数的形参" class="headerlink" title="6.2 可变个数的形参"></a><strong>6.2 可变个数的形参</strong></h5><p>JavaSE 5.0 中提供了Varargs(variable number of arguments)机制，允许直接定义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可变的实参。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a ,String[] books)</span></span>;</span><br><span class="line"><span class="comment">//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a ,String…books)</span></span>;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>声明格式：方法名(参数的类型名 …参数名)</li>
<li> 可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个</li>
<li>可变个数形参的方法与同名的方法之间，彼此构成重载</li>
<li>可变参数方法的使用与方法参数部分使用数组是一致的，所以二者不能同名</li>
<li>方法的参数部分有可变形参，需要放在形参声明的最后</li>
<li>在一个方法的形参位置，最多只能声明一个可变个数形参</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> First;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-15-11:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOverload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String[] msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;含字符串数组参数的test方法 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(String book)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;****与可变形参方法构成重载的test1方法****&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(String ... books)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;****形参长度可变的test1方法****&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TestOverload to = <span class="keyword">new</span> TestOverload();</span><br><span class="line">        to.test1();</span><br><span class="line">        to.test1(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">        to.test1(<span class="string">&quot;aa&quot;</span> , <span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        <span class="comment">//下面将执行第一个test方法</span></span><br><span class="line">        to.test(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;aa&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><strong>形参长度可变的test1方法</strong></strong><br><strong><strong>与可变形参方法构成重载的test1方法</strong></strong><br><strong><strong>形参长度可变的test1方法</strong></strong><br>含字符串数组参数的test方法 </p>
</blockquote>
<h5 id="6-3-方法参数的值传递机制"><a href="#6-3-方法参数的值传递机制" class="headerlink" title="6.3 方法参数的值传递机制"></a>6.3 方法参数的值传递机制</h5><ul>
<li><p>方法，必须由其所在类或对象调用才有意义。若方法含有参数：</p>
<ul>
<li>形参：方法声明时的参数</li>
<li>实参：方法调用时实际传递给形参的参数值</li>
</ul>
</li>
<li><p>Java的实参值如何传入方法</p>
<p>Java里方法的参数传递方式只有一种：值传递。即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响</p>
<ul>
<li><p>形参时基本数据类型：将实参基本数据类型变量的“数据值”传递给形参</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151200848.png" alt="image-20210815120004597"></p>
</li>
<li><p>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151200796.png" alt="image-20210815120025890"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151200065.png" alt="image-20210815120039588"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151206781.png" alt="image-20210815120654063"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151207526.png" alt="image-20210815120718551"></p>
</li>
</ul>
</li>
</ul>
<h4 id="7-OOP特征一：封装与隐藏"><a href="#7-OOP特征一：封装与隐藏" class="headerlink" title="7. OOP特征一：封装与隐藏"></a>7. OOP特征一：封装与隐藏</h4><h5 id="7-1-信息的封装和隐藏"><a href="#7-1-信息的封装和隐藏" class="headerlink" title="7.1 信息的封装和隐藏"></a>7.1 信息的封装和隐藏</h5><p>Java中通过将数据声明为私有的(private)，再提供公共的（public） 方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的：</p>
<ul>
<li>隐藏一个类中不需要对外提供的实现细节；</li>
<li>使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑， 限制对属性的不合理操作；</li>
<li>便于修改，增强代码的可维护性；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> legs;<span class="comment">// 将属性legs定义为private，只能被Animal类内部访问</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLegs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// 在这里定义方法 eat() 和 move()</span></span><br><span class="line">		<span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != <span class="number">2</span> &amp;&amp; i != <span class="number">4</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Wrong number of legs!&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		legs = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLegs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> legs;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">		Animal xb = <span class="keyword">new</span> Animal();</span><br><span class="line">		xb.setLegs(<span class="number">4</span>); <span class="comment">// xb.setLegs(-1000);</span></span><br><span class="line">		<span class="comment">//xb.legs = -1000; // 非法</span></span><br><span class="line">		System.out.println(xb.getLegs());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-2-四种访问权限修饰符"><a href="#7-2-四种访问权限修饰符" class="headerlink" title="7.2 四种访问权限修饰符"></a>7.2 四种访问权限修饰符</h5><p>Java权限修饰符public、protected、(缺省)、private置于类的成员定义前， 用来限定对象对该类成员的访问权限。</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>内部类</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(缺省)</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<p>对于class的权限修饰只可以用public和default(缺省)。 </p>
<p>public类可以在任意地方被访问。</p>
<p>default类只可以被同一个包内部的类访问。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151213718.png" alt="image-20210815121330304"></p>
<h4 id="8-类的成员之三：构造器"><a href="#8-类的成员之三：构造器" class="headerlink" title="8. 类的成员之三：构造器"></a>8. 类的成员之三：构造器</h4><h5 id="8-1-创建构造器"><a href="#8-1-创建构造器" class="headerlink" title="8.1 创建构造器"></a>8.1 创建构造器</h5><ul>
<li><p>构造器的特征</p>
<ul>
<li>它具有与类相同的名称</li>
<li>它不声明返回值类型。（与声明为void不同）</li>
<li>不能被static、final、synchronized、abstract、native修饰，不能有 return语句返回值</li>
</ul>
</li>
<li><p>构造器的作用：创建对象；给对象进行初始化</p>
<ul>
<li>如：Order o = new Order(); Person p = new Person(“Peter”,15)</li>
<li>如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的 构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自 动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们 要“洗澡”了。</li>
</ul>
</li>
<li><p>语法格式</p>
<p>修饰符 类名 (参数列表) { 初始化语句； }</p>
</li>
<li><pre><code class="java">public class Animal &#123;
    private int legs;
    // 构造器
    public Animal() &#123;
        legs = 4;
    &#125; 
    public void setLegs(int i) &#123;
        legs = i;
    &#125;
    public int getLegs() &#123;
        return legs;
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 创建Animal类的实例：Animal a &#x3D; new Animal(); 调用构造器，将legs初始化为4。</span><br><span class="line"></span><br><span class="line">* 根据参数不同，构造器可以分为如下两类：</span><br><span class="line"></span><br><span class="line">  * 隐式无参构造器（系统默认提供）</span><br><span class="line">  * 显式定义一个或多个构造器（无参、有参）</span><br><span class="line"></span><br><span class="line">* 注意</span><br><span class="line"></span><br><span class="line">  * Java语言中，每个类都至少有一个构造器</span><br><span class="line">  * 默认构造器的修饰符与所属类的修饰符一致</span><br><span class="line">  * 一旦显式定义了构造器，则系统不再提供默认构造器</span><br><span class="line">  * 一个类可以创建多个重载的构造器</span><br><span class="line">  * 父类的构造器不可被子类继承</span><br><span class="line"></span><br><span class="line">##### 8.2 构造器重载</span><br><span class="line"></span><br><span class="line">* 构造器一般用来创建对象的同时初始化对象。如</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;java</span><br><span class="line">  class Person&#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line">  public Person(String n , int a)&#123; name&#x3D;n; age&#x3D;a;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>构造器重载使得对象的创建更加灵活，方便创建各种不同的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Date d)</span> </span>&#123;<span class="keyword">this</span>(name,age);…&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;…&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Date d)</span> </span>&#123;…&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;…&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造器重载，参数列表必须不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; 构造器重载举例</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> Date birthDate;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n, <span class="keyword">int</span> a, Date d)</span> </span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		age = a;</span><br><span class="line">		birthDate = d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n, Date d)</span> </span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		birthDate = d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		age = <span class="number">30</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="8-3-属性赋值过程"><a href="#8-3-属性赋值过程" class="headerlink" title="8.3 属性赋值过程"></a>8.3 属性赋值过程</h5><ul>
<li><p>赋值的位置： </p>
<p>① 默认初始化 </p>
<p>② 显式初始化 </p>
<p>③ 构造器中初始化 </p>
<p>④ 通过“对象.属性“或“对象.方法”的方式赋值</p>
</li>
<li><p>赋值的先后顺序： ① - ② - ③ - ④</p>
</li>
</ul>
<h5 id="8-4-JavaBean"><a href="#8-4-JavaBean" class="headerlink" title="8.4 JavaBean"></a>8.4 JavaBean</h5><ul>
<li><p>JavaBean是一种Java语言写成的可重用组件。</p>
</li>
<li><p>所谓javaBean，是指符合如下标准的Java类： </p>
<ul>
<li>类是公共的 </li>
<li>有一个无参的公共的构造器 </li>
<li>有属性，且有对应的get、set方法</li>
</ul>
</li>
<li><p>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以 用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP 页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用 户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关心任何改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">// 属性一般定义为private</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JavaBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="8-5-UML类图"><a href="#8-5-UML类图" class="headerlink" title="8.5 UML类图"></a>8.5 UML类图</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151227426.png" alt="image-20210815122714388"></p>
<ol>
<li>+ 表示 public 类型， - 表示 private 类型，#表示protected类型</li>
<li>方法的写法:  方法的类型(+、-) 方法名(参数名： 参数类型)：返回值类型</li>
</ol>
<h4 id="9-关键字：this"><a href="#9-关键字：this" class="headerlink" title="9. 关键字：this"></a>9. 关键字：this</h4><h5 id="9-1-this是什么"><a href="#9-1-this是什么" class="headerlink" title="9.1 this是什么?"></a>9.1 this是什么?</h5><ul>
<li><p>在Java中，this关键字比较难理解，它的作用和其词义很接近。</p>
<ul>
<li>它在方法内部使用，即这个方法所属对象的引用；</li>
<li>它在构造器内部使用，表示该构造器正在初始化的对象。</li>
</ul>
</li>
<li><p>this 可以调用类的属性、方法和构造器</p>
</li>
<li><p>什么时候使用this关键字呢？</p>
<ul>
<li>当在方法内需要用到调用该方法的对象时，就用this。 </li>
<li>具体的：我们可以用this来区分属性和局部变量。 比如：this.name = name;</li>
</ul>
</li>
<li><p>使用this，调用属性、方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; <span class="comment">// 定义Person类</span></span><br><span class="line">	<span class="keyword">private</span> String name ;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age ;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name ; </span><br><span class="line">		<span class="keyword">this</span>.age = age ; </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span> + name) ;</span><br><span class="line">		<span class="keyword">this</span>.speak();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(“年龄：” + <span class="keyword">this</span>.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><ol>
<li>在任意方法或构造器内，如果使用当前类的成员变量或成员方法可以在其前面添加this， 增强程序的阅读性。不过，通常我们都习惯省略this。</li>
<li>当形参与成员变量同名时， 如果在方法内或构造器内需要使用成员变量，必须添加this来表明该变量是类的成员变量 </li>
<li>使用this访问属性和方法时， 如果在本类中未找到，会从父类中查找 </li>
</ol>
</li>
</ul>
</li>
<li><p>使用this调用本类的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; <span class="comment">// 定义Person类</span></span><br><span class="line">	<span class="keyword">private</span> String name ;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age ;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123; <span class="comment">// 无参构造器</span></span><br><span class="line">		System.out.println(<span class="string">&quot;新对象实例化&quot;</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(); <span class="comment">// 调用本类中的无参构造器</span></span><br><span class="line">		<span class="keyword">this</span>.name = name ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(name) ; <span class="comment">// 调用有一个参数的构造器</span></span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;，年龄：&quot;</span> + age ;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="4">
<li>.this可以作为一个类中构造器相互调用的特殊格式</li>
</ol>
</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其他的构造器！</li>
<li>明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器</li>
<li>如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了 “this(形参列表)”</li>
<li>“this(形参列表)”必须声明在类的构造器的首行！</li>
<li>在类的一个构造器中，最多只能声明一个”this(形参列表)”</li>
</ul>
</li>
</ul>
<h4 id="10-关键字：package、import"><a href="#10-关键字：package、import" class="headerlink" title="10. 关键字：package、import"></a>10. 关键字：package、import</h4><h5 id="10-1-关键字—package"><a href="#10-1-关键字—package" class="headerlink" title="10.1 关键字—package"></a>10.1 关键字—package</h5><ul>
<li><p>package语句作为Java源文件的第一条语句，指明该文件中定义的类所在的包。(若缺省该语句，则指定为无名包)。它的格式为： package 顶层包名.子包名 ;</p>
<p>举例：pack1\pack2\PackageTest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pack1.pack2; <span class="comment">//指定类PackageTest属于包pack1.pack2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;in method display()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包对应于文件系统的目录，package语句中，用 “.” 来指明包(目录)的层次；</p>
<p>包通常用小写单词标识。通常使用所在公司域名的倒置：com.baiduu.xxx</p>
</li>
<li><p>源文件布局：</p>
<ul>
<li><p>Java源文件基本语法</p>
<p>[&lt;包声明&gt;]</p>
<p>​    [&lt;导入声明&gt;]</p>
<p>​    &lt;类声明&gt;+</p>
</li>
<li><p>示例，VehicleCapacityReport.java文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> shipping.reports;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shipping.domain.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VehicleCapacityReport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List vehicles;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateReport</span><span class="params">(Writer output)</span></span>&#123; ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><strong>包的作用：</strong></p>
<ul>
<li><p>包帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式</p>
</li>
<li><p>包可以包含类和子包，划分项目层次，便于管理</p>
</li>
<li><p>解决类命名冲突的问题</p>
</li>
<li><p>控制访问权限</p>
<p>例：某航运软件系统包括：一组域对象、GUI和reports子系统</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151242664.png" alt="image-20210815124245134"></p>
</li>
</ul>
<p><strong>MVC设计模式</strong></p>
<p>MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与数据模型层。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式 使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程 序的耦合性。<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151243920.png" alt="image-20210815124347443"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151244461.png" alt="image-20210815124423340"> </p>
<p><strong>JDK中主要的包介绍</strong></p>
<ol>
<li>java.lang—-包含一些Java语言的核心类，如String、Math、Integer、 System和 Thread，提供常用功能</li>
<li>java.net—-包含执行与网络相关的操作的类和接口。</li>
<li>java.io —-包含能提供多种输入/输出功能的类。</li>
<li>java.util—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。</li>
<li>java.text—-包含了一些java格式化相关的类</li>
<li>java.sql—-包含了java进行JDBC数据库编程的相关类/接口</li>
<li>java.awt—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 B/S C/S</li>
</ol>
<h5 id="10-2-关键字—import"><a href="#10-2-关键字—import" class="headerlink" title="10.2 关键字—import"></a>10.2 关键字—import</h5><ul>
<li>为使用定义在不同包中的Java类，需用import语句来引入指定包层次下所需要的类或全部类(.*)。import语句告诉编译器到哪里去寻找类。</li>
<li>语法格式： import 包名. 类名;</li>
<li>注意<ol>
<li>在源文件中使用import显式的导入指定包下的类或接口 </li>
<li> 声明在包的声明和类的声明之间。 </li>
<li> 如果需要导入多个类或接口，那么就并列显式多个import语句即可 </li>
<li> 举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。 </li>
<li> 如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。 </li>
<li> 如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的 是哪个类。 </li>
<li> 如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。 </li>
<li> import static组合的使用：调用指定类或接口下的静态的属性或方法</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>05-面向对象编程（中）</title>
    <url>/2021/09/17/05%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="05—面向对象编程（中）"><a href="#05—面向对象编程（中）" class="headerlink" title="05—面向对象编程（中）"></a>05—面向对象编程（中）</h3><h4 id="1-OPP特征二：继承性"><a href="#1-OPP特征二：继承性" class="headerlink" title="1. OPP特征二：继承性"></a>1. OPP特征二：继承性</h4><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151517127.png" alt="image-20210815151705107"></p>
<ul>
<li><p>为什么要有继承？</p>
<ul>
<li>多个类中存在相同属性和行为时，将这些内容抽取到一个单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</li>
</ul>
</li>
<li><p>此处的多个类称为子类(派生类)，单独的这个类称为父类(基类或超类)。可以理解为:“子类 is a 父类”</p>
</li>
<li><p>类继承语法规则:</p>
<p>class Subclass extends SuperClass{ }</p>
</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151518835.png" alt="屏幕截图 2021-08-15 151823"></p>
<ul>
<li><p>作用：</p>
<ul>
<li>继承的出现减少了代码冗余，提高了代码的复用性。 </li>
<li>继承的出现，更有利于功能的扩展。 </li>
<li>继承的出现让类与类之间产生了关系，提供了多态的前提。</li>
</ul>
</li>
<li><p>注意：不要仅为了获取其他类中某个功能而去继承</p>
</li>
<li><p>子类继承了父类，就继承了父类的方法和属性。 </p>
</li>
<li><p> 在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。 </p>
</li>
<li><p> 在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集， 而是对父类的“扩展”。 </p>
</li>
<li><p>关于继承的规则： </p>
<ul>
<li>子类不能直接访问父类中私有的(private)的成员变量和方法。</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151521356.png" alt="image-20210815152152978"></p>
</li>
<li><p>Java只支持单继承和多层继承，不允许多重继承</p>
<ul>
<li><p>一个子类只能有一个父类</p>
</li>
<li><p>一个父类可以派生出多个子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubDemo</span> <span class="keyword">extends</span> <span class="title">Demo</span></span>&#123; &#125; <span class="comment">//ok</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubDemo</span> <span class="keyword">extends</span> <span class="title">Demo1</span>,<span class="title">Demo2</span>...//<span class="title">error</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多层继承<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151525655.png" alt="image-20210815152555906"><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151523332.png" alt="image-20210815152332229"></p>
</li>
<li><p>多重继承(×)</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151524636.png" alt="image-20210815152406598"></p>
</li>
</ul>
</li>
</ul>
<h4 id="2-方法的重写（override）"><a href="#2-方法的重写（override）" class="headerlink" title="2. 方法的重写（override）"></a>2. 方法的重写（override）</h4><ul>
<li><p>定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。</p>
</li>
<li><p>要求：</p>
<ol>
<li>子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表</li>
<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型 </li>
<li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限 <ol>
<li>子类不能重写父类中声明为private权限的方法 </li>
</ol>
</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
</ol>
</li>
<li><p>注意： 子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为 static的（不是重写）。因为static方法是属于类的，子类无法覆盖父类的方法</p>
</li>
<li><p>重写举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span>+ name + <span class="string">&quot;\n&quot;</span> +<span class="string">&quot;age: &quot;</span>+ age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String school;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123; <span class="comment">//重写方法</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span>+ name + <span class="string">&quot;\nage: &quot;</span>+ age + <span class="string">&quot;\nschool: &quot;</span>+ school;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		Student s1=<span class="keyword">new</span> Student();</span><br><span class="line">		s1.name=<span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">		s1.age=<span class="number">20</span>;</span><br><span class="line">		s1.school=<span class="string">&quot;school2&quot;</span>;</span><br><span class="line">		System.out.println(s1.getInfo()); <span class="comment">//Name:Bob age:20 school:school2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//调用Person类的getInfo()方法</span></span><br><span class="line">p1.getInfo();</span><br><span class="line">Student s1=<span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//调用Student类的getInfo()方法</span></span><br><span class="line">s1.getInfo();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是一种“多态性”：同名的方法，用不同的对</span></span><br><span class="line"><span class="comment">象来区分调用的是哪一个方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"><span class="comment">//非法，子类中的method1()的访问权限private比被覆盖方法的访问权限public小</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-四种访问权限修饰符"><a href="#3-四种访问权限修饰符" class="headerlink" title="3. 四种访问权限修饰符"></a>3. 四种访问权限修饰符</h4><p>封装性的体现，需要权限修饰符来配合。</p>
<p>类的成员：可以用public、protected、 (缺省)、 private修饰</p>
<p>类：只可以用public和default(缺省)。</p>
<ol>
<li>public类可以在任意地方被访问。</li>
<li>default类只可以被同一个包内部的类访问。</li>
</ol>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210612235948.jpg" alt="微信图片编辑_20210612235925" style="zoom:67%;" /> 

<blockquote>
<p>其中Hello_son是Hello的子类</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210612234455.png" alt="image-20210612234446616" style="zoom: 67%;" /><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210613000341.png" alt="image-20210613000339972" style="zoom:50%;" /></p>
</blockquote>
<ul>
<li><p>Java规定的4种权限（从小到大排列）：private、缺省、protected、public</p>
<ul>
<li><table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺省</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>对于class的权限修饰，只可以用public和缺省(default)</p>
<ul>
<li>public类可以在任意地方被访问</li>
<li>default类只可以被同一个包的内部类访问</li>
</ul>
</blockquote>
</li>
<li><p>4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类</p>
<p>具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</p>
<p>修饰类的话，只能使用：缺省、public</p>
</li>
</ul>
<h5 id="3-1在类为public时，对于属性和方法"><a href="#3-1在类为public时，对于属性和方法" class="headerlink" title="3.1在类为public时，对于属性和方法"></a>3.1在类为public时，对于属性和方法</h5><p><strong>在Test包下</strong></p>
<p><strong>在Hello.java文件里</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> helloPrivate;</span><br><span class="line">    <span class="keyword">int</span> helloDefault;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> helloProtected;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> helloPublic;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">methodProtected</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodPublic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在test_.java文件里</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test_</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Hello hello = <span class="keyword">new</span> Hello();<span class="comment">//通过类造对象，再去调用对象里的属性和方法</span></span><br><span class="line">        </span><br><span class="line">     <span class="comment">// hello.helloPrivate   = 1;//声明为private的属性只能在类内部被调用</span></span><br><span class="line">     <span class="comment">// The field Hello.helloPrivate is not visible （属性不可见）</span></span><br><span class="line">        hello.helloProtected = <span class="number">2</span>;<span class="comment">//赋值成功</span></span><br><span class="line">        hello.helloDefault   = <span class="number">3</span>;<span class="comment">//赋值成功</span></span><br><span class="line">        hello.helloPublic    = <span class="number">4</span>;<span class="comment">//赋值成功</span></span><br><span class="line">        </span><br><span class="line">     <span class="comment">// hello.methodPrivate();//声明为private的方法只能在类内部被调用</span></span><br><span class="line">     <span class="comment">// The method methodPrivate() from the type Hello is not visible</span></span><br><span class="line">        hello.methodProtected();<span class="comment">//成功调用</span></span><br><span class="line">        hello.methodDefault();<span class="comment">//成功调用</span></span><br><span class="line">        hello.methodPublic();<span class="comment">//成功调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在test2包下</strong></p>
<p><strong>在test2.java文件下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test.Hello; <span class="comment">//将test包下的Hello导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Hello hello = <span class="keyword">new</span> Hello();<span class="comment">//通过类造对象，再去调用对象里的属性和方法</span></span><br><span class="line">        </span><br><span class="line">     <span class="comment">// hello.helloPrivate   = 1;//声明为private的属性只能在类内部被调用</span></span><br><span class="line">     <span class="comment">// The field Hello.helloPrivate is not visible （属性不可见）</span></span><br><span class="line">     <span class="comment">// hello.helloDefault   = 2;//声明为Default的属性只能在包内部被调用</span></span><br><span class="line">     <span class="comment">// The field Hello.helloDefault is not visible （属性不可见） </span></span><br><span class="line">     <span class="comment">// hello.helloProtected = 3;</span></span><br><span class="line">        hello.helloPublic    = <span class="number">3</span>;<span class="comment">//赋值成功</span></span><br><span class="line">        </span><br><span class="line">     <span class="comment">// hello.methodPrivate();//声明为private的方法只能在类内部被调用</span></span><br><span class="line">     <span class="comment">// The method methodPrivate() from the type Hello is not visible</span></span><br><span class="line">     <span class="comment">// hello.methodDefault();//声明为Default的方法只能在包内部被调用</span></span><br><span class="line">     <span class="comment">// The method methodDefault() from the type Hello is not visible </span></span><br><span class="line">     <span class="comment">// hello.methodProtected();</span></span><br><span class="line">        hello.methodPublic();<span class="comment">//成功调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在Hello_son.java文件下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test.Hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello_son</span> <span class="keyword">extends</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// helloPrivate   = 1;  //not visible</span></span><br><span class="line">     <span class="comment">// helloDefault   = 2;  //not visible</span></span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">4</span>;</span><br><span class="line">        </span><br><span class="line">     <span class="comment">// methodProivate();   //not visible</span></span><br><span class="line">     <span class="comment">// methodDefault();    //not visible</span></span><br><span class="line">        methodProtected();</span><br><span class="line">        methodPublic();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-2-在类为缺省时，对于属性和方法"><a href="#3-2-在类为缺省时，对于属性和方法" class="headerlink" title="3.2 在类为缺省时，对于属性和方法"></a>3.2 在类为缺省时，对于属性和方法</h5><p><strong>在Test包下</strong></p>
<p><strong>在Hello.java文件里</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> helloPrivate;</span><br><span class="line">    <span class="keyword">int</span> helloDefault;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> helloProtected;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> helloPublic;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodProtected</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodPublic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在test_.java文件里</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Hello hello = <span class="keyword">new</span> Hello();<span class="comment">//通过类造对象，再去调用对象里的属性和方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// hello.helloPrivate   = 1;//声明为private的属性只能在类内部被调用</span></span><br><span class="line">        <span class="comment">// The field Hello.helloPrivate is not visible （属性不可见）</span></span><br><span class="line">        hello.helloProtected = <span class="number">2</span>;<span class="comment">//赋值成功</span></span><br><span class="line">        hello.helloDefault   = <span class="number">3</span>;<span class="comment">//赋值成功</span></span><br><span class="line">        hello.helloPublic    = <span class="number">4</span>;<span class="comment">//赋值成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// hello.methodPrivate();//声明为private的方法只能在类内部被调用</span></span><br><span class="line">        <span class="comment">// The method methodPrivate() from the type Hello is not visible</span></span><br><span class="line">        hello.methodProtected();<span class="comment">//成功调用</span></span><br><span class="line">        hello.methodDefault();<span class="comment">//成功调用</span></span><br><span class="line">        hello.methodPublic();<span class="comment">//成功调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在test2包下</strong></p>
<p><strong>在test2.java文件下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test.Hello; <span class="comment">//将test包下的Hello导入 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Hello hello = <span class="keyword">new</span> Hello();<span class="comment">//报错，声明为缺省状态的类只能在包里面使用</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在Hello_son.java文件下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test.Hello;<span class="comment">//报错 The type test.Hello is not visible</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello_son</span> <span class="keyword">extends</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="comment">//报错 Hello cannot be resolved to a type</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-关键字：super"><a href="#4-关键字：super" class="headerlink" title="4. 关键字：super"></a>4. 关键字：super</h4><ul>
<li><p>在Java类中使用super来调用父类中的指定操作： </p>
<ul>
<li>super可用于访问父类中定义的属性 </li>
<li>super可用于调用父类中定义的成员方法 </li>
<li>super可用于在子类构造器中调用父类的构造器</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员</li>
<li>super的追溯不仅限于直接父类</li>
<li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识</li>
</ul>
</li>
<li><p>关键字super举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span> + name + <span class="string">&quot;\nage: &quot;</span> + age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> String name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> String school = <span class="string">&quot;New Oriental&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSchool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> school;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getInfo() + <span class="string">&quot;\nschool: &quot;</span> + school;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Student st = <span class="keyword">new</span> Student();</span><br><span class="line">		System.out.println(st.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Name: 张三<br>age: 0<br>school: New Oriental</p>
</blockquote>
</li>
</ul>
<h5 id="4-1-调用父类的构造器"><a href="#4-1-调用父类的构造器" class="headerlink" title="4.1 调用父类的构造器"></a>4.1 调用父类的构造器</h5><ul>
<li><p>子类中所有的构造器默认都会访问父类中空参的构造器</p>
</li>
<li><p>当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，只能”二选一” ，且必须放在构造器的首行</p>
</li>
<li><p>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错</p>
</li>
<li><p>调用父类构造器举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> Date birthDate;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Date d)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.birthDate = d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(name, age, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Date d)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(name, <span class="number">30</span>, d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(name, <span class="number">30</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String school;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, age);</span><br><span class="line">		school = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		school = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 编译出错: no super(),系统将调用父类无参数的构造器。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">		school = s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="4-2-this和super的区别"><a href="#4-2-this和super的区别" class="headerlink" title="4.2 this和super的区别"></a>4.2 this和super的区别</h5><table>
<thead>
<tr>
<th>No.</th>
<th>区别点</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>访问属性</td>
<td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td>
<td>直接访问父类中的属性</td>
</tr>
<tr>
<td>2</td>
<td>调用方法</td>
<td>访问本类中的方法，如果本类没有此方法则从父类中继续查找</td>
<td>直接访问父类中的方法</td>
</tr>
<tr>
<td>3</td>
<td>调用构造器</td>
<td>调用本类构造器，必须放在构造器的首行</td>
<td>调用父类构造器，必须 放在子类构造器的首行</td>
</tr>
</tbody></table>
<p>super(…)和this(…)调用语句不能同时在一个构造器中出现</p>
<h4 id="5-子类实例化过程"><a href="#5-子类实例化过程" class="headerlink" title="5. 子类实例化过程"></a>5. 子类实例化过程</h4><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151604286.png" alt="image-20210815160431840"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151607694.png" alt="image-20210815160659235"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108161439286.jpg" alt="Inked202108151607563_LI"></p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-15-15:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Creature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creature无参数的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">Creature</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal带一个参数的构造器，该动物的name为&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal带两个参数的构造器，其age为&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wolf</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wolf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;灰太狼&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Wolf无参数的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Wolf();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Creature无参数的构造器<br>Animal带一个参数的构造器，该动物的name为灰太狼<br>Animal带两个参数的构造器，其age为3<br>Wolf无参数的构造器</p>
</blockquote>
<h4 id="6-OOP特征三：多态性"><a href="#6-OOP特征三：多态性" class="headerlink" title="6. OOP特征三：多态性"></a>6. OOP特征三：多态性</h4><ul>
<li><p>多态性，是面向对象中最重要的概念，在Java中的体现： </p>
<p>对象的多态性：父类的引用指向子类的对象</p>
<ul>
<li>可以直接应用在抽象类和接口上</li>
</ul>
</li>
<li><p>Java引用变量有两个类型：编译时类型和运行时类型。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简 称：编译时，看左边；运行时，看右边。 </p>
<ul>
<li><p>若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism) </p>
</li>
<li><p>多态情况下， “看左边” ：看的是父类的引用（父类中不具备子类特有的方法）</p>
<p>​                              “看右边” ：看的是子类的对象（实际运行的是子类重写父类的方法）</p>
</li>
</ul>
</li>
<li><p>对象的多态 —在Java中,子类的对象可以替代父类的对象使用</p>
<ul>
<li><p>一个变量只能有一种确定的数据类型</p>
</li>
<li><p>一个引用类型变量可能指向(引用)多种不同类型的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">Object o = <span class="keyword">new</span> Person();<span class="comment">//Object类型的变量o，指向Person类型的对象</span></span><br><span class="line">o = <span class="keyword">new</span> Student(); <span class="comment">//Object类型的变量o，指向Student类型的对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。</p>
</li>
</ul>
</li>
<li><p>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student m = <span class="keyword">new</span> Student();</span><br><span class="line">m.school = “pku”; <span class="comment">//合法,Student类有school成员变量</span></span><br><span class="line">Person e = <span class="keyword">new</span> Student(); </span><br><span class="line">e.school = “pku”; <span class="comment">//非法,Person类没有school成员变量</span></span><br></pre></td></tr></table></figure>

<p>属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。</p>
</li>
<li><p>方法声明的形参类型为父类类型，可以使用子类的对象作为实参调用该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person e)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ……</span></span><br><span class="line">		e.getInfo();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stirng args[])</span> </span>&#123;</span><br><span class="line">		Test t = <span class="keyword">new</span> Test();</span><br><span class="line">		Student m = <span class="keyword">new</span> Student();</span><br><span class="line">		t.method(m); <span class="comment">// 子类的对象m传送给父类类型的参数e</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="5-1-虚拟方法调用"><a href="#5-1-虚拟方法调用" class="headerlink" title="5.1 虚拟方法调用"></a>5.1 虚拟方法调用</h5><ul>
<li><p>正常的方法调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person e = <span class="keyword">new</span> Person();</span><br><span class="line">e.getInfo();</span><br><span class="line">Student e = <span class="keyword">new</span> Student();</span><br><span class="line">e.getInfo();</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚拟方法调用(多态情况下)</p>
<p>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person e = <span class="keyword">new</span> Student();</span><br><span class="line">e.getInfo(); <span class="comment">//调用Student类的getInfo()方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译时类型和运行时类型</p>
<p>编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类 的getInfo()方法。——动态绑定</p>
</li>
</ul>
<h5 id="5-2-方法的重载与重写"><a href="#5-2-方法的重载与重写" class="headerlink" title="5.2 方法的重载与重写"></a>5.2 方法的重载与重写</h5><p>​            从编译和运行的角度看： </p>
<p>​            重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子的，即子类可以重载父类的同名不同参数的方法。 所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法， 这称为“早绑定”或“静态绑定”；</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体 方法，这称为“晚绑定”或“动态绑定”。 引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”</span><br></pre></td></tr></table></figure>

<h5 id="5-3-instanceof操作符"><a href="#5-3-instanceof操作符" class="headerlink" title="5.3 instanceof操作符"></a>5.3 instanceof操作符</h5><p>x instanceof A：检验x是否为类A的对象，返回值为boolean型。 </p>
<ul>
<li><p>要求x所属的类与类A必须是子类和父类的关系，否则编译错误。 </p>
</li>
<li><p>如果x属于类A的子类B，x instanceof A值也为true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;…&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;…&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graduate</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;…&#125;</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(Person e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e <span class="keyword">instanceof</span> Person) </span><br><span class="line">		<span class="comment">// 处理Person类及其子类对象</span></span><br><span class="line">	<span class="keyword">if</span> (e <span class="keyword">instanceof</span> Student) </span><br><span class="line">		<span class="comment">//处理Student类及其子类对象</span></span><br><span class="line">	<span class="keyword">if</span> (e <span class="keyword">instanceof</span> Graduate)</span><br><span class="line">		<span class="comment">//处理Graduate类及其子类对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="5-4-对象类型转换-Casting"><a href="#5-4-对象类型转换-Casting" class="headerlink" title="5.4 对象类型转换 (Casting )"></a>5.4 对象类型转换 (Casting )</h5><ul>
<li><p>基本数据类型的Casting：</p>
<ul>
<li><p>自动类型转换：小的数据类型可以自动转换成大的数据类型 </p>
<p>如long g=20; double d=12.0f</p>
</li>
<li><p>强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型 </p>
<p>如 float f=(float)12.0; int a=(int)1200L</p>
</li>
</ul>
</li>
<li><p>对Java对象的强制类型转换称为造型 </p>
<ul>
<li>从子类到父类的类型转换可以自动进行 </li>
<li>从父类到子类的类型转换必须通过造型(强制类型转换)实现 </li>
<li>无继承关系的引用类型间的转换是非法的 </li>
<li>在造型前可以使用instanceof操作符测试一个对象的类型</li>
</ul>
</li>
<li><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151643504.png" alt="image-20210815164314304"></p>
</li>
<li><p>继承成员变量和继承方法的区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldMethodTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Sub s = <span class="keyword">new</span> Sub();</span><br><span class="line">		System.out.println(s.count);</span><br><span class="line">		s.display();</span><br><span class="line">		Base b = s;</span><br><span class="line">		System.out.println(b == s);</span><br><span class="line">		System.out.println(b.count);</span><br><span class="line">		b.display();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>20<br>20<br>true<br>10<br>20</p>
</blockquote>
</li>
<li><p>子类继承父类</p>
<ul>
<li>若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。</li>
<li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量。</li>
</ul>
</li>
</ul>
<h4 id="7-Object类的使用"><a href="#7-Object类的使用" class="headerlink" title="7. Object类的使用"></a>7. Object类的使用</h4><p>Object类是所有Java类的根父类，如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-1-Object类中的主要结构"><a href="#7-1-Object类中的主要结构" class="headerlink" title="7.1 Object类中的主要结构"></a>7.1 Object类中的主要结构</h5><table>
<thead>
<tr>
<th>NO.</th>
<th>方法名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>public Object()</td>
<td>构造</td>
<td>构造器</td>
</tr>
<tr>
<td>2</td>
<td>public boolean equals(Object obj)</td>
<td>普通</td>
<td>对象比较</td>
</tr>
<tr>
<td>3</td>
<td>public int hashCode()</td>
<td>普通</td>
<td>取得Hash码</td>
</tr>
<tr>
<td>4</td>
<td>public String toString()</td>
<td>普通</td>
<td>对象打印时调用</td>
</tr>
</tbody></table>
<h5 id="7-2-操作符与equals方法"><a href="#7-2-操作符与equals方法" class="headerlink" title="7.2 ==操作符与equals方法"></a>7.2 ==操作符与equals方法</h5><ul>
<li><p>==</p>
<ul>
<li><p>基本类型比较值:只要两个变量的值相等，即为true。 </p>
<ul>
<li>int a=5; if(a==6){…}</li>
</ul>
</li>
<li><p>引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才返回true。</p>
<p>Person p1=new Person(); </p>
<p>Person p2=new Person();</p>
<p> if (p1==p2){…}</p>
<ul>
<li>用“ == ” 进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错</li>
</ul>
</li>
</ul>
</li>
<li><p>equals()：所有类都继承了Object，也就获得了equals()方法。还可以重写。如果该方法没有被重写过默认也是  ==  ;</p>
<ul>
<li>只能比较引用类型，其作用与“==”相同,比较是否指向同一个对象。</li>
<li>格式:obj1.equals(obj2)</li>
</ul>
</li>
<li><p>特例：当用equals()方法进行比较时，对类File、String、Date及包装类 （Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对 象；</p>
<ul>
<li>原因：在这些类中重写了Object类的equals()方法。</li>
</ul>
<p>当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等</p>
</li>
</ul>
<h6 id="7-2-1-重写equals-方法的原则"><a href="#7-2-1-重写equals-方法的原则" class="headerlink" title="7.2.1 重写equals()方法的原则"></a>7.2.1 重写equals()方法的原则</h6><ul>
<li>对称性：如果x.equals(y)返回是“true” ，那么y.equals(x)也应该返回是 “true”。</li>
<li>自反性：x.equals(x)必须返回是“true”。</li>
<li>传递性：如果x.equals(y)返回是“true” ，而且y.equals(z)返回是“true” ， 那么z.equals(x)也应该返回是“true”。</li>
<li>一致性：如果x.equals(y)返回是“true” ，只要x和y内容一直不变，不管你 重复x.equals(y)多少次，返回都是“true”。</li>
<li>任何情况下，x.equals(null)，永远返回是“false” ； x.equals(和x不同类型的对象)永远返回是“false”。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> it = <span class="number">65</span>;</span><br><span class="line"><span class="keyword">float</span> fl = <span class="number">65.0f</span>;</span><br><span class="line">System.out.println(“<span class="number">65</span>和<span class="number">65.0f</span>是否相等？” + (it == fl)); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">char</span> ch1 = <span class="string">&#x27;A&#x27;</span>; <span class="keyword">char</span> ch2 = <span class="number">12</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;65和&#x27;A&#x27;是否相等？&quot;</span> + (it == ch1));<span class="comment">//true</span></span><br><span class="line">System.out.println(“<span class="number">12</span>和ch2是否相等？<span class="string">&quot; + (12 == ch2));//true</span></span><br><span class="line"><span class="string">String str1 = new String(&quot;</span>hello<span class="string">&quot;);</span></span><br><span class="line"><span class="string">String str2 = new String(&quot;</span>hello<span class="string">&quot;);</span></span><br><span class="line"><span class="string">System.out.println(&quot;</span>str1和str2是否相等？<span class="string">&quot;+ (str1 == str2));//false</span></span><br><span class="line"><span class="string">System.out.println(&quot;</span>str1是否equals str2？<span class="string">&quot;+(str1.equals(str2)));//true</span></span><br><span class="line"><span class="string">System.out.println(“hello” == new java.util.Date()); //编译不通过</span></span><br></pre></td></tr></table></figure>

<h5 id="7-3-toString-方法"><a href="#7-3-toString-方法" class="headerlink" title="7.3 toString()方法"></a>7.3 toString()方法</h5><p>toString()方法在Object类中定义，其返回值是String类型，返回类名和它的引用地址。在进行String与其它类型数据的连接操作时，自动调用toString()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date now=<span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(“now=”+now); 相当于</span><br><span class="line">System.out.println(“now=”+now.toString());</span><br></pre></td></tr></table></figure>

<p>可以根据需要在用户自定义类型中重写toString()方法 如String 类重写了toString()方法，返回字符串的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1=“hello”;</span><br><span class="line">System.out.println(s1);<span class="comment">//相当于System.out.println(s1.toString());</span></span><br></pre></td></tr></table></figure>

<p>基本类型数据转换为String类型时，调用了对应包装类的toString()方法 </p>
<p>int a=10; System.out.println(“a=”+a)</p>
<h4 id="8-包装类-Wrapper-的使用"><a href="#8-包装类-Wrapper-的使用" class="headerlink" title="8. 包装类(Wrapper)的使用"></a>8. 包装类(Wrapper)的使用</h4><p>针对八种基本数据类型定义相应的引用类型—包装类（封装类）,有了类的特点，就可以调用类中的方法，Java才是真正的面向对象</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151712053.png" alt="image-20210815171252735"> </p>
<ul>
<li><p>基本数据类型包装成包装类的实例 —装箱</p>
<ul>
<li><p>通过包装类的构造器实现：</p>
<p> int i = 500; </p>
<p>Integer t = new Integer(i);</p>
</li>
<li><p>还可以通过字符串参数构造包装类对象：</p>
<p>Float f = new Float(“4.56”); </p>
<p>Long l = new Long(“asdf”); //NumberFormatException</p>
</li>
</ul>
</li>
<li><p>获得包装类对象中包装的基本类型变量 —拆箱</p>
<ul>
<li><p>调用包装类的.xxxValue()方法： </p>
<p>boolean b = bObj.booleanValue();</p>
<p>JDK1.5之后，支持自动装箱，自动拆箱。但类型必须匹配。</p>
</li>
</ul>
</li>
<li><p>字符串转换成基本数据类型 </p>
<ul>
<li><p>通过包装类的构造器实现： </p>
<p>int i = new Integer(“12”); </p>
</li>
<li><p>通过包装类的parseXxx(String s)静态方法： </p>
<p>Float f = Float.parseFloat(“12.1”);</p>
</li>
</ul>
</li>
<li><p>基本数据类型转换成字符串 </p>
<ul>
<li>调用字符串重载的valueOf()方法： String fstr = String.valueOf(2.34f); </li>
<li>更直接的方式： String intStr = 5 + “”</li>
</ul>
</li>
<li><p>基本类型、包装类与String类间的转换</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151719326.png" alt="image-20210815171942936"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>07-异常处理</title>
    <url>/2021/09/17/07%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="07—异常处理"><a href="#07—异常处理" class="headerlink" title="07—异常处理"></a>07—异常处理</h3><h4 id="1-异常概述与异常体系结构"><a href="#1-异常概述与异常体系结构" class="headerlink" title="1. 异常概述与异常体系结构"></a>1. 异常概述与异常体系结构</h4><p>​          异常：在Java语言中，将程序执行中发生的不正常情况称为“异常” 。 (开发过程中的语法错误和逻辑错误不是异常)。Java程序在执行过程中所发生的异常事件可分为两类：</p>
<ol>
<li><p>Error：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError和OOM。一般不编写针对性 的代码进行处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Error</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.栈溢出：java.lang.StackOverflowError</span></span><br><span class="line">        <span class="comment">// main(args);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.堆溢出：java.lang.OutOfMemoryError</span></span><br><span class="line">        <span class="comment">// Integer[] arr = new Integer[1024*1024*1024];</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Exception: 其它因编程错误或偶然的外在因素导致的一般性问题，可以使 用针对性的代码进行处理。例如：</p>
<ol>
<li>空指针访问</li>
<li>试图读取不存在的文件</li>
<li>网络连接中断</li>
<li>数组角标越界</li>
</ol>
</li>
</ol>
<p>​        对于这些错误，一般有两种解决方法：一是遇到错误就终止程序的运行。另一种方法是由程序员在编写程序时，就考虑到错误的检测、错误消息的提示，以及错误的处理。捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生。 比如：除数为0，数组下标越界等</p>
<p>​          分类：编译时异常和运行时异常</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108160833401.png" alt="屏幕截图 2021-08-16 082835"></p>
<ul>
<li>运行时异常<ul>
<li>是指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。java.lang.RuntimeException类及它的子类都是运行时异常。</li>
<li>对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对 程序的可读性和运行效率产生影响。</li>
</ul>
</li>
<li>编译时异常<ul>
<li>是指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一 般性异常。编译器要求Java程序必须捕获或声明所有编译时异常。</li>
<li>对于这类异常，如果程序不处理，可能会带来意想不到的结果。</li>
</ul>
</li>
</ul>
<h4 id="2-常见异常"><a href="#2-常见异常" class="headerlink" title="2. 常见异常"></a>2. 常见异常</h4><p><strong>异常体系结构</strong><br>java.lang.Throwable<br>    |—–java.lang.Error:一般不编写针对性代码进行处理<br>    |—–java.lang.Exception:可以进行异常处理<br>        |—–编译时异常(checked)<br>            |—–IOException<br>                |—–FileNotFoundException<br>            |—–ClassNotFoundException<br>        |—–运行时异常(unchecked)<br>            |—–NullPointerException<br>            |—–ArrayIndexOutOfBoundsException<br>            |—–ClassCastException<br>            |—–NumberFormatException<br>            |—–InputMismatchException<br>            |—–ArithmeticException</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 异常概述;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//********************以下是运行时异常*************************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//NullPointerException</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArrayINdexOUtofBOundsException</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        System.out.println(arr[<span class="number">10</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ClassCastException</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Date();</span><br><span class="line">        String str = (String)obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//NUmberFormanException</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">      String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">      <span class="keyword">int</span> num = Integer.parseInt(str);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//知识串联：包装类转化为String</span></span><br><span class="line">      <span class="comment">//Integer integer = 99;</span></span><br><span class="line">        <span class="comment">// String string = String.valueOf(integer);</span></span><br><span class="line">      <span class="comment">//System.out.println(string);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//InputMismatchException</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入&quot;</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> score = scanner.nextInt();</span><br><span class="line">        System.out.println(score);</span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ArithmeticException</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        System.out.println(a/b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//********************以下是编译时异常*************************</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);<span class="comment">//Unhandled exception type FileNotFoundexception</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = fis.read();<span class="comment">//Unhandled exception type IOException</span></span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) data);</span><br><span class="line">            data = fis.read();<span class="comment">//Unhandled exception type IOException</span></span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();<span class="comment">//Unhandled exception type IOException</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-异常处理机制一：try-catch-finally"><a href="#3-异常处理机制一：try-catch-finally" class="headerlink" title="3. 异常处理机制一：try-catch-finally"></a>3. 异常处理机制一：try-catch-finally</h4><p>​          在编写程序时，经常要在可能出现错误的地方加上检测的代码， 如进行x/y运算时，要检测分母为0，数据为空，输入的不是数据 而是字符等。过多的if-else分支会导致程序的代码加长、臃肿， 可读性差。因此采用异常处理机制。<br>​          Java异常处理 ：Java采用的异常处理机制，是将异常处理的程序代码集中在一起， 与正常的程序代码分开，使得程序简洁、优雅，并易于维护。</p>
<p>​            Java提供的是异常处理的抓抛模型。Java程序的执行过程中如出现异常，会生成一个异常类对象， 该异常对象将被提交给Java运行时系统，这个过程称为抛出 (throw)异常。</p>
<p>​            异常对象的生成：①由虚拟机自动生成：程序运行过程中，虚拟机检测到程序发生了问题，如果在当 前代码中没有找到相应的处理程序，就会在后台自动创建一个对应异常类的实例 对象并抛出——自动抛出；②由开发人员手动创建：Exception exception = new ClassCastException();——创建好的异常对象不抛出对程序没有任何影响，和创建一个普通对象一样</p>
<h5 id="3-1-异常抛出机制"><a href="#3-1-异常抛出机制" class="headerlink" title="3.1 异常抛出机制"></a>3.1 异常抛出机制</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108160845141.png" alt="image-20210816084505060"></p>
<ul>
<li>如果一个方法内抛出异常，该异常对象会被抛给调用者方法中处 理。如果异常没有在调用者方法中处理，它继续被抛给这个调用 方法的上层方法。这个过程将一直继续下去，直到异常被处理。 这一过程称为捕获(catch)异常。</li>
<li>如果一个异常回到main()方法，并且main()也不处理，则程序运行终止。</li>
<li>程序员通常只能处理Exception，而对Error无能为力。</li>
</ul>
<p><strong>异常处理是通过try-catch-finally语句实现的。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	...... <span class="comment">//可能产生异常的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName1 e )&#123;</span><br><span class="line">	...... <span class="comment">//当产生ExceptionName1型异常时的处置措施</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>( ExceptionName2 e )&#123;</span><br><span class="line">	...... <span class="comment">//当产生ExceptionName2型异常时的处置措施</span></span><br><span class="line">&#125;</span><br><span class="line">[ <span class="keyword">finally</span>&#123;</span><br><span class="line">	...... <span class="comment">//无论是否发生异常，都无条件执行的语句</span></span><br><span class="line">&#125; ]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>try</p>
<p>捕获异常的第一步是用try{…}语句块选定捕获异常的范围，将可能出现 异常的代码放在try语句块中。</p>
</li>
<li><p>catch (Exceptiontype e)</p>
<p>在catch语句块中是对异常对象进行处理的代码。每个try语句块可以伴随 一个或多个catch语句，用于处理可能产生的不同类型的异常对象。</p>
<p>如果明确知道产生的是何种异常，可以用该异常类作为catch的参数；也可以用其父类作为catch的参数。 比 如 ： 可以 用 ArithmeticException 类 作 为 参 数 的 地 方 ， 就 可 以 用 RuntimeException类作为参数，或者用所有异常的父类Exception类作为参数。 但不能是与ArithmeticException类无关的异常，如NullPointerException（catch 中的语句将不会执行）。</p>
<ul>
<li><p>捕获异常的有关信息：</p>
<p>与其它对象一样，可以访问一个异常对象的成员变量或调用它的 方法。</p>
<ul>
<li><p>getMessage() 获取异常信息，返回字符串</p>
</li>
<li><p>printStackTrace() 获取异常类名和异常信息，以及异常出 现在程序中的位置。返回值void。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108160850419.png" alt="屏幕截图 2021-08-16 085000"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>finally</p>
<ul>
<li><p>捕获异常的最后一步是通过finally语句为异常处理提供一个统一的出口，使得在控制流转到程序的其它部分以前，能够 对程序的状态作统一的管理。</p>
</li>
<li><p>不论在try代码块中是否发生了异常事件，catch语句是否执行，catch语句是否有异常，catch语句中是否有return， finally块中的语句都会被执行。</p>
</li>
<li><p>finally语句和catch语句是任选的</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108160851827.png" alt="image-20210816085152978"></p>
</li>
</ul>
</li>
</ul>
<h5 id="3-2-不捕获异常时的情况"><a href="#3-2-不捕获异常时的情况" class="headerlink" title="3.2 不捕获异常时的情况"></a>3.2 不捕获异常时的情况</h5><p>​          当异常是RuntimeException类或是它的子类时，这些类的异常的特点是：即使没有使用try和catch捕获，Java自己也能捕获，并且编译通过 ( 但运行时会发生异常使得程序运行终止 )。如果抛出的异常是IOException等类型的非运行时异常，则必须捕获，否则编译错误。也就是说，我们必须处理编译时异常，将异常进行捕捉，转化为运行时异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOExp</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span> b;</span><br><span class="line">		b = in.read();</span><br><span class="line">		<span class="keyword">while</span> (b != -<span class="number">1</span>) &#123;</span><br><span class="line">			System.out.print((<span class="keyword">char</span>) b);</span><br><span class="line">			b = in.read();</span><br><span class="line">		&#125;</span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相关知识：FileInputStream类的成员方法read()的功能是每次从相应的(本地为 ASCII码编码格式)文件中读取一个字节，并转换成0~255之间的int型整数返回， 到达文件末尾时则返回-1。</p>
<h5 id="3-3-异常处理示例"><a href="#3-3-异常处理示例" class="headerlink" title="3.3 异常处理示例"></a>3.3 异常处理示例</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108160903770.png" alt="image-20210708221213190"> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 异常概述;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一、异常的处理：抓抛模型</span></span><br><span class="line"><span class="comment">过程一：“抛”，程序在正常执行的过程中，一旦出现异常，就会在异常代码出生成一个对应异常类的对象</span></span><br><span class="line"><span class="comment">       并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       关于异常对象的产生：①系统自动生成的异常对象   ②手动的生成一个异常对象，并抛出(throw)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">过程二：“抓”，可以理解为异常的处理方式：①try-catch-finally ②throws</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、try-catch-finally的使用</span></span><br><span class="line"><span class="comment">try&#123;</span></span><br><span class="line"><span class="comment">    //可能出现异常的代码</span></span><br><span class="line"><span class="comment">&#125;catch(异常类型1 变量名1)&#123;</span></span><br><span class="line"><span class="comment">    //处理异常的方式1</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">catch(异常类型2 变量名2)&#123;</span></span><br><span class="line"><span class="comment">    //处理异常的方式2</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">……</span></span><br><span class="line"><span class="comment">finally&#123;</span></span><br><span class="line"><span class="comment">    //一定会执行的代码</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">1.finally是可选的</span></span><br><span class="line"><span class="comment">2.使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常的类，根据此对象的类型，去catch中进行匹配</span></span><br><span class="line"><span class="comment">（不会执行发生异常行的后续的且同样被try包括起来的代码）</span></span><br><span class="line"><span class="comment">3.一旦try中的异常对象匹配到某一个catch是，就进入catch中进行异常的处理。一旦处理完成，就跳出当前的try-catch结构（在没有写finally的情况下）。</span></span><br><span class="line"><span class="comment">继续执行其后的代码</span></span><br><span class="line"><span class="comment">4.catch中的异常如果没有子父类关系，则声明的先后顺序对程序无影响</span></span><br><span class="line"><span class="comment">  catch中的异常类型如果满足子父类关系，则要求子类一定要声明在父类之前。否则报错</span></span><br><span class="line"><span class="comment">  （Exception时NumberFormatException和NullPointerException的父类，所以要声明在二者之后，</span></span><br><span class="line"><span class="comment">  而这二者之间无子父类关系，所以二者的先后顺序不做特殊要求）</span></span><br><span class="line"><span class="comment">5.常用的异常对象处理方式：①String getMessage()  ②printStackTrace()</span></span><br><span class="line"><span class="comment">6.在try结构中声明的变量，出了try结构以后，就不能再被调用了</span></span><br><span class="line"><span class="comment">7.try-catch-finally结构可以嵌套</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">体会：</span></span><br><span class="line"><span class="comment">1.使用try-catch-finally处理编译时异常（如test3)，使得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用try-catch-finally</span></span><br><span class="line"><span class="comment">将一个编译时可能出现的异常，延迟到运行时出现。</span></span><br><span class="line"><span class="comment">2.开发中由于运行时异常比较常见，所以我们通常将不针对运行时异常编写try-catch-finally了。针对编译时的异常，我们要考虑异常的处理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Integer integer = Integer.parseInt(str);</span><br><span class="line">            System.out.println(<span class="string">&quot;hello-----1&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">            <span class="comment">//System.out.println(&quot;出现数值转换异常了，不要着急……&quot;);</span></span><br><span class="line">            <span class="comment">//String getMessage()</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">            <span class="comment">//printStackTrack</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NullPointerException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出现空指针异常&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;出现异常&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行finally&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;hello-----2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Test</span></span><br><span class="line"><span class="comment">//    public void test2()&#123;</span></span><br><span class="line"><span class="comment">//        File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line"><span class="comment">//        FileInputStream fis = null;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            fis = new FileInputStream(file);</span></span><br><span class="line"><span class="comment">//        &#125; catch (FileNotFoundException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int data = 0;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            data = fis.read();</span></span><br><span class="line"><span class="comment">//        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        while(data != -1)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println((char) data);</span></span><br><span class="line"><span class="comment">//            try &#123;</span></span><br><span class="line"><span class="comment">//                data = fis.read();</span></span><br><span class="line"><span class="comment">//            &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//                e.printStackTrace();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            fis.close();</span></span><br><span class="line"><span class="comment">//        &#125; catch (IOException e) &#123;</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">            FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);<span class="comment">//Unhandled exception type FileNotFoundexception</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> data = fis.read();<span class="comment">//Unhandled exception type IOException</span></span><br><span class="line">            <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println((<span class="keyword">char</span>) data);</span><br><span class="line">                data = fis.read();<span class="comment">//Unhandled exception type IOException</span></span><br><span class="line">            &#125;</span><br><span class="line">            fis.close();<span class="comment">//Unhandled exception type IOException</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-异常处理机制二：throws"><a href="#4-异常处理机制二：throws" class="headerlink" title="4. 异常处理机制二：throws"></a>4. 异常处理机制二：throws</h4><p>声明抛出异常是Java中处理异常的第二种方式</p>
<ol>
<li>如果一个方法(中的语句执行时)可能生成某种异常，但是并不能确定如何处理这 种异常，则此方法应显示地声明抛出异常，表明该方法将不对这些异常进行处理， 而由该方法的调用者负责处理。</li>
<li>在方法声明中用throws语句可以声明抛出异常的列表，throws后面的异常类型可 以是方法中产生的异常类型，也可以是它的父类。</li>
</ol>
<p>声明抛出异常举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFile</span><span class="params">(String file)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="comment">// 读文件的操作可能产生FileNotFoundException类型的异常</span></span><br><span class="line">	FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">	..……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108160916820.png" alt="image-20210816091631721"></p>
<h5 id="4-1-重写方法声明抛出异常的原则"><a href="#4-1-重写方法声明抛出异常的原则" class="headerlink" title="4.1 重写方法声明抛出异常的原则"></a>4.1 重写方法声明抛出异常的原则</h5><p>重写方法不能抛出比被重写方法范围更大的异常类型。在多态的情况下， 对methodA()方法的调用-异常的捕获按父类声明的异常处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		……</span><br><span class="line">	&#125; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B1</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">		……</span><br><span class="line">	&#125; &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B2</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">//报错</span></span><br><span class="line">		……</span><br><span class="line">	&#125; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-异常处理示例"><a href="#4-2-异常处理示例" class="headerlink" title="4.2 异常处理示例"></a>4.2 异常处理示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 异常概述;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">三、异常处理方式二 throws + 异常类型</span></span><br><span class="line"><span class="comment">1.“throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。一旦方法体执行时，出现异常，</span></span><br><span class="line"><span class="comment">仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出</span></span><br><span class="line"><span class="comment">2.体会：try-catch-finally：真正的将异常处理掉。throws的方式只是将异常抛给了调用者。并没真正处理掉</span></span><br><span class="line"><span class="comment">3.开发中如何选择使用try-catch-finaly还是使用throws?</span></span><br><span class="line"><span class="comment">    3.1如果父类被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，则必须要用try-catch-finally方式处理</span></span><br><span class="line"><span class="comment">    3.2执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//method2();//main是静态方法，不能调用非静态的method2()</span></span><br><span class="line">        <span class="comment">//此时若main方法也继续往上抛出异常，那么则会抛到虚拟机里。若虚拟机也处理不了，则会崩溃，所以main不建议往上继续抛出</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method3();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> ExceptionTest2().method2();<span class="comment">//method2()已经将异常处理好了，所以不用再继续处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        method1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);<span class="comment">//Unhandled exception type FileNotFoundexception</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> data = fis.read();<span class="comment">//Unhandled exception type IOException</span></span><br><span class="line">        <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="keyword">char</span>) data);</span><br><span class="line">            data = fis.read();<span class="comment">//Unhandled exception type IOException</span></span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();<span class="comment">//Unhandled exception type IOException</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-手动抛出异常"><a href="#5-手动抛出异常" class="headerlink" title="5. 手动抛出异常"></a>5. 手动抛出异常</h4><p>​           Java异常类对象除在程序执行过程中出现异常时由系统自动生成并 抛出，也可根据需要使用人工创建并抛出。</p>
<ol>
<li>首先要生成异常类对象，然后通过throw语句实现抛出操作(提交给Java运 行环境)。 IOException e = new IOException(); throw e; </li>
<li>可以抛出的异常必须是Throwable或其子类的实例。下面的语句在编译时将会产生语法错误： throw new String(“want to throw”);</li>
</ol>
<h5 id="5-1-手动抛出异常示例"><a href="#5-1-手动抛出异常示例" class="headerlink" title="5.1 手动抛出异常示例"></a>5.1 手动抛出异常示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 手动抛出异常;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Student student = <span class="keyword">new</span> Student();</span><br><span class="line">            student.regist(<span class="number">1001</span>);</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;您输入的数据非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-用户自定义异常类"><a href="#6-用户自定义异常类" class="headerlink" title="6. 用户自定义异常类"></a>6. 用户自定义异常类</h4><p>一般地，用户自定义异常类都是RuntimeException的子类。自定义异常类通常需要编写几个重载的构造器。自定义异常需要提供serialVersionUID,自定义的异常通过throw抛出。自定义异常最重要的是异常类的名字，当异常出现时，可以根据 名字判断异常类型。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108160924155.png" alt="image-20210708221744776"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 用户自定义异常类;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如何自定义异常类？</span></span><br><span class="line"><span class="comment">1.继承于现有的异常结构：RuntimeException、Exception</span></span><br><span class="line"><span class="comment">2.提供全局常量：serialVersionUID</span></span><br><span class="line"><span class="comment">3.提供重载的构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7034897193246939L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 用户自定义异常类;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行时异常向上抛出后不用进行try-catch处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRuntimeException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">70348971932469399L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRuntimeException</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRuntimeException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 用户自定义异常类;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            student.regist(<span class="number">1001</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MyException e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stu stu = <span class="keyword">new</span> Stu();</span><br><span class="line">        stu.setId(-<span class="number">111</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regist</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> MyException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyException(<span class="string">&quot;输入的id不能为负&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stu</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MyRuntimeException(<span class="string">&quot;输入的id不能为负&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnExceptionDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;进入方法A&quot;</span>);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;制造异常&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;用A方法的finally&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;进入方法B&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;调用B方法的finally&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			methodA();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(e.getMessage());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		methodB();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>进入方法A<br>用A方法的finally<br>制造异常<br>进入方法B<br>调用方法B的finally</p>
</blockquote>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210709114946.png" alt="image-20210709114937084"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 异常练习;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 编写应用程序EcmDef.java，接收命令行的两个参数，要求不能输入负数，计算两数相除。</span></span><br><span class="line"><span class="comment">	对数据类型不一致(NumberFormatException)、缺少命令行参数(ArrayIndexOutOfBoundsException、</span></span><br><span class="line"><span class="comment">  	除0(ArithmeticException)及输入负数(EcDef 自定义的异常)进行异常处理。</span></span><br><span class="line"><span class="comment">提示：</span></span><br><span class="line"><span class="comment">	(1)在主类(EcmDef)中定义异常方法(ecm)完成两数相除功能。</span></span><br><span class="line"><span class="comment">	(2)在main()方法中使用异常处理语句进行异常处理。</span></span><br><span class="line"><span class="comment">	(3)在程序中，自定义对应输入负数的异常类(EcDef)。</span></span><br><span class="line"><span class="comment">	(4)运行时接受参数 java EcmDef 20 10   //args[0]=“20” args[1]=“10”</span></span><br><span class="line"><span class="comment">	(5)Interger类的static方法parseInt(String s)将s转换成对应的int值。</span></span><br><span class="line"><span class="comment">        如：int a=Interger.parseInt(“314”);	//a=314;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EcmDef</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ecm(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ecm</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> num1 = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> num2 = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(num1 &lt; <span class="number">0</span> || num2 &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EcDef(<span class="string">&quot;输入不能为负数&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;两数相除结果为：&quot;</span>+ (num1/num2));</span><br><span class="line">        &#125; <span class="keyword">catch</span>(NumberFormatException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 异常练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EcDef</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1234142134</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EcDef</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EcDef</span><span class="params">(String mes)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>C:\Users\xiong\IdeaProjects\异常\src\异常练习&gt;javac -encoding utf-8 EcmDef.java EcDef.java</p>
<p>C:\Users\xiong\IdeaProjects\异常\src\异常练习&gt;cd ..</p>
<p>C:\Users\xiong\IdeaProjects\异常\src&gt;java 异常练习.EcmDef 20 10<br>两数相除结果为：2</p>
</blockquote>
<p><strong>终端运行时的注意点：</strong></p>
<ul>
<li><p>当Java源代码中包含中文字符时,我们在用javac编译时会出现“错误:编码GBK的不可映射字符”。 “输入javac -encoding utf-8 文件名.java。就可以解决了。 </p>
</li>
<li><p>找不到或无法加载主类：</p>
<ul>
<li><p>方法一：在java文件把包删掉或者注释掉</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210709130131.png" alt="image-20210709130129602"></p>
</li>
<li><p>方法二：不删除java文件里的package行，返回到package包文件的前一个目录，直接编译。</p>
</li>
</ul>
</li>
</ul>
<p><strong>面试题</strong></p>
<p>throw和throws区别：</p>
<p>throw表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。</p>
<p>throws属于异常处理的一种方式，声明在方法的声明处。</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>10-枚举类与注解</title>
    <url>/2021/09/17/10%E2%80%94%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="10—枚举类与注解"><a href="#10—枚举类与注解" class="headerlink" title="10—枚举类与注解"></a>10—枚举类与注解</h3><h4 id="1-枚举类"><a href="#1-枚举类" class="headerlink" title="1.枚举类"></a>1.枚举类</h4><ul>
<li>类的对象只有有限个，确定的。举例如下： <ul>
<li>星期：Monday(星期一)、……、Sunday(星期天) </li>
<li>性别：Man(男)、Woman(女) </li>
<li> 季节：Spring(春节)……Winter(冬天) </li>
<li>支付方式：Cash（现金）、WeChatPay（微信）、Alipay(支付宝)、BankCard(银 行卡)、CreditCard(信用卡) </li>
<li>就职状态：Busy、Free、Vocation、Dimission </li>
<li>订单状态：Nonpayment（未付款）、Paid（已付款）、Delivered（已发货）、 Return（退货）、Checked（已确认）Fulfilled（已配货） </li>
<li>线程状态：创建、就绪、运行、阻塞、死亡 </li>
</ul>
</li>
<li> 当需要定义一组常量时，强烈建议使用枚举类</li>
</ul>
<h5 id="1-1-枚举类的实现"><a href="#1-1-枚举类的实现" class="headerlink" title="1.1 枚举类的实现"></a>1.1 枚举类的实现</h5><ul>
<li>枚举类的实现<ul>
<li>JDK1.5之前需要自定义枚举类</li>
<li>JDK1.5新增的enum关键字用于定义枚举类</li>
</ul>
</li>
<li>若枚举只有一个对象，则可作为一种单例模式的实现方式</li>
<li>枚举类的属性<ul>
<li>枚举类对象的属性应不允许被改动，所以应该使用private final修饰</li>
<li>枚举类的使用private final修饰的属性应该在构造器中为其赋值</li>
<li>若枚举类显示的定义了带参数的构造器，则在列出枚举值时也必须对应的传入参数</li>
</ul>
</li>
</ul>
<h5 id="1-2-自定义枚举类"><a href="#1-2-自定义枚举类" class="headerlink" title="1.2 自定义枚举类"></a>1.2 自定义枚举类</h5><ol>
<li>私有化类的构造器，保证不能在类的外部创建其对象</li>
<li>在类的内部创建枚举类的实例。声明为：public static final</li>
<li>对象如果有实例变量，应该声明为private final，并在构造器中初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 枚举;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeasonTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Season season =Season.SPRING;</span><br><span class="line">        System.out.println(season);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Season</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.声明Season对象的属性：private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有化类的构造器。并给对象属性赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String seasonName, String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING = <span class="keyword">new</span> Season(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER = <span class="keyword">new</span> Season(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN = <span class="keyword">new</span> Season(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER = <span class="keyword">new</span> Season(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冬山如睡&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1；获取枚举类对象属性</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Season{seasonName=’春天’, seasonDesc=’春暖花开’}</p>
</blockquote>
<h5 id="1-3-使用enum定义枚举类"><a href="#1-3-使用enum定义枚举类" class="headerlink" title="1.3 使用enum定义枚举类"></a>1.3 使用enum定义枚举类</h5><ul>
<li>使用说明<ul>
<li>使用enum定义的枚举类默认继承了java.lang.Enum类，因此不能再继承其他类</li>
<li>枚举类的构造器只能使用private权限修饰符</li>
<li>枚举类的所有实例必须在枚举类中显示列出(,分隔 ;结尾)。列出的实例系统会自动添加public static final修饰</li>
</ul>
</li>
<li>JDK1.5中可以在switch表达式中使用Enum定义的枚举类的对象作为表达式，case子句可以直接使用美剧值的名字，无需添加枚举类作为限定</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SeasonEnum</span> </span>&#123;</span><br><span class="line">	SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春风又绿江南岸&quot;</span>),</span><br><span class="line">	SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">	AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">	WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">		<span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> seasonName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> seasonDesc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="1-4-Enum类的主要方法"><a href="#1-4-Enum类的主要方法" class="headerlink" title="1.4 Enum类的主要方法"></a>1.4 Enum类的主要方法</h5><table>
<thead>
<tr>
<th>方法名</th>
<th>方法描述</th>
</tr>
</thead>
<tbody><tr>
<td>valeOf</td>
<td>传递枚举类型的Class对象和枚举常量名称给静态方法valueOf，会得到与参数匹配的枚举常量</td>
</tr>
<tr>
<td>toString</td>
<td>得到当前枚举常量的名称。可以通过重写这个方法来使得到的结果更加易读</td>
</tr>
<tr>
<td>equals</td>
<td>在枚举类型中可以直接使用 == 来比较两个枚举常量是否相等。Enum在提供的这个equals()方法，也是直接使用 == 来实现的。它的存在时为了在Set、List和Map中使用。注意，equals()是不可变的</td>
</tr>
<tr>
<td>hashCode</td>
<td>Enum实现了hashCode()来和equals()保持一致。他也是不可变的</td>
</tr>
<tr>
<td>getDeclaringClass</td>
<td>得到枚举常量所属类型的Class对象。可以用它来判断两个枚举常量是否属于同一枚举类型</td>
</tr>
<tr>
<td>name</td>
<td>得到当前枚举常量的名称。建议优先使用toString()</td>
</tr>
<tr>
<td>oridinal</td>
<td>得到当前枚举常量的次序</td>
</tr>
<tr>
<td>compareTo</td>
<td>枚举类型实现了Comparable接口，这样可以比较两个枚举常量的大小（按声明的顺序排列）</td>
</tr>
<tr>
<td>clone</td>
<td>枚举类型不能被Clone。为了防止子类实现克隆方法，Enum实现了一个仅抛出CloneNotSupportedException异常的不变Clone()</td>
</tr>
</tbody></table>
<ul>
<li>Enum类的主要方法<ul>
<li>values()返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值</li>
<li>valueOf(String str)可以把一个字符串转化为对应的枚举类对象。要求字符串必须是枚举对象的“名字”。如不是，会有运行时异常：IllegalArgumentException</li>
<li>toStirng()返回当前枚举类对象常量的名称</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 枚举;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeasonEnumTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SeasonEnum seasonEnum = SeasonEnum.AUTUMN;</span><br><span class="line">        System.out.println(seasonEnum);<span class="comment">//返回枚举类对象的名称AUTUMN</span></span><br><span class="line">        System.out.println(<span class="string">&quot;——————————&quot;</span>);</span><br><span class="line">        <span class="comment">//values()返回所有的枚举对象构成的数组</span></span><br><span class="line">        SeasonEnum[] values = SeasonEnum.values();</span><br><span class="line">        <span class="keyword">for</span> (SeasonEnum sea :</span><br><span class="line">                values) &#123;</span><br><span class="line">            System.out.println(sea);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//valueOf(String objName):返回枚举类中对象名时objName的对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;——————————&quot;</span>);</span><br><span class="line">        SeasonEnum winter = SeasonEnum.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line">        System.out.println(winter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">SeasonEnum</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间使用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春意盎然&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏炎酷暑&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋风习习&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冬日黑裘&quot;</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//2.声明Season对象属性：private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.私有化类的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="keyword">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求：获取枚举类对象的属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSeasonDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>AUTUMN<br>——————————<br>SPRING<br>SUMMER<br>AUTUMN<br>WINTER<br>——————————<br>WINTER</p>
</blockquote>
<h5 id="1-5-实现接口的枚举类"><a href="#1-5-实现接口的枚举类" class="headerlink" title="1.5 实现接口的枚举类"></a>1.5 实现接口的枚举类</h5><ul>
<li>和普通Java类一样，枚举类可以实现一个或多个接口</li>
<li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可</li>
<li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 枚举;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumAndInterfaceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumAndInterface1 e1 = EnumAndInterface1.AUTUMN;</span><br><span class="line">        e1.show();</span><br><span class="line">        EnumAndInterface2 e2 = EnumAndInterface2.SPRING;</span><br><span class="line">        e2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumAndInterface1</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line"></span><br><span class="line">    EnumAndInterface1(String seasonName) &#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方式一：直接实现接口的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumAndInterface2</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;方式二：在枚举值里实现该方法，当前枚举值为\&quot;SPRING\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;方式二：在枚举值里实现该方法，当前枚举值为\&quot;SUMMER\&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EnumAndInterface2</span><span class="params">(String seasonName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seasonName = seasonName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方式一：直接实现接口的方法<br>方式二：在枚举值里实现该方法，当前枚举值为”SPRING”</p>
</blockquote>
<h4 id="2-注解的使用"><a href="#2-注解的使用" class="headerlink" title="2.注解的使用"></a>2.注解的使用</h4><ul>
<li>注解(Annotation)概述 </li>
<li>常见的Annotation示例 </li>
<li>自定义Annotation </li>
<li>JDK中的元注解 </li>
<li>利用反射获取注解信息（在反射部分涉及） </li>
<li>JDK 8中注解的新特性</li>
</ul>
<h5 id="2-1-注解-Annotation-概述"><a href="#2-1-注解-Annotation-概述" class="headerlink" title="2.1 注解(Annotation)概述"></a>2.1 注解(Annotation)概述</h5><ul>
<li>从JDK5.0开始，Java增加了对元数据(MetaData)的支持，也就是Annotation(注解)</li>
<li>Annotation其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用Annotation，程序员可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署</li>
<li>Annotation可以像修饰符一样被使用，可以用于修饰包，类，构造器，方法，成员变量，参数，局部变量声明，这些信息被保存在Annotation的”name = value”对中</li>
<li>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等</li>
<li>未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：框架 = 注解 + 反射 + 涉及模式</li>
</ul>
<h5 id="2-2-常见的Annotation示例"><a href="#2-2-常见的Annotation示例" class="headerlink" title="2.2 常见的Annotation示例"></a>2.2 常见的Annotation示例</h5><ul>
<li><p>使用Annotation时要在其前面增加@符号。并把该Annotation当选成一个修饰符使用。用于修饰它支持的程序元素</p>
</li>
<li><p>示例一：生成文档相关的注解</p>
<ul>
<li><p>@autor标明开发该类模块的作者，多个作者之间使用,分割</p>
</li>
<li><p>@version标明开发类的模板</p>
</li>
<li><p>@see参考转向，也就是相关主题</p>
</li>
<li><p>@since从哪个版本开始增加的</p>
</li>
<li><p>@param对方法中某参数的说明，如果没有参数就不能写</p>
</li>
<li><p>@return对方法返回值的说明，如果方法的返回值类型是viod就不能写</p>
</li>
<li><p>@exception对方法可能抛出的异常进行说明，如果方法没有用throws显示抛出的异常就不能写其中</p>
</li>
<li><p>@param @return 和 @exception 这三个标记都是只用于方法的。 @param的格式要求：@param 形参名 形参类型 形参说明 @return 的格式要求：@return 返回值类型 返回值说明 @exception的格式要求：@exception 异常类型 异常说明 @param和@exception可以并列多个</p>
</li>
<li><pre><code class="java">public class JavadocTest &#123;
/**
* 程序的主方法，程序的入口
* @param args String[] 命令行参数
*/
public static void main(String[] args) &#123;
&#125;
/**
* 求圆面积的方法
* @param radius double 半径值
* @return double 圆的面积
*/
public static double getArea(double radius)&#123;
return Math.PI * radius * radius;
&#125;
&#125;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 示例二：在编译时进行格式检查(JDK内置的三个基本注解)</span><br><span class="line"></span><br><span class="line">  * @Override：限定重写父类方法，该注解只能用于方法</span><br><span class="line"></span><br><span class="line">  * @Deprecated：用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</span><br><span class="line"></span><br><span class="line">  * @SuppressWarnings：抑制编译器警告</span><br><span class="line"></span><br><span class="line">  * &#96;&#96;&#96;java</span><br><span class="line">    package com.annotation.javadoc;</span><br><span class="line">    public class AnnotationTest&#123;</span><br><span class="line">    	public static void main(String[] args) &#123;</span><br><span class="line">    		@SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">    		int a &#x3D; 10;</span><br><span class="line">    	&#125;</span><br><span class="line">    	@Deprecated</span><br><span class="line">    	public void print()&#123;</span><br><span class="line">    		System.out.println(&quot;过时的方法&quot;);</span><br><span class="line">    	&#125;</span><br><span class="line">    	@Override</span><br><span class="line">    	public String toString() &#123;</span><br><span class="line">    		return &quot;重写的toString方法()&quot;;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>示例三：跟踪代码依赖性，实现替代配置文件功能</p>
<ul>
<li><p>Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">ServletException, IOException </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">ServletException, IOException </span>&#123;</span><br><span class="line">doGet(request, response);</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">servlet</span>.<span class="title">LoginServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">LoginServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">login</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>spring框架中关于“事务”的管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRES_NEW,</span></span><br><span class="line"><span class="meta">isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyBook</span><span class="params">(String username, String isbn)</span> </span>&#123;</span><br><span class="line"><span class="comment">//1.查询书的单价</span></span><br><span class="line"><span class="keyword">int</span> price = bookShopDao.findBookPriceByIsbn(isbn);</span><br><span class="line"><span class="comment">//2. 更新库存</span></span><br><span class="line">bookShopDao.updateBookStock(isbn);</span><br><span class="line"><span class="comment">//3. 更新用户的余额</span></span><br><span class="line">bookShopDao.updateUserAccount(username, price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!-- 配置事务属性 --&gt;</span><br><span class="line">&lt;tx:advice transaction-manager=<span class="string">&quot;dataSourceTransactionManager&quot;</span> id=<span class="string">&quot;txAdvice&quot;</span>&gt;</span><br><span class="line">&lt;tx:attributes&gt;</span><br><span class="line">&lt;!-- 配置每个方法使用的事务属性 --&gt;</span><br><span class="line">&lt;tx:method name=<span class="string">&quot;buyBook&quot;</span> propagation=<span class="string">&quot;REQUIRES_NEW&quot;</span></span><br><span class="line">isolation=<span class="string">&quot;READ_COMMITTED&quot;</span> read-only=<span class="string">&quot;false&quot;</span> timeout=<span class="string">&quot;3&quot;</span> /&gt;</span><br><span class="line">&lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h5 id="2-3-自定义Annotation"><a href="#2-3-自定义Annotation" class="headerlink" title="2.3 自定义Annotation"></a>2.3 自定义Annotation</h5><ul>
<li>定义新的Annotation类型使用@interface关键字</li>
<li>自定义注解自动继承了java.lang.annotation.Annotation接口</li>
<li>Annotation的成员变量在Annotation定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型：Strign类型、Class类型、enum类型、Annotation类型、以上所有类型的数组</li>
<li>可以在定义Annotationi的成员变量时为其指定初始值，指定成员变量的初始值可以使用default关键字</li>
<li>如果只有一个参数成员，建议使用参数名为value</li>
<li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非他有默认的值。格式是”参数名 = 参数值”，如果只有一个参数成员，且名称为value，可以省略”value=”</li>
<li>没有成员定义的Annotation称为标记；包含成员变量的Annotation称为元数据Annotation</li>
</ul>
<p>注意：自定义注解必须配上注解的信息处理流程才有意义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 注解;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="comment">@Retention(RetentionPolicy.SOURCE)</span></span><br><span class="line"><span class="comment">public @interface SuppressWarnings &#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * The set of warnings that are to be suppressed by the compiler in the</span></span><br><span class="line"><span class="comment">     * annotated element.  Duplicate names are permitted.  The second and</span></span><br><span class="line"><span class="comment">     * successive occurrences of a name are ignored.  The presence of</span></span><br><span class="line"><span class="comment">     * unrecognized warning names is &lt;i&gt;not&lt;/i&gt; an error: Compilers must</span></span><br><span class="line"><span class="comment">     * ignore any warning names they do not recognize.  They are, however,</span></span><br><span class="line"><span class="comment">     * free to emit a warning if an annotation contains an unrecognized</span></span><br><span class="line"><span class="comment">     * warning name.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; The string &#123;@code &quot;unchecked&quot;&#125; is used to suppress</span></span><br><span class="line"><span class="comment">     * unchecked warnings. Compiler vendors should document the</span></span><br><span class="line"><span class="comment">     * additional warning names they support in conjunction with this</span></span><br><span class="line"><span class="comment">     * annotation type. They are encouraged to cooperate to ensure</span></span><br><span class="line"><span class="comment">     * that the same names work across multiple compilers.</span></span><br><span class="line"><span class="comment">     * @return the set of warnings to be suppressed</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    String[] value();</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    参考@SuppressWarnings进行定义</span></span><br><span class="line"><span class="comment">    ①注解声明为：@interface</span></span><br><span class="line"><span class="comment">    ②内部定义成员，通常使用value表示</span></span><br><span class="line"><span class="comment">    ③可以指定成员的默认值，使用default定义</span></span><br><span class="line"><span class="comment">    ④如果自定义注解没有成员，表明是一个标识作用</span></span><br><span class="line"><span class="comment">    如果注解有成员，在使用注解时，需要指明成员的值，自定义注解必须配上注解信息处理流程（使用反射）才有意义</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Annoation的成员变量在Annotation定义中以无参数方法的形式来声明。</span></span><br><span class="line"><span class="comment">    其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型：</span></span><br><span class="line"><span class="comment">    String、Class、enum、Annotation和以上所有类型的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;xiong&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="2-4-JDK中的元注解"><a href="#2-4-JDK中的元注解" class="headerlink" title="2.4 JDK中的元注解"></a>2.4 JDK中的元注解</h5><ul>
<li>JDK的元Annotation用于修饰其他的Annotation定义</li>
<li>JDK5.0提供了4个标准的meta-annotation类型，分别是：<ul>
<li>Retention</li>
<li>Target</li>
<li>Documented</li>
<li>Inherited</li>
</ul>
</li>
<li>@Retention：只能用于修饰一个Annotation定义，用于指定该Annotation的生命周期，@Rention包含一个RetentionPolicy类型的成员变量。使用@Rentention时必须为该value成员变量指定值：<ul>
<li>RetentionPolicy.SOURCE：在源文件中有效(即源文件保留)，编译器直接丢弃这种策略的注释</li>
<li>RetentionPolicy.CLASS：在class文件中有效(即class保留)，当运行Java程序时，JVM不会保留注解。这是默认值</li>
<li>RetentionPolicy.RUNTIME：在运行时有效(即运行时保留)，当运行Java程序时，JVM会保留注解。程序可以通过反射来获取该注解</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210722155839.png" alt="image-20210722155829815"></p>
<ul>
<li><p>@Target：用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素。@Target也包含一个名为value的成员变量</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210722160047.png" alt="image-20210722160046459"></p>
</li>
<li><p>@Documented：用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档。默认情况下，javadoc时不包括注解的</p>
<ul>
<li>定义为Documented的注解必须设置Retention值为RUNTIME</li>
</ul>
</li>
<li><p>@Inherited：被它修饰的Annotation将具有==继承性==。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解</p>
<ul>
<li>比如：如果把标有@Inherited注解的之定义的注解标注在类级别上，子类可以继承父类级别的注解</li>
<li>实际应用中，使用较少</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 注解;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.LOCAL_VARIABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">JDK提供的四种元注解</span></span><br><span class="line"><span class="comment">元注解：对现有的注解进行解释说明的注解</span></span><br><span class="line"><span class="comment">Retention:指定所修饰的Annotation的声明周期。SOURCE/CLASS(默认行为)/RUNTIME</span></span><br><span class="line"><span class="comment">          只有声明为RUNTIME生命周期的注解才能通过反射获取</span></span><br><span class="line"><span class="comment">Target:用于指定被修饰的Annotation能用于修饰哪些程序元素</span></span><br><span class="line"><span class="comment">Documented:表示所修饰的注解被javadoc解析时，保留下来</span></span><br><span class="line"><span class="comment">Inherited:被它所修饰的Annotation将具有继承性</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">通过反射来获得注解信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyMetaAnnotation &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-5-利用反射获取注解信息"><a href="#2-5-利用反射获取注解信息" class="headerlink" title="2.5 利用反射获取注解信息"></a>2.5 利用反射获取注解信息</h5><ul>
<li>JDK5.0在java.lang.reflect包下新增了AnnotatedElement接口，该接口代表程序中可以接收注解的程序元素</li>
<li>当一个Annotation类型被定义为运行时Annotation后，该注解才是运行时可见，当class文件被载入时保存在class文件中的Annotation才会被虚拟机读取</li>
<li>程序可以调用AnnotatedElement对象的如下方法来访问Annotation信息</li>
</ul>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210722172007.png" alt="image-20210722172006524"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 注解;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetAnnotation</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用反射获取Student上的注解，来验证元注解的继承性</span></span><br><span class="line">        Class&lt;Student&gt; studentClass = Student.class;</span><br><span class="line">        Annotation[] annotations = studentClass.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; annotations.length; i++) &#123;</span><br><span class="line">            System.out.println(annotations[i]);<span class="comment">//@注解.MyMetaAnnotation(value=[xiong])</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MyMetaAnnotation(&quot;xiong&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-6-JDK8中注解的新特性"><a href="#2-6-JDK8中注解的新特性" class="headerlink" title="2.6 JDK8中注解的新特性"></a>2.6 JDK8中注解的新特性</h5><p>Java8对注解处理提供了两点改进：可重复的注解及可用于类型的注解。此外反射也得到了加强，在Java8中能够得到方法参数的名称，这会简化标注在方法参数上的注解。</p>
<p><strong>可重复注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 注解;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.LOCAL_VARIABLE;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable(MyMetaAnnotationArrays.class)</span></span><br><span class="line"><span class="comment">//@Inherited</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyMetaAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 注解;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.LOCAL_VARIABLE;</span><br><span class="line"><span class="comment">//@Inherited</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyMetaAnnotationArrays &#123;</span><br><span class="line">   MyMetaAnnotation[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 注解;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetAnnotation1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">        Annotation[] annotations = personClass.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; annotations.length; i++) &#123;</span><br><span class="line">            System.out.println(annotations[i]);</span><br><span class="line">            <span class="comment">//@注解.MyMetaAnnotationArrays(value=[@注解.MyMetaAnnotation(value=xiong), @注解.MyMetaAnnotation(value=zhuo)])</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重复注解：jdk8之前</span></span><br><span class="line"><span class="comment">//创建一个新的自定义注解，包含成员变量MyMetaAnnotation的数组,</span></span><br><span class="line"><span class="comment">//@MyMetaAnnotationArrays(&#123;@MyMetaAnnotation(&quot;hello&quot;),@MyMetaAnnotation(&quot;hello&quot;)&#125;)</span></span><br><span class="line"><span class="comment">//jdk8之后</span></span><br><span class="line"><span class="meta">@MyMetaAnnotation(&quot;xiong&quot;)</span></span><br><span class="line"><span class="meta">@MyMetaAnnotation(&quot;zhuo&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>类型注解</strong></p>
<ul>
<li><p>JDK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个：TYPE_PARAMENTER,TYPE_USE</p>
</li>
<li><p>在Java8之前，注解只能是在声明的地方使用，Java8开始，注解可以应用在任何地方</p>
<ul>
<li><p>ElementType.TYPE_PARAMENTER表示该注解能写在类型变量的声明语句中（如：泛型声明）</p>
</li>
<li><p>ElementType.TYPE_USE表示该注解能写在使用类型的任何语句在中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTypeDefine</span>&lt;@<span class="title">TypeDefine</span>() <span class="title">U</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> U u;</span><br><span class="line"><span class="keyword">public</span> &lt;<span class="meta">@TypeDefine()</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE_PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> TypeDefine&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@MyAnnotation</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AnnotationTest&lt;<span class="meta">@MyAnnotation</span> String&gt; t = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">int</span> a = (<span class="meta">@MyAnnotation</span> <span class="keyword">int</span>) <span class="number">2L</span>;</span><br><span class="line">		<span class="meta">@MyAnnotation</span></span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;<span class="meta">@MyAnnotation</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="meta">@MyAnnotation</span> String arg)</span> <span class="keyword">throws</span> @MyAnnotation Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_USE)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>12-泛型</title>
    <url>/2021/09/17/12%E2%80%94%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="12—泛型"><a href="#12—泛型" class="headerlink" title="12—泛型"></a>12—泛型</h3><p><a href="https://www.cnblogs.com/coprince/p/8603492.html">java 泛型详解</a></p>
<h4 id="1-为什么要有泛型"><a href="#1-为什么要有泛型" class="headerlink" title="1. 为什么要有泛型"></a>1. 为什么要有泛型</h4><h5 id="1-1-泛型-Generic"><a href="#1-1-泛型-Generic" class="headerlink" title="1.1 泛型(Generic)"></a>1.1 泛型(Generic)</h5><ul>
<li><p>泛型：标签</p>
</li>
<li><p>举例：</p>
<ul>
<li>中药店，每个抽屉外面贴着标签</li>
<li>超市购物架上很多瓶子，每个瓶子装的是什么，有标签</li>
</ul>
</li>
<li><p>泛型的设计背景</p>
<p>结合容器在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK5.0之前只能把元素类型设计为Object，JDK1.5之后使用泛型解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection<E>,List<E>,ArrayList<E>这个<E>就是类型参数，即泛型。</p>
</li>
</ul>
<h5 id="1-2-泛型的概念"><a href="#1-2-泛型的概念" class="headerlink" title="1.2 泛型的概念"></a>1.2 泛型的概念</h5><ul>
<li>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值类型及参数类型。这个类型参数将在使用时（例如：继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型参数）</li>
<li>从JDK1.5以后，Java引入了”参数化类型（Parameteized type）“的概念，允许我们在创建集合时再指定集合元素的类型，正如：List<String>，这表明该List只能保存字符串类型的对象</li>
<li>JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参</li>
</ul>
<p><strong>为什么要有泛型呢，直接Object不是也可以存储数据吗？</strong></p>
<ol>
<li><p>解决元素存储的安全性问题，好比商品、药品标签，不会弄错</p>
</li>
<li><p>解决获取元素时，需要类型强制转换的问题，好比不用每次拿商品、药品都要辨别</p>
</li>
<li><p>在集合没有泛型时</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210728175559.png" alt="image-20210728175558063"></p>
</li>
<li><p>在集合有泛型时</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210728175640.png" alt="image-20210728175639031"></p>
</li>
</ol>
<blockquote>
<p>Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁、健壮</p>
</blockquote>
<h5 id="1-3-概述"><a href="#1-3-概述" class="headerlink" title="1.3 概述"></a>1.3 概述</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</span><br><span class="line"></span><br><span class="line">泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</span><br></pre></td></tr></table></figure>

<h5 id="1-4-一个例子"><a href="#1-4-一个例子" class="headerlink" title="1.4 一个例子"></a>1.4 一个例子</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">    Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;item = &quot;</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序崩溃</p>
<blockquote>
<p>java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</p>
</blockquote>
<p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//arrayList.add(100); 在编译阶段，编译器就会报错</span></span><br></pre></td></tr></table></figure>

<h5 id="1-5-特性"><a href="#1-5-特性" class="headerlink" title="1.5 特性"></a>1.5 特性</h5><p>泛型只在编译阶段有效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;类型相同&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>D/泛型测试: 类型相同</p>
</blockquote>
<p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。<strong>也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。</strong>也就是说，泛型信息不会进入到运行时阶段。</p>
<p>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</p>
<h4 id="2-自定义泛型结构"><a href="#2-自定义泛型结构" class="headerlink" title="2. 自定义泛型结构"></a>2. 自定义泛型结构</h4><h5 id="2-1-自定义泛型结构"><a href="#2-1-自定义泛型结构" class="headerlink" title="2.1 自定义泛型结构"></a>2.1 自定义泛型结构</h5><ol>
<li><p>泛型的声明</p>
<p>interface List<T> 和calss GenTest&lt;K,V&gt;，其中，T,K,V不代表值，而是表示类型。这里使用任意字母都可以。常用T表示，是Type的缩写</p>
</li>
<li><p>泛型的实例化</p>
<p>一定要在类名后面指定类型参数的值（类型）。如：</p>
<p>List<String> strList = new ArrayList<Sting>();</p>
<p>Iterator<Customer> iterator = customers.iterator();</p>
<ul>
<li>T只能是类，不能用基本数据类型填充。但可以使用包装类填充</li>
<li>把一个集合中的内容限制为一个特定的数据类型，这就是generics背后的核心思想</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210729212123.png" alt="image-20210729212121077"></li>
</ul>
</li>
</ol>
<h5 id="2-2-泛型类、泛型接口"><a href="#2-2-泛型类、泛型接口" class="headerlink" title="2.2 泛型类、泛型接口"></a>2.2 泛型类、泛型接口</h5><ol>
<li><p>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</p>
</li>
<li><p>泛型类的构造器如下：public GenericClass(){}</p>
<p>而下面是错误的：public GenericClass<E>(){}</p>
</li>
<li><p>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致</p>
</li>
<li><p>泛型不同的引用不能相互赋值</p>
<p>尽管在编译时ArrayList<String>和ArrayList<Integer>是两种类型，但是，在运行时只有一个ArrayList被加载到JVM</p>
</li>
<li><p>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，且不等价于Object。经验：泛型要使用一路都用。要不用，一路都不要用</p>
</li>
<li><p>如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象</p>
</li>
<li><p>JDK1.7，泛型的简化操作：ArrayList<Fruit> firt = new ArrayList&lt;&gt;();</p>
</li>
<li><p>泛型的指定中不能使用基本数据类型，可以使用包装类替换</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1、使用时：类似于Object，不等同于Object</span></span><br><span class="line">		ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="comment">// list.add(new Date());//有风险</span></span><br><span class="line">		list.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">		test(list);<span class="comment">// 泛型擦除，编译不会类型检查</span></span><br><span class="line">		<span class="comment">// ArrayList&lt;Object&gt; list2 = new ArrayList&lt;Object&gt;();</span></span><br><span class="line">		<span class="comment">// test(list2);//一旦指定Object，编译会类型检查，必须按照Object处理</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">		String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">			str += s + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;元素:&quot;</span> + str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态 属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法 中不能使用类的泛型。</p>
</li>
<li><p>异常类不能是泛型的</p>
</li>
<li><p>不能使用new E[]。但是可以：E[] elements = (E[])new Object[capacity]; 参考：ArrayList源码中声明：Object[] elementData，而非泛型参数类型数组。</p>
</li>
<li><p>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：</p>
<ul>
<li>子类不保留父类的泛型：按需实现<ul>
<li>没有类型 擦除</li>
<li>具体类型</li>
</ul>
</li>
<li>子类保留父类的泛型：泛型子类<ul>
<li>全部保留</li>
<li>部分保留</li>
</ul>
</li>
</ul>
<p>结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自 己的泛型</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line">	<span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son1</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;<span class="comment">// 等价于class Son extends 				Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="comment">// 2)具体类型</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Son2</span> <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 子类保留父类的泛型</span></span><br><span class="line">	<span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类不保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)没有类型 擦除</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;<span class="comment">//等价于class Son extends Father&lt;Object,Object&gt;&#123;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)具体类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span>&lt;<span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类保留父类的泛型</span></span><br><span class="line"><span class="comment">// 1)全部保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son3</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>, <span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2)部分保留</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son4</span>&lt;<span class="title">T2</span>, <span class="title">A</span>, <span class="title">B</span>&gt; <span class="keyword">extends</span> <span class="title">Father</span>&lt;<span class="title">Integer</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">// 使用T类型定义变量</span></span><br><span class="line"><span class="keyword">private</span> T info;</span><br><span class="line"><span class="comment">// 使用T类型定义一般方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(T info)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.info = info;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用T类型定义构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(T info)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.info = info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型 方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。</p>
</li>
<li><p>泛型方法的格式：</p>
<p>[访问权限] &lt;泛型&gt; 返回类型 方法名([泛型标识 参数名称]) 抛出的异常</p>
</li>
<li><p>泛型方法声明泛型时也可以指定上限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DAO</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> id, E e)</span> </span>&#123;</span><br><span class="line">E result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">fromArrayToCollection</span><span class="params">(T[] a, Collection&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (T o : a) &#123;</span><br><span class="line">c.add(o);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Object[] ao = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">Collection&lt;Object&gt; co = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">fromArrayToCollection(ao, co);</span><br><span class="line">String[] sa = <span class="keyword">new</span> String[<span class="number">20</span>];</span><br><span class="line">Collection&lt;String&gt; cs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">fromArrayToCollection(sa, cs);</span><br><span class="line">Collection&lt;Double&gt; cd = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 下面代码中T是Double类，但sa是String类型，编译错误。</span></span><br><span class="line"><span class="comment">// fromArrayToCollection(sa, cd);</span></span><br><span class="line"><span class="comment">// 下面代码中T是Object类型，sa是String类型，可以赋值成功。</span></span><br><span class="line">fromArrayToCollection(sa, co);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Creature</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Person&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">System.out.println(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">test(<span class="keyword">new</span> Person());</span><br><span class="line">test(<span class="keyword">new</span> Man());</span><br><span class="line"><span class="comment">//The method test(T) in the type PersonTest is not </span></span><br><span class="line"><span class="comment">//applicable for the arguments (Creature)</span></span><br><span class="line">test(<span class="keyword">new</span> Creature());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="3-泛型的使用"><a href="#3-泛型的使用" class="headerlink" title="3. 泛型的使用"></a>3. 泛型的使用</h4><h5 id="3-1-泛型在集合中的使用"><a href="#3-1-泛型在集合中的使用" class="headerlink" title="3.1 泛型在集合中的使用"></a>3.1 泛型在集合中的使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 集合中使用泛型;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在集合中使用泛型：以ArrayList为例</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//自动类型推断</span></span><br><span class="line">        arrayList.add(<span class="number">123</span>);</span><br><span class="line">        arrayList.add(<span class="number">456</span>);</span><br><span class="line">        arrayList.add(<span class="number">789</span>);</span><br><span class="line">        <span class="comment">//遍历方式一</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i:</span><br><span class="line">             arrayList) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历方式二</span></span><br><span class="line">        Iterator&lt;Integer&gt; iterator = arrayList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            <span class="keyword">int</span> num = iterator.next();</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在集合中使用泛型：以Map为例</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;xiong&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        map.put(<span class="string">&quot;zhuo&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        map.put(<span class="string">&quot;guet&quot;</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; set = map.entrySet();</span><br><span class="line">        Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Map.Entry&lt;String,Integer&gt; entry = iterator.next();</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            Integer value = entry.getValue();</span><br><span class="line">            System.out.println(key + <span class="string">&quot;---&gt;&quot;</span> + value);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            zhuo---&gt;21</span></span><br><span class="line"><span class="comment">            xiong---&gt;23</span></span><br><span class="line"><span class="comment">            guet---&gt;25</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-2-泛型类"><a href="#3-2-泛型类" class="headerlink" title="3.2 泛型类"></a>3.2 泛型类</h5><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。泛型类定义的泛型，在整个类中有效。如果被方法使用，那么泛型类的对象明确要操作的具体类型后，所有要操作的类型就已经固定了。为了让不同的方法可以操作不同类型，而且类型还不确定。那么可以将泛型定义在方法上。</p>
<p><strong>泛型类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show: &quot;</span>+t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show: &quot;</span>+t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericDemo4</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Demo&lt;Integer&gt;d = <span class="keyword">new</span> Demo&lt;Integer&gt;();</span><br><span class="line">        d.show(<span class="keyword">new</span> Integer(<span class="number">4</span>));</span><br><span class="line">        Demo&lt;String&gt;d1 = <span class="keyword">new</span> Demo&lt;String&gt;();</span><br><span class="line">        d1.print(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>show: 4<br>show: haha</p>
</blockquote>
<h5 id="3-3-泛型方法"><a href="#3-3-泛型方法" class="headerlink" title="3.3 泛型方法"></a>3.3 泛型方法</h5><p>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show: &quot;</span>+t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;Q&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Q q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;print:&quot;</span>+q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericDemo4</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line">        d.show(<span class="string">&quot;hello boy!&quot;</span>);</span><br><span class="line">        d.print(<span class="string">&quot;Alex i love you !&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>show: hello boy!<br>print:Alex i love you !</p>
</blockquote>
<p><strong>同时定义泛型类和泛型方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show: &quot;</span>+t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;Q&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Q q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;print:&quot;</span>+q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericDemo4</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Demo &lt;String&gt; d = <span class="keyword">new</span> Demo&lt;String&gt;();</span><br><span class="line">        d.show(<span class="string">&quot;hello boy!&quot;</span>);</span><br><span class="line">        d.print(<span class="string">&quot;Alex i love you !&quot;</span>);</span><br><span class="line">        d.print(<span class="number">5</span>);</span><br><span class="line">        d.print(<span class="string">&quot;heiei&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>show: hello boy!<br>print:Alex i love you !<br>print:5<br>print:heiei</p>
</blockquote>
<p>特殊之处：<br>静态方法不可以访问类上定义的泛型<br>如果静态方法操作的应用数据类型不确定，可以将泛型定义在方法上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show: &quot;</span>+t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;Q&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Q q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;print:&quot;</span>+q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;W&gt;<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">(W t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;method: &quot;</span>+t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericDemo4</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Demo &lt;String&gt; d = <span class="keyword">new</span> Demo&lt;String&gt;();</span><br><span class="line">        d.show(<span class="string">&quot;hello boy!&quot;</span>);</span><br><span class="line">        d.print(<span class="string">&quot;Alex i love you !&quot;</span>);</span><br><span class="line"></span><br><span class="line">        d.print(<span class="number">5</span>);</span><br><span class="line">        d.print(<span class="string">&quot;heiei&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Demo.method(<span class="string">&quot;hihi&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>show: hello boy!<br>print:Alex i love you !<br>print:5<br>print:heiei<br>method: hihi</p>
</blockquote>
<h5 id="3-4-泛型定义在接口上"><a href="#3-4-泛型定义在接口上" class="headerlink" title="3.4 泛型定义在接口上"></a>3.4 泛型定义在接口上</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterImpl</span> <span class="keyword">implements</span> <span class="title">Inter</span>&lt;<span class="title">String</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show :&quot;</span>+t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*第二种</span></span><br><span class="line"><span class="comment">class InterImpl&lt;T&gt;implements Inter&lt;T&gt;</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    public void show(T t)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;show :&quot;+t);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericDemo5</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*  </span></span><br><span class="line"><span class="comment">        InterImpl&lt;Integer&gt; i = new InterImpl&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">        i.show(4);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        InterImpl i = <span class="keyword">new</span> InterImpl();</span><br><span class="line">        i.show(<span class="string">&quot;haha&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>show :haha</p>
</blockquote>
<p><strong>静态泛型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//普通转换</span></span><br><span class="line">        ArrayList&lt;String&gt; result1 = (ArrayList&lt;String&gt;) list;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//静态泛型转换</span></span><br><span class="line">        String result2 = convert(list);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">convert</span><span class="params">(Object a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上述代码是 编译通过，运行异常，为什么会出现这种现象呢？这是因为Java的泛型方法属于伪泛型，在编译的时候将进行类型擦除。普通的泛型方法在类构建时已经明确制定了对应的类型，而在静态泛型方法中，类型是无法直接推测的，缺少了明确的类型，最终造成类型转化异常。</p>
<p>convert函数最终转化后对应的字节码为 Method convert:(Ljava/lang/Object;)Ljava/lang/Object; 参数为Object类型，返回也为Object类型，而在接下来的 checkcast 操作中，由于 List 和 String 类型的不同，所以抛出了异常。</p>
</blockquote>
<p><strong>静态泛型相关问题</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	E name;</span><br><span class="line">	<span class="comment">//编译通过</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show1</span><span class="params">(T[] arr)</span></span>&#123;</span><br><span class="line">		System.out.println(arr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//编译不通过</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">(E[]arr)</span></span>&#123;</span><br><span class="line">		System.out.println(arr);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态关键字修饰的是静态方法，然后我们给他加了泛型，至于为什么静态关键字可以修饰泛型方法，这就是Java的规定。</p>
<p><strong>为什么第一个能编译通过，第二个不通过？</strong></p>
<p>首先是静态方法都是通过 <strong>类名</strong> 来调用。前面的泛型T是声明了一个泛型，在这里可以通过extends等对泛型具体类型进行一个限定。T的具体类型由使用show1传入具体参数类型为准。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编译通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show1</span><span class="params">(T[] arr)</span></span>&#123;</span><br><span class="line">   System.out.println(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类泛型是在 <strong>创建对象</strong> 的时候才指定，静态方法是 <strong>通过类名</strong> 直接调用，当使用类名来调用show2方法时，引发Father类的初始化，静态变量/方法的声明是在类的初始化之前的，所以<strong>静态属性不能使用类泛型</strong></p>
<p>第二个方法改成非静态方法就编译通过了，因为成员方法需要通过new对象来调用.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">(E[]arr)</span></span>&#123;</span><br><span class="line">  System.out.println(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father&lt;String&gt; info = <span class="keyword">new</span> Father&lt;&gt;();</span><br><span class="line">String[] str = &#123;&#125;;</span><br><span class="line">info.show2(str);</span><br></pre></td></tr></table></figure>

<h5 id="3-5-泛型数组"><a href="#3-5-泛型数组" class="headerlink" title="3.5 泛型数组"></a>3.5 泛型数组</h5><p>查看sun的说明文档，在java中是”不能创建一个确切的泛型类型的数组”的。也就是说下面的这个例子是不可以的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>];  </span><br></pre></td></tr></table></figure>

<p>而使用通配符创建泛型数组是可以的，如下面这个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;?&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>这样也是可以的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>

<p>下面使用<a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html">Sun</a><a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html">的一篇文档</a>的一个例子来说明这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.    </span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check    </span></span><br><span class="line">String s = lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error: ClassCastException.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</span><br></pre></td></tr></table></figure>

<p>下面采用通配符的方式是被允许的:数组的类型不可以是类型变量，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> List&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.    </span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct.    </span></span><br><span class="line">Integer i = (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>



<h4 id="4-泛型在继承上的体现"><a href="#4-泛型在继承上的体现" class="headerlink" title="4. 泛型在继承上的体现"></a>4. 泛型在继承上的体现</h4><p>如果B是A的一个子类型（子类或者子接口），而G是具有泛型声明的 类或接口，G<strong>并不是G的子类型！ 比如：String是Object的子类，但是List并不是List 的子类。</strong></p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210729213719.png" alt="image-20210729213718040"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 泛型在继承中的体现;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.AbstractList;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    泛型在继承方面的体现</span></span><br><span class="line"><span class="comment">    虽然类A是类B的父类，但是G&lt;A&gt;和G&lt;B&gt;二者不具备父子关系，二者是并列关系</span></span><br><span class="line"><span class="comment">    补充：类A是类B的父类，A&lt;G&gt;是B&lt;G&gt;的父类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        obj = str;</span><br><span class="line"></span><br><span class="line">        Object[] arr1 = <span class="keyword">null</span>;</span><br><span class="line">        String[] arr2 = <span class="keyword">null</span>;</span><br><span class="line">        arr1 = arr2;</span><br><span class="line"></span><br><span class="line">        List&lt;Object&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//此时的list1与list2不具有子父类关系，编译不通过</span></span><br><span class="line">        <span class="comment">//list1 = list2;</span></span><br><span class="line"></span><br><span class="line">        AbstractList&lt;String&gt; list3 = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;String&gt; list4 = <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;String&gt; list5 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        list3 = list5;</span><br><span class="line">        list4 = list5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-通配符的使用"><a href="#5-通配符的使用" class="headerlink" title="5. 通配符的使用"></a>5. 通配符的使用</h4><p>1.使用类型通配符：？ 比如：List<?> ，Map<?,?></p>
<p> List&lt;?&gt;是List<Srting>、List<Object>等各种泛型List的父类。 </p>
<p>2.读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为不管list的真实类型 是什么，它包含的都是Object。 </p>
<p>3.写入list中的元素时，不行。因为我们不知道c的元素类型，我们不能向其中添加对象。 </p>
<p> 唯一的例外是null，它是所有类型的成员。</p>
<ul>
<li><p>将任意元素加入到其中不是类型安全的： </p>
<p>Collection&lt;?&gt; c = new ArrayList();</p>
<p>c.add(new Object()); // 编译时错误</p>
<p>因为我们不知道c的元素类型，我们不能向其中添加对象。add方法有类型参数E作为集 合的元素类型。我们传给add的任何参数都必须是一个未知类型的子类。因为我们不知 道那是什么类型，所以我们无法传任何东西进去。</p>
</li>
<li><p>唯一的例外的是null，它是所有类型的成员。</p>
</li>
<li><p>另一方面，我们可以调用get()方法并使用其返回值。返回值是一个未知的类型，但是我们知道，它总是一个Object。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 通配符的使用;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    通配符的使用</span></span><br><span class="line"><span class="comment">    通配符：?</span></span><br><span class="line"><span class="comment">    类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;是没有关系的，二者的共同父类是：G&lt;?&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Object&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;String&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;?&gt; list = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        list = list1;</span><br><span class="line">        list = list2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list3.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        list3.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">        list3.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">        list = list3;</span><br><span class="line">        <span class="comment">//添加（写入）：对于List&lt;?&gt;就不能向其内部添加数据</span></span><br><span class="line">        <span class="comment">//除了添加null外</span></span><br><span class="line">        <span class="comment">//list.add(&quot;DD&quot;);</span></span><br><span class="line">        list.add(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//获取（读取）：允许读取数据，读取的数据类型为Object</span></span><br><span class="line">        Object o = list.get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(o);</span><br><span class="line"></span><br><span class="line">        print(list);<span class="comment">//AA BB CC null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">        Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    有限制条件的通配符的使用：</span></span><br><span class="line"><span class="comment">        ? extends A: (-∞,A]</span></span><br><span class="line"><span class="comment">            G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类。其中B是A的子类</span></span><br><span class="line"><span class="comment">        ? super A：[A,+∞)</span></span><br><span class="line"><span class="comment">            G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类。其中B是A的父类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;? extends Person&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">        List&lt;? <span class="keyword">super</span> Person&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Studen&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Person&gt; list4 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Object&gt; list5 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list1 = list3;</span><br><span class="line">        list1 = list4;</span><br><span class="line">        <span class="comment">//list1 = list5; //Object并非Person的子类</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//list2 =list3; //Student并非Person的父类</span></span><br><span class="line">        list2 = list4;</span><br><span class="line">        list2 = list5;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        list1 = list3;</span><br><span class="line">        Person p1 = list1.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        <span class="comment">//Student s1 = list1.get(0);</span></span><br><span class="line">        Studen s1 = (Studen) list1.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        list1 = list4;</span><br><span class="line">        Person p2 = list1.get(<span class="number">0</span>);</span><br><span class="line">        Studen s2 = (Studen) list1.get(<span class="number">0</span>);<span class="comment">//类型强转后可以通过编译，但是运行时会出错，</span></span><br><span class="line"></span><br><span class="line">        list2 = list4;</span><br><span class="line">        Object obj = list2.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//编译不通过</span></span><br><span class="line">        <span class="comment">//Person p3 = list2.get(0);</span></span><br><span class="line">        Person p3 = (Person) list2.get(<span class="number">0</span>);<span class="comment">//类型强转之后可以通过编译</span></span><br><span class="line"></span><br><span class="line">        list2 = list5;</span><br><span class="line">        Object obj1 = list2.get(<span class="number">0</span>);</span><br><span class="line">        Person p4 = (Person) list2.get(<span class="number">0</span>);<span class="comment">//类型强转后可以通过编译，但是运行时会出错，</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Studen</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;?&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(ArrayList&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意点2：编译错误：不能用在泛型类的声明上</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericTypeClass</span>&lt;?&gt;</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象</span></span><br><span class="line">ArrayList&lt;?&gt; list2 = <span class="keyword">new</span> ArrayList&lt;?&gt;();</span><br></pre></td></tr></table></figure>

<p><strong>有限的通配符</strong></p>
<ul>
<li><?> 允许所有泛型的引用调用
</li>
<li><p>通配符指定上限</p>
<p>上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;= </p>
</li>
<li><p>通配符指定下限</p>
<p>下限super：使用时指定的类型不能小于操作的类，即&gt;=</p>
</li>
<li><p>举例： </p>
<ul>
<li><? extends Number> (无穷小 , Number] 只允许泛型为Number及Number子类的引用调用 </li>
<li><? super Number> [Number , 无穷大) 只允许泛型为Number及Number父类的引用调用</li>
<li><? extends Comparable>  只允许泛型为实现Comparable接口的实现类的引用调用

</li>
</ul>
</li>
</ul>
<h4 id="6-泛型应用实例"><a href="#6-泛型应用实例" class="headerlink" title="6. 泛型应用实例"></a>6. 泛型应用实例</h4><h5 id="6-1-泛型嵌套"><a href="#6-1-泛型嵌套" class="headerlink" title="6.1 泛型嵌套"></a>6.1 泛型嵌套</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String, ArrayList&lt;Citizen&gt;&gt;();</span><br><span class="line">	ArrayList&lt;Citizen&gt; list = <span class="keyword">new</span> ArrayList&lt;Citizen&gt;();</span><br><span class="line">	list.add(<span class="keyword">new</span> Citizen(<span class="string">&quot;刘恺威&quot;</span>));</span><br><span class="line">	list.add(<span class="keyword">new</span> Citizen(<span class="string">&quot;杨幂&quot;</span>));</span><br><span class="line">	list.add(<span class="keyword">new</span> Citizen(<span class="string">&quot;小糯米&quot;</span>));</span><br><span class="line">	map.put(<span class="string">&quot;刘恺威&quot;</span>, list);</span><br><span class="line">	Set&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">	Iterator&lt;Entry&lt;String, ArrayList&lt;Citizen&gt;&gt;&gt; iterator = entrySet.iterator();</span><br><span class="line">	<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">		Entry&lt;String, ArrayList&lt;Citizen&gt;&gt; entry = iterator.next();</span><br><span class="line">		String key = entry.getKey();</span><br><span class="line">		ArrayList&lt;Citizen&gt; value = entry.getValue();</span><br><span class="line">		System.out.println(<span class="string">&quot;户主：&quot;</span> + key);</span><br><span class="line">		System.out.println(<span class="string">&quot;家庭成员：&quot;</span> + value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 自定义泛型结构;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFruit</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fruit fruit = <span class="keyword">new</span> Fruit();</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        Generic&lt;Fruit&gt; generic =  <span class="keyword">new</span> Generic&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        generic.show1(fruit);<span class="comment">//Fruit&#123;&#125;</span></span><br><span class="line">        generic.show1(apple);<span class="comment">//Apple&#123;&#125;</span></span><br><span class="line">        <span class="comment">//generic.show1(person);//</span></span><br><span class="line"></span><br><span class="line">        generic.show2(fruit);<span class="comment">//Fruit&#123;&#125;</span></span><br><span class="line">        generic.show2(apple);<span class="comment">//Apple&#123;&#125;</span></span><br><span class="line">        generic.show2(person);<span class="comment">//Person&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">        generic.show3(fruit);<span class="comment">//Fruit&#123;&#125;</span></span><br><span class="line">        generic.show3(apple);<span class="comment">//Apple&#123;&#125;</span></span><br><span class="line">        generic.show3(person);<span class="comment">//Person&#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Fruit&#123;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Apple&#123;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">    <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show2</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show3</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        System.out.println(t.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>14-网络编程</title>
    <url>/2021/09/17/14%E2%80%94%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="14—网络编程"><a href="#14—网络编程" class="headerlink" title="14—网络编程"></a>14—网络编程</h3><h4 id="1-网络编程概述"><a href="#1-网络编程概述" class="headerlink" title="1. 网络编程概述"></a>1. 网络编程概述</h4><ul>
<li>Java是Internet上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络程序应用</li>
<li>Java提供的网络类库。可以实现无痛的网络连接，联网的底层细节被隐藏在Java的本机安装系统里，由JVM进行控制。并且Java实现了一个跨平台的网络库，程序员面对的是一个同一的网络编程环境</li>
<li>网络编程的目的：直接或间接地通过网络协议与其他计算机实现数据交换，进行通讯</li>
<li>网络编程中有两个主要的问题：<ul>
<li>如何准确地定位网络上一台或多台主机；定位主机上的特定应用</li>
<li>找到主机后如何可靠高效地进行数据传输</li>
</ul>
</li>
</ul>
<h4 id="2-网络通信要素概括"><a href="#2-网络通信要素概括" class="headerlink" title="2. 网络通信要素概括"></a>2. 网络通信要素概括</h4><h5 id="2-1-如何实现网络中地主机相互通信"><a href="#2-1-如何实现网络中地主机相互通信" class="headerlink" title="2.1 如何实现网络中地主机相互通信"></a>2.1 如何实现网络中地主机相互通信</h5><ul>
<li>通信双方地址<ul>
<li>IP</li>
<li>端口号</li>
</ul>
</li>
<li>一定的规则（即：网络通信协议。有两套参考模型）<ul>
<li>OSI参考模型：模型过于理想化，未能在英特网上进行广泛推广</li>
<li>TCP/IP参考模型（或TCP/IP协议）：事实上的国际标准</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210801113613.png" alt="image-20210801113602577"></p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210801113651.png" alt="image-20210801113649784"></p>
<h4 id="3-通信要素1：IP和端口号"><a href="#3-通信要素1：IP和端口号" class="headerlink" title="3. 通信要素1：IP和端口号"></a>3. 通信要素1：IP和端口号</h4><h5 id="3-1-IP地址：InetAddress"><a href="#3-1-IP地址：InetAddress" class="headerlink" title="3.1 IP地址：InetAddress"></a>3.1 IP地址：InetAddress</h5><ul>
<li><p>唯一的标识Internet上的计算机（通信实体）</p>
</li>
<li><p>本地回环地址（hostAddress）：127.0.0.1 主机名（hostName）：localhost</p>
</li>
<li><p>IP地址分类方式1：IPV4 和 IPV6</p>
<ul>
<li>IPV4：4个字节组成，4个0-255。大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。以点分十进制表示，如192.168.0.1</li>
<li>IPV6：128位（16个字节），写成8个无符号整数，每个整数用四个十六进制位表示， 数之间用冒号（：）分开，如：3ffe:3201:1401:1280:c8ff:fe4d:db39:1984</li>
</ul>
</li>
<li><p>IP地址分类方式2：公网地址（万维网使用）和私有地址（局域网使用）。192.168. 开头的就是私有址址，范围即为192.168.0.0–192.168.255.255，专门为组织机构内部使用</p>
</li>
<li><p>端口号标识正在计算机上运行的进程（程序）</p>
<ul>
<li>不同的进程有不同的端口号</li>
<li>被规定为一个16位的整数0-65535</li>
<li>端口分类：<ul>
<li>公认端口：0-1023。被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，TeInet占用端口23）</li>
<li>注册端口：1024-49151分配给用户进程或应用程序。（如：Tomcat占用端口8080，MySQL占用端口3360，Oracle占用端口1521等）</li>
<li>动态/私有端口：49152-65535</li>
</ul>
</li>
</ul>
</li>
<li><p>端口号与IP地址的组合得出一个网络套接字：Socket</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210801121803.png" alt="image-20210801121801521"></p>
</li>
</ul>
<h5 id="3-2-InetAddress类"><a href="#3-2-InetAddress类" class="headerlink" title="3.2 InetAddress类"></a>3.2 InetAddress类</h5><ul>
<li>Internet上的主机有两种方式表示地址：<ul>
<li>域名（hostName)：<a href="http://www.baidu.com/">www.baidu.com</a></li>
<li>IP地址（hostAddress）：202.108.22.5</li>
</ul>
</li>
<li>InetAddress类主要表示IP地址，两个子类：Inet4Address、Inet6Address</li>
<li>InetAddress类对象主要含有一个Internet主机地址的域名和IP地址：<a href="http://www.baidu.com和202.108.22.5/">www.baidu.com和202.108.22.5</a></li>
<li>域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化为IP地址，这样才能和主机建立连接——域名解析</li>
<li>先找本机的hosts，是否有输入的域名地址，没有的话，再通过DNS服务器，找主机</li>
<li>InetAddress类没有提供公共的构造器，而是提供如下几个静态方法来获取InetAddress实例<ul>
<li>public static InetAddress getLocalHost()</li>
<li>public static InetAddress getByName(String host)</li>
</ul>
</li>
<li>InetAddress提供了如下几个常用的方法<ul>
<li>public String getHostAddress()：返回IP地址字符串（以文本表现形式）</li>
<li>public String getHostName()：获取此IP地址的主机名</li>
<li>public boolean isReachable(int timeout)：测试是否可以达到该地址</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InteAddress address_1 = InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">System.out.println(address_1);</span><br><span class="line"><span class="comment">//获取InetAddress对象所含的域名</span></span><br><span class="line">System.out.println(address_1.getHostName());</span><br><span class="line"><span class="comment">//获取InetAddress对象所包含的IP地址</span></span><br><span class="line">System.out.println(address_1.getHostAddress());</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取本机的域名和IP地址</span></span><br><span class="line">InetAddress address_2 = InetAddress.getLocalHost();</span><br><span class="line">System.out.println(address_2);</span><br></pre></td></tr></table></figure>

<h4 id="4-通信要素2：网络协议"><a href="#4-通信要素2：网络协议" class="headerlink" title="4. 通信要素2：网络协议"></a>4. 通信要素2：网络协议</h4><ul>
<li><p>网络通信协议</p>
<p>计算机网络中实现通信必须要有一些约定，即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等指定标准</p>
</li>
<li><p>问题：网路协议太复杂</p>
<p>计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量控制，路由控制，如何实现复杂的网络协议呢？</p>
</li>
<li><p>通信协议分层思想</p>
<p>在制定协议是，把复杂成分分解成一些简单的成分，再将它们复合起来。最常用的复合方式时层次方式，即同层间可以互相通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展</p>
</li>
</ul>
<h5 id="4-1-TCP-IP协议簇"><a href="#4-1-TCP-IP协议簇" class="headerlink" title="4.1 TCP/IP协议簇"></a>4.1 TCP/IP协议簇</h5><ul>
<li>传输层协议中有两个非常重要的协议：<ul>
<li>传输控制协议TCP(Transmission Control Protocol)</li>
<li>用户数据报协议UDP(User Datagram Protocol)</li>
</ul>
</li>
<li>TCP/IP以其两个主要协议：传输控制协议(TCP)和互联网协议(IP)而得名，实际上是一组协议，包括多个具有不同功能且互为关联的协议</li>
<li>IP(Internet Protocol)协议是从网络层的主要协议，支持网间互连的数据通信。</li>
<li>TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理链路层、IP层、传输层和应用层</li>
</ul>
<h5 id="4-2-TCP和UDP"><a href="#4-2-TCP和UDP" class="headerlink" title="4.2 TCP和UDP"></a>4.2 TCP和UDP</h5><ul>
<li>TCP协议<ul>
<li>使用TCP协议前，须先建立TCP连接，形成数据传输通道</li>
<li>传输前，采用”三次握手“方式，点对点通信，是可靠的</li>
<li>TCP协议进程通信的两个应用进程：客户端、服务端</li>
<li>再连接中可进行大量数据的传输</li>
<li>传输完毕，需释放已经建立的连接，效率低</li>
</ul>
</li>
<li>UDP协议<ul>
<li>将数据、源、目的封装成数据包，不需要进行连接</li>
<li>每个数据报的大小限制在64K内</li>
<li>发送方不管对方是否准备好，接收方收到也不确认，故是不可靠的</li>
<li>可以广播发送</li>
<li>发送数据结束时无需释放资源，开销小，速度快</li>
</ul>
</li>
</ul>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210801131634.png" alt="image-20210801131632738" style="zoom:50%;" />

<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210801131716.png" alt="image-20210801131714952" style="zoom:50%;" />

<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210801133525.webp" alt="img" style="zoom:50%;" />

<h5 id="4-3-Socket"><a href="#4-3-Socket" class="headerlink" title="4.3 Socket"></a>4.3 Socket</h5><ul>
<li>利用套接字（Socket）开发网络应用程序早已被广泛的采用，以至于成为事实上的标准</li>
<li>网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字</li>
<li>通信的两端都要有Socket，是两台机器间通信的端点</li>
<li>网络通信其实就是Socket间的通信</li>
<li>Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输</li>
<li>一般主动发起通信的应用程序属于客户端，等待通信请求的为服务端</li>
<li>Socket分类：<ul>
<li>流套接字（stream socket)：使用TCP提供可依赖的字节流服务</li>
<li>数据报套接字（datagram socket)：使用UDP提供”尽力而为”的数据报服务</li>
</ul>
</li>
<li>Socket类常用的构造器：<ul>
<li>public Socket(InetAddress address, int port)创建一个流套接字，并将其连接到指定IP地址的指定端口号</li>
<li>public Socket（String host, int port）创建一个流套接字并将其连接到指定端口号</li>
</ul>
</li>
<li>Socket类的常用方法：<ul>
<li>public InputStream getInputStream()返回此套接字的输入流。可以用于接收网络消息</li>
<li>public OutputStream getOutputStream()返回此套接字的输出流。可以用于发哦那个网络消息</li>
<li>public InetAddress getInetAddress()此套接字连接到远程的IP地址；如果套接字是未连接的，则返回null</li>
<li>public InetAddress getLocalAddress()获取套接字绑定的本地地址。即本端的IP地址</li>
<li>public int getPort()此套接字连接到的远程端口号；如果尚未连接套接字，则返回0</li>
<li>public int getLocalPort()返回此套接字绑定到的本地端口号。如果尚未绑定套接字，则返回-1</li>
<li>public void close()关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定）。需要创建新的套接字对象。关闭此套接字也会关闭该套接字的InputStream和OutputStream</li>
<li>public void shutdownInput()如果在套接字上调用shutdownInput()后从套接字输入流读取内容，则流将返回EOF（文件结束符）。即不能再从此套接字的输入流中接收任何数</li>
<li>public void shutdownOutput()禁用此套接字的输入流。对于TCP套接字，任何以前写入的数据都将被发送，并且后跟TCP的正常中止序列。如果在套接字上调用shutdownOutput()后写入套接字输出流，则该流将抛出IOException。即不能通过此套接字的输出流发送任何数据</li>
</ul>
</li>
</ul>
<h4 id="5-TCP网络编程"><a href="#5-TCP网络编程" class="headerlink" title="5. TCP网络编程"></a>5. TCP网络编程</h4><h5 id="5-1-基于Socket的TCP编程"><a href="#5-1-基于Socket的TCP编程" class="headerlink" title="5.1 基于Socket的TCP编程"></a>5.1 基于Socket的TCP编程</h5><ul>
<li><p>Java语言的基于套接字编程分为服务点编程和客户端编程，其通信模型如图所示</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210801140720.png" alt="image-20210801140718934"></p>
</li>
</ul>
<p><strong>客户端Socket的工作过程包含以下四个基本步骤</strong></p>
<ul>
<li><p>创建Socket：根据指定服务端口的IP地址或端口号构造Socket类对象。若服务器端口响应，则建立客户端到服务器的通信线路。若连接失败会出现异常</p>
</li>
<li><p>打开连接到Socket的输入/输出流：使用getInputStram()方法获得输入流，使用getOutputStream()方法获得输出流，进行数据传输</p>
</li>
<li><p>按照一定的协议对Socket进行读/写操作：通过输入流读取服务器放入线路的信息（但不能读取自己的放入线路的信息）。通过输出流将信息写入线程</p>
</li>
<li><p>关闭Socket：断开客户端到服务器的连接，释放线路</p>
</li>
<li><p>客户端创建Socket对象</p>
<ul>
<li><p>客户端程序可以使用Socket类创建对象，创建的同时会自动向服务器发起连接。Socket的构造器是：</p>
<ul>
<li>Socket(String host, int port)throws UnkonwnHostException,IOException：向服务器（域名是host。端口号为port）发起TCP连接，若成功，则创建Socket对象，否则抛出异常</li>
<li>Socket(InetAddress address, int port)throws IOException：根据InetAddress对象所表示的IP地址以及端口号port发起连接</li>
</ul>
</li>
<li><p>客户端建立socketAtClient对象的过程就是向服务器发出套接字连接请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Socket s = <span class="keyword">new</span> Socket(<span class="string">&quot;192.168.40.165&quot;</span>,<span class="number">9999</span>);</span><br><span class="line">OutputStream out = s.getOutputStream();</span><br><span class="line">out.write(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">s.close();</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>服务器程序的工作过程包含以下四个基本步骤：</p>
<ul>
<li><p>调用ServerSocket(int port)：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求</p>
</li>
<li><p>调用accept()：监听连接请求，如果客户端请求连接，则接收连接，返回通信套接字对象</p>
</li>
<li><p>调用该Socket类对象的getOutputStream()和getInputStream()：获取输出流和输入流，开始网络数据的发送和接收</p>
</li>
<li><p>关闭ServerSocket和Socket对象：客户端访问结束，关闭通信套接字</p>
</li>
<li><p>服务器建立ServerSocket对象</p>
<ul>
<li><p>ServerSocket对象负责等待客户端请求建立套接字连接，类似邮局某个窗口中的业务员。也就是说，服务器必须实现建立一个等待客户请求建立套接字连接的ServerSocket对象</p>
</li>
<li><p>所谓”接收“客户的套接字请求，就是accept()方法会返回一个Socket对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">Socket s = ss.accept();</span><br><span class="line">InputStream in = s.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> num = in.read(buf);</span><br><span class="line">String  str = <span class="keyword">new</span> String(buf,<span class="number">0</span>,num);</span><br><span class="line">System.out.println(s.getInetAddress().toString() + <span class="string">&quot; :&quot;</span> + str);</span><br><span class="line">s.close();</span><br><span class="line">ss.close();</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210801160159.png" alt="image-20210801160157108"></p>
<p><strong>客户端—服务端</strong></p>
<ul>
<li>客户端：<ul>
<li>自定义</li>
<li>浏览器</li>
</ul>
</li>
<li>服务端<ul>
<li>自定义</li>
<li>Tomcat服务器</li>
</ul>
</li>
</ul>
<h5 id="5-2-示例"><a href="#5-2-示例" class="headerlink" title="5.2 示例"></a>5.2 示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> TCP编程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现TCP的网络编程</span></span><br><span class="line"><span class="comment">从客户端发送文件给服务器，服务器保存到本地，并返回“发送成功”给客户端</span></span><br><span class="line"><span class="comment">关闭相应连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPTest3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Socket socketClient = <span class="keyword">null</span>;<span class="comment">//指定IP与端口，创建客户端Socket</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;<span class="comment">//创建文件输入流，读取本地文件</span></span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;<span class="comment">//创建Socket的输出流，将文件输出给服务器</span></span><br><span class="line">        InputStream is = <span class="keyword">null</span>;<span class="comment">//创建Socket的输入流，接收来自服务器的文件</span></span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;<span class="comment">//创建字节数组输出流，用于接收来自服务器的信息</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建Socket</span></span><br><span class="line">            socketClient = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(),<span class="number">8989</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.创建输出流</span></span><br><span class="line">            os = socketClient.getOutputStream();</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;文件夹\\发送文件\\send.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.操作文件进行发送</span></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            socketClient.shutdownOutput();<span class="comment">//结束输出</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.接收来自服务器的消息</span></span><br><span class="line">            is = socketClient.getInputStream();</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">int</span> length ;</span><br><span class="line">            <span class="keyword">while</span>((length = is.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(bytes,<span class="number">0</span>,length);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(baos.toString());<span class="comment">//输出来自服务器的信息</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//5.关闭资源</span></span><br><span class="line">            <span class="keyword">if</span> (socketClient != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socketClient.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;<span class="comment">//指定端口号，创建服务端ServerSocket</span></span><br><span class="line">        Socket socketFromClient = <span class="keyword">null</span>;<span class="comment">//创建来自于客户端的Socket</span></span><br><span class="line">        InputStream is = <span class="keyword">null</span>;<span class="comment">//创建Socket的输入流</span></span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;<span class="comment">//创建Socket的输出流</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;<span class="comment">//将来自客户端文件保存到本地</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建服务端ServerSocket</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8989</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.调用accept()</span></span><br><span class="line">            socketFromClient = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.创建流</span></span><br><span class="line">            is = socketFromClient.getInputStream();</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;文件夹\\接收文件\\receive.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.接收</span></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.接收完成进行反馈</span></span><br><span class="line">            os = socketFromClient.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;文件接收完成&quot;</span>.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//6.关闭资源</span></span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (socketFromClient != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socketFromClient.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="6-UDP网络编程"><a href="#6-UDP网络编程" class="headerlink" title="6. UDP网络编程"></a>6. UDP网络编程</h4><ul>
<li>类DatagramSocket和DatagramPacket实现了基于UDP协议网络程序</li>
<li>UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达</li>
<li>DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号</li>
<li>UDP协议中每个数据报都给出了完整的地址信息，因此无需建立发送方和接收方的连接。如同发快递包裹一样</li>
</ul>
<h5 id="6-1-DatagramSocket类的常用方法"><a href="#6-1-DatagramSocket类的常用方法" class="headerlink" title="6.1 DatagramSocket类的常用方法"></a>6.1 DatagramSocket类的常用方法</h5><ul>
<li>public DatagramSocket(int port)创建数据报套接字并将其绑定到本地主机上的指定端口。套接字被绑定到通配符地址，IP地址由内核来选择</li>
<li>public DatagramSocket(int port, InetAddress Iaddr)创建数据报套接字，将其绑定到指定的本地地址。本地端口必须在0-65535之间（包括两者）。如果IP地址为0.0.0.0，套接字将被绑定到通配符地址，IP地址由内核选择</li>
<li>public void close()关闭此数据报套接字</li>
<li>public void send(DatagramPacket p)从此套接字发送数据包。DatagramPacket包含的信息将指示：将要发送的数据、其长度、远程主机的IP地址和远程主机的端口号。</li>
<li>public void receive(DatagramPacket p)从此套接字接收数据包。当此方法返回时，DatagramPacket的缓冲区填充了接收的数据。数据报包也包含发送方的IP地址和发送机器上的端口号。此方法在接收到数据报前一直阻塞。数据报包对象的length字段包含所接收信息的长度。如果信息比包的长度长，该信息将被截短</li>
<li>public InetAddress getLocalAddress()获取套接字绑定的本地地址</li>
<li>public int getLocalPort()返回此套接字绑定的本地主机上的端口号</li>
<li>public InetAddress getInetAddress()返回此套接字连接的地址。如果套接字未连接，则返回null</li>
<li>public int getPort()返回此套接字的端口。如果套接字未连接，则返回-1</li>
<li>public DatagramPacket(byte[] buf, int length)构造DatagramPacket，用来接收长度为length的数据包。length参数必须小于等于buf.length</li>
<li>public DatagramPacket(byte[] buf, int length, InetAddress, int port)构造数据包，用来将长度为length的包发送到指定主机的指定端口号。length参数必须小于等于buf.length</li>
<li>public InetAddress getAddress()返回某台机器的IP地址，此数据报将要发往该主机或者是从该主机接收到的</li>
<li>public int getPort()返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的</li>
<li>public byte[] getData()返回数据缓冲区。接收到的或将要发送的数据从缓冲区中的偏移量offset处开始，持续length长度</li>
<li>public int getLength()返回将要发送或接收到的数据的长度</li>
</ul>
<h5 id="6-2-UDP网络通信"><a href="#6-2-UDP网络通信" class="headerlink" title="6.2 UDP网络通信"></a>6.2 UDP网络通信</h5><ul>
<li><p>流程：</p>
<ol>
<li>DatagramSocket与DatagramPacket</li>
<li>建立发送端，接收端</li>
<li>建立数据包</li>
<li>调用Socket的发送、接收方法</li>
<li>关闭Socket</li>
</ol>
</li>
<li><p>发送端与接收端是两个独立的运行程序</p>
</li>
<li><p>发送端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket ds = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">    <span class="keyword">byte</span>[] by = <span class="string">&quot;hello&quot;</span>.getBytes();</span><br><span class="line">    DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(by,<span class="number">0</span>,by.length, InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">10000</span>);</span><br><span class="line">    ds.send(dp);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ds != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收端，在接收端，要指定监听的端口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramSocket ds = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ds = <span class="keyword">new</span> DatagramSocket(<span class="number">10000</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] by = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(by,by.length);</span><br><span class="line">    ds.receive(dp);</span><br><span class="line">    String str = <span class="keyword">new</span> String(dp.getData(),<span class="number">0</span>,dp.getLength());</span><br><span class="line">    System.out.println(str + <span class="string">&quot;——&quot;</span> + dp.getAddress());</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ds != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="6-3-示例"><a href="#6-3-示例" class="headerlink" title="6.3 示例"></a>6.3 示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> UDP编程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DatagramSocket ds = <span class="keyword">null</span>;</span><br><span class="line">        InetAddress inet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ds = <span class="keyword">new</span> DatagramSocket();<span class="comment">//创建数据报套接字</span></span><br><span class="line">            inet = InetAddress.getLocalHost();</span><br><span class="line"></span><br><span class="line">            String str = <span class="string">&quot;以UDP方式发送文件&quot;</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes =str.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bytes,<span class="number">0</span>,bytes.length,inet,<span class="number">9898</span>);</span><br><span class="line"></span><br><span class="line">            ds.send(dp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ds.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DatagramSocket ds = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ds = <span class="keyword">new</span> DatagramSocket(<span class="number">9898</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">            DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line"></span><br><span class="line">            ds.receive(dp);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(dp.getData(), <span class="number">0</span>, dp.getLength()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ds.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="7-URL编程"><a href="#7-URL编程" class="headerlink" title="7. URL编程"></a>7. URL编程</h4><h5 id="7-1-URL类"><a href="#7-1-URL类" class="headerlink" title="7.1 URL类"></a>7.1 URL类</h5><ul>
<li><p>URL(Uniform Resource Locator)：统一资源定位符，它表示Internet上某一资源的地址</p>
</li>
<li><p>它是一种具体的URI，即URL可以用来表示一个资源，而且还指明了如何locate这个资源</p>
</li>
<li><p>通过URL我们可以访问Internet上的各种网络资源，比如最常见的www，ftp站点。浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源</p>
</li>
<li><p>URL的基本结构由5部分组成：</p>
<p>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名？参数列表</p>
<ul>
<li><p>例如：</p>
<p><a href="http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123">http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123</a></p>
</li>
<li><p>片段名：即锚点，例如看小说，之间定位到章节</p>
</li>
<li><p>参数列表格式：参数名 = 参数值 &amp; 参数名 = 参数值…</p>
</li>
</ul>
</li>
</ul>
<h5 id="7-2-URL类构造器"><a href="#7-2-URL类构造器" class="headerlink" title="7.2 URL类构造器"></a>7.2 URL类构造器</h5><ul>
<li><p>为了表示URL，java.net中实现了类URL。我们可以通过下面的构造器来初始化一个URL对象：</p>
<ul>
<li><p>public URL(String spec)：通过一个表示URL地址的字符串可以构造一个URL对象。</p>
<p>URL url = new URL(“<a href="https://www.baidu.com&quot;/">https://www.baidu.com&quot;</a>);</p>
</li>
<li><p>public URL(URL context, String spec)：通过基 URL 和相对 URL 构造一个 URL 对象。</p>
<p>URL downloadUrl = new URL(url, “download.html”)</p>
</li>
<li><p>public URL(String protocol, String host, int port, String file);</p>
<p>URL gamelan = new  URL(“http”, “<a href="http://www.baidu.com&quot;/">www.baidu.com&quot;</a>, 80, “download.html”);</p>
</li>
</ul>
</li>
<li><p>URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通 常是用 try-catch 语句进行捕获。</p>
</li>
</ul>
<h5 id="7-3-URL常用方法"><a href="#7-3-URL常用方法" class="headerlink" title="7.3 URL常用方法"></a>7.3 URL常用方法</h5><ul>
<li>一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性<ul>
<li>public String getProtocol()        获取该URL的协议名</li>
<li>public String getHost()              获取该URL的主机号</li>
<li>public String getPort()               获取该URL的端口号</li>
<li>public String getPath()              获取该URL的文件路径</li>
<li>public String getFile()                获取该URL的文件名</li>
<li>public String getQuery()           获取该URL的查询名</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://localhost:8080/examples/myTest.txt&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;getProtocol() :&quot;</span>+url.getProtocol());</span><br><span class="line">System.out.println(<span class="string">&quot;getHost() :&quot;</span>+url.getHost());</span><br><span class="line">System.out.println(<span class="string">&quot;getPort() :&quot;</span>+url.getPort());</span><br><span class="line">System.out.println(<span class="string">&quot;getPath() :&quot;</span>+url.getPath());</span><br><span class="line">System.out.println(<span class="string">&quot;getFile() :&quot;</span>+url.getFile());</span><br><span class="line">System.out.println(<span class="string">&quot;getQuery() :&quot;</span>+url.getQuery());</span><br></pre></td></tr></table></figure>

<h5 id="7-3-针对HTTP协议的URLConnection类"><a href="#7-3-针对HTTP协议的URLConnection类" class="headerlink" title="7.3 针对HTTP协议的URLConnection类"></a>7.3 针对HTTP协议的URLConnection类</h5><ul>
<li>URL的方法openStream()：能从网络上读取数据</li>
<li>若希望输出数据，例如向服务器端的CGI（公共网关接口-Common Gateway Interface-简称，是用户浏览器和服务器端的应用程序进行连接的接口）程序发送一次额数据，必须先与URL建立连接，然后才能对其进行读写，此时需要使用URLConnection</li>
<li>URLConnection：表示到URL所引用的远程对象的连接。当与一个URL建立连接时，首先要在一个URL对象上通过方法openConnection()生成对应的URLConnection对象。如果连接过程失败，将产生IOExecption<ul>
<li>URL netchinaren = new URL (“<a href="http://www.baiduu.com/index.shtml&quot;">http://www.baiduu.com/index.shtml&quot;</a>);</li>
<li>URLConnectonn u = netchinaren.openConnection( ); </li>
</ul>
</li>
<li>通过URLConnection对象获取的输入流和输出流，即可以与现有的CGI 程序进行交互。<ul>
<li>public Object getContent( ) throws IOException</li>
<li>public int getContentLength( )</li>
<li>public String getContentType( )</li>
<li>public long getDate( )</li>
<li>public long getLastModified( )</li>
<li>public InputStream getInputStream( )throws IOException</li>
<li>public OutputSteram getOutputStream( )throws IOException</li>
</ul>
</li>
</ul>
<h6 id="7-3-1-URI、URL和URN的区别"><a href="#7-3-1-URI、URL和URN的区别" class="headerlink" title="7.3.1 URI、URL和URN的区别"></a>7.3.1 URI、URL和URN的区别</h6><p>URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个 资源。而URL是uniform resource locator，统一资源定位符，它是一种具体 的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。 而URN，uniform resource name，统一资源命名，是通过名字来标识资源， 比如mailto:<a href="mailto:&#106;&#x61;&#x76;&#97;&#x2d;&#x6e;&#101;&#116;&#x40;&#106;&#97;&#x76;&#97;&#46;&#x73;&#x75;&#110;&#46;&#99;&#x6f;&#x6d;">&#106;&#x61;&#x76;&#97;&#x2d;&#x6e;&#101;&#116;&#x40;&#106;&#97;&#x76;&#97;&#46;&#x73;&#x75;&#110;&#46;&#99;&#x6f;&#x6d;</a>。也就是说，URI是以一种抽象的，高层 次概念定义统一资源标识，而URL和URN则是具体的资源标识的方式。URL 和URN都是一种URI。</p>
<p>在Java的URI中，一个URI实例可以代表绝对的，也可以是相对的，只要它符 合URI的语法规则。而URL类则 不仅符合语义，还包含了定位该资源的信息， 因此它不能是相对的。</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210801173322.png" alt="image-20210801173320541"></p>
<h5 id="7-4-示例"><a href="#7-4-示例" class="headerlink" title="7.4 示例"></a>7.4 示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> URL编程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URLTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://localhost:8080/examples/两只小熊.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            public String getProtocol(  )     获取该URL的协议名</span></span><br><span class="line">            System.out.println(url.getProtocol());</span><br><span class="line"><span class="comment">//            public String getHost(  )           获取该URL的主机名</span></span><br><span class="line">            System.out.println(url.getHost());</span><br><span class="line"><span class="comment">//            public String getPort(  )            获取该URL的端口号</span></span><br><span class="line">            System.out.println(url.getPort());</span><br><span class="line"><span class="comment">//            public String getPath(  )           获取该URL的文件路径</span></span><br><span class="line">            System.out.println(url.getPath());</span><br><span class="line"><span class="comment">//            public String getFile(  )             获取该URL的文件名</span></span><br><span class="line">            System.out.println(url.getFile());</span><br><span class="line"><span class="comment">//            public String getQuery(   )        获取该URL的查询名</span></span><br><span class="line">            System.out.println(url.getQuery());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HttpURLConnection urlConnection = <span class="keyword">null</span>;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://localhost:8080/examples/%E4%B8%A4%E5%8F%AA%E5%B0%8F%E7%86%8A.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">            urlConnection.connect();</span><br><span class="line"></span><br><span class="line">            is = urlConnection.getInputStream();</span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;文件夹\\接收文件\\两只小熊.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;下载完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(is != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fos != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(urlConnection != <span class="keyword">null</span>)&#123;</span><br><span class="line">                urlConnection.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="8-小结"><a href="#8-小结" class="headerlink" title="8.小结"></a>8.小结</h4><ul>
<li>位于网络中的计算机具有唯一的IP地址，这样不同的主机可以互相区分。</li>
<li>客户端－服务器是一种最常见的网络应用程序模型。服务器是一个为其客户端提供某种特定 服务的硬件或软件。客户机是一个用户应用程序，用于访问某台服务器提供的服务。端口号 是对一个服务的访问场所，它用于区分同一物理计算机上的多个服务。套接字用于连接客户 端和服务器，客户端和服务器之间的每个通信会话使用一个不同的套接字。TCP协议用于实 现面向连接的会话。</li>
<li>Java 中有关网络方面的功能都定义在 java.net 程序包中。Java 用 InetAddress 对象表示 IP  地址，该对象里有两个字段：主机名(String) 和 IP 地址(int)。</li>
<li>类 Socket 和 ServerSocket 实现了基于TCP协议的客户端－服务器程序。Socket是客户端 和服务器之间的一个连接，连接创建的细节被隐藏了。这个连接提供了一个安全的数据传输 通道，这是因为 TCP 协议可以解决数据在传送过程中的丢失、损坏、重复、乱序以及网络 拥挤等问题，它保证数据可靠的传送。</li>
<li>类 URL 和 URLConnection 提供了最高级网络应用。URL 的网络资源的位置来同一表示 Internet 上各种网络资源。通过URL对象可以创建当前应用程序和 URL 表示的网络资源之 间的连接，这样当前程序就可以读取网络资源数据，或者把自己的数据传送到网络上去。</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>15-反射机制</title>
    <url>/2021/09/17/15%E2%80%94%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="15—反射机制"><a href="#15—反射机制" class="headerlink" title="15—反射机制"></a>15—反射机制</h3><h4 id="1-Java反射机制概述"><a href="#1-Java反射机制概述" class="headerlink" title="1. Java反射机制概述"></a>1. Java反射机制概述</h4><h5 id="1-1Java-Reflection"><a href="#1-1Java-Reflection" class="headerlink" title="1.1Java Reflection"></a>1.1Java Reflection</h5><ul>
<li><p>Reflection(反射)是被是为动态语言的关键，反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</p>
</li>
<li><p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以我们形象的称之为：反射</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108051058768.png" alt="image-20210805105812183"></p>
</li>
</ul>
<p><strong>动态语言VS静态语言</strong></p>
<ol>
<li><p>动态语言</p>
<p>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗来说就是在运行时代码可以根据某些条件改变自身结构</p>
<p>主要的动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。</p>
</li>
<li><p>静态语言</p>
<p>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++</p>
<blockquote>
<p>Java不是动态语言，但Java可以称为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性。</p>
</blockquote>
</li>
</ol>
<h5 id="1-2-Java反射机制研究及应用"><a href="#1-2-Java反射机制研究及应用" class="headerlink" title="1.2 Java反射机制研究及应用"></a>1.2 Java反射机制研究及应用</h5><ul>
<li>Java反射机制提供的功能<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
</li>
</ul>
<h5 id="1-3-反射相关的主要API"><a href="#1-3-反射相关的主要API" class="headerlink" title="1.3 反射相关的主要API"></a>1.3 反射相关的主要API</h5><ul>
<li>java.lang.Class：代表一个类</li>
<li>java.lang.reflect.Method：代表类的方法</li>
<li>java.lang.reflect.Field：代表类的成员变量</li>
<li>java.lang.reflect.Constructor：代表类的构造器</li>
</ul>
<h4 id="2-理解Class类并获取Class实例"><a href="#2-理解Class类并获取Class实例" class="headerlink" title="2.理解Class类并获取Class实例"></a>2.理解Class类并获取Class实例</h4><h5 id="2-1-Class类"><a href="#2-1-Class类" class="headerlink" title="2.1 Class类"></a>2.1 Class类</h5><p>在Object类中定义了以下方法，此方法将被所有子类继承</p>
<ul>
<li><p>public final Class getClass()</p>
<p>以上方法返回值的类型是一个Class类，此类是Java反射的源头，实际上所谓反射从程序运行结果来看也很好理解，即：可以通过对象反射求出类的名称。</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108051121088.png" alt="image-20210805112119113"></p>
</li>
<li><p>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE都为其保留了一个不变的Class类型的对象。一个Class对象包括了特定某个结构(class/interface/enum/annotation/primitive type/void[])的有关信息</p>
<ul>
<li>Class本身也是一个类</li>
<li>Class对象只能由系统建立对象</li>
<li>一个加载的类在JVM中只会有一个Class实例</li>
<li>一个Class对象对应的是一个加载到JVM中的一个.class文件</li>
<li>每个类的实例都会记得自己是由哪个Class实例所生成</li>
<li>通过Class可以完整地得到一个类中的所有被加载的结构</li>
<li>Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</li>
</ul>
</li>
</ul>
<h5 id="2-2-Class类的常用方法"><a href="#2-2-Class类的常用方法" class="headerlink" title="2.2 Class类的常用方法"></a>2.2 Class类的常用方法</h5><table>
<thead>
<tr>
<th>方法名</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>static Class forName(String name)</td>
<td>返回指定类名name的Class对象</td>
</tr>
<tr>
<td>Object newInstance()</td>
<td>调用缺省构造函数，返回该Class对象的一个实例</td>
</tr>
<tr>
<td>getName()</td>
<td>返回此Class对象所表示的实体（类、接口、数组类、基本类型或void）名称</td>
</tr>
<tr>
<td>Class getSuperClass()</td>
<td>返回当前Class对象的父类的Class对象</td>
</tr>
<tr>
<td>Class[] getInterfaces()</td>
<td>获取当前Class对象的接口</td>
</tr>
<tr>
<td>ClassLoader getClassLoader()</td>
<td>返回该类的加载器</td>
</tr>
<tr>
<td>Class getSuperclass()</td>
<td>返回表示此Class所表示的实体类的超类的Class</td>
</tr>
<tr>
<td>Construct[] getConstructors()</td>
<td>返回一个包含某些Constructor对象的数组</td>
</tr>
<tr>
<td>Field[] getDeclareFields()</td>
<td>返回Field对象的一个数组</td>
</tr>
<tr>
<td>Method getMethod(String name, Class … paramTypes)</td>
<td>返回一个Method对象，此对象的形参类型为paramType</td>
</tr>
</tbody></table>
<h5 id="2-3-反射的应用举例"><a href="#2-3-反射的应用举例" class="headerlink" title="2.3 反射的应用举例"></a>2.3 反射的应用举例</h5> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 反射的引入;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">showNation</span><span class="params">(String nation)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的国籍是：&quot;</span> + nation);</span><br><span class="line">        <span class="keyword">return</span> nation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Person类里的show()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class clazz = Person.class;</span><br><span class="line">        <span class="comment">//1.通过反射，创建Person类的对象</span></span><br><span class="line">        Constructor cons = clazz.getConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">        Object obj = cons.newInstance(<span class="string">&quot;xiong&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        Person person = (Person) obj;</span><br><span class="line">        System.out.println(person);<span class="comment">//Person&#123;name=&#x27;xiong&#x27;, age=23&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.通过反射，调用对象指定的属性和方法</span></span><br><span class="line">        <span class="comment">//调用属性</span></span><br><span class="line">        Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.set(person,<span class="number">10</span>);</span><br><span class="line">        System.out.println(person);<span class="comment">//Person&#123;name=&#x27;xiong&#x27;, age=10&#125;</span></span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        Method show = clazz.getMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">        show.invoke(person);<span class="comment">//Person类里的show()</span></span><br><span class="line">        System.out.println(<span class="string">&quot;|++++++++++++++++++++++++|&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射可以调用类的私有结构。比如：私有的构造器、方法、属性</span></span><br><span class="line">        <span class="comment">//调用私有的构造器</span></span><br><span class="line">        Constructor cons1 = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">        cons1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Person person1 = (Person)cons1.newInstance(<span class="string">&quot;zhuo&quot;</span>);</span><br><span class="line">        System.out.println(person1);<span class="comment">//Person&#123;name=&#x27;zhuo&#x27;, age=0&#125;</span></span><br><span class="line">        <span class="comment">//调用私有的属性</span></span><br><span class="line">        Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        name.set(person1,<span class="string">&quot;Guet&quot;</span>);</span><br><span class="line">        System.out.println(person1);<span class="comment">//Person&#123;name=&#x27;Guet&#x27;, age=0&#125;</span></span><br><span class="line">        <span class="comment">//调用私有方法</span></span><br><span class="line">        Method showNation = clazz.getDeclaredMethod(<span class="string">&quot;showNation&quot;</span>, String.class);</span><br><span class="line">        showNation.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        String nation = (String) showNation.invoke(person1,<span class="string">&quot;中国&quot;</span>);<span class="comment">//我的国籍是：中国</span></span><br><span class="line">        System.out.println(nation);<span class="comment">//中国</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-4-获取Class类的四种实例（四种方法）"><a href="#2-4-获取Class类的四种实例（四种方法）" class="headerlink" title="2.4 获取Class类的四种实例（四种方法）"></a>2.4 获取Class类的四种实例（四种方法）</h5><ol>
<li><p>前提；若已知具体的类，通过类的class属性获取。该方法最为可靠，程序性能最高</p>
<p>实例：Class clazz = String.class;</p>
</li>
<li><p>前提：已知某个类的实例，调用该实例的getClass()方法获取Class对象</p>
<p>实例：Class clazz = “reflection”.getClass();</p>
</li>
<li><p>前提：已知一个类的全类名，且该类在类路径下，可以通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException</p>
<p>实例：Class class = Class.forName(“java.lang.String”);</p>
</li>
<li><p>其他方式</p>
<p>ClassLoader cl = this.getClass().getClassLoader();</p>
<p>Class clazz = cl.loadClass(“类的全类名”)；</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//方式一：调用运行时类的属性：.class</span></span><br><span class="line">        Class clazz1 = Person.class;</span><br><span class="line">        System.out.println(clazz1);<span class="comment">//class 获取Class的实例方式.Person</span></span><br><span class="line">        <span class="comment">//方式二：通过运行时类的对象，调用getClass()</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">        Class clazz2 = p1.getClass();</span><br><span class="line">        System.out.println(clazz2);<span class="comment">//class 获取Class的实例方式.Person</span></span><br><span class="line">        <span class="comment">//方式三：调用Class的静态方法：forName(String classPath)</span></span><br><span class="line">        Class clazz3 = Class.forName(<span class="string">&quot;获取Class的实例方式.Person&quot;</span>);</span><br><span class="line">        System.out.println(clazz3);<span class="comment">//class 获取Class的实例方式.Person</span></span><br><span class="line"></span><br><span class="line">        System.out.println(clazz1 == clazz2);<span class="comment">//true</span></span><br><span class="line">        System.out.println(clazz2 == clazz3);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式四：使用类加载器：ClassLoader</span></span><br><span class="line">        ClassLoader classLoader = GetClassTest.class.getClassLoader();</span><br><span class="line">        Class clazz4 = classLoader.loadClass(<span class="string">&quot;获取Class的实例方式.Person&quot;</span>);</span><br><span class="line">        System.out.println(clazz4);<span class="comment">//class 获取Class的实例方式.Person</span></span><br><span class="line"></span><br><span class="line">        System.out.println(clazz3 == clazz4);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h5 id="2-5-哪些类型可以有Class对象"><a href="#2-5-哪些类型可以有Class对象" class="headerlink" title="2.5 哪些类型可以有Class对象"></a>2.5 哪些类型可以有Class对象</h5><ol>
<li>class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</li>
<li>interface：接口</li>
<li>[]：数组</li>
<li>enum：枚举</li>
<li>annotation：注解@interface</li>
<li>primitive type：基本数据类型</li>
<li>void</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class c1 = Object.class;</span><br><span class="line">Class c2 = Comparable.class;</span><br><span class="line">Class c3 = String[].class;</span><br><span class="line">Class c4 = <span class="keyword">int</span>[][].class;</span><br><span class="line">Class c5 = ElementType.class;</span><br><span class="line">Class c6 = Override.class;</span><br><span class="line">Class c7 = <span class="keyword">int</span>.class;</span><br><span class="line">Class c8 = <span class="keyword">void</span>.class;</span><br><span class="line">Class c9 = Class.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">Class c10 = a.getClass();</span><br><span class="line">Class c11 = b.getClass();</span><br><span class="line"><span class="comment">//只要元素类型与维度一样，就是同一个Class</span></span><br><span class="line">System.out.println(c10 == c11);</span><br></pre></td></tr></table></figure>



<h4 id="3-类的加载与ClassLoader的理解"><a href="#3-类的加载与ClassLoader的理解" class="headerlink" title="3.类的加载与ClassLoader的理解"></a>3.类的加载与ClassLoader的理解</h4><h5 id="3-1-类的加载过程"><a href="#3-1-类的加载过程" class="headerlink" title="3.1 类的加载过程"></a>3.1 类的加载过程</h5><p>当程序主动使用了某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108051455506.png" alt="image-20210805145547292"></p>
<ul>
<li>加载：将class文件字节码内容加载到内存中，并将这些静态数据转化成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与</li>
<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<ul>
<li>验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题</li>
<li>准备：正式为类变量（static）分配内存并设置类变量默认的初始值的阶段，这些内存都将在方法区中进行分配</li>
<li>解析：虚拟机常量池的符号引用（常量名）替换为直接引用（地址）的过程</li>
</ul>
</li>
<li>初始化：<ul>
<li>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的（类构造器是构造类信息的，不是构造该类对象的构造器）</li>
<li>当初始化一个类的时候，如果发现其父类还没进行初始化，则需要先触发其父类的初始化</li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁和同步</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadingTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(A.m);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		m = <span class="number">300</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第二步：链接结束后m=0</span></span><br><span class="line"><span class="comment">//第三步：初始化后，m的值由&lt;clinit&gt;()方法执行决定</span></span><br><span class="line"><span class="comment">// 这个A的类构造器&lt;clinit&gt;()方法由类变量的赋值和静态代码块中的语句按照顺序合并产生，类似于</span></span><br><span class="line"><span class="comment">// &lt;clinit&gt;()&#123;</span></span><br><span class="line"><span class="comment">// m = 300;</span></span><br><span class="line"><span class="comment">// m = 100;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="3-2-什么时候会发生类初始化"><a href="#3-2-什么时候会发生类初始化" class="headerlink" title="3.2 什么时候会发生类初始化"></a>3.2 什么时候会发生类初始化</h5><ul>
<li>类的主动引用（一定会发生类的初始化）<ul>
<li>当虚拟机启动，先初始化main方法所在的类</li>
<li>new一个类的对象</li>
<li>调用类的静态成员（除了final常量）和静态方法</li>
<li>使用java.lang.reflect包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则会先初始化它的父类</li>
</ul>
</li>
<li>类的被动引用（不会发生类的初始化）<ul>
<li>当访问一个静态域时，只有真正声明了这个域的类才会被初始化<ul>
<li>当通过子类引用父类的静态变量时，不会导致子类初始化</li>
</ul>
</li>
<li>通过数组定义类的引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadingTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 主动引用：一定会导致A和Father的初始化</span></span><br><span class="line">		<span class="comment">// A a = new A();</span></span><br><span class="line">		<span class="comment">// System.out.println(A.m);</span></span><br><span class="line">		<span class="comment">// Class.forName(&quot;com.atguigu.java2.A&quot;);</span></span><br><span class="line">		<span class="comment">// 被动引用</span></span><br><span class="line">		A[] array = <span class="keyword">new</span> A[<span class="number">5</span>];<span class="comment">//不会导致A和Father的初始化</span></span><br><span class="line">		<span class="comment">// System.out.println(A.b);//只会初始化Father</span></span><br><span class="line">		<span class="comment">// System.out.println(A.M);//不会导致A和Father的初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;main所在的类&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;父类被加载&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;子类被加载&quot;</span>);</span><br><span class="line">		m = <span class="number">300</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108051708546.png" alt="image-20210805170831278"></p>
<h5 id="3-3-类加载器的作用"><a href="#3-3-类加载器的作用" class="headerlink" title="3.3 类加载器的作用"></a>3.3 类加载器的作用</h5><ul>
<li>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转化成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口</li>
<li>类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象类加载器作用是用来把类(class)装载进内存的。JVM规范定义了如下类型的类的加载器</li>
</ul>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108051715466.png" alt="image-20210805171547278"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获取一个系统类加载器</span></span><br><span class="line">ClassLoader classloader = ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(classloader);</span><br><span class="line"><span class="comment">//2.获取系统类加载器的父类加载器，即扩展类加载器</span></span><br><span class="line">classloader = classloader.getParent();</span><br><span class="line">System,out.println(classloader);</span><br><span class="line"><span class="comment">//3.获取扩展类的加载器的父类加载器，即引导类的加载器</span></span><br><span class="line">classloader = classloader.getParent();</span><br><span class="line">System.out.println(classloader);</span><br><span class="line"><span class="comment">//4.测试当前类由哪个类加载器进行加载</span></span><br><span class="line">classloader = Class.forName(<span class="string">&quot;exer2.ClassloaderDemo&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(classloader);</span><br><span class="line"><span class="comment">//5.测试JDK提供的Object类由哪个类加载器加载</span></span><br><span class="line">classloader = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(classloader);</span><br><span class="line"><span class="comment">//6.关于类加载器的一个主要方法：getResourceAsStream(String str)：获取类路径下的指定文件的输入流</span></span><br><span class="line">InputStream in = <span class="keyword">null</span>;</span><br><span class="line">in = <span class="keyword">this</span>.getClass.getClassLoader().getResourceAsStream(<span class="string">&quot;反射\\文件\\test.properties&quot;</span>);</span><br><span class="line">System.out.println(in);</span><br></pre></td></tr></table></figure>

<p><strong>实践</strong></p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108110956620.png" alt="image-20210811095555132"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 类的加载;</span><br><span class="line"><span class="comment">//了解类的加载器</span></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//对于自定义类，使用系统类加载器进行加载</span></span><br><span class="line">        ClassLoader classLoader1 = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader1);<span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//调用系统类加载器的getParent()：获取扩展类加载器</span></span><br><span class="line">        ClassLoader classLoader2 = classLoader1.getParent();</span><br><span class="line">        System.out.println(classLoader2);<span class="comment">//sun.misc.Launcher$ExtClassLoader@28a418fc</span></span><br><span class="line">        <span class="comment">//调用扩展类加载器的getParent()：无法获得类引导加载器</span></span><br><span class="line">        <span class="comment">//引导加载器主要负责加载java的核心类库，无法加载自定义类</span></span><br><span class="line">        ClassLoader classLoader3 = classLoader2.getParent();</span><br><span class="line">        System.out.println(classLoader3);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader4 = String.class.getClassLoader();</span><br><span class="line">        System.out.println(classLoader4);<span class="comment">//null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Properties：用来读取配置文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//此时文件默认在当前Module下</span></span><br><span class="line">        <span class="comment">//读取配置文件方式一：</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        pros.load(fis);</span><br><span class="line"></span><br><span class="line">        String user = pros.getProperty(<span class="string">&quot;姓名&quot;</span>);</span><br><span class="line">        String password = pros.getProperty(<span class="string">&quot;密码&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + user + <span class="string">&quot; 密码：&quot;</span> + password);<span class="comment">//姓名：熊卓 密码：1234</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取配置文件方式二：使用ClassLoader</span></span><br><span class="line">        <span class="comment">//配置文件默认识别为：当前Module的src下</span></span><br><span class="line"></span><br><span class="line">        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line"><span class="comment">//        InputStream is = classLoader.getResourceAsStream(&quot;C:\\Users\\xiong\\IdeaProjects\\反射\\src\\jdbc.properties&quot;);//无法识别</span></span><br><span class="line">        InputStream is = classLoader.getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        pros.load(is);</span><br><span class="line"></span><br><span class="line">        String user1 = pros.getProperty(<span class="string">&quot;姓名&quot;</span>);</span><br><span class="line">        String password1 = pros.getProperty(<span class="string">&quot;密码&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span> + user1 + <span class="string">&quot; 密码：&quot;</span> + password1);<span class="comment">//姓名：熊卓GUET 密码：12345678</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-创建运行时类的对象"><a href="#4-创建运行时类的对象" class="headerlink" title="4.创建运行时类的对象"></a>4.创建运行时类的对象</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 创建运行时类;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过反射创建运行时类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceTest</span>  </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        newInstance()：调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参构造器</span></span><br><span class="line"><span class="comment">        想要此方法正常的创建运行时类的对象，要求；</span></span><br><span class="line"><span class="comment">        1.运行时类必须提供空参的构造器</span></span><br><span class="line"><span class="comment">        2.空参构造器的访问权限得够，通常设置为public</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        在javabean中要求提供一个public的空参构造器。原因：</span></span><br><span class="line"><span class="comment">        1.便于通过反射，创建运行时类的对象</span></span><br><span class="line"><span class="comment">        2.便于子类继承此类运行时类时，默认调用super()时，保证父类有此构造器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Person obj = clazz.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        调用空参构造器</span></span><br><span class="line"><span class="comment">        Person&#123;name=&#x27;null&#x27;, age=0&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//体会反射的动态性</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);<span class="comment">//0,1,2</span></span><br><span class="line">            String classPath = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    classPath = <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="comment">//                    classPath = &quot;创建运行时类&quot;+ File.separator+&quot;Person&quot;; //无法识别中文路径</span></span><br><span class="line">                    classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Object obj = getInstance(classPath);</span><br><span class="line">                System.out.println(obj);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个指定类的对象</span></span><br><span class="line"><span class="comment">    classPath：指定类的全类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class clazz = Class.forName(classPath);</span><br><span class="line">        <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="4-1-有了Class对象能做什么"><a href="#4-1-有了Class对象能做什么" class="headerlink" title="4.1 有了Class对象能做什么"></a>4.1 有了Class对象能做什么</h5><p>创建类的对象：调用Class对象的newInstance()方法</p>
<p>要求：1. 类必须要有无参构造器； 2. 类的构造器的访问权限需要足够</p>
<p>难道没有无参构造器就不能创建对象了吗？</p>
<p>不是，只要在操作的时候明确调用类中的构造器，并将参数传递进去之后，才可以实例化操作。步骤如下：</p>
<ol>
<li><p>通过Class类的getDeclaredConstruct(Class … parameterTypes)取得本类的指定形参类型的构造器</p>
</li>
<li><p>向构造器的形成中传递一个对象数组进去，里面包含了构造器中那个所需的各个参数</p>
</li>
<li><p>通过Construct实例化对象</p>
<p>在Constructor类中存在一个方法：</p>
<p><code>public T newInstance(Object ... initargs)</code></p>
<p>以上是反射机制应用最多的地方</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.根据全类名获取对应的Class对象</span></span><br><span class="line">String name = <span class="string">&quot;reflection.Person&quot;</span>;</span><br><span class="line">Class clazz = <span class="keyword">null</span>;</span><br><span class="line">clazz = Class.forName(name);</span><br><span class="line"><span class="comment">//2.调用指定参数结构的构造器，生成Constructor实例</span></span><br><span class="line">Constructor con = clazz.getConstructor(String.class,Integer.class);</span><br><span class="line"><span class="comment">//3.通过Constructor的实例创建对应类的对象，并初始化类的属性</span></span><br><span class="line">Person p2 = (Person)con.newInstance(<span class="string">&quot;Peter&quot;</span>,<span class="number">20</span>);</span><br><span class="line">System.out.println(p2);</span><br></pre></td></tr></table></figure>

<h4 id="5-获取运行时类的完整结构"><a href="#5-获取运行时类的完整结构" class="headerlink" title="5.获取运行时类的完整结构"></a>5.获取运行时类的完整结构</h4><h5 id="5-1-通过反射获取运行时类的完整结构"><a href="#5-1-通过反射获取运行时类的完整结构" class="headerlink" title="5.1 通过反射获取运行时类的完整结构"></a>5.1 通过反射获取运行时类的完整结构</h5><p><strong>Field、Method、Construct、Superclass、Interface、Annotation</strong></p>
<ul>
<li>实现的全部接口</li>
<li>所继承的父类</li>
<li>全部的构造器</li>
<li>全部的方法</li>
<li>全部的Field</li>
</ul>
<p><strong>实现反射可以取得：</strong></p>
<p>1.实现的全部接口</p>
<ul>
<li><p>public Class&lt;?&gt;[] getInterfaces()</p>
<p>确定此对象所表示的类或接口实现的接口</p>
</li>
</ul>
<p>2.所继承的父类</p>
<ul>
<li><p>public Class&lt;? Super T&gt; getSuperclass()</p>
<p>返回表示此Class所表示的实体（类、接口、基本类型）的父类的Class</p>
</li>
</ul>
<p>3.全部的构造器</p>
<ul>
<li><p>public Constructor<T>[] getConstruct()</p>
<p>返回此Class对象所表示的类的所有public构造方法</p>
</li>
<li><p>public Constructor<T>[] getDeclaredConstructors()</p>
<p>返回此Class对象表示的类声明的所有构造方法</p>
</li>
</ul>
<p>Constructor类中</p>
<ul>
<li>取得修饰符：public int getModifiers()</li>
<li>取得方法名称：public String getName()</li>
<li>取得参数的类型：public Class&lt;?&gt;[] getParameterTypes()</li>
</ul>
<p>4.全部的方法</p>
<ul>
<li><p>public Method[] getDeclaredMethods()</p>
<p>返回此Class对象所表示的类或接口的全部方法</p>
</li>
<li><p>public Method[] getMethods()</p>
<p>返回此Class对象所表示的类或接口的public的方法</p>
</li>
</ul>
<p>Method类中</p>
<ul>
<li>public Class&lt;?&gt; getReturnType()取得全部的返回值</li>
<li>public Class&lt;?&gt;[] getParameterTypes取得全部的参数</li>
<li>public int getMethodifiers()取得修饰符</li>
<li>public Class&lt;?&gt;[] getExceptionTypes()取得异常信息</li>
</ul>
<p>5.全部的Field</p>
<ul>
<li><p>public Field[] getFields()</p>
<p>返回此Class对象所表示的类或接口的public的Field</p>
</li>
<li><p>public Field[] getDeclaredFields()</p>
<p>返回此Class对象所表示的类或接口的全部Fiels</p>
</li>
</ul>
<p>Field方法中</p>
<ul>
<li>public int getModifiers()以整数形式返回此Field的修饰符</li>
<li>public Class&lt;?&gt; getType()得到Field的属性类型</li>
<li>public String getName()返回Field的名称</li>
</ul>
<p>6.Annotation相关</p>
<ul>
<li>get Annotation(Class<T> annotaionClass)</li>
<li>getDeclaredAnnotations()</li>
</ul>
<p>7.泛型相关</p>
<p>获取父类泛型类型：Type getGenericSuperclass()</p>
<p>泛型类型：ParameterizedType</p>
<p>获取实际的泛型类型参数数组：getActualTypeArguments()</p>
<p>8.类所在的包 Package getPackage()</p>
<h4 id="6-调用运行时类的指定结构"><a href="#6-调用运行时类的指定结构" class="headerlink" title="6.调用运行时类的指定结构"></a>6.调用运行时类的指定结构</h4><h5 id="6-1-调用指定方法"><a href="#6-1-调用指定方法" class="headerlink" title="6.1 调用指定方法"></a>6.1 调用指定方法</h5><p>通过反射，调用类中的方法，通过Method类完成。步骤：</p>
<ol>
<li>通过Class类的getMethod(String name, Class … parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型</li>
<li>之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息</li>
</ol>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108061424618.png" alt="image-20210806142442981"></p>
<p><strong>Object invoke(Object obj, Object … args)</strong></p>
<p>说明：</p>
<ol>
<li>Object对应原方法的返回值，若原方法无返回值，此时返回null</li>
<li>若原方法为静态方法，此时形参Object obj可为null</li>
<li>若原方法形参列表为空，则Object[] args为null</li>
<li>若原方法声明为private，则需要在调用此invoke()方法之前，显示调用方法对象的setAccessible(true)方法，将可访问private的方法</li>
</ol>
<h5 id="6-2-调用属性"><a href="#6-2-调用属性" class="headerlink" title="6.2 调用属性"></a>6.2 调用属性</h5><p>在反射机制中，可以直接通过Field类操作类中的属性，通过Field类提供的set()和get()方法就可以完成设置和取得属性内容的操作</p>
<ul>
<li>public Field getField(String name)返回此Class对象表示的类或接口的指定的public的Field</li>
<li>public Field getDeclaredField(String name)返回此Class对象表示的类或接口的指定的Field</li>
<li>在Field中：<ul>
<li>public Object get(Object obj)取得指定对象obj上此Field的属性内容</li>
<li>public void set(Object obj, Object value)设置指定对象obj上此Field的属性内容</li>
</ul>
</li>
</ul>
<h5 id="6-3-关于setAccessible方法的使用"><a href="#6-3-关于setAccessible方法的使用" class="headerlink" title="6.3 关于setAccessible方法的使用"></a>6.3 关于setAccessible方法的使用</h5><ul>
<li>Method和Field、Constructor对象都有setAccessible()方法</li>
<li>setAccessible启动和禁用访问安全检查的开关</li>
<li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检查<ul>
<li>提高反射的效率。如果代码中必须使用放射，而该句代码需要频繁的被调用，那么请设置为true</li>
<li>使得原本无法访问的私有成员也可以访问</li>
</ul>
</li>
<li>参数值为false则指示反射的对象应该实施Java语言访问检查</li>
</ul>
<h4 id="7-反射的引用：动态代理"><a href="#7-反射的引用：动态代理" class="headerlink" title="7.反射的引用：动态代理"></a>7.反射的引用：动态代理</h4><h5 id="7-1-代理设计模式的原理"><a href="#7-1-代理设计模式的原理" class="headerlink" title="7.1 代理设计模式的原理"></a>7.1 代理设计模式的原理</h5><p>使用一个代理将对象包装起来，然后用该代理取得原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上</p>
<ul>
<li><p>动态代理是指客户通过代理类来调用其他对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象</p>
</li>
<li><p>动态代理使用场合</p>
<ul>
<li>调试</li>
<li>远程方法调用</li>
</ul>
</li>
<li><p>动态代理相比于静态代理的优点</p>
<p>抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活统一的处理众多的方法</p>
</li>
</ul>
<h5 id="7-2-Java动态代理相关API"><a href="#7-2-Java动态代理相关API" class="headerlink" title="7.2 Java动态代理相关API"></a>7.2 Java动态代理相关API</h5><ul>
<li>Proxy：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态的生成实现类</li>
<li>提供用于创建动态代理类和动态代理对象的静态方法<ul>
<li>static Class<?> getProxyClass(ClassLoader loader, Class<?> … interface)创建一个动态代理类所对应的Class对象</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108061451071.png" alt="image-20210806145058217"></li>
</ul>
</li>
</ul>
<h5 id="7-3-动态代理步骤"><a href="#7-3-动态代理步骤" class="headerlink" title="7.3 动态代理步骤"></a>7.3 动态代理步骤</h5><ol>
<li><p>创建一个实现接口InvocationHandler的类，它必须实现invoke方法，以完成代理的具体操作。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108162129142.jpg" alt="Inked202108061453500_LI"></p>
</li>
<li><p>创建被代理的类以及接口</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108061453573.png" alt="image-20210806145355114"></p>
</li>
<li><p>通过Proxy的静态方法 newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h) 创建 一个Subject接口代理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RealSubject target = <span class="keyword">new</span> RealSubject();</span><br><span class="line"><span class="comment">// Create a proxy to wrap the original implementation</span></span><br><span class="line">DebugProxy proxy = <span class="keyword">new</span> DebugProxy(target);</span><br><span class="line"><span class="comment">// Get a reference to the proxy through the Subject interface</span></span><br><span class="line">Subject sub = (Subject) Proxy.newProxyInstance(</span><br><span class="line">Subject.class.getClassLoader(),<span class="keyword">new</span> Class[] &#123; Subject.class &#125;, proxy);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 Subject代理调用RealSubject实现类的方法</p>
<p><code>String info = sub.say(“Peter&quot;, 24);</code></p>
<p><code>System.out.println(info);</code></p>
</li>
</ol>
<h5 id="7-4-动态代理与AOP（Aspect-Orient-Programming"><a href="#7-4-动态代理与AOP（Aspect-Orient-Programming" class="headerlink" title="7.4 动态代理与AOP（Aspect Orient Programming)"></a>7.4 动态代理与AOP（Aspect Orient Programming)</h5><p>前面介绍的Proxy和InvocationHandler，很难看出这种动态代理的优势，下 面介绍一种更实用的动态代理机制</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108162131985.jpg" alt="Inked202108061456771_LI"></p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108061457620.png" alt="image-20210806145706453"></p>
<blockquote>
<p>改进后的说明：代码段1、代码段2、代码段3和深色代码段分离开了，但代码段1、2、3又和 一个特定的方法A耦合了！最理想的效果是：代码块1、2、3既可以执行方法A，又无须在程序 中以硬编码的方式直接调用深色代码的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuntingDog</span> <span class="keyword">implements</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我是一只猎狗&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;我奔跑迅速&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogUtil</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;=====模拟通用方法一=====&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;=====模拟通用方法二=====&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">	<span class="comment">// 需要被代理的对象</span></span><br><span class="line">	<span class="keyword">private</span> Object target;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.target = target;&#125;</span><br><span class="line">	<span class="comment">// 执行动态代理对象的所有方法时，都会被替换成执行如下的invoke方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">			DogUtil du = <span class="keyword">new</span> DogUtil();</span><br><span class="line">			<span class="comment">// 执行DogUtil对象中的method1。</span></span><br><span class="line">			du.method1();</span><br><span class="line">			<span class="comment">// 以target作为主调来执行method方法</span></span><br><span class="line">			Object result = method.invoke(target , args);</span><br><span class="line">			<span class="comment">// 执行DogUtil对象中的method2。</span></span><br><span class="line">			du.method2();</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProxyFactory</span></span>&#123;</span><br><span class="line">	<span class="comment">// 为指定target生成动态代理对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxy</span><span class="params">(Object target)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个MyInvokationHandler对象</span></span><br><span class="line">		MyInvokationHandler handler = </span><br><span class="line">		<span class="keyword">new</span> MyInvokationHandler();</span><br><span class="line">		<span class="comment">// 为MyInvokationHandler设置target对象</span></span><br><span class="line">		handler.setTarget(target);</span><br><span class="line">		<span class="comment">// 创建、并返回一个动态代理对象</span></span><br><span class="line">		<span class="keyword">return</span> </span><br><span class="line">		Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces() , handler);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个原始的HuntingDog对象，作为target</span></span><br><span class="line">		Dog target = <span class="keyword">new</span> HuntingDog();</span><br><span class="line">		<span class="comment">// 以指定的target来创建动态代理</span></span><br><span class="line">		Dog dog = (Dog)MyProxyFactory.getProxy(target);</span><br><span class="line">		dog.info();</span><br><span class="line">		dog.run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用Proxy生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有 太大的意义。通常都是为指定的目标对象生成动态代理</li>
<li>这种动态代理在AOP中被称为AOP代理，AOP代理可代替目标对象，AOP代理 包含了目标对象的全部方法。但AOP代理中的方法与目标对象的方法存在差异： AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108061502837.png" alt="image-20210806150224762"></li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git原理(03)</title>
    <url>/2021/09/17/Git%E5%8E%9F%E7%90%86%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D3/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="18-本地分支和远程分支"><a href="#18-本地分支和远程分支" class="headerlink" title="18. 本地分支和远程分支"></a>18. 本地分支和远程分支</h3><p>新建文件夹，将远程仓库克隆到本地</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108240833804.png" alt="image-20210824083327654"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/xiongzhuozhuo/2021-git-demo.git</span></span><br><span class="line">Cloning into &#x27;2021-git-demo&#x27;...</span><br><span class="line">remote: Enumerating objects: 17, done.</span><br><span class="line">remote: Counting objects: 100% (17/17), done.</span><br><span class="line">remote: Compressing objects: 100% (11/11), done.</span><br><span class="line">remote: Total 17 (delta 3), reused 10 (delta 1), pack-reused 0</span><br><span class="line">Receiving objects: 100% (17/17), 4.28 KiB | 548.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (3/3), done.</span><br></pre></td></tr></table></figure>

<p>克隆的仓库只有一个master分支，且是默认分支</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108240841646.png" alt="image-20210824084144741" style="zoom:50%;" />

<p>克隆完远程仓库后，本地仓库也会新建出一个master分支 ，这个分支就是远程仓库的默认分支。</p>
<p>①查看本地分支<code>git branch</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> 2021-git-demo/</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>②查看远程分支<code>git branch -r</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line">  origin/HEAD -&gt; origin/master</span><br><span class="line">  origin/master</span><br></pre></td></tr></table></figure>

<p>③查看refs</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-clone\2021-git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/refs /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-CLONE\2021-GIT-DEMO\.GIT\REFS</span><br><span class="line">├─heads</span><br><span class="line">│      master  #本地分支</span><br><span class="line">│</span><br><span class="line">├─remotes     #远程分支</span><br><span class="line">│  └─origin</span><br><span class="line">│          HEAD</span><br><span class="line">│</span><br><span class="line">└─tags</span><br></pre></td></tr></table></figure>

<p>④refs里只有远程的HEAD，没有远程的分支，远程的分支被放在了<code>packed-refs</code>里了，查看该文件内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/packed-refs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pack-refs with: peeled fully-peeled sorted</span></span><br><span class="line">70795aa27f962c60c6c139dcb390492cf5f6b615 refs/remotes/origin/master</span><br></pre></td></tr></table></figure>

<p>文件存储了远程的master分支所指向的commit</p>
<p>⑤查看提交历史</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 70795aa27f962c60c6c139dcb390492cf5f6b615 (HEAD -&gt; master, origin/master, origin/HEAD)</span><br><span class="line">Author: xiong &lt;68106285+xiongzhuozhuo@users.noreply.github.com&gt;</span><br><span class="line">Date:   Sun Aug 22 12:26:02 2021 +0800</span><br><span class="line"></span><br><span class="line">    Update README.md</span><br><span class="line"></span><br><span class="line">commit 7a2612b3ae1e6fd6824781d3dd921608adb6a619</span><br><span class="line">Author: xiong &lt;68106285+xiongzhuozhuo@users.noreply.github.com&gt;</span><br><span class="line">Date:   Sun Aug 22 12:16:09 2021 +0800</span><br><span class="line"></span><br><span class="line">    Create README.md</span><br><span class="line"></span><br><span class="line">commit a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 17:10:05 2021 +0800</span><br><span class="line"></span><br><span class="line">    3rd commit</span><br><span class="line"></span><br><span class="line">commit 1928061d327bfa64a0a6ce3f4faa029b8c1ce776</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 16:14:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 8a44e8c0e81d4766b22777a61f3233d8b14497cc</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 15:37:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br></pre></td></tr></table></figure>

<hr>
<p>模拟远程仓库有人进行提交</p>
<p>①仓库的初始情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/packed-refs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pack-refs with: peeled fully-peeled sorted</span></span><br><span class="line">70795aa27f962c60c6c139dcb390492cf5f6b615 refs/remotes/origin/master</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/refs/heads/master</span></span><br><span class="line">70795aa27f962c60c6c139dcb390492cf5f6b615</span><br></pre></td></tr></table></figure>

<p>远程分支与本地分支指向的commit相同</p>
<p>②在远程仓库修改file1.txt</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108240931983.png" alt="image-20210824093058140" style="zoom:50%;" /> 

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108240932020.png" alt="image-20210824093235863"></p>
<p>查看远程的origin</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/packed-refs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pack-refs with: peeled fully-peeled sorted</span></span><br><span class="line">70795aa27f962c60c6c139dcb390492cf5f6b615 refs/remotes/origin/master</span><br></pre></td></tr></table></figure>

<p>使用<code>git fetch</code>与远程进行同步</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch</span></span><br><span class="line">remote: Enumerating objects: 5, done.</span><br><span class="line">remote: Counting objects: 100% (5/5), done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), 648 bytes | 64.00 KiB/s, done.</span><br><span class="line">From https://github.com/xiongzhuozhuo/2021-git-demo</span><br><span class="line">   70795aa..278dcf6  master     -&gt; origin/master</span><br></pre></td></tr></table></figure>

<p>再次查看远程origin：仍未发生改变</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/packed-refs</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> pack-refs with: peeled fully-peeled sorted</span></span><br><span class="line">70795aa27f962c60c6c139dcb390492cf5f6b615 refs/remotes/origin/master</span><br></pre></td></tr></table></figure>

<p>查看refs：出现了master</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-clone\2021-git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/refs /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-CLONE\2021-GIT-DEMO\.GIT\REFS</span><br><span class="line">├─heads</span><br><span class="line">│      master</span><br><span class="line">│</span><br><span class="line">├─remotes</span><br><span class="line">│  └─origin</span><br><span class="line">│          HEAD</span><br><span class="line">│          master</span><br><span class="line">│</span><br><span class="line">└─tags</span><br></pre></td></tr></table></figure>

<p>查看master：指向的是最新的一次提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/refs/remotes/origin/master</span></span><br><span class="line">278dcf612bf8e033a15c9b429adbb32b0a9210b6</span><br></pre></td></tr></table></figure>

<p>出现的原因，packed-refs不是实时的压缩，是在某个时间点进行的，所以不同步。</p>
<hr>
<p>在本地查看提交历史</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 70795aa27f962c60c6c139dcb390492cf5f6b615 (HEAD -&gt; master)</span><br><span class="line">Author: xiong &lt;68106285+xiongzhuozhuo@users.noreply.github.com&gt;</span><br><span class="line">Date:   Sun Aug 22 12:26:02 2021 +0800</span><br><span class="line"></span><br><span class="line">    Update README.md</span><br><span class="line"></span><br><span class="line">commit 7a2612b3ae1e6fd6824781d3dd921608adb6a619</span><br><span class="line">Author: xiong &lt;68106285+xiongzhuozhuo@users.noreply.github.com&gt;</span><br><span class="line">Date:   Sun Aug 22 12:16:09 2021 +0800</span><br><span class="line"></span><br><span class="line">    Create README.md</span><br><span class="line"></span><br><span class="line">commit a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 17:10:05 2021 +0800</span><br><span class="line"></span><br><span class="line">    3rd commit</span><br><span class="line"></span><br><span class="line">commit 1928061d327bfa64a0a6ce3f4faa029b8c1ce776</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 16:14:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 8a44e8c0e81d4766b22777a61f3233d8b14497cc</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 15:37:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br></pre></td></tr></table></figure>

<p>origin/master, origin/HEAD与现在的指向不一样了，因为远程仓库进行了一次提交，现在它超前一次本地提交</p>
<hr>
<p><strong>一些命令</strong></p>
<p><code>git branch -a</code>：列出本地和远程所有的分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure>

<p><code>git remote -v</code>：fetch与push的远程仓库信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line">origin  https://github.com/xiongzhuozhuo/2021-git-demo.git (fetch)</span><br><span class="line">origin  https://github.com/xiongzhuozhuo/2021-git-demo.git (push)</span><br></pre></td></tr></table></figure>

<p><code>git remote show origin</code>：给出远程仓库的的信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line">  Push  URL: https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branch:</span><br><span class="line">    master tracked</span><br><span class="line">  Local branch configured for &#x27;git pull&#x27;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &#x27;git push&#x27;:</span><br><span class="line">    master pushes to master (local out of date)</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>修改远程仓库的分支</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108241003112.png" alt="image-20210824100348299" style="zoom:50%;" /> 

<p><code>git remote show origin</code>：显示远程仓库信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line">  Push  URL: https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    dev    new (next fetch will store in remotes/origin)</span><br><span class="line">    master tracked</span><br><span class="line">  Local branch configured for &#x27;git pull&#x27;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &#x27;git push&#x27;:</span><br><span class="line">    master pushes to master (local out of date)</span><br></pre></td></tr></table></figure>

<p><code> dev    new (next fetch will store in remotes/origin)</code>：检测到远程仓库有新分支产生，使用fetch来存储信息到remotes/origin(如果不进行同步，本地存储的关于远程仓库的信息就仍然是旧的)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch</span></span><br><span class="line">From https://github.com/xiongzhuozhuo/2021-git-demo</span><br><span class="line"> * [new branch]      dev        -&gt; origin/dev</span><br></pre></td></tr></table></figure>

<p>再次使用<code>git remote show origin</code>：就会显示dev tracked</p>
<hr>
<p><strong>删除远程分支</strong></p>
<p><code>git fetch</code>对于远程分支被删除的情况是不做任何反应的，它只会将远程仓库新增的信息抓取到本地</p>
<p>使用<code>git remote show origin</code>查看远程仓库信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line">  Push  URL: https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    master                  tracked</span><br><span class="line">    refs/remotes/origin/dev stale (use &#x27;git remote prune&#x27; to remove)</span><br><span class="line">  Local branch configured for &#x27;git pull&#x27;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &#x27;git push&#x27;:</span><br><span class="line">    master pushes to master (local out of date)</span><br></pre></td></tr></table></figure>

<p><code>refs/remotes/origin/dev stale (use &#39;git remote prune&#39; to remove)</code>：检测到dev是过期的，让用户使用<code>git remote prune</code>去移除这个垃圾对象，实际上也可以通过<code>git fetch --prune</code>进行移除。</p>
<p>使用<code>git fetch --prune</code>时，它会先将本地有而远程没有的进行修剪，然后再进行抓取</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch --prune</span></span><br><span class="line">From https://github.com/xiongzhuozhuo/2021-git-demo</span><br><span class="line"> - [deleted]         (none)     -&gt; origin/dev</span><br></pre></td></tr></table></figure>



<h3 id="19-git-fetch-amp-git-pull"><a href="#19-git-fetch-amp-git-pull" class="headerlink" title="19. git fetch &amp; git pull"></a>19. git fetch &amp; git pull</h3><p><strong>1.初始状态</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108241050696.png" alt="image-20210824104751038"></p>
<p><strong>2.远程仓库更新一次提交，本地仓库使用fetch抓取更新</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108241054966.png" alt="image-20210824105452484"></p>
<p><strong>3.执行git merge origin/master，合并分支</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108241058827.png" alt="image-20210824105849505"></p>
<p><strong>4.远程仓库有一次提交，本地仓库在未fetch的情况下更新一次提交，同时进行git fetch 抓取远程仓库</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108241109457.png" alt="image-20210824110936322"></p>
<p><strong>5.执行git merge origin/master</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108241113696.png" alt="image-20210824111351495"></p>
<p><strong>6. 执行git push origin master</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108241115446.png" alt="image-20210824111542375"></p>
<p><code>git pull</code>可以一次性代替<code>git fetch</code>和<code>git merge origin/master</code>将本地仓库推送到远程仓库</p>
<h3 id="20-FETCH-HEAD与git-pull"><a href="#20-FETCH-HEAD与git-pull" class="headerlink" title="20. FETCH_HEAD与git pull"></a>20. FETCH_HEAD与git pull</h3><p>如果是在某个分支上去执行了<code>git fetch</code>，则排在FETCH_HEAD第一行的就是当前分支所对应的远程分支所对应的最新一次commit，只要切换分支并运行了<code>git fetch</code>那么FETCH_HEAD里的内容顺序就会改变</p>
<p><strong>验证</strong></p>
<ol>
<li><p>在远程仓库创建新的分支dev</p>
</li>
<li><p>并在新分支上做一次commit</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108241227860.png" alt="image-20210824122743203"></p>
</li>
<li><p><code>git remote show origin</code>查看远程仓库信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line">  Push  URL: https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    dev    new (next fetch will store in remotes/origin)</span><br><span class="line">    master tracked</span><br><span class="line">  Local branch configured for &#x27;git pull&#x27;:</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local ref configured for &#x27;git push&#x27;:</span><br><span class="line">    master pushes to master (local out of date)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>git fetch</code>拉取远程仓库更新</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch</span></span><br><span class="line">remote: Enumerating objects: 4, done.</span><br><span class="line">remote: Counting objects: 100% (4/4), done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), 660 bytes | 22.00 KiB/s, done.</span><br><span class="line">From https://github.com/xiongzhuozhuo/2021-git-demo</span><br><span class="line"> * [new branch]      dev        -&gt; origin/dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看objects文件内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-clone\2021-git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-CLONE\2021-GIT-DEMO\.GIT</span><br><span class="line">│  config</span><br><span class="line">│  description</span><br><span class="line">│  FETCH_HEAD  #新增</span><br><span class="line">│  HEAD</span><br><span class="line">│  index</span><br><span class="line">│  packed-refs</span><br><span class="line">│</span><br><span class="line">├─hooks</span><br><span class="line">│      applypatch-msg.sample</span><br><span class="line">│      commit-msg.sample</span><br><span class="line">│      fsmonitor-watchman.sample</span><br><span class="line">│      post-update.sample</span><br><span class="line">│      pre-applypatch.sample</span><br><span class="line">│      pre-commit.sample</span><br><span class="line">│      pre-merge-commit.sample</span><br><span class="line">│      pre-push.sample</span><br><span class="line">│      pre-rebase.sample</span><br><span class="line">│      pre-receive.sample</span><br><span class="line">│      prepare-commit-msg.sample</span><br><span class="line">│      push-to-checkout.sample</span><br><span class="line">│      update.sample</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">│      exclude</span><br><span class="line">│</span><br><span class="line">├─logs</span><br><span class="line">│  │  HEAD</span><br><span class="line">│  │</span><br><span class="line">│  └─refs</span><br><span class="line">│      ├─heads</span><br><span class="line">│      │      master</span><br><span class="line">│      │</span><br><span class="line">│      └─remotes</span><br><span class="line">│          └─origin</span><br><span class="line">│                  dev #新增</span><br><span class="line">│                  HEAD</span><br><span class="line">│                  master</span><br><span class="line">│</span><br><span class="line">├─objects</span><br><span class="line">│  ├─1a</span><br><span class="line">│  │      4a4bc16d7019273dfacb0060e1cb654e8b4e11</span><br><span class="line">│  │</span><br><span class="line">│  ├─27</span><br><span class="line">│  │      8dcf612bf8e033a15c9b429adbb32b0a9210b6</span><br><span class="line">│  │</span><br><span class="line">│  ├─7c</span><br><span class="line">│  │      8ac2f8d82a1eb5f6aaece6629ff11015f91eb4</span><br><span class="line">│  │</span><br><span class="line">│  ├─b8</span><br><span class="line">│  │      db963d8a1508baf093baf5e7f9424d3e384717</span><br><span class="line">│  │</span><br><span class="line">│  ├─ba</span><br><span class="line">│  │      b3f8573c3317c30242494a0f48d1c99d97eabe</span><br><span class="line">│  │</span><br><span class="line">│  ├─da</span><br><span class="line">│  │      1f73460673c0e876e2995d4a44889d75372bef</span><br><span class="line">│  │</span><br><span class="line">│  ├─info</span><br><span class="line">│  └─pack</span><br><span class="line">│          pack-531f25c34d918bbf4e84a1004317c263c51a18aa.idx</span><br><span class="line">│          pack-531f25c34d918bbf4e84a1004317c263c51a18aa.pack</span><br><span class="line">│</span><br><span class="line">└─refs</span><br><span class="line">    ├─heads</span><br><span class="line">    │      master</span><br><span class="line">    │</span><br><span class="line">    ├─remotes</span><br><span class="line">    │  └─origin</span><br><span class="line">    │          dev   #新增</span><br><span class="line">    │          HEAD</span><br><span class="line">    │          master</span><br><span class="line">    │</span><br><span class="line">    └─tags</span><br></pre></td></tr></table></figure>

<p>虽然抓取了远程新增的dev分支，但是本地的heads里没有dev分支信息</p>
</li>
<li><p>查看新增的FETCH_HEAD文件内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/FETCH_HEAD</span></span><br><span class="line">278dcf612bf8e033a15c9b429adbb32b0a9210b6                branch &#x27;master&#x27; of https://github.com/xiongzhuozhuo/2021-git-demo</span><br><span class="line">da1f73460673c0e876e2995d4a44889d75372bef        not-for-merge   branch &#x27;dev&#x27; of https://github.com/xiongzhuozhuo/2021-git-demo</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>git checkout dev</code>，本地会新建一个dev分支，并与远程的dev分支进行关联</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -vv</span></span><br><span class="line">* master 70795aa [origin/master: behind 1] Update README.md</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev</span></span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -vv</span></span><br><span class="line">* dev    da1f734 [origin/dev] Create file3.txt</span><br><span class="line">  master 70795aa [origin/master: behind 1] Update README.md</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看FETCH_HEAD内容：没有变化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/FETCH_HEAD</span></span><br><span class="line">278dcf612bf8e033a15c9b429adbb32b0a9210b6                branch &#x27;master&#x27; of https://github.com/xiongzhuozhuo/2021-git-demo</span><br><span class="line">da1f73460673c0e876e2995d4a44889d75372bef        not-for-merge   branch &#x27;dev&#x27; of https://github.com/xiongzhuozhuo/2021-git-demo</span><br></pre></td></tr></table></figure>

<p>但是在当前分支上运行<code>git fetch</code>后，再次查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/FETCH_HEAD</span></span><br><span class="line">da1f73460673c0e876e2995d4a44889d75372bef                branch &#x27;dev&#x27; of https://github.com/xiongzhuozhuo/2021-git-demo</span><br><span class="line">278dcf612bf8e033a15c9b429adbb32b0a9210b6        not-for-merge   branch &#x27;master&#x27; of https://github.com/xiongzhuozhuo/2021-git-demo</span><br></pre></td></tr></table></figure>

<p>描述得到验证</p>
</li>
</ol>
<hr>
<p><strong>查看分支状况</strong></p>
<p>此时本地分支和远程分支是同步的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -vv</span></span><br><span class="line">  dev    da1f734 [origin/dev] Create file3.txt</span><br><span class="line">* master 278dcf6 [origin/master] Update file1.txt</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch -v</span></span><br><span class="line">POST git-upload-pack (154 bytes)</span><br><span class="line">From https://github.com/xiongzhuozhuo/2021-git-demo</span><br><span class="line"> = [up to date]      master     -&gt; origin/master</span><br><span class="line"> = [up to date]      dev        -&gt; origin/dev</span><br><span class="line"> </span><br><span class="line"> xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show origin</span></span><br><span class="line">* remote origin</span><br><span class="line">  Fetch URL: https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line">  Push  URL: https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line">  HEAD branch: master</span><br><span class="line">  Remote branches:</span><br><span class="line">    dev    tracked</span><br><span class="line">    master tracked</span><br><span class="line">  Local branches configured for &#x27;git pull&#x27;:</span><br><span class="line">    dev    merges with remote dev</span><br><span class="line">    master merges with remote master</span><br><span class="line">  Local refs configured for &#x27;git push&#x27;:</span><br><span class="line">    dev    pushes to dev    (up to date)</span><br><span class="line">    master pushes to master (up to date)</span><br></pre></td></tr></table></figure>

<p>在远程仓库的dev分支添加一次commit，再执行一次<code>git pull</code>拉取远程仓库的更新</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull -v</span></span><br><span class="line">POST git-upload-pack (154 bytes)</span><br><span class="line">POST git-upload-pack (268 bytes)</span><br><span class="line">remote: Enumerating objects: 5, done.</span><br><span class="line">remote: Counting objects: 100% (5/5), done.</span><br><span class="line">remote: Compressing objects: 100% (2/2), done.</span><br><span class="line">remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), 640 bytes | 42.00 KiB/s, done.</span><br><span class="line">From https://github.com/xiongzhuozhuo/2021-git-demo</span><br><span class="line">   da1f734..53d3f54  dev        -&gt; origin/dev</span><br><span class="line"> = [up to date]      master     -&gt; origin/master</span><br><span class="line">Updating da1f734..53d3f54</span><br><span class="line">Fast-forward</span><br><span class="line"> file3.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>执行<code>git pull</code>时等同于先执行<code>git fetch</code>再执行<code>git merge</code>，查看FETCH_HEAD内容，发现出现在首行的正式dev，得到验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/FETCH_HEAD</span></span><br><span class="line">53d3f54af87b26dc3d774b6741bcd5bb562a70e6                branch &#x27;dev&#x27; of https://github.com/xiongzhuozhuo/2021-git-demo</span><br><span class="line">278dcf612bf8e033a15c9b429adbb32b0a9210b6        not-for-merge   branch &#x27;master&#x27; of https://github.com/xiongzhuozhuo/2021-git-demo</span><br></pre></td></tr></table></figure>



<h3 id="22-git-push"><a href="#22-git-push" class="headerlink" title="22. git push"></a>22. git push</h3><p>如果本地分支与远程分支已经同步，则可以直接使用<code>git push</code>进行推送，如果本地仓库又有新建的分支，而且没有和远程仓库的分支进行关联，则可以使用`git </p>
<p><strong>验证</strong></p>
<ol>
<li><p>查看本地分支与远程分支的同步情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -vv</span></span><br><span class="line">  dev    53d3f54 [origin/dev] Update file3.txt</span><br><span class="line">* master 278dcf6 [origin/master] Update file1.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建一个本地分支，查看分支关联情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b tmp</span></span><br><span class="line">Switched to a new branch &#x27;tmp&#x27;</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -vv</span></span><br><span class="line">  dev    53d3f54 [origin/dev] Update file3.txt</span><br><span class="line">  master 278dcf6 [origin/master] Update file1.txt</span><br><span class="line">* tmp    278dcf6 Update file1.txt</span><br></pre></td></tr></table></figure>

<p>tmp现在没有远程分支进行关联</p>
</li>
<li><p>在tmp分支上进行一次提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;tmp&#x27;</span> &gt; tmp.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add tmp</span></span><br><span class="line">fatal: pathspec &#x27;tmp&#x27; did not match any files</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add tmp.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in tmp.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;commit from tmp&#x27;</span></span></span><br><span class="line">[tmp 11cdb0f] commit from tmp</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 tmp.txt</span><br></pre></td></tr></table></figure>

<p>如果直接<code>git push</code>：当前分支tmp没有上游分支。推送当前分支并将远程分支设置为上游</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br><span class="line">fatal: The current branch tmp has no upstream branch.</span><br><span class="line">To push the current branch and set the remote as upstream, use</span><br><span class="line"></span><br><span class="line">    git push --set-upstream origin tmp</span><br></pre></td></tr></table></figure>

<p><code>--set -upstream</code>：进行关联的选项</p>
<p>先不进行关联，进行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin tmp</span></span><br><span class="line">Enumerating objects: 4, done.</span><br><span class="line">Counting objects: 100% (4/4), done.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 271 bytes | 271.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (1/1), completed with 1 local object.</span><br><span class="line">remote:</span><br><span class="line">remote: Create a pull request for &#x27;tmp&#x27; on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/xiongzhuozhuo/2021-git-demo/pull/new/tmp</span><br><span class="line">remote:</span><br><span class="line">To https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line"> * [new branch]      tmp -&gt; tmp</span><br></pre></td></tr></table></figure>

<p>查看关联情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -vv</span></span><br><span class="line">  dev    53d3f54 [origin/dev] Update file3.txt</span><br><span class="line">  master 278dcf6 [origin/master] Update file1.txt</span><br><span class="line">* tmp    11cdb0f commit from tmp</span><br></pre></td></tr></table></figure>

<p>tmp仍然没有远程分支进行关联，虽然此时远程仓库已经新建有tmp分支</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108241334119.png" alt="image-20210824133448921" style="zoom:50%;" /> 

<p>删除远程分支，测试<code>git push -u</code>命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin -d tmp</span></span><br><span class="line">To https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line"> - [deleted]         tmp</span><br></pre></td></tr></table></figure>

<p>将本地tmp再推送一遍</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin tmp</span></span><br><span class="line">Enumerating objects: 4, done.</span><br><span class="line">Counting objects: 100% (4/4), done.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (3/3), 271 bytes | 271.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 1), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (1/1), completed with 1 local object.</span><br><span class="line">remote:</span><br><span class="line">remote: Create a pull request for &#x27;tmp&#x27; on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/xiongzhuozhuo/2021-git-demo/pull/new/tmp</span><br><span class="line">remote:</span><br><span class="line">To https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line"> * [new branch]      tmp -&gt; tmp</span><br><span class="line">Branch &#x27;tmp&#x27; set up to track remote branch &#x27;tmp&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure>

<p>查看此时关联情况：拥有了关联</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-clone/2021-git-demo (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -vv</span></span><br><span class="line">  dev    53d3f54 [origin/dev] Update file3.txt</span><br><span class="line">  master 278dcf6 [origin/master] Update file1.txt</span><br><span class="line">* tmp    11cdb0f [origin/tmp] commit from tmp</span><br></pre></td></tr></table></figure>

<p>有了关联之后直接使用<code>git push</code>就能进行推送</p>
</li>
</ol>
<h3 id="22-git-hook"><a href="#22-git-hook" class="headerlink" title="22. git hook"></a>22. git hook</h3><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108241344376.png" alt="image-20210824134450124"></p>
<h3 id="23-pre-commit钩子"><a href="#23-pre-commit钩子" class="headerlink" title="23. pre-commit钩子"></a>23. pre-commit钩子</h3><h3 id="24-git-hook和python"><a href="#24-git-hook和python" class="headerlink" title="24. git hook和python"></a>24. git hook和python</h3>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(01)—安装与使用</title>
    <url>/2021/09/17/MySQL(01)%E2%80%94%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><p><strong>图解MySQL程序结构</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171027291.png" alt="image-20210817100754276" style="zoom:50%;" />

<h4 id="1-MySQL数据库产品的介绍"><a href="#1-MySQL数据库产品的介绍" class="headerlink" title="1. MySQL数据库产品的介绍"></a>1. MySQL数据库产品的介绍</h4><h5 id="1-1-MySQL产品的特点"><a href="#1-1-MySQL产品的特点" class="headerlink" title="1.1 MySQL产品的特点"></a>1.1 MySQL产品的特点</h5><ul>
<li><p>MySQL数据库隶属于MySQL AB公司，总部位于瑞典，后被Oracle收购。</p>
</li>
<li><p>优点： </p>
<p>– 成本低：开放源代码，一般可以免费试用 </p>
<p>– 性能高：执行很快 </p>
<p>– 简单：很容易安装和使用</p>
</li>
</ul>
<h4 id="2-MySQL数据库的安装"><a href="#2-MySQL数据库的安装" class="headerlink" title="2. MySQL数据库的安装"></a>2. MySQL数据库的安装</h4><ul>
<li><p>DBMS分为两类： </p>
<p>– 基于共享文件系统的DBMS （Access ） </p>
<p>– 基于客户机——服务器的DBMS （MySQL、Oracle、SqlServer）</p>
</li>
<li><p>MySQL的版本</p>
<ul>
<li><p>社区版（免费）</p>
</li>
<li><p>企业版（收费）</p>
<p>Windows平台下下载：<a href="http://dev.mysql.com/downloads/mysql">http://dev.mysql.com/downloads/mysql</a></p>
</li>
</ul>
</li>
</ul>
<h5 id="2-1下载"><a href="#2-1下载" class="headerlink" title="2.1下载"></a>2.1下载</h5><p>Windows安装程序MySQL Installer MSI。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171030928.png" alt="image-20210817103058472"></p>
<p>下载离线安装版（文件大的那个）。需要注意的是，这里的32-bit是指安装程序Installer是32位，并非指下载的MySQL是32位，实际上MySQL会适应系统位数。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171029732.png" alt="image-20210817102936648"></p>
<p>点击**”No thanks, just start my download”**开始下载。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171028108.png" alt="image-20210817102826741"></p>
<h5 id="2-2-安装"><a href="#2-2-安装" class="headerlink" title="2.2 安装"></a>2.2 安装</h5><p>下载完成之后双击安装，可以选择自定义安装。</p>
<p> <img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171017712.png" alt="img"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171048497.png" alt="image-20210817104842064"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171050085.png" alt="image-20210817104958534"></p>
<p>我一般安装以下两个就够。具体情况请根据你的实际需求。</p>
<p>MySQL Server 8.0.26 - X64：服务器</p>
<p>MySQL Workench 8.0.26 - X64：数据可视化管理工具</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171104207.png" alt="image-20210817110434593"></p>
<p>一路执行或下一步。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171107298.png" alt="image-20210817110700697"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171108111.png" alt="image-20210817110839698"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171109803.png" alt="image-20210817110919637"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171110503.png" alt="image-20210817111049201"></p>
<p>这一步要注意，最好选择传统密码验证方式，否则使用第三方数据库管理软件在连接时会报错。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171111872.png" alt="image-20210817111151168"></p>
<p>密码很重要，本人设置密码与锁屏密码一致，便于记忆</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171137068.png" alt="image-20210817113736168"></p>
<p>Windows Service Name: Windows托管服务名，用于停止、启动</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171139109.png" alt="image-20210817113910167"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171141021.png" alt="image-20210817114145727"></p>
<p> <img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171142899.png" alt="image-20210817114218504"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171142563.png" alt="image-20210817114243171"></p>
<p> <img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171143976.png" alt="image-20210817114306719"></p>
<p>添加MySQL系统环境变量。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171145920.png" alt="image-20210817114532726"></p>
<p>到此，安装完成！ </p>
<h5 id="2-3-验证登陆"><a href="#2-3-验证登陆" class="headerlink" title="2.3 验证登陆"></a>2.3 验证登陆</h5><p>打开管理员CMD，输入密码。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171149249.png" alt="image-20210817114954715"></p>
<h5 id="2-4-使用workbench可视化工具"><a href="#2-4-使用workbench可视化工具" class="headerlink" title="2.4 使用workbench可视化工具"></a>2.4 使用workbench可视化工具</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171151817.png" alt="image-20210817115112191"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171152038.png" alt="image-20210817115234402"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171153321.png" alt="image-20210817115345133"></p>
<h5 id="2-5-更改MySQL数据存储路径的方法"><a href="#2-5-更改MySQL数据存储路径的方法" class="headerlink" title="2.5 更改MySQL数据存储路径的方法"></a>2.5 更改MySQL数据存储路径的方法</h5><p><strong>先停止mysql服务</strong></p>
<p>(1)停止服务，管理员进入cmd &gt;net stop MySQL (mysql的服务名：查找方法：右键我的电脑–&gt;管理–&gt;服务，然后找到mysql的服务名即可)；</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171158804.png" alt="image-20210817115856877"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171201941.png" alt="image-20210817120106794"></p>
<p>(2)将mysql安装路径下的data目录下的文件（通常是C:\ProgramData\MySQL\MySQL Server\Data）拷贝到自己想要储存的路径如：datadir=C:\Files\MySQLData；</p>
<p>(3)修改”my.ini”配置文件，记事本打开找到Datadir的部分 </p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171203012.png" alt="image-20210817120357477"></p>
<p>修改为： </p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171225736.png" alt="image-20210817122546594"></p>
<p>datadir=C:/Files/MySQLData\Data【备注：这里是”/”而不是”\”，一般的配置文件都这样】</p>
<p>(4)重启mysql服务验证一下是否成功，管理员进入cmd &gt;net start MySQL80</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171226682.png" alt="image-20210817122630329"></p>
<p>接着进入mysql创建一个数据库看一下</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171234450.png" alt="image-20210817123421886"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171234290.png" alt="image-20210817123447043"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;mysql –u root –p</span><br><span class="line">&gt;输入密码</span><br><span class="line">&gt;create database xiong;</span><br></pre></td></tr></table></figure>

<p>可以看到原先的data目录没有生成”xiong”的database，而在我们新建的mysqlData路径目录下多了”xiong”的database。更改到此完毕。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171235349.png" alt="image-20210817123519140"></p>
<h5 id="2-6MySQL卸载"><a href="#2-6MySQL卸载" class="headerlink" title="2.6MySQL卸载"></a>2.6MySQL卸载</h5><h6 id="（1）先停止服务"><a href="#（1）先停止服务" class="headerlink" title="（1）先停止服务"></a>（1）先停止服务</h6><p>服务器名是你安装时写的Windows服务名。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171237110.png" alt="image-20210817123717794"></p>
<h6 id="（2）1-使用安装程序Installer卸载"><a href="#（2）1-使用安装程序Installer卸载" class="headerlink" title="（2）1.使用安装程序Installer卸载"></a>（2）1.使用安装程序Installer卸载</h6><p>安装程序不仅用来安装MySQL（可安装多个不同版本的MySQL服务），还可以用来修复及卸载MySQL。使用它卸载的好处就是能卸载干净，卸载不干净再重装很可能会出问题！</p>
<p>点击Remove</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171239379.png" alt="image-20210817123906965"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108171239001.png" alt="image-20210817123947729"></p>
<p> 完成卸载，重启计算机。</p>
<h6 id="（2）2-使用命令卸载"><a href="#（2）2-使用命令卸载" class="headerlink" title="（2）2.使用命令卸载"></a>（2）2.使用命令卸载</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net stop mysql　　　　　　# 停服务</span><br><span class="line">mysqld remove mysql　　　# 卸载服务</span><br></pre></td></tr></table></figure>

<h5 id="2-7-启动和停止MySQL服务"><a href="#2-7-启动和停止MySQL服务" class="headerlink" title="2.7. 启动和停止MySQL服务"></a>2.7. 启动和停止MySQL服务</h5><ul>
<li><p>方式一：通过计算机管理方式</p>
<p>右击计算机—管理—服务—启动或停止MySQL服务</p>
</li>
<li><p>方式二：通过命令行方式</p>
<p>启动：net start mysql服务名</p>
<p>停止：net stop mysql服务名</p>
</li>
</ul>
<h5 id="2-8-MySQL服务端的登录和退出"><a href="#2-8-MySQL服务端的登录和退出" class="headerlink" title="2.8 MySQL服务端的登录和退出"></a>2.8 MySQL服务端的登录和退出</h5><ul>
<li><p>登录</p>
<p>mysql -h 主机名 -u 用户名 -p 密码</p>
</li>
<li><p>退出</p>
<p>exit</p>
</li>
</ul>
<h4 id="3-MySQL数据库的使用"><a href="#3-MySQL数据库的使用" class="headerlink" title="3. MySQL数据库的使用"></a>3. MySQL数据库的使用</h4><h5 id="3-1-MySQL语法规范"><a href="#3-1-MySQL语法规范" class="headerlink" title="3.1 MySQL语法规范"></a>3.1 MySQL语法规范</h5><ul>
<li>不区分大小写</li>
<li>每句话用;或\g结尾</li>
<li>各子句一般分行写</li>
<li>关键字不能缩写也不能分行</li>
<li>用缩进提高语句的可读性</li>
<li>注释<ul>
<li>单行注释 ：#注释文字</li>
<li>单行注释：– 注释文字</li>
<li>多行注释：/*注释文字*/</li>
</ul>
</li>
</ul>
<ol>
<li><p>进入mysql，在命令行中输入：mysql -uroot -p ####(其中：####表示密码)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Users\xiong</span><br><span class="line"># net start MySQL80</span><br><span class="line">MySQL80 服务正在启动 .</span><br><span class="line">MySQL80 服务已经启动成功。</span><br><span class="line"></span><br><span class="line">xiong@SURFACE-PRO6 C:\Users\xiong</span><br><span class="line"># mysql -h localhost -P 3306 -u root -p</span><br><span class="line">Enter password: ******</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 8</span><br><span class="line">Server version: 8.0.26 MySQL Community Server - GPL</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2021, Oracle and&#x2F;or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and&#x2F;or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建一个数据库：<code>create database 数据库名;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create xiong;</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看mysql中有哪些个数据库：<code>show databases;</code></p>
<p>xiong为自己建立的数据库，其他几个数据库为mysql自带的样例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| xiong              |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用一个数据库：<code>use数据库名称;</code></p>
<p>使用“xiong”数据库，显示 Database changed</p>
<ol>
<li><p>使用<code>show tables;</code>，查看数据库表中的内容，显示为Empty set</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; use xiong                                                                  </span><br><span class="line">Database changed                                                                    </span><br><span class="line">mysql&gt; show tables                                                                  </span><br><span class="line">    -&gt; ;                                                                            </span><br><span class="line">Empty set (0.01 sec)                                                                </span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前所处的数据库：<code>select database();</code></p>
<p>显示处在“xiong”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select database();</span><br><span class="line">+------------+</span><br><span class="line">| database() |</span><br><span class="line">+------------+</span><br><span class="line">| xiong      |</span><br><span class="line">+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在“xiong”里查看“mysql”数据库</p>
<p><code>show tables from 数据库名;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show tables from mysql;</span><br><span class="line">+------------------------------------------------------+</span><br><span class="line">| Tables_in_mysql                                      |</span><br><span class="line">+------------------------------------------------------+</span><br><span class="line">| columns_priv                                         |</span><br><span class="line">| component                                            |</span><br><span class="line">| db                                                   |</span><br><span class="line">| default_roles                                        |</span><br><span class="line">| engine_cost                                          |</span><br><span class="line">| func                                                 |</span><br><span class="line">| general_log                                          |</span><br><span class="line">| global_grants                                        |</span><br><span class="line">| gtid_executed                                        |</span><br><span class="line">| help_category                                        |</span><br><span class="line">| help_keyword                                         |</span><br><span class="line">| help_relation                                        |</span><br><span class="line">| help_topic                                           |</span><br><span class="line">| innodb_index_stats                                   |</span><br><span class="line">| innodb_table_stats                                   |</span><br><span class="line">| password_history                                     |</span><br><span class="line">| plugin                                               |</span><br><span class="line">| procs_priv                                           |</span><br><span class="line">| proxies_priv                                         |</span><br><span class="line">| replication_asynchronous_connection_failover         |</span><br><span class="line">| replication_asynchronous_connection_failover_managed |</span><br><span class="line">| replication_group_configuration_version              |</span><br><span class="line">| replication_group_member_actions                     |</span><br><span class="line">| role_edges                                           |</span><br><span class="line">| server_cost                                          |</span><br><span class="line">| servers                                              |</span><br><span class="line">| slave_master_info                                    |</span><br><span class="line">| slave_relay_log_info                                 |</span><br><span class="line">| slave_worker_info                                    |</span><br><span class="line">| slow_log                                             |</span><br><span class="line">| tables_priv                                          |</span><br><span class="line">| time_zone                                            |</span><br><span class="line">| time_zone_leap_second                                |</span><br><span class="line">| time_zone_name                                       |</span><br><span class="line">| time_zone_transition                                 |</span><br><span class="line">| time_zone_transition_type                            |</span><br><span class="line">| user                                                 |</span><br><span class="line">+------------------------------------------------------+</span><br><span class="line">37 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>在数据库中新建一个表：<code>create database 表名(列名 类型,...);</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table stuinfo(</span><br><span class="line">    -&gt; id int,</span><br><span class="line">    -&gt; name varchar(20)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+-----------------+</span><br><span class="line">| Tables_in_xiong |</span><br><span class="line">+-----------------+</span><br><span class="line">| stuinfo         |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ol>
<li><p>查看表的结构 <code>desc 表名;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc stuinfo;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| id    | int         | YES  |     | NULL    |       |</span><br><span class="line">| name  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在表中添加数据<code>insert into 表名 values(属性1，属性2...) (属性1的值，属性2的值...);</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; desc stuinfo;</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type        | Null | Key | Default | Extra |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">| id    | int         | YES  |     | NULL    |       |</span><br><span class="line">| name  | varchar(20) | YES  |     | NULL    |       |</span><br><span class="line">+-------+-------------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into stuinfo (id, name) values(1001,&#39;小天才&#39;);</span><br><span class="line">Query OK, 1 row affected (0.11 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into stuinfo (id, name) values(1002,&quot;花江&quot;);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from stuinfo;</span><br><span class="line">+------+--------+</span><br><span class="line">| id   | name   |</span><br><span class="line">+------+--------+</span><br><span class="line">| 1001 | 小天才 |</span><br><span class="line">| 1002 | 花江   |</span><br><span class="line">+------+--------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改表中数据 <code>update 表名 set 属性 = xxx where 限制条件;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; update stuinfo</span><br><span class="line">    -&gt; set name &#x3D; &quot;天空龙&quot;</span><br><span class="line">    -&gt; where id &#x3D; 1002;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from stuinfo;</span><br><span class="line">+------+--------+</span><br><span class="line">| id   | name   |</span><br><span class="line">+------+--------+</span><br><span class="line">| 1001 | 小天才 |</span><br><span class="line">| 1002 | 天空龙 |</span><br><span class="line">+------+--------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>查看服务器版本：</p>
<ol>
<li><p>在mysql命令行下：<code>select version();</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+-----------+</span><br><span class="line">| version() |</span><br><span class="line">+-----------+</span><br><span class="line">| 8.0.26    |</span><br><span class="line">+-----------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在cmd下：<code>mysql --version</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Users\xiong</span><br><span class="line"># mysql --version</span><br><span class="line">mysql  Ver 8.0.26 for Win64 on x86_64 (MySQL Community Server - GPL)</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h5 id="3-2-图形化数据库管理软件的使用"><a href="#3-2-图形化数据库管理软件的使用" class="headerlink" title="3.2 图形化数据库管理软件的使用"></a>3.2 图形化数据库管理软件的使用</h5><p>此处以DataGrip为例</p>
<p>1.新建项目</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108172049413.png" alt="image-20210817204911546"></p>
<p>2.选择数据源</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108172048910.png" alt="image-20210817204810167"></p>
<p>3.设置</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108172046663.png" alt="image-20210817204608049"></p>
<p>4.连接成功</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108172047820.png" alt="image-20210817204715308"></p>
<p>5.右键选中的数据库连接。选择Jump to Query Console，即可在控制台中书写sql语句了</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108172109063.png" alt="image-20210817210942876"></p>
<p>6.添加多个数据库源：File –&gt; DataSource –&gt;选择数据源</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108201746453.png" alt="image-20210817211336419" style="zoom:50%;" /> 

<p>点击 + 选择数据库类型，并新建连接</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108172114883.png" alt="image-20210817211437787"></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL(02)—数据处理之查询</title>
    <url>/2021/09/17/MySQL(02)%E2%80%94%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B9%8B%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><p>使用前，对当前数据库写入测试用的数据库脚本，点击下载脚本</p>
<h4 id="1-基本的SELECT语句"><a href="#1-基本的SELECT语句" class="headerlink" title="1. 基本的SELECT语句"></a>1. 基本的SELECT语句</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * | &#123;[DISTINCT] cloumn | expression [alias],...&#125;</span><br><span class="line">FROM table;</span><br></pre></td></tr></table></figure>

<p>SELECT    标识选择哪些列<br>FROM        标识从哪个表中选择</p>
<ol>
<li><p>选择全部列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use myemployees;</span><br><span class="line">select *</span><br><span class="line">from departments;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108172236487.png" alt="image-20210817223641403"></p>
</li>
<li><p>选择特定列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select department_id, location_id</span><br><span class="line">from departments;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108172240127.png" alt="image-20210817224055778" style="zoom:50%;" /> 
</li>
<li><p>使用别名</p>
<p>重命名一个列。 便于计算。紧跟列名，也可以在列名和别名之间加入关键字 ‘AS’，别名使用双引号，以便在别名中包含空 格或特殊的字符并区分大小写</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select last_name as name, commission_pct comm</span><br><span class="line">from employees;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181702327.png" alt="image-20210817224341768" style="zoom: 67%;" /> 

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name &quot;Name&quot;, salary*12 &quot;Annual Salary&quot;</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181702009.png" alt="image-20210817224607348" style="zoom: 50%;" /> 

</li>
</ol>
<p><strong>字符串</strong> </p>
<p> 字符串可以是 SELECT 列表中的一个字符,数字,日期。 </p>
<p> 日期和字符只能在单引号中出现。</p>
<p>每当返回一行时，字符串被输出一次</p>
<p><strong>显示表结构</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DESCRIBE employees;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108172250194.png" alt="image-20210817225013421"></p>
<h4 id="2-过滤和排序数据"><a href="#2-过滤和排序数据" class="headerlink" title="2. 过滤和排序数据"></a>2. 过滤和排序数据</h4><h5 id="2-1-过滤"><a href="#2-1-过滤" class="headerlink" title="2.1 过滤"></a>2.1 过滤</h5><p>使用where子句，将不满足条件的行过滤掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT *|&#123;[DISTINCT] column|expression [alias],...&#125;</span><br><span class="line">FROM table</span><br><span class="line">[WHERE condition(s)];</span><br></pre></td></tr></table></figure>

<p>WHERE 子句紧随 FROM 子句</p>
<p>返回在90号部门工作的所有员工的信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select employee_id,last_name,job_id,department_id</span><br><span class="line">from employees</span><br><span class="line">where department_id &#x3D; 90;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108172254393.png" alt="image-20210817225405029"></p>
<h6 id="2-1-1-比较运算符"><a href="#2-1-1-比较运算符" class="headerlink" title="2.1.1 比较运算符"></a>2.1.1 比较运算符</h6><table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>等于 (不是 ==)</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于、等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>&lt;&gt;</td>
<td>不等于（也可以是!=)</td>
</tr>
</tbody></table>
<p>查询薪资在3000以下的员工的姓氏和薪资</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT last_name, salary</span><br><span class="line">FROM employees</span><br><span class="line">WHERE salary &lt;&#x3D; 3000;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181702407.png" alt="image-20210817225941018" style="zoom:50%;" /> 

<h6 id="2-1-2-1其他比较运算符"><a href="#2-1-2-1其他比较运算符" class="headerlink" title="2.1.2 1其他比较运算符"></a>2.1.2 1其他比较运算符</h6><table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>BETWEEN …AND…</td>
<td>在两个值之间 (包含边界)</td>
</tr>
<tr>
<td>IN(set)</td>
<td>等于值列表中的一个</td>
</tr>
<tr>
<td>LIKE</td>
<td>模糊查询</td>
</tr>
<tr>
<td>IS NULL</td>
<td>空值</td>
</tr>
</tbody></table>
<ol>
<li><p>使用BETWEEN AND运算来显示在一个区间内的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select last_name,salary</span><br><span class="line">from employees</span><br><span class="line">where salary between 2500 and 3500;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>​          <img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181702778.png" alt="image-20210818101509030" style="zoom: 50%;" /></p>
<ol start="2">
<li><p>使用IN运算显示列表中的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select employee_id,last_name,salary,manager_id</span><br><span class="line">from employees</span><br><span class="line">where manager_id in (100,101,201);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181021440.png" alt="image-20210818102130760"></p>
</li>
<li><p>使用LIKE运算选择类似的值</p>
<p>选择条件可以包含字符或数字：</p>
<ul>
<li>%代表零个或多个字符（任意个字符）</li>
<li>_代表一个字符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select first_name</span><br><span class="line">from employees</span><br><span class="line">where first_name like &#39;S%&#39;;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181702056.png" alt="image-20210818102756282" style="zoom:50%;" /> 
</li>
<li><p>使用IS(NOT)NULL判断空值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select last_name,manager_id</span><br><span class="line">from employees</span><br><span class="line">where manager_id is null;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181702584.png" alt="image-20210818104508246" style="zoom: 50%;" /> 

</li>
</ol>
<h6 id="2-1-3-逻辑运算"><a href="#2-1-3-逻辑运算" class="headerlink" title="2.1.3 逻辑运算"></a>2.1.3 逻辑运算</h6><table>
<thead>
<tr>
<th>操作符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>AND</td>
<td>逻辑与</td>
</tr>
<tr>
<td>OR</td>
<td>逻辑或</td>
</tr>
<tr>
<td>NOT</td>
<td>逻辑否</td>
</tr>
</tbody></table>
<ol>
<li><p>AND要求并的关系为真</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select employee_id,last_name,job_id,salary</span><br><span class="line">from employees</span><br><span class="line">where salary &gt;&#x3D; 1000</span><br><span class="line">and job_id like &#39;%MAN%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181052461.png" alt="image-20210818105203409"></p>
</li>
<li><p>OR要求或关系为真</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select employee_id,last_name,job_id,salary</span><br><span class="line">from employees</span><br><span class="line">where salary &gt;&#x3D; 10000</span><br><span class="line">or job_id like &#39;%MAN%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181104628.png" alt="image-20210818110427489"></p>
</li>
<li><p>NOT</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select last_name,job_id</span><br><span class="line">from employees</span><br><span class="line">where job_id</span><br><span class="line">not in (&#39;IT_PROG&#39;,&#39;ST_CLERK&#39;,&#39;SA_REP&#39;);</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181702141.png" alt="image-20210818110731163" style="zoom:50%;" /> 

</li>
</ol>
<h6 id="2-1-4-ORDER-BY子句"><a href="#2-1-4-ORDER-BY子句" class="headerlink" title="2.1.4 ORDER BY子句"></a>2.1.4 ORDER BY子句</h6><p>使用ORDER BY子句排序</p>
<ul>
<li>ASC(ascend)：升序</li>
<li>DESC(descend)：降序</li>
<li>ORDER BY子句在SELECT语句的结尾</li>
</ul>
<ol>
<li><p>默认使用升序排列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select last_name,job_id,department_id,heirdate</span><br><span class="line">from employees</span><br><span class="line">order by hiredate;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181114297.png" alt="image-20210818111440587"></p>
</li>
<li><p>使用降序排列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select last_name,job_id,department_id,hiredate</span><br><span class="line">from employees</span><br><span class="line">order by hiredate desc;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181126715.png" alt="image-20210818112612280"></p>
</li>
<li><p>按别名排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select employee_id,last_name,salary*12 &#39;annual salary&#39;</span><br><span class="line">from employees</span><br><span class="line">order by &#39;annual salary&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181132667.png" alt="image-20210818113244031"></p>
</li>
<li><p>按照ORDER BY列表的顺序排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select last_name,department_id,salary</span><br><span class="line">from employees</span><br><span class="line">order by department_id,salary desc;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181136217.png" alt="image-20210818113616110"></p>
<p>可以使用不在SELECT列表里中的列排序</p>
</li>
</ol>
<h4 id="3-分组函数"><a href="#3-分组函数" class="headerlink" title="3. 分组函数"></a>3. 分组函数</h4><h5 id="3-1-什么是分组函数"><a href="#3-1-什么是分组函数" class="headerlink" title="3.1 什么是分组函数"></a>3.1 什么是分组函数</h5><p>分组函数作用于一组数据，并对一组数据返回一个值</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181142674.png" alt="image-20210818114256311"></p>
<h5 id="3-2-组函数类型"><a href="#3-2-组函数类型" class="headerlink" title="3.2 组函数类型"></a>3.2 组函数类型</h5><ul>
<li>AVG()</li>
<li>COUNT()</li>
<li>MAX()</li>
<li>MIN()</li>
<li>SUM()</li>
</ul>
<h5 id="3-3-组函数语法"><a href="#3-3-组函数语法" class="headerlink" title="3.3 组函数语法"></a>3.3 组函数语法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT [column,] group_function(column), ...</span><br><span class="line">FROM table</span><br><span class="line">[WHERE condition]</span><br><span class="line">[GROUP BY column]</span><br><span class="line">[ORDER BY column];</span><br></pre></td></tr></table></figure>

<ol>
<li><p>AVG(平均值)、MIN(最小值)、 MAX(最大值)、SUM(合计)函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select avg(salary),max(salary),min(salary),sum(salary)</span><br><span class="line">from employees</span><br><span class="line">where job_id like &#39;%REP%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181701771.png" alt="image-20210818114856880"></p>
</li>
<li><p>COUNT(*)返回表中记录总数，适用于任意数据类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count(*)</span><br><span class="line">from employees</span><br><span class="line">where department_id &#x3D; 50;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181701166.png" alt="image-20210818115408365" style="zoom:50%;" /> 

<p>COUNT(expr)返回expr不为空的记录总数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select last_name,count(commission_pct)</span><br><span class="line">from employees</span><br><span class="line">where department_id &#x3D; 50;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181701531.png" alt="image-20210818115815622" style="zoom:50%;" /> 

</li>
</ol>
<h5 id="3-4-分组数据"><a href="#3-4-分组数据" class="headerlink" title="3.4 分组数据"></a>3.4 分组数据</h5><h6 id="3-4-1-单列分组"><a href="#3-4-1-单列分组" class="headerlink" title="3.4.1 单列分组"></a>3.4.1 单列分组</h6><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181159664.png" alt="image-20210818115909354"></p>
<p>GROUP BY子句语法，可以使用GROUP BY子句将表中的数据分成若干组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT column, group_function(column)</span><br><span class="line">FROM table</span><br><span class="line">[WHERE condition]</span><br><span class="line">[GROUP BY group_by_expression]</span><br><span class="line">[ORDER BY column];</span><br></pre></td></tr></table></figure>

<p>明确：WHERE一定放在FROM后面</p>
<ol>
<li><p>在SELECT 列表中所有未包含在组函数中的列都应该包含 在 GROUP BY 子句中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select department_id,AVG(salary)</span><br><span class="line">from employees</span><br><span class="line">group by department_id;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181701632.png" alt="image-20210818120451894" style="zoom:50%;" /> 
</li>
<li><p>包含在GROUP BY子句中的列不必包含在SELECT列表中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select avg(salary)</span><br><span class="line">from employees</span><br><span class="line">group by department_id;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181701071.png" alt="image-20210818121325998" style="zoom:50%;" /> 

</li>
</ol>
<h6 id="3-4-2-多列分组"><a href="#3-4-2-多列分组" class="headerlink" title="3.4.2 多列分组"></a>3.4.2 多列分组</h6><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181215576.png" alt="image-20210818121522543"></p>
<ol>
<li><p>在GROUP BY子句中包含多个列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select department_id,dept_id,job_id,sum(salary)</span><br><span class="line">from employees</span><br><span class="line">group by department_id,job_id;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181223117.png" alt="image-20210818122333093" style="zoom:50%;" /> 

</li>
</ol>
<h6 id="3-4-3-过滤分组"><a href="#3-4-3-过滤分组" class="headerlink" title="3.4.3 过滤分组"></a>3.4.3 过滤分组</h6><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181545183.png" alt="image-20210818154507053"></p>
<p>使用HAVING过滤分组</p>
<ol>
<li><p>行已经被分组</p>
</li>
<li><p>使用了组函数</p>
</li>
<li><p>满足HAVING子句中条件的分组将被显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT column, group_function</span><br><span class="line">FROM table</span><br><span class="line">[WHERE condition]</span><br><span class="line">[GROUP BY group_by_expression]</span><br><span class="line">[HAVING group_condition]</span><br><span class="line">[ORDER BY column];</span><br></pre></td></tr></table></figure>
</li>
<li><p>HAVING子句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select department_id,MAX(salary)</span><br><span class="line">from employees</span><br><span class="line">group by department_id</span><br><span class="line">having max(salary)&gt;10000;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181701982.png" alt="image-20210818155219393" style="zoom:50%;" /> 

</li>
</ol>
<h6 id="3-4-4-SELECT语句执行顺序"><a href="#3-4-4-SELECT语句执行顺序" class="headerlink" title="3.4.4 SELECT语句执行顺序"></a>3.4.4 <a href="https://www.cnblogs.com/warehouse/p/9410599.html">SELECT语句执行顺序</a></h6><p>having子句与where都是设定条件筛选的语句，有相似之处也有区别。</p>
<p>having与where的区别:<br>having是在分组后对数据进行过滤<br>where是在分组前对数据进行过滤<br>having后面可以使用聚合函数<br>where后面不可以使用聚合</p>
<p>在查询过程中执行顺序：from&gt;where&gt;group（含聚合）&gt;having&gt;order&gt;select。</p>
<p>所以聚合语句(sum,min,max,avg,count)要比having子句优先执行，而where子句在查询过程中执行优先级别优先于聚合语句(sum,min,max,avg,count)。<br>where子句：<br>select sum(num) as rmb from order where id&gt;10<br>//只有先查询出id大于10的记录才能进行聚合语句</p>
<p>having子句:<br>select reports， count(<em>)  from employees group by reports having count(</em>) &gt; 4<br>上例having条件表达示为聚合语句，肯定的说having子句查询过程执行优先级别低于聚合语句。<br>再换句说话说把上面的having换成where则会出错，统计分组数据时用到聚合语句。<br>对分组数据再次判断时要用having。如果不用这些关系就不存在使用having。直接使用where就行了。<br>having就是来弥补where在分组数据判断时的不足。因为where执行优先级别要快于聚合语句。</p>
<p>聚合函数：<br>例如SUM, COUNT, MAX, AVG等。这些函数和其它函数的根本区别就是它们一般作用在多条记录上。</p>
<p>HAVING子句可以让我们直接筛选成组后的各组数据，也可以在聚合后对组记录进行筛选，而WHERE子句在聚合前先筛选记录，也就是说作用在GROUP BY 子句和HAVING子句前。</p>
<h6 id="3-4-5-非法使用组函数"><a href="#3-4-5-非法使用组函数" class="headerlink" title="3.4.5 非法使用组函数"></a>3.4.5 非法使用组函数</h6><p>不能在WHERE子句中使用组函数</p>
<p>可以在HAVING子句中使用组函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT department_id, AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE AVG(salary) &gt; 8000</span><br><span class="line">GROUP BY department_id;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WHERE AVG(salary) &gt; 8000</span><br><span class="line">*</span><br><span class="line">ERROR at line 3:</span><br><span class="line">ORA-00934: group function is not allowed here</span><br></pre></td></tr></table></figure>



<h4 id="4-多表查询"><a href="#4-多表查询" class="headerlink" title="4. 多表查询"></a>4. 多表查询</h4><p>两表做笛卡尔积</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181700156.png" alt="image-20210818165345140" style="zoom:45.5%;" />  

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108201748927.png" alt="image-20210819115650359" style="zoom:50%;" /> 

<h5 id="4-1-多表连接"><a href="#4-1-多表连接" class="headerlink" title="4.1 多表连接"></a>4.1 多表连接</h5><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select name,boyName </span><br><span class="line">from beauty,boys;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181700756.png" alt="image-20210818161943007" style="zoom:50%;" /> 

<h5 id="4-2-笛卡尔集"><a href="#4-2-笛卡尔集" class="headerlink" title="4.2 笛卡尔集"></a>4.2 笛卡尔集</h5><p>笛卡尔集会在下面的条件下产生</p>
<p>①省略连接条件；②连接条件无效；③所有表中的所有行互相链接</p>
<p>为了避免笛卡尔集，可以在WHERE加入有效的连接条件</p>
<h5 id="4-3-MySQL连接"><a href="#4-3-MySQL连接" class="headerlink" title="4.3 MySQL连接"></a>4.3 MySQL连接</h5><p>使用连接在多个表中查询数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT table1.column, table2.column</span><br><span class="line">FROM table1, table2</span><br><span class="line">WHERE table1.column1 &#x3D; table2.column2;</span><br></pre></td></tr></table></figure>

<p>在 WHERE 子句中写入连接条件。 在表中有相同列时，在列名之前加上表名前缀</p>
<ol>
<li><p>等值连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select beauty.id,name,boyName</span><br><span class="line">from beauty,boys</span><br><span class="line">where beauty.boyfriend_id&#x3D;boys.id;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181700310.png" alt="image-20210818165426323" style="zoom:50%;" /> 

<p>区分重复的列名：使用表名前缀在多个表中区分相同的列，在不同表中具有相同列名的列可以用表的别名加以区分，如果使用了表别名，则在select语句中需要使用表别名代替表名，表别名最多支持32个字符长度，但建议越少越好</p>
</li>
<li><p>表的别名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select bt.id,name,boyName</span><br><span class="line">from beauty bt, boys b</span><br><span class="line">where bt.boyfriend_id&#x3D;b.id;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181700310.png" alt="image-20210818165426323" style="zoom:50%;" /> 

</li>
</ol>
<h5 id="4-4-连接多个表"><a href="#4-4-连接多个表" class="headerlink" title="4.4 连接多个表"></a>4.4 连接多个表</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181704125.png" alt="image-20210818170424732"></p>
<p>连接 n个表,至少需要 n-1个连接条件。 例如：连接 三个表，至少需要两个连接条件。</p>
<ol>
<li><p>查询出公司员工的 last_name, department_name, city</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select last_name,department_name,city</span><br><span class="line">from employees,departments,locations</span><br><span class="line">where employees.department_id &#x3D; departments.department_id </span><br><span class="line">and departments.location_id &#x3D; locations.location_id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181710569.png" alt="image-20210818171002376"></p>
</li>
</ol>
<h5 id="4-5-使用ON子句创建连接"><a href="#4-5-使用ON子句创建连接" class="headerlink" title="4.5 使用ON子句创建连接"></a>4.5 使用ON子句创建连接</h5><p>自然连接中是以具有相同名字的列为连接条件的，可以使用ON子句指定额外的连接条件，这个连接条件是与其他条件分开的，ON子句使语句具有更高的易读性</p>
<h6 id="4-5-1-JOIN连接"><a href="#4-5-1-JOIN连接" class="headerlink" title="4.5.1 JOIN连接"></a>4.5.1 JOIN连接</h6><p><strong>分类：</strong></p>
<ul>
<li><p>内连接 [inner] join on</p>
<p>（典型的连接运算，使用像 = 或 &lt;&gt; 之类的比较运算符）。包括相等联接和自然联接。<u>内联接</u>使用比较运算符根据每个表<u>共有的列</u>的值匹配两个表中的行。例如，检索 students和courses表中学生标识号相同的所有行。</p>
</li>
<li><p>外连接</p>
<p>外联接可以是左向外连接、右向连接或完整外部连接。在 FROM子句中指定外联接时，可以由下列几组关键字中的一组指定： </p>
<ol>
<li><p>LEFT JOIN或LEFT OUTER JOIN   </p>
<p>左向外联接的结果集包括 LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。</p>
</li>
<li><p>RIGHT JOIN 或 RIGHT OUTER JOIN   </p>
<p>右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。 </p>
</li>
<li><p>FULL JOIN 或 FULL OUTER JOIN</p>
<p>完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。</p>
</li>
</ol>
</li>
<li><p>交叉联接 </p>
<p>交叉联接返回左表中的所有行，左表中的每一行与右表中的所有行组合。交叉联接也称作笛卡尔积。 </p>
<p>FROM 子句中的表或视图可通过内联接或完整外部联接按任意顺序指定；但是，用左或右向外联接指定表或视图时，表或视图的顺序很重要。有关使用左或右向外联接排列表的更多信息，请参见使用外联接。</p>
</li>
</ul>
<p><strong>示例</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108191158985.png" alt="image-20210819115832571">  </p>
<ol>
<li><p>内连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select bt.*,boys.*</span><br><span class="line">from beauty bt inner join boys on bt.boyfriend_id &#x3D; boys.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108191134586.png" alt="image-20210819113439230"></p>
</li>
<li><p>左连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select bt.*,boys.*</span><br><span class="line">from beauty bt left join boys on bt.boyfriend_id &#x3D; boys.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108191137831.png" alt="image-20210819113745505"></p>
<p>左表独有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select bt.*,boys.*</span><br><span class="line">from beauty bt left join boys on bt.boyfriend_id &#x3D; boys.id</span><br><span class="line">where boys.id is null;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108191205623.png" alt="image-20210819120507351"></p>
</li>
<li><p>右连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select bt.*,boys.*</span><br><span class="line">from beauty bt right join boys on bt.boyfriend_id &#x3D; boys.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108191200995.png" alt="image-20210819120023490"></p>
<p>右表独有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select bt.*,boys.*</span><br><span class="line">from beauty bt right join boys on bt.boyfriend_id &#x3D; boys.id</span><br><span class="line">where bt.boyfriend_id is null;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108191207304.png" alt="image-20210819120702172"></p>
</li>
<li><p>完全连接</p>
<p>oracle里面有full join,但是在mysql中没有full join。我们可以使用union来达到目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select bt.* from beauty bt left join boys on bt.boyfriend_id &#x3D; boys.id</span><br><span class="line">union</span><br><span class="line">select bt.* from beauty bt right join boys on bt.boyfriend_id &#x3D; boys.id;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108191201518.png" alt="image-20210819120133259"></p>
<p>并集去交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from beauty bt left join boys on bt.boyfriend_id &#x3D; boys.id</span><br><span class="line">where boys.id is null</span><br><span class="line">union</span><br><span class="line">select * from beauty bt right join boys on bt.boyfriend_id &#x3D; boys.id</span><br><span class="line">where bt.boyfriend_id is null;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108191212037.png" alt="image-20210819121248356"></p>
</li>
</ol>
<ul>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181731726.png" alt="image-20210818173141054"></li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108181732947.png" alt="image-20210818173235317"></li>
</ul>
<h4 id="5-SELECT语句执行顺序"><a href="#5-SELECT语句执行顺序" class="headerlink" title="5. SELECT语句执行顺序"></a>5. <a href="https://www.cnblogs.com/warehouse/p/9410599.html">SELECT语句执行顺序</a></h4><p>查询操作是关系数据库中使用最为频繁的操作，也是构成其他SQL语句（如DELETE、UPDATE）的基础。我们知道，SQL 查询的大致语法结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(5)SELECT DISTINCT &lt;select_list&gt;                     </span><br><span class="line">(1)FROM &lt;left_table&gt; &lt;join_type&gt; JOIN &lt;right_table&gt; ON &lt;on_predicate&gt;</span><br><span class="line">(2)WHERE &lt;where_predicate&gt;</span><br><span class="line">(3)GROUP BY &lt;group_by_specification&gt;</span><br><span class="line">(4)HAVING &lt;having_predicate&gt;</span><br><span class="line">(6)ORDER BY &lt;order_by_list&gt;</span><br><span class="line">(7)LIMIT n, m</span><br></pre></td></tr></table></figure>

<p>这些步骤执行时，每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只是最后一步生成的表才会返回给调用者。如果没有在查询中指定某一子句，将跳过相应的步骤。</p>
<p>SELECT各个阶段分别干了什么：</p>
<h5 id="5-1-FROM阶段"><a href="#5-1-FROM阶段" class="headerlink" title="5.1 FROM阶段"></a>5.1 FROM阶段</h5><p>FROM阶段标识出查询的来源表，并处理表运算符。在涉及到联接运算的查询中（各种JOIN），主要有以下几个步骤：</p>
<ul>
<li><strong>求笛卡尔积</strong>。不论是什么类型的联接运算，首先都是执行交叉连接（CROSS JOIN），求笛卡儿积（Cartesian product），生成虚拟表VT1-J1。</li>
<li><strong>ON筛选器</strong>。 这个阶段对上个步骤生成的VT1-J1进行筛选，根据ON子句中出现的谓词进行筛选，让谓词取值为true的行通过了考验，插入到VT1-J2。</li>
<li><strong>添加外部行</strong>。如果指定了OUTER JOIN，如LEFT OUTERJOIN、RIGHT OUTER JOIN，还需要将VT1-J2中没有找到匹配的行，作为外部行添加到VT1-J2中，生成VT1-J3。如果FROM子句包含两个以上表，则对上一个连接生成的结果表VT1-J3和下一个表重复依次执行3个步骤，直到处理完所有的表为止。</li>
</ul>
<p>经过以上步骤，FROM阶段就完成了。</p>
<h5 id="5-2-WHERE阶段"><a href="#5-2-WHERE阶段" class="headerlink" title="5.2 WHERE阶段"></a>5.2 WHERE阶段</h5><p>WHERE阶段是根据<where_predicate>中条件对VT1中的行进行筛选，让条件成立的行才会插入到VT2中。<strong>此时数据还没有分组，所以不能在WHERE中出现对统计的过滤。</strong></p>
<h5 id="5-3-GROUP-BY阶段"><a href="#5-3-GROUP-BY阶段" class="headerlink" title="5.3 GROUP BY阶段"></a>5.3 GROUP BY阶段</h5><p>GROUP阶段按照指定的列名列表，将VT2中的行进行分组，生成VT3。最后每个分组只有一行。<strong>在GROUP BY阶段，数据库认为两个NULL值是相等的，因此会将NULL值分到同一个分组中。</strong></p>
<h5 id="5-4-HAVING阶段"><a href="#5-4-HAVING阶段" class="headerlink" title="5.4 HAVING阶段"></a>5.4 HAVING阶段</h5><p>该阶段根据HAVING子句中出现的谓词对VT3的分组进行筛选，并将符合条件的组插入到VT4中。<strong>COUNT(expr) 会返回expr不为NULL的行数，count(1)、count(*)会返回包括NULL值在内的所有数量。</strong></p>
<h5 id="5-5-SELECT阶段"><a href="#5-5-SELECT阶段" class="headerlink" title="5.5 SELECT阶段"></a>5.5 SELECT阶段</h5><p>这个阶段是投影的过程，处理SELECT子句提到的元素，产生VT5。这个步骤一般按下列顺序进行：</p>
<ul>
<li>计算SELECT列表中的表达式，生成VT5-1。</li>
<li>若有DISTINCT，则删除VT5-1中的重复行，生成VT5-2。</li>
</ul>
<h5 id="5-6-ORDER-BY阶段"><a href="#5-6-ORDER-BY阶段" class="headerlink" title="5.6 ORDER BY阶段"></a>5.6 ORDER BY阶段</h5><p>根据ORDER BY子句中指定的列明列表，对VT5-2中的行，进行排序，生成VT6。<strong>如果不指定排序，数据并非总是按照主键顺序进行排序的。NULL被视为最小值。</strong></p>
<h5 id="5-7-LIMIT阶段"><a href="#5-7-LIMIT阶段" class="headerlink" title="5.7 LIMIT阶段"></a>5.7 LIMIT阶段</h5><p>取出指定行的记录，产生虚拟表VT7，并返回给查询用户。<strong>LIMIT n, m的效率是十分低的，一般可以通过在WHERE条件中指定范围来优化 \</strong>WHERE** id &gt; ? limit 10。**</p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>DJ音标——元音</title>
    <url>/2021/09/17/%E9%9F%B3%E6%A0%87/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="DJ音标简介和示范"><a href="#DJ音标简介和示范" class="headerlink" title="DJ音标简介和示范 "></a><a href="https://www.yingyutu.com/dj">DJ音标简介和示范 </a></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108271600814.png" alt="image-20210827160037276"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108271627621.png" alt="音标"></p>
<table>
<thead>
<tr>
<th align="center"><a href="https://en-yinbiao.xiao84.com/study/24568.html">元音</a></th>
<th align="center"><a href="https://en-yinbiao.xiao84.com/study/24557.html">单元音</a></th>
<th align="center"><a href="https://en-yinbiao.xiao84.com/study/24554.html">前元音</a></th>
<th>/iː/</th>
<th>/ɪ/</th>
<th>/e/</th>
<th>/æ/</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24555.html">中元音</a></td>
<td>/ə/</td>
<td>/ɜː/</td>
<td>/ʌ/</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24556.html">后元音</a></td>
<td>/uː/</td>
<td>/ʊ/</td>
<td>/ɔː/</td>
<td>/ɒ/</td>
<td>/ɑː/</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24560.html">双元音</a></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24558.html">开合双元音</a></td>
<td>/eɪ/</td>
<td>/aɪ/</td>
<td>/ɔɪ/</td>
<td>/aʊ/</td>
<td>/əʊ/</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24559.html">集中双元音</a></td>
<td>/ɪə/</td>
<td>/eə/</td>
<td>/ʊə/</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24569.html">辅音</a></td>
<td align="center">爆破音</td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24561.html">清辅音</a></td>
<td>/p/</td>
<td>/t/</td>
<td>/k/</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24562.html">浊辅音</a></td>
<td>/b/</td>
<td>/d/</td>
<td>/ɡ/</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">摩擦音</td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24561.html">清辅音</a></td>
<td>/f/</td>
<td>/s/</td>
<td>/ʃ/</td>
<td>/θ/</td>
<td>/h/</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24562.html">浊辅音</a></td>
<td>/v/</td>
<td>/z/</td>
<td>/ʒ/</td>
<td>/ð/</td>
<td>/r/</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">破擦音</td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24561.html">清辅音</a></td>
<td>/tʃ/</td>
<td>/tr/</td>
<td>/ts/</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"><a href="https://en-yinbiao.xiao84.com/study/24562.html">浊辅音</a></td>
<td>/dʒ/</td>
<td>/dr/</td>
<td>/dz/</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">鼻音</td>
<td align="center">（浊辅音）</td>
<td>/m/</td>
<td>/n/</td>
<td>/ŋ/</td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">舌则音</td>
<td align="center">（浊辅音）</td>
<td>/l/</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td align="center"></td>
<td align="center">半元音</td>
<td align="center">（浊辅音）</td>
<td>/j/</td>
<td>/w/</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="1-元音"><a href="#1-元音" class="headerlink" title="1. 元音"></a>1. 元音</h3><h4 id="1-1-单元音"><a href="#1-1-单元音" class="headerlink" title="1.1 单元音"></a>1.1 单元音</h4><h5 id="1-1-1-前元音"><a href="#1-1-1-前元音" class="headerlink" title="1.1.1 前元音"></a>1.1.1 前元音</h5><h6 id="iː"><a href="#iː" class="headerlink" title="/iː/"></a>/iː/</h6> <img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108271639127.png" alt="image-20210827163922965" style="zoom:25%;" />

<p>b<code>ee</code>  f<code>ee</code>  p<code>ea</code></p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdRMUFuVUFvclBjU0ViOVE_ZT02Q2FrNnU.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的长元音/iː/</li>
<li>小写字母i右边加上两点(ː)，表示长音</li>
<li>在句中书写时为/iː/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108280920194.png" alt="image-20210828092006413"></p>
<p>上唇和上下齿都稍微分开，双唇扁平发音，念成字母e的本身读音</p>
<blockquote>
<p>前元音、长元音<br>舌身前部尽量抬向硬腭，在舌面和硬腭之间留一定空隙，舌尖抵住前下齿，下颚略向下伸，使牙齿分开；<br>唇形：两唇展开，拉向两侧的嘴角；<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>和“医”发音相似</li>
<li>舌位更高（舌面更靠近硬腭）</li>
<li>嘴角要向两侧拉开</li>
</ul>
<p><strong>单词练习</strong></p>
<table>
<thead>
<tr>
<th>b<code>ee</code>  /biː/</th>
<th>f<code>ee</code>  /fiː/</th>
<th>p<code>ea</code>  /piː/</th>
</tr>
</thead>
<tbody><tr>
<td><strong>r<code>ea</code>d  /riːd/</strong></td>
<td><strong>m<code>ea</code>t  /miːt/</strong></td>
<td><strong>l<code>ea</code>d  /liːd/</strong></td>
</tr>
</tbody></table>
<p><strong>常见错误</strong></p>
<p>如果发音时离**<u>硬腭</u>**太远，就容易发成汉语拼音里的ei，从而导致以下错误读音</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108271708786.png" alt="image-20210827170842177" style="zoom: 33%;" />

<hr>
<h6 id="ɪ"><a href="#ɪ" class="headerlink" title="/ɪ/"></a>/ɪ/</h6><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108271717595.png" alt="image-20210827171238150" style="zoom:33%;" /> 

<p>l<code>i</code>st l<code>i</code>t      h<code>i</code>t     f<code>i</code>sh</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWRfVGJseHJNSWhvU2JVMVE_ZT1RQmJNNU4.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的短元音</li>
<li>缩小了的大写字母I</li>
<li>在句中书写时为/ɪ/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108280919846.png" alt="image-20210828091933546"></p>
<p>嘴型和/e/音一样，但上下齿开合度又更小一些，也是不必太用力，音自然由水平方向流出，只须发字母A[e]的后半部声即可</p>
<blockquote>
<p>高位前元音，短元音<br>舌身抬起的高度略低于长元音/iː/，舌尖抵住前下齿，舌尖用力略小于发/iː/时的力度，两齿分开；<br>唇形：稍扁；<br>声带：振动</p>
</blockquote>
<p><strong>发音诀窍</strong></p>
<ul>
<li>在中文（普通话）里没有（虽然发音近似“医”）</li>
<li>舌位更低（舌上方空间更大），再扩大就更像/e/</li>
<li>舌尖在下齿后方</li>
<li>嘴角没有/iː/那么咧开</li>
<li>发音更加放松</li>
</ul>
<p><strong>单词练习</strong></p>
<table>
<thead>
<tr>
<th>b<code>i</code>t    /bɪt/</th>
<th>f<code>i</code>t    /fɪt/</th>
<th>p<code>i</code>t    /pɪt/</th>
</tr>
</thead>
<tbody><tr>
<td><strong>l<code>i</code>t    /lɪt/</strong></td>
<td><strong>h<code>i</code>t    /hɪt/</strong></td>
<td><strong>f<code>i</code>sh    /fɪʃ/</strong></td>
</tr>
</tbody></table>
<p><strong>常见错误</strong></p>
<p>读这个音，容易把普通话“医生”的“医”短着读，也就是**<u>舌位过高</u>**，舌头离硬腭太近，以下是舌位过高产生的错误读音</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108272012083.png" alt="image-20210827201225658" style="zoom:50%;" />

<p>注意发/ɪ/这个音时，舌位要降低，离开硬腭，嘴角不需要像/iː/那样向两边拉开，舌端和硬腭离得更远，但是矫枉过正，读过头，以下是舌位过低时所产生的错误读音</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108272032987.png" alt="image-20210827203236018" style="zoom:50%;" />

<hr>
<h6 id="e"><a href="#e" class="headerlink" title="/e/"></a>/e/</h6><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108280921450.png" alt="image-20210828092105350" style="zoom: 67%;" /> 

<p>b<code>e</code>t    g<code>e</code>t    p<code>e</code>t</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWQtR25BcHk3RTI1RExaWXc_ZT11MHFXdGg.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的短元音</li>
<li>和小写字母e相同</li>
<li>在句中书写时为/e/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108280925621.png" alt="image-20210828092543740"></p>
<blockquote>
<p>中高位前元音<br>舌尖抵住下齿，舌前部向硬腭上抬，舌侧边缘轻贴上臼齿，舌位略低于发/ɪ/音时的舌位。口腔接近半开，舌稍扁；<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>双唇自然张开，口腔放松</li>
<li>舌尖在下牙齿后方，舌面平放，离开硬腭有一段距离</li>
</ul>
<p><strong>单词练习</strong></p>
<table>
<thead>
<tr>
<th>b<code>e</code>d    /bed/</th>
<th>g<code>e</code>t    /get/</th>
<th>p<code>e</code>t    /pet/</th>
</tr>
</thead>
<tbody><tr>
<td><strong>l<code>e</code>t    /let/</strong></td>
<td><strong>m<code>e</code>t    /met/</strong></td>
<td><strong>s<code>e</code>t    /set/</strong></td>
</tr>
</tbody></table>
<p><strong>常见错误</strong></p>
<p>有人会把它发成普通话中的“爱”</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281013949.png" alt="image-20210828101301123" style="zoom:50%;" />

<p><strong>DJ音标与KK音标对比</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281011784.png" alt="image-20210828100900362" style="zoom:50%;" />

<p>但是这两个音并非同一个音</p>
<hr>
<h6 id="ae"><a href="#ae" class="headerlink" title="/æ/"></a>/æ/</h6><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281016393.png" alt="image-20210828101616064" style="zoom: 50%;" /> 

<p>b<code>a</code>d    m<code>a</code>d   m<code>a</code>n</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWQ5TkYzNE1fVlBtaVQzcUE_ZT16TEM4eVc.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的短元音/æ/</li>
<li>像是小写字母a和e的组合</li>
<li>在句中书写时为/æ/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281045262.png" alt="image-20210828104538447" style="zoom: 50%;" />

<blockquote>
<p>中下位前元音<br>舌尖抵住下前齿，舌位稍高，但比其他前元音/ɪ/和/e/要低；<br>唇形：牙床要开得比较大，可以容下一个食指和一个中指，口要张至近乎全开<br>声带：振动</p>
</blockquote>
<p><strong>发音诀窍</strong></p>
<ul>
<li>这个音在中文中不存在</li>
<li>最容易读错的音之一</li>
<li>口型一定要张大，饱满</li>
<li>嘴角也要向两边拉伸</li>
<li>舌端在牙齿后方</li>
<li>“同时”发/ɑː/和/e/这两个音，口型张大像/ɑː/，舌位近似于/e/</li>
</ul>
<p><strong>单词练习</strong></p>
<table>
<thead>
<tr>
<th>b<code>a</code>d   /bæd/</th>
<th>f<code>a</code>t    /fæt/</th>
<th>p<code>a</code>t    /pæt/</th>
</tr>
</thead>
<tbody><tr>
<td><strong>l<code>a</code>d    /læd/</strong></td>
<td><strong>m<code>a</code>t   /mæt/</strong></td>
<td><strong>s<code>a</code>t    /sæt/</strong></td>
</tr>
</tbody></table>
<p><strong>绕口令</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281038380.png" alt="image-20210828103806231" style="zoom:50%;" />

<p><strong>常见错误</strong></p>
<p>使用汉语拼音的ai来代替这个读音</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281055160.png" alt="image-20210828105517920"></p>
<hr>
<h5 id="1-1-2-中元音"><a href="#1-1-2-中元音" class="headerlink" title="1.1.2 中元音"></a>1.1.2 中元音</h5><h6 id="ɜː"><a href="#ɜː" class="headerlink" title="/ɜː/"></a>/ɜː/</h6><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281058218.png" alt="image-20210828105821427" style="zoom:50%;" /> 

<p>h<code>er</code>    p<code>er</code>son    l<code>ear</code>n</p>
<p><strong>发音</strong></p>
<audio   src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdCV1oxbjZQdTVQTWpQS0E_ZT00Z2xDNVA.mp3">
    </audio>

<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的长元音/ɜː/</li>
<li>反过来写的希腊字母，ε(epsilon)</li>
<li>右侧加长音符号ː，表示长元音</li>
<li>在句中书写时为/ɜː/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281105880.png" alt="image-20210828110508698" style="zoom:50%;" />

<blockquote>
<p>中央、不圆唇长元音<br>发音时，舌中部向硬腭中部上抬，其高度位中高，舌身与臼齿有接触，但不紧密；<br>唇形：展唇形，展开程度与/iː/相同<br>声带：振动</p>
</blockquote>
<p><strong>发音诀窍</strong></p>
<ul>
<li>嘴自然张开，唇和舌都自然放松</li>
<li>像普通话里的“饿”（汉语拼音e）</li>
<li>要确保发音时间够长</li>
<li>不重度，更短 —&gt; <strong>/ə/</strong></li>
</ul>
<p><strong>单词练习</strong></p>
<table>
<thead>
<tr>
<th>her    /hɜː/</th>
<th>person    /pɜːsn/</th>
<th>learn    /lɜːn/</th>
</tr>
</thead>
<tbody><tr>
<td>bird    /bɜːd/</td>
<td>word    /wɜːd/</td>
<td>fur    /fɜː/</td>
</tr>
</tbody></table>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281122633.png" alt="image-20210828112242719" style="zoom:50%;" /> 

<p><strong>常见错误</strong></p>
<ul>
<li>这个读音中国人很少犯严重错误</li>
<li>单词拼写与er，ear，ir，or，ur等情况</li>
</ul>
<p><strong>DJ音标与KK音标对比</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281125064.png" alt="image-20210828112524731" style="zoom:50%;" />

<hr>
<h6 id="ə"><a href="#ə" class="headerlink" title="/ə/"></a>/ə/</h6><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281127312.png" alt="image-20210828112715851" style="zoom:67%;" /> 

<p><code>a</code>bout    f<code>a</code>mily  s<code>u</code>pply   </p>
<p><strong>读音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdDMmZqMDhXR2ZXUVpVNHc_ZT1ZSjVBR3Q.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的短元音/ə/</li>
<li>上下和左右都颠倒的小写字母e</li>
<li>在句中书写时为/ə/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281130245.png" alt="image-20210828113031300" style="zoom:50%;" />

<blockquote>
<p>中央非、不圆唇、非重读<br>舌头中间部分抬起，舌，唇和牙床都很自然，肌肉相对放松<br>声带：振动</p>
</blockquote>
<p><strong>发音诀窍</strong></p>
<ul>
<li>嘴自然张开，唇和舌都自然放松</li>
<li>像普通话里的轻声“么”的韵母</li>
<li>不要重读，轻轻地让气流冲出声带自然读出</li>
<li>重度，变长 —&gt; /ɜː/</li>
<li>英语中出现频率最高，最特殊，最重要的音</li>
<li>schwa（“中央元音”或“中性元音”）</li>
<li>代表了很多元音字母在英语中的发音</li>
</ul>
<p><strong>单词练习</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281142731.png" alt="image-20210828114231144" style="zoom:50%;" />

<p><strong>常见错误</strong></p>
<ul>
<li>对于我们中国人来说不算难发音</li>
<li>但恰恰是最经常读错的音</li>
<li>因为很多单词中的元音字母都读/ə/，而不是元音字母本音</li>
<li>学汉语拼音“后遗症”：看见字母a就读“啊”，u读“呜”，o读“哦”</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281222554.png" alt="image-20210828122208878"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281222347.png" alt="image-20210828122247750"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281224847.png" alt="image-20210828122446948"></p>
<hr>
<h6 id="v"><a href="#v" class="headerlink" title="/ʌ/"></a>/ʌ/</h6><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281226733.png" alt="image-20210828122611912" style="zoom:67%;" /> 

<p>b<code>u</code>t    h<code>u</code>t    m<code>u</code>st</p>
<p><strong>读音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdBdU00NXNtemVGVkZLYlE_ZT1qNFBxTWc.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的短元音/ʌ/</li>
<li>倒过来的小写字母v</li>
<li>在句中书写时为/ʌ/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281229352.png" alt="image-20210828122855627" style="zoom:50%;" />

<blockquote>
<p>中后、中下、不圆唇短元音<br>舌中部向硬腭中部上抬，上抬高度与/æ/几乎相等，口腔接近全开<br>唇形：自然状态<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>舌尖在下牙齿后方，舌头平放</li>
<li>发音靠口腔中后方</li>
<li>近似普通话“啊”，但是口型没有那么大，时长更短</li>
<li>英美发音不一样</li>
</ul>
<p><strong>单词练习</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281238867.png" alt="image-20210828123818924" style="zoom:50%;" />

<p><strong>常见错误</strong></p>
<ul>
<li>对于中国人来说不算难发音</li>
<li>避免用普通话的“啊”来取代他</li>
<li>避免口型过大，或发音过长</li>
<li>避免发成/ɑː/这个音</li>
</ul>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281241511.png" alt="image-20210828124125916" style="zoom:67%;" />

<hr>
<h5 id="1-1-3-后元音"><a href="#1-1-3-后元音" class="headerlink" title="1.1.3 后元音"></a>1.1.3 后元音</h5><h6 id="ɑː"><a href="#ɑː" class="headerlink" title="/ɑː/"></a>/ɑː/</h6><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281245872.png" alt="image-20210828124502769" style="zoom:50%;" /> 

<p>c<code>a</code>r    p<code>a</code>rk    m<code>a</code>rk</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdEbmJXbTVFOWw1V3lVMVE_ZT1sRmkzaEo.mp33"></audio></p>
<p><strong>音标符号</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281246775.png" alt="image-20210828124646063" style="zoom: 33%;" /> 

<p><strong>舌位图</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281247305.png" alt="image-20210828124733493" style="zoom:50%;" />

<blockquote>
<p>后元音、长元音<br>舌身平放在口腔里，发音时舌后靠前的部分用力<br>唇形：上下颚分得很开，两唇张开呈自然状，肌肉放松<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>/ɑː/和“啊”（汉语拼音a）相似，但不同</li>
<li>/ɑː/的口型更大，发音更靠口腔后部（舌根处）</li>
<li>发音时长要足够</li>
</ul>
<p><strong>单词练习</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281254047.png" alt="image-20210828125412862" style="zoom:50%;" />

<p><strong>常见错误</strong></p>
<ul>
<li>对于中国人来说不算难发音</li>
<li>常见的问题是口型不够饱满（张嘴过小）</li>
<li>发音过于短促</li>
</ul>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281256145.png" alt="image-20210828125554591" style="zoom: 50%;" />

<hr>
<h6 id="oː"><a href="#oː" class="headerlink" title="/ɔː/"></a>/ɔː/</h6><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281300461.png" alt="image-20210828125955724" style="zoom:50%;" /> 

<p>c<code>augh</code>t   b<code>ough</code>t    l<code>aw</code></p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdGNm96YndOQ0lrbFZRUUE_ZT1KcGlYNFQ.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的长元音/ɔː/</li>
<li>左右颠倒的小写字母c，右边再加上长音符号ː</li>
<li>在句中书写时为/ɔː/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281303059.png" alt="image-20210828130316572" style="zoom:50%;" />

<blockquote>
<p>中高、后舌位、圆唇长元音<br>舌尖抵住下齿，舌后部向软腭抬起，舌后身肌肉稍紧张些<br>唇形：双唇呈圆形而突出<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>/ɔː/和普通话里的“哦”（o）相似</li>
<li>嘴唇要撅起来，圆而外凸，肌肉较为紧张</li>
<li>口腔后方发音</li>
</ul>
<p><strong>单词练习</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281310839.png" alt="image-20210828131010407" style="zoom:50%;" />

<p><strong>常见错误</strong></p>
<ul>
<li>对中国人来说不难发</li>
<li>但是英音美音读法不同</li>
<li>美音内也有两大读法</li>
</ul>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281312395.png" alt="image-20210828131220582" style="zoom:50%;" />

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281314863.png" alt="image-20210828131402816" style="zoom:50%;" />

<hr>
<h6 id="ɒ"><a href="#ɒ" class="headerlink" title="/ɒ/"></a>/ɒ/</h6><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281805111.png" alt="image-20210828180547496" style="zoom:50%;" /> 

<p>t<code>o</code>p    h<code>o</code>t    l<code>o</code>t </p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdFTmkwYkJsUFBDYkhBNGc_ZT1qU21nbzg.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的短元音/ɒ/</li>
<li>转过来的a，“手写体a”</li>
<li>在句中书写时为/ɒ/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108281810008.png" alt="image-20210828181015333" style="zoom:50%;" />

<blockquote>
<p>低、后舌位、圆唇短元音<br>舌尖离下齿，舌后向软腭微微抬起，舌后和喉头比较紧张；<br>唇形：双唇稍用力，使嘴唇呈圆形，不突出<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>/ɒ/和普通话的“凹”（ao）相似，但并不相同</li>
<li>发/ɒ/时，嘴型更小，时间更短</li>
<li>“凹”有口型变化，但/ɒ/没有</li>
</ul>
<p><strong>单词练习</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108282049336.png" alt="image-20210828204937547" style="zoom:50%;" />

<p><strong>绕口令</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108282051664.png" alt="image-20210828205134537" style="zoom:50%;" />

<p><strong>常见错误</strong></p>
<ul>
<li>第一个常见错误：把/ɔː/短着读，或者读成“哦”</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108282055823.png" alt="image-20210828205510994"></p>
<ul>
<li>第二个错误常见错误：张口过大，发成类似“奥”的音</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108282056733.png" alt="image-20210828205610182"></p>
<ul>
<li>第三个常见错误：英音美音混读</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108282058608.png" alt="image-20210828205812186"></p>
<hr>
<h6 id="uː"><a href="#uː" class="headerlink" title="/uː/"></a>/uː/</h6><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108282100203.png" alt="image-20210828210041428" style="zoom:50%;" /> 

<p>t<code>oo</code>    f<code>oo</code>d    l<code>oo</code>se</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdIVHdoS0RKOURNbndvR1E_ZT1VZ0RvYnQ.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的长元音/uː/</li>
<li>小写字母u右侧加上长音符号ː</li>
<li>在句中书写为/uː/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108282106506.png" alt="image-20210828210622789" style="zoom:50%;" />

<blockquote>
<p>高位、圆唇后元音<br>舌尖离开下齿，舌后部向软腭抬起，在后元音中舌位最高<br>唇形：双唇收圆，向前用力突出，肌肉紧张，形成小孔<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>/uː/和普通话“呜”相似，但并不相同</li>
<li>/uː/口型没有那么圆，而是更扁，嘴角向两边拉伸</li>
<li>发音部位靠口腔后部（不要发成“淤”）</li>
</ul>
<p><strong>单词练习</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108282117003.png" alt="image-20210828211730101" style="zoom:50%;" />

<p><strong>常见错误</strong></p>
<ul>
<li>嘴唇过于外凸，唇形太圆，发成汉语的“呜”</li>
<li>请比较：“too”和“兔”</li>
</ul>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108282119660.png" alt="image-20210828211943129" style="zoom:50%;" />

<hr>
<h6 id="ʊ"><a href="#ʊ" class="headerlink" title="/ʊ/"></a>/ʊ/</h6><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108282122317.png" alt="image-20210828212227239" style="zoom:50%;" /> 

<p>b<code>oo</code>k    l<code>oo</code>k    g<code>oo</code>d</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdHS0hMYWxGaVQwdHd5SGc_ZT0zVGg2ZGc.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的短元音/ʊ/</li>
<li>从希腊字母υ(Upsilon)变过来的</li>
<li>ʊ叫做“拉丁Upsilon”</li>
<li>俗称“马蹄u”（horseshoe u）</li>
<li>在句中书写时为/ʊ/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108282128607.png" alt="image-20210828212839711" style="zoom:50%;" />

<blockquote>
<p>次高位、圆唇后元音<br>舌尖离开下齿，舌后部向软腭抬起，舌最高点比元音相对前移，比/ɑː/还略前些<br>唇形：双唇略微用力向前突出，但双唇没有发/uː/的唇形紧张<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>/ʊ/和普通话“呜”相似，但并不相同</li>
<li>发/ʊ/时，嘴唇没有那么“噘”，更放松，时长更短，发音更靠后</li>
<li>/ʊ/并不仅仅是把长音/uː/短着读</li>
<li>/uː/的唇形向两边拉开，而/ʊ/唇形更圆更放松</li>
</ul>
<p><strong>单词练习</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108282137099.png" alt="image-20210828213712726" style="zoom:50%;" />

<p><strong>绕口令</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108282138967.png" alt="image-20210828213756994" style="zoom:50%;" />

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108282139276.png" alt="image-20210828213901604" style="zoom:50%;" />

<p><strong>常见错误</strong></p>
<ul>
<li>最容易读错的音之一</li>
<li>很多人把它读成中文“呜”，唇形过于突出，过于圆</li>
</ul>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108282145489.png" alt="image-20210828214544496" style="zoom:50%;" />

<hr>
<h4 id="1-2-双元音"><a href="#1-2-双元音" class="headerlink" title="1.2 双元音"></a>1.2 双元音</h4><h5 id="1-2-1-开双元音"><a href="#1-2-1-开双元音" class="headerlink" title="1.2.1 开双元音"></a>1.2.1 开双元音</h5><h6 id="eɪ"><a href="#eɪ" class="headerlink" title="/eɪ/"></a>/eɪ/</h6><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291214920.png" alt="image-20210829121326364" style="zoom:50%;" /> 

<p>pl<code>a</code>ne    tr<code>a</code>in    r<code>a</code>in</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdNNlZwVlB5THFpQnFyZkE_ZT1BRUk3dno.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的双元音</li>
<li>/e/和/ɪ/连在一起</li>
<li>在句中书写时为/eɪ/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291231055.png" alt="image-20210829123103176"  />

<blockquote>
<p>合口双元音<br>将舌尖抵住下前齿，舌前部抬向硬腭，高度为中高，发元音/e/，然后两唇拉向两边，宽度减小，同时舌身抬至/ɪ/的高度，在这一滑动过程中形成/eɪ/音<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>它是双元音(diphthong)，由两个元音组成</li>
<li>/e/和/ɪ/一前一后快速紧密发出</li>
<li>发这个音口腔是有变化的</li>
<li>类似“嘿”的韵母</li>
</ul>
<p><strong>单词练习</strong></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291239719.png" alt="image-20210829123901488"  />

<p><strong>常见错误</strong></p>
<ul>
<li>用“唉”来取代</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291240648.png" alt="image-20210829124054203"></p>
<ul>
<li>另一个常见错误：把/eɪn/读成/en/</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291243422.png" alt="image-20210829124312772"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291243039.png" alt="image-20210829124351482"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291245346.png" alt="image-20210829124500761"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291246131.png" alt="image-20210829124631417"></p>
<hr>
<h6 id="aɪ"><a href="#aɪ" class="headerlink" title="/aɪ/"></a>/aɪ/</h6><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291248927.png" alt="image-20210829124836217" style="zoom:67%;" /> 

<p>b<code>i</code>ke    n<code>i</code>ce    t<code>i</code>me</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdMeU55anhic1NWbmtDNnc_ZT0weklVTTE.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的双元音</li>
<li>/a/和/ɪ/连在一起</li>
<li>在句中书写时为/aɪ/</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109232256039.png" alt="image-20210923225551817"></p>
<blockquote>
<p>合口双元音<br>先将舌身放平在口腔中，起始音是低位前元音/a/，然后滑向放松的高位前元音/ɪ/。舌身由/a/的舌位抬向/ɪ/的方位，这一滑动过程形成的音便是/aɪ/<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>它是双元音(diphthong)，由两个元音组成</li>
<li>/a/(类似汉语“啊”)和/ɪ/一前一后快速紧密发出</li>
<li>发这个音口腔是有变化的</li>
<li>类似“爱”的韵母，但更加饱满</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291304669.png" alt="image-20210829130411218"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>口型过小，不够饱满</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291305233.png" alt="image-20210829130532286"></p>
<hr>
<h6 id="oɪ"><a href="#oɪ" class="headerlink" title="/ɔɪ/"></a>/ɔɪ/</h6><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291306013.png" alt="image-20210829130638857"> </p>
<p>b<code>oy</code>    t<code>oy</code>  s<code>o</code>y</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdLREp4MHM0OXhzRU9ZSkE_ZT1Vam5FeDM.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的双元音</li>
<li>/ɔ/和/ɪ/连在一起</li>
<li>在句中书写时为/ɔɪ/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291309413.png" alt="image-20210829130906029"></p>
<blockquote>
<p>合口双元音<br>舌身平放于口腔中，先发圆唇音/ɔ/，然后滑向放松的高位前元音/ɪ/，舌身抬向硬腭/ɪ/的高度，这一滑动过程中形成的音便是/ɔɪ/<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>它是双元音(diphthong)，由两个元音组成</li>
<li>/ɔː/变短后和/ɪ/一前一后快速紧密发出</li>
<li>发这个音口腔是有变化的</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291319959.png" alt="image-20210829131917702"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>/ɔɪ/中的/ɪ/读成/e/，/ɔɪ/就误读成了/ɔe/</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291321340.png" alt="image-20210829132153880"></p>
<hr>
<h6 id="aʊ"><a href="#aʊ" class="headerlink" title="/aʊ/"></a>/aʊ/</h6><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291322101.png" alt="image-20210829132255702"> </p>
<p>h<code>ow</code>    c<code>ow</code>    all<code>ow</code></p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdKdFVVQmFTUE9MekZOSnc_ZT00VmpHVGs.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的双元音</li>
<li>/a/和/ʊ/连在一起，注意不是/aʊ/</li>
<li>在句中书写时为/aʊ/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291325563.png" alt="image-20210829132547295"></p>
<blockquote>
<p>合口双元音<br>/aʊ/的起始音是低位后元音/a/，然后向高位后元音/ʊ/的舌位过渡，此时舌位稍抬高，口型变小<br>唇形：呈圆形，并向前稍微突出<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>它是双元音(diphthong)，由两个元音组成</li>
<li>类似于“啊”的音(/a/，比/ɑ/发音考前)和/ʊ/一前一后紧密发出</li>
<li>发这个音口腔是有变化的</li>
<li>类似于“嗷”(汉语拼音ao)，但是更饱满，更长</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291339255.png" alt="image-20210829133947614"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>用汉语拼音的ao来取代，导致嘴型过小，发音不够饱满</li>
<li>把双元音/aʊ/读成单元音/ɔː/</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291341107.png" alt="image-20210829134145181"></p>
<hr>
<h6 id="əʊ"><a href="#əʊ" class="headerlink" title="/əʊ/"></a>/əʊ/</h6><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291342595.png" alt="image-20210829134236156"> </p>
<p><code>o</code>pen    h<code>o</code>pe p<code>o</code>st</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdJVXYzQl9ROGRLUDRCMFE_ZT10ZE1RY0Y.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的双元音</li>
<li>/ə/和/ʊ/连在一起</li>
<li>在句中书写时为/əʊ/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291345251.png" alt="image-20210829134539757"></p>
<blockquote>
<p>开口双元音<br>舌头在口腔中自然放松，/əʊ/的起始音是/ə/，发音时向/ʊ/方向过渡，口型也相应的做一些变化<br>唇形：由扁平转化为圆唇<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>它是双元音(diphthong)，由两个元音组成</li>
<li>/ə/和/ʊ/一前一后紧密发出</li>
<li>发这个音口腔是有变化的</li>
<li>类似于“欧”（汉语拼音ou）</li>
<li>英音更靠前</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291350624.png" alt="image-20210829135051419"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>发音避免过于夸张（尤其英音），读成近似/aʊ/的音</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291352476.png" alt="image-20210829135245036"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291353911.png" alt="image-20210829135307845"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291356537.png" alt="image-20210829135628430"></p>
<hr>
<h5 id="1-2-2-集中双元音"><a href="#1-2-2-集中双元音" class="headerlink" title="1.2.2 集中双元音"></a>1.2.2 集中双元音</h5><h6 id="ɪə"><a href="#ɪə" class="headerlink" title="/ɪə/"></a>/ɪə/</h6><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291357729.png" alt="image-20210829135730011"> </p>
<p>ar<code>ea</code>    id<code>ea</code>    var<code>iou</code>s</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdQODFLVmNaY24wai14VFE_ZT1hbzJCeWI.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的双元音</li>
<li>/ɪ/和/ə/连在一起</li>
<li>在句中书写时为/ɪə/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291408883.png" alt="image-20210829140806771"></p>
<blockquote>
<p>集中双元音<br>发音时，舌身从前元音/ɪ/的近似位置向/ə/的方向滑动，在整个滑动过程中，唇形是非圆唇，唇由扁到开<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>它是双元音(diphthong)，由两个元音组成</li>
<li>/ɪ/和/ə/一前一后紧密发出</li>
<li>发音一定要连贯</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291418505.png" alt="image-20210829141840397"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>把其中的/ɪ/读成普通话中的“医”</li>
<li>把其中的/ə/读成普通话中的“额”</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291421663.png" alt="image-20210829142100132"></p>
<ul>
<li>从/ɪ/到/ə/过渡时舌端往口腔后部上扬，导致末尾/ə/误读成卷舌</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291423422.png" alt="image-20210829142300344"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291424394.png" alt="image-20210829142427754"></p>
<hr>
<h6 id="eə"><a href="#eə" class="headerlink" title="/eə/"></a>/eə/</h6><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291425887.png" alt="image-20210829142515843"> </p>
<p>h<code>air</code>    p<code>air</code>    ch<code>air</code></p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdOX21UcGZHZFJLR3dQZlE_ZT05cFg2TzU.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的双元音</li>
<li>/e/和/ə/连在一起</li>
<li>在句中书写时为/eə/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291430983.png" alt="image-20210829143037513"></p>
<blockquote>
<p>集中双元音<br>发音时，舌头从前元音/e/的位置上开始移向/ə/，形成的音便是/eə/<br>唇形：非圆唇<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>它是双元音(diphthong)，由两个元音组成</li>
<li>/e/和/ə/一前一后快速紧密发出</li>
<li>发音一定要连贯</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291439789.png" alt="image-20210829143933520"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>把其中的/e/读成普通话中的“爱”</li>
<li>把其中的/ə/读成普通话中的“尔”</li>
<li>错误发成/æə/，/ær/，/aɪə/或/aɪr/</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291727995.png" alt="image-20210829172633869"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291742813.png" alt="image-20210829174206421"></p>
<hr>
<h6 id="ʊə"><a href="#ʊə" class="headerlink" title="/ʊə/"></a>/ʊə/</h6><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108291742722.png" alt="image-20210829174231770"> </p>
<p>t<code>our</code>    p<code>oor</code>    m<code>oor</code></p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdPMFZXb0xsYTdLVHo0bUE_ZT13c0NBZDU.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>DJ音标中的双元音</li>
<li>/ʊ/和/ə/连在一起</li>
<li>在句中书写时为/ʊə/，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108292020722.png" alt="image-20210829202002428"></p>
<blockquote>
<p>集中双元音<br>发音时，舌头从/ʊ/的位置开始，朝/ə/的方向滑动，在此过程中形成的音便是/ʊə/<br>唇形：由微圆到开<br>声带：振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>它是双元音(diphthong)，由两个元音组成</li>
<li>/ʊ/和/ə/一前一后快速紧密发出</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108292008825.png" alt="image-20210829200825212"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>把/ʊə/读成/ɔː/</li>
<li>/ʊə/和/ɔː/听起来有点像，但是往往拼写不同</li>
<li>前者是双元音，后者是单元音</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108292011973.png" alt="image-20210829201104189"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108292011048.png" alt="image-20210829201137857"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108292013225.png" alt="image-20210829201321890"></p>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>IPA</tag>
      </tags>
  </entry>
  <entry>
    <title>06-面向对象编程（下）</title>
    <url>/2021/09/17/06%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="06—面向对象编程（下）"><a href="#06—面向对象编程（下）" class="headerlink" title="06—面向对象编程（下）"></a>06—面向对象编程（下）</h3><h4 id="1-关键字：static"><a href="#1-关键字：static" class="headerlink" title="1. 关键字：static"></a>1. 关键字：static</h4><p>​          当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产生出对象，这时系统才会分配内存空间给对象， 其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少 对象的情况下，某些特定的数据在内存空间里只有一份，例如所有的中国人都有个国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中都单独分配一个用于代表国家名称的变量。</p>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210530224607.png" alt="image-20210530224606173" style="zoom:50%;" />

<ul>
<li>static：静态的</li>
<li>static可以用来修饰：属性、方法、代码块、内部类</li>
</ul>
<h5 id="1-1-static关键字的修饰属性"><a href="#1-1-static关键字的修饰属性" class="headerlink" title="1.1 static关键字的修饰属性"></a>1.1 static关键字的修饰属性</h5><ul>
<li><p>使用static修饰属性：静态变量（类变量）</p>
<ul>
<li><p>属性，按是否使用static修饰，又分为：静态属性 vs 非静态属性（实例变量）</p>
<ul>
<li>实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</li>
<li>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210628163408.png" alt="image-20210628163357103" style="zoom: 67%;" />
</li>
</ul>
</li>
<li><p>static修饰属性的其他说明：</p>
<ul>
<li><p>静态变量随着类的加载而加载。可以通过“类.静态变量”的方式进行调用   如：<code>System.out</code></p>
</li>
<li><p>静态变量的加载要早于对象的创建。</p>
</li>
<li><p>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</p>
<ul>
<li><table>
<thead>
<tr>
<th></th>
<th>类变量</th>
<th>实例变量</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>类.类变量</td>
<td>×</td>
</tr>
<tr>
<td>对象</td>
<td>对象.类变量</td>
<td>对象.实例变量</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>静态属性举例：System.out ; Math.PI ; </p>
</li>
</ul>
</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210628165522.png" alt="image-20210628165519723" style="zoom:80%;" />

</li>
</ul>
<h5 id="1-2-static关键字的修饰方法"><a href="#1-2-static关键字的修饰方法" class="headerlink" title="1.2 static关键字的修饰方法"></a>1.2 static关键字的修饰方法</h5><ul>
<li><p>使用static修饰方法：静态方法</p>
<ul>
<li><p>随着类的加载而加载，可以通过“类.静态方法”的方式进行调用</p>
<ul>
<li><table>
<thead>
<tr>
<th></th>
<th>静态方法</th>
<th>非静态方法</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>类.静态方法</td>
<td>×</td>
</tr>
<tr>
<td>对象</td>
<td>对象.静态方法</td>
<td>对象.非静态方法</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>静态方法中，只能调用静态的方法或属性，非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210710133901.png" alt="image-20210710133850210"></p>
</li>
<li><p>static注意点：</p>
<ul>
<li>在静态方法内，不能使用this关键字、super关键字</li>
<li>关于静态属性和静态方法的使用，从生命周期的角度去理解（晚出生的可以调用早出生的，早出生的不能调晚出生的）</li>
</ul>
</li>
<li><p>开发中，如何确定一个属性是否要声明未static</p>
<p>​        属性是可以被多个对象所共享的，不回随着对象的不同而不同</p>
<p>开发中，如何确定一个方法是否要声明为static</p>
<p>​        操作静态属性的方法，通常设置为static的</p>
<p>​        工具类中的方法，习惯上声明为static。比如Math、Arrays、Collections</p>
</li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<p>​        静态方法可以被继承，但是，不能被覆盖，即重写。如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将被隐藏。可以使用语法：父类名.静态方法调用隐藏的静态方法。 </p>
<p>​        如果父类中含有一个静态方法，且在子类中也含有一个返回类型、方法名、参数列表均与之相同的静态方法，那么该子类实际上只是将父类中的该同名方法进行了隐藏，而非重写。换句话说，父类和子类中含有的其实是两个没有关系的方法，它们的行为也并不具有多态性 </p>
<p>​        因此，通过一个指向子类对象的父类引用变量来调用父子同名的静态方法时，只会调用父类的静态方法。</p>
<h5 id="1-3-单例模式"><a href="#1-3-单例模式" class="headerlink" title="1.3 单例模式"></a>1.3 单例模式</h5><p><strong>设计模式</strong></p>
<p>在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式免去我们自己思考和摸索。</p>
<p><strong>单例设计模式</strong></p>
<p>采取一定的方法，保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。如果我们要让类在虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单例饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//此时的bank1与bank2指向的是同一个对象</span></span><br><span class="line">        Bank bank1 = Bank.getInstance();</span><br><span class="line">        Bank bank2 = Bank.getInstance();</span><br><span class="line">        System.out.println(bank1 == bank2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.私有化类的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.内部创建类的对象，此对象也必须为静态的，否则静态方法里无法对其进行返回</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.提供公共的静态方法，返回类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单例懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Order Order1 = Order.getInstance();</span><br><span class="line">        Order Order2 = Order.getInstance();</span><br><span class="line">        System.out.println(Order1 == Order2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.私有化类的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.声明对象，并不进行初始化，否则静态方法里无法对其进行初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">             instance = <span class="keyword">new</span> Order();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>饿汉式 vs 懒汉式</strong></p>
<ul>
<li><p>饿汉式：</p>
<ul>
<li>坏处：对象加载时间过长</li>
<li>好处：饿汉式是线程安全的</li>
</ul>
</li>
<li><p>懒汉式：</p>
<ul>
<li>好处：延迟对象创建</li>
<li>坏处：目前写法是不安全的<ul>
<li>例如，一个线程在调用getInstance()时，判断完if，准备新建对象，另一个线程也同样进行到if里，最后导致新建出两个对象。</li>
</ul>
</li>
</ul>
</li>
<li><p>单例模式的优点：：</p>
<ul>
<li>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的 产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。</li>
</ul>
</li>
<li><p>举例 java.lang.Runtime</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108152054366.png" alt="image-20210815205450550"></p>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ol>
<li>网站的计数器，一般也是单例模式实现，否则难以同步。</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志 文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。</li>
<li>项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，都生成一个对象去读取。</li>
<li>Application 也是单例的典型应用</li>
<li>Windows的Task Manager (任务管理器)就是很典型的单例模式</li>
<li>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。</li>
</ol>
<h4 id="2-理解main方法的语法"><a href="#2-理解main方法的语法" class="headerlink" title="2. 理解main方法的语法"></a>2. 理解main方法的语法</h4><p>​          由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是 public，又因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须 是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令时传递给所运行的类的参数。</p>
<p>​            又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情况，我们在之前的例子中多次碰到。</p>
<h5 id="2-1-命令行参数用法举例"><a href="#2-1-命令行参数用法举例" class="headerlink" title="2.1 命令行参数用法举例"></a>2.1 命令行参数用法举例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandPara</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;args[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//运行程序CommandPara.java java CommandPara “Tom” “Jerry”  </p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108152059228.png" alt="image-20210815205937678"> </p>
<p>输出结果：</p>
<blockquote>
<p>args[0] = Tom<br>args[1] = Jerry</p>
</blockquote>
<p><strong>面试题</strong></p>
<p>此处，Something类的文件名叫OtherThing.java </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] something_to_do)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Do something ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序是否可以正常编译、运行？</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108152107280.png" alt="image-20210815210742392"></p>
<h4 id="3-类的成员之四：代码块"><a href="#3-类的成员之四：代码块" class="headerlink" title="3. 类的成员之四：代码块"></a>3. 类的成员之四：代码块</h4><ul>
<li><p>代码块(或初始化块)的作用：</p>
<ul>
<li>对Java类或对象进行初始化</li>
</ul>
</li>
<li><p>代码块(或初始化块)的分类：</p>
<ul>
<li>一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块 (static block)，没有使用static修饰的，为非静态代码块。</li>
</ul>
</li>
<li><p>static代码块通常用于初始化static的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> total;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		total = <span class="number">100</span>;<span class="comment">//为total赋初值</span></span><br><span class="line">	&#125;</span><br><span class="line">	…… <span class="comment">//其它属性或方法声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="3-1-静态代码块"><a href="#3-1-静态代码块" class="headerlink" title="3.1 静态代码块"></a>3.1 静态代码块</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//static的代码块</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello,static block&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部可以有输出语句，随着类的加载而执行，而且只执行一次，如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行。静态代码块的执行优先于非静态代码块的执行。静态代码块内只能调用静态的方法、静态的属性，不能调用非静态的结构</p>
<p>作用：初始化类的信息</p>
<h5 id="3-2-非静态代码块"><a href="#3-2-非静态代码块" class="headerlink" title="3.2 非静态代码块"></a>3.2 非静态代码块</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello,block&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部可以有输出语句，随着对象的创建而执行，每创建一个对象，就执行一次非静态的代码块.如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行。非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法。</p>
<p>作用：可以在创建对象时，对对象的属性等进行初始化</p>
<p>对属性可以赋值的位置以及先后顺序：</p>
<p>①默认初始化，②显式初始化；在代码块中赋值，③构造器中初始化，④有了对象以后，可以通过“对象.属性”或”对象.方法”的方式进行赋值</p>
<h5 id="3-3-代码块执行顺序测试"><a href="#3-3-代码块执行顺序测试" class="headerlink" title="3.3 代码块执行顺序测试"></a>3.3 代码块执行顺序测试</h5><p>LeafTest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Root</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		<span class="comment">//通过this调用同一类中重载的构造器</span></span><br><span class="line">		<span class="keyword">this</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的带参数构造器，其参数值：&quot;</span>+ msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Mid</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//通过super调用父类中有一个字符串参数的构造器</span></span><br><span class="line">		<span class="keyword">super</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeafTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Leaf(); </span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="keyword">new</span> Leaf();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果：</p>
<p>Root的静态初始化块<br>Mid的静态初始化块<br>Leaf的静态初始化块<br>Root的普通初始化块<br>Root的无参数的构造器<br>Mid的普通初始化块<br>Mid的无参数的构造器<br>Mid的带参数构造器，其参数值：尚硅谷<br>Leaf的普通初始化块<br>Leaf的构造器</p>
<p>Root的普通初始化块<br>Root的无参数的构造器<br>Mid的普通初始化块<br>Mid的无参数的构造器<br>Mid的带参数构造器，其参数值：尚硅谷<br>Leaf的普通初始化块<br>Leaf的构造器</p>
</blockquote>
<p>因为是继承关系，所以首先会加载Father的静态代码块，然后加载Son的静态代码块，之后在加载Father的构造方法，然后在加载Son的构造方法，且静态代码块在这个类被调用时只执行一次。</p>
<p>总结：对于继承的方法来讲，首先会加载父类，而静态代码块是在类加载时加载的，所以对于新建子类对象时，会先从最高一级的父类静态代码块开始加载。然后再从最高一级的父类非静态代码块和无参构造器逐级加载（因为对于没显式写有this()的方法，会隐式的调用super() ）。</p>
<p>Son.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;11111111111&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;22222222222&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;33333333333&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;44444444444&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;55555555555&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;66666666666&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// 由父及子 静态先行</span></span><br><span class="line">		System.out.println(<span class="string">&quot;77777777777&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;|++++++++++++++++++++++|&quot;</span>);</span><br><span class="line">		<span class="keyword">new</span> Son();</span><br><span class="line">		System.out.println(<span class="string">&quot;|++++++++++++++++++++++|&quot;</span>);</span><br><span class="line">		<span class="keyword">new</span> Son();</span><br><span class="line">		System.out.println(<span class="string">&quot;|++++++++++++++++++++++|&quot;</span>);</span><br><span class="line">		<span class="keyword">new</span> Father();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>11111111111<br>44444444444<br>77777777777<br>|++++++++++++++++++++++|<br>22222222222<br>33333333333<br>55555555555<br>66666666666<br>|++++++++++++++++++++++|<br>22222222222<br>33333333333<br>55555555555<br>66666666666<br>|++++++++++++++++++++++|<br>22222222222<br>33333333333</p>
</blockquote>
<p>先执行静态代码块，且在类加载时执行，并且只执行一次，若有多个静态代码块，则会按照静态代码块在代码中的顺序来执行静态代码块。</p>
<p>　　再执行普通（构造代码块）代码块，先于构造方法执行，可以执行多次，构造方法执行几次，构造代码块就执行几次</p>
<p>　　<strong>（优先级从高到低）静态代码块 &gt; main方法 &gt; 构造代码块 &gt; 构造方法。</strong></p>
<h4 id="4-关键字：final"><a href="#4-关键字：final" class="headerlink" title="4. 关键字：final"></a>4. 关键字：final</h4><p><strong>final修饰变量</strong></p>
<p><strong>final修饰的变量究竟是怎么个不变性呢</strong></p>
<p>答案就是：对于final修饰的变量来说，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的，也就是说在对其初始化之后便不能再让其指向另一个对象。</p>
<h5 id="4-1-final修饰的实例变量"><a href="#4-1-final修饰的实例变量" class="headerlink" title="4.1 final修饰的实例变量"></a>4.1 final修饰的实例变量</h5><ol>
<li>被final修饰的实例变量必须显示的指定初始值</li>
<li>对于普通实例变量，Java程序可以对它执行默认的初始化，也就是将实例变量的值指定为默认的初始值0或null，但对于final修饰的实例变量，则必须由程序员显示的赋予初始值。</li>
<li>final实例变量必须显示地被赋初始值，而且本质上final实例变量只能在构造器中被赋初始值。在定义final实例变量时指定初始值，和在初始化块中为final实例变量指定初始值本质上是一样的。除此之外，final实例变量将不能被再次赋值。</li>
</ol>
<p>方法一：直接赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> f1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> String f2 = <span class="string">&quot;you&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：构造器中赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> f1;</span><br><span class="line">    <span class="keyword">final</span> String f2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalTest</span><span class="params">(<span class="keyword">int</span> f1,String f2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.f1 =f1;</span><br><span class="line">        <span class="keyword">this</span>.f2 = f2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-final修饰的类变量"><a href="#4-2-final修饰的类变量" class="headerlink" title="4.2 final修饰的类变量"></a>4.2 final修饰的类变量</h5><p>对于final类变量而言，同样必须显示指定初始值，而且final类变量只能在2个地方指定初始值：</p>
<ol>
<li><p>定义final类变量时指定初始值；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> calss FinalTest&#123;</span><br><span class="line">    <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在静态初始化块中为final类变量指定初始值；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> calss FinalTest&#123;</span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方式都会被抽取到静态初始化块中赋初始值。定义final类变量时指定初始值和在静态初始化块中为final类变量指定初始值，本质是一样的。除此之外final类变量将不能被再次赋值。</p>
</li>
</ol>
<h5 id="4-3-final修饰局部变量"><a href="#4-3-final修饰局部变量" class="headerlink" title="4.3 final修饰局部变量"></a>4.3 final修饰局部变量</h5><p>final修饰的局部变量一样需要被显式地赋初始值，因为Java本来就要求局部变量必须被显式地赋初始值。与普通变量不同的是，final修饰的局部变量被赋初始值之后，将不能再被重新赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> number = num;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> number2;</span><br><span class="line">        number2 = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-4-内部类中的局部变量"><a href="#4-4-内部类中的局部变量" class="headerlink" title="4.4 内部类中的局部变量"></a>4.4 内部类中的局部变量</h5><ol>
<li><p>这里不仅仅是匿名内部类，即使是普通内部类，在任何内部类中访问的局部变量都应该使用final修饰。</p>
</li>
<li><p>此处说的内部类指的是局部内部类，只有局部内部类（包括匿名内部类）才可以访问局部变量，普通静态内部类、非静态内部类不可能访问方法体内的局部变量。</p>
</li>
<li><p>Java要求所有被内部类访问的局部变量都使用final修饰，对于普通局部变量而言，它的作用域就是停留在该方法内，当方法执行结束，该局部变量也随之消失。但内部类则可能产生隐式的“闭包”闭包将使得局部变量脱离它所在的方法继续存在。<a href="https://blog.csdn.net/tianjindong0804/article/details/81710268">JDK8之前，匿名内部类访问的局部变量必须要用final修饰</a></p>
</li>
<li><p>匿名内部类的实例生命周期没有结束的话，将一直可以访问局部变量的值，这就是内部类会扩大局部变量作用域的实例。</p>
</li>
<li><p>由于内部类可能扩大局部变量的作用域，如果再加上这个被内部类访问的局部变量没有使用final修饰，也就是说该变量的值可以随意改变，就会引起大乱。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;<span class="comment">//成员内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            num = <span class="number">100</span>;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m1;<span class="comment">//省略了final</span></span><br><span class="line">        <span class="keyword">int</span>[] m2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];<span class="comment">//省略了final</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TestInner</span></span>&#123;<span class="comment">//局部内部类</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="comment">//      m1 = 10;//Variable &#x27;m1&#x27; is accessed from within inner class, needs to be final or effectively final</span></span><br><span class="line">                m2[<span class="number">0</span>] = <span class="number">100</span>;<span class="comment">//指向的对象没有变，但是对象里的内容可以更改</span></span><br><span class="line">                m2[<span class="number">0</span>] = <span class="number">1000</span>;<span class="comment">//指向的对象没有变，但是对象里的内容可以更改</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p> <strong>因此Java编译器要求所有被内部类访问的局部变量必须使用final修饰</strong></p>
<p><strong>总而言之：</strong></p>
<ol>
<li><p>final修饰符的第一简单的功能就是一旦被赋初始值，将不可改变。</p>
</li>
<li><p>final的另一个简单的功能就是在定义了该final类变量时指定了初始值，且该初始值可以在编译时就被确定下来，系统将不会在静态初始化块中对该类变量赋初始值，而将是在类定义中直接使用该初始化值代替该final变量。</p>
</li>
<li><p>对于一个使用final修饰的变量而言，如果定义该final变量时就指定初始值，而且这个初始值可以在编译时就确定下来，那么这个final变量将不再是一个变量，系统会将其变成“宏变量”处理。所有出现该变量的地方，系统将直接把它当成对应的值处理。</p>
</li>
</ol>
<h4 id="5-抽象类与抽象方法"><a href="#5-抽象类与抽象方法" class="headerlink" title="5. 抽象类与抽象方法"></a>5. 抽象类与抽象方法</h4><h5 id="5-1-抽象类与抽象方法的概念"><a href="#5-1-抽象类与抽象方法的概念" class="headerlink" title="5.1 抽象类与抽象方法的概念"></a>5.1 抽象类与抽象方法的概念</h5><p>​          随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一 般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108152152520.png" alt="image-20210815215240015"></p>
<ul>
<li><p>用abstract关键字来修饰一个类，这个类叫做抽象类。</p>
</li>
<li><p>用abstract来修饰一个方法，该方法叫做抽象方法。</p>
<ul>
<li><p>抽象方法：只有方法的声明，没有方法的实现。以分号结束： </p>
<p>比如：public abstract void talk();</p>
</li>
</ul>
</li>
<li><p>含有抽象方法的类必须被声明为抽象类。</p>
</li>
<li><p>抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。</p>
</li>
<li><p>不能用abstract修饰变量、代码块、构造器；</p>
</li>
<li><p>不能用abstract修饰私有方法、静态方法、final的方法、final的类。</p>
</li>
</ul>
<h5 id="5-2-抽象类与抽象方法的使用"><a href="#5-2-抽象类与抽象方法的使用" class="headerlink" title="5.2 抽象类与抽象方法的使用"></a>5.2 抽象类与抽象方法的使用</h5><p>abstract关键字的使用</p>
<p>1.abstract可以用来修饰的结构：类、方法</p>
<p>2.abstract修饰类：抽象类</p>
<ul>
<li>此类不能实例化</li>
<li>抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</li>
<li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作</li>
</ul>
<p>3.abstract修饰方法：抽象方法</p>
<ul>
<li>抽象方法只有方法的声明，没有方法体</li>
<li>包含抽象方法的类，一定是个抽象类。反之抽象类不一定包含抽象方法</li>
<li>若子类重写了父类中的所有抽象方法后，此子类方可实例化，若子类没有重写父类中的所有抽象方法，则此子类也是一个抽象类，需要用abstract修饰。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//一旦Person类抽象了，就不可以实例化</span></span><br><span class="line">        <span class="comment">// Person p1 = new Person();</span></span><br><span class="line">        <span class="comment">// p1.walk();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人走路&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生应该多吃有营养的食物。&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-多态的应用：模板方法设计模式"><a href="#5-3-多态的应用：模板方法设计模式" class="headerlink" title="5.3 多态的应用：模板方法设计模式"></a>5.3 多态的应用：模板方法设计模式</h5><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
<p>解决的问题：</p>
<ul>
<li>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</li>
<li>换句话说，在软件开发中实现一个算法时，整体步骤很容易固定、通用，这些步骤在父类写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</li>
</ul>
<p><strong>使用模板方法计算某个抽象方法执行所需时间</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SubTemplate subTemplate = <span class="keyword">new</span> SubTemplate();</span><br><span class="line">		subTemplate.spendTime();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">	<span class="comment">//计算某段代码执行所需花费的时间</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">this</span>.code();<span class="comment">//不确定的部分，易变的部分</span></span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;花费时间是:&quot;</span>+(end - start));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">boolean</span> isFlag = <span class="keyword">true</span> ;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= Math.sqrt(i); j++ ) &#123;</span><br><span class="line">				<span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">					isFlag = <span class="keyword">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(isFlag) &#123;</span><br><span class="line">				System.out.println(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-接口-interface"><a href="#6-接口-interface" class="headerlink" title="6. 接口(interface)"></a>6. 接口(interface)</h4><h5 id="6-1-接口概述"><a href="#6-1-接口概述" class="headerlink" title="6.1 接口概述"></a>6.1 接口概述</h5><ul>
<li>一方面，有时候必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</li>
<li>另一方面，有时必须从几个类中抽取一些共同的特征行为，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机……都支持USB连接。</li>
<li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要……则必须能……”的思想，继承是一个“是不是”的关系，而接口实现的则是“能不能”的关系</li>
<li>接口的本质是契约，标准，规范</li>
</ul>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210703195906.png" alt="image-20210703195856881" style="zoom:67%;" />

<h5 id="6-2-接口的使用"><a href="#6-2-接口的使用" class="headerlink" title="6.2 接口的使用"></a>6.2 接口的使用</h5><ol>
<li><p>接口使用interface来定义</p>
</li>
<li><p>Java中，接口和类是并列的两个结构</p>
</li>
<li><p>如何定义接口：定义接口中的成员</p>
<ol>
<li>JDK7及以前：只能定义全局常量和抽象方法<ol>
<li>全局常量：public static final的，但是书写时可以省略不写。</li>
<li>抽象方法：public abstract的，但是书写时可以省略不写</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210703202801.png" alt="image-20210703202800208" style="zoom:150%;" /></li>
</ol>
</li>
<li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</li>
</ol>
</li>
<li><p>接口中不能定义构造器，此举意味着接口不可以实例化。</p>
</li>
<li><p>Java开发中，接口通过类去实现（implements）的方式来使用。</p>
<ol>
<li>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化</li>
<li>如果实现类没有覆盖接口中的所有抽象方法，则此实现类仍为一个抽象类</li>
</ol>
</li>
<li><p>Java类可以实现多个接口—&gt;弥补了Java的多继承</p>
<ol>
<li><p>格式class AA extends BB implements CC,DD,EE{</p>
<p>​         }</p>
</li>
</ol>
</li>
<li><p>接口与接口之间可以继承，而且可以多继承</p>
</li>
<li><p>接口的具体使用，体现多态性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USBTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        <span class="comment">//方式一：创建接口的非匿名实现类的非匿名对象</span></span><br><span class="line">        Flash flash = <span class="keyword">new</span> Flash();</span><br><span class="line">        computer.transferData(flash);</span><br><span class="line">        System.out.println(<span class="string">&quot;********************************&quot;</span>);</span><br><span class="line">        <span class="comment">//方式二：创建接口的非匿名实现类的匿名对象</span></span><br><span class="line">        computer.transferData(<span class="keyword">new</span> Flash());</span><br><span class="line">        System.out.println(<span class="string">&quot;********************************&quot;</span>);</span><br><span class="line">        <span class="comment">//方式三：创建接口的匿名实现类的非匿名对象</span></span><br><span class="line">        USB phone = <span class="keyword">new</span> USB()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;手机接入，开始工作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;手机结束传输&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        computer.transferData(phone);</span><br><span class="line">        System.out.println(<span class="string">&quot;********************************&quot;</span>);</span><br><span class="line">        <span class="comment">//方式四：创建接口的匿名实现类的匿名对象</span></span><br><span class="line">        computer.transferData(<span class="keyword">new</span> USB()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;未知设备接入，开始工作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;未知设备传输完成&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flash</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Flash接入设备，传输准备&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Flash传输结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferData</span><span class="params">(USB usb)</span></span>&#123;</span><br><span class="line">        usb.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;具体传输细节&quot;</span>);</span><br><span class="line">        usb.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210703213324.png" alt="image-20210703213322669" style="zoom:80%;" />
</li>
<li><p>接口，实际上可以看作一种规范，在开发中体现面向接口编程</p>
</li>
</ol>
<h5 id="6-3-接口应用：代理模式-amp-工厂模式"><a href="#6-3-接口应用：代理模式-amp-工厂模式" class="headerlink" title="6.3  接口应用：代理模式 &amp; 工厂模式"></a>6.3  接口应用：代理模式 &amp; 工厂模式</h5><p><strong>代理模式</strong></p>
<p>代理模式是Java开发中使用较多的一种设计模式。代理模式设计就是为其他对象提供一种代理，以控制这个对象的访问。</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210704125216.webp" alt="img" style="zoom: 40%;" /><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210704125145.webp" alt="img" style="zoom: 80%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetWorkTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line">        ProxyServer proxyServer = <span class="keyword">new</span> ProxyServer(server);</span><br><span class="line"></span><br><span class="line">        proxyServer.browse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;真实的服务器访问网络&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyServer</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NetWork netWork;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyServer</span><span class="params">(NetWork netWork)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.netWork = netWork;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;启用网络服务前的检查工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        check();</span><br><span class="line">        netWork.browse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<ul>
<li>安全代理：屏蔽对真实角色的直接访问</li>
<li>远程代理：通过代理类处理远程方法的调用(RMI)</li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对现象</li>
</ul>
<p>比如要开发一个大文档查看软件，大文档中有大得图片，有可能一个图片有100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用Proxy来进行大图片的打开</p>
<ul>
<li>分类<ul>
<li>静态代理（静态定义代理类）</li>
<li>动态代理（动态生成代理类）<ul>
<li>JDK自带的动态代理类，需要反射等知识</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="6-4-接口笔试题"><a href="#6-4-接口笔试题" class="headerlink" title="6.4 接口笔试题"></a>6.4 接口笔试题</h5><p>[面试题]排错</p>
<p>题目1.接口与类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pX</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// System.out.println(x); 出现错误，不明确的x</span></span><br><span class="line">       System.out.println(<span class="keyword">super</span>.x);<span class="comment">//1</span></span><br><span class="line">       System.out.println(A.x);<span class="comment">//0 接口中的都为static,可以通过“接口名.属性&quot;进行调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> C().pX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>知识点：如果一个类需要调用父类中重名的属性，则可以使用”super.属性”进行调用，同时应该注意，不存在”super.super…”的用法，换言之，子类只能调用直接父类中的属性，而不能调用父类的父类的属性。（在开发中，尽量不要写重名的属性）</p>
<p>如果接口的实现类，要调用接口中的属性，可以使用”接口.属性”的方式进行调用，因为接口中的属性全部为static final </p>
</blockquote>
<p>题目2.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Playable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bounceable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Rollable</span> <span class="keyword">extends</span> <span class="title">Playable</span>,<span class="title">Bounceable</span> </span>&#123;</span><br><span class="line">    Ball ball = <span class="keyword">new</span> Ball(<span class="string">&quot;PingPang&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> <span class="keyword">implements</span> <span class="title">Rollable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Ball</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// ball = new Ball(&quot;Football&quot;);    接口中的ball是final的，无法对其进行改变</span></span><br><span class="line">        System.out.println(ball.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-5-抽象类与接口的问题"><a href="#6-5-抽象类与接口的问题" class="headerlink" title="6.5 抽象类与接口的问题"></a>6.5 抽象类与接口的问题</h5><ol>
<li><p>abstract 能修饰哪些结构？ 修饰以后，有什么特点？</p>
<p>类、方法。<br>类不能实例化，提供子类<br>抽象方法，只定义了一种功能的标准。具体的执行，需要子类去实现。</p>
</li>
<li><p>接口是否能继承接口? 抽象类是否能实现(implements)接口? 抽象类是否能继承非抽象的类? </p>
<p>能，能，能</p>
</li>
<li><p>声明抽象类，并包含抽象方法。测试类中创建一个继承抽象类的匿名子类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="keyword">abstract</span> AA&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">   	AA a = <span class="keyword">new</span> AA()&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">	a.m();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二： </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"> String name;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">	Person p = <span class="keyword">new</span> Person()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    p.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象类和接口有哪些共同点和区别？ </p>
<p>相同点：不能实例化，都可以被继承<br>不同点：抽象类：有构造器。 接口：不能声明构造器<br>多继承vs 单继承 </p>
</li>
</ol>
<h4 id="7-类的成员之五：内部类"><a href="#7-类的成员之五：内部类" class="headerlink" title="7. 类的成员之五：内部类"></a>7. 类的成员之五：内部类</h4><ul>
<li><p>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部类的完整结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类</p>
</li>
<li><p>在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。</p>
</li>
<li><p>Inner class一般用在定义它的类或语句块之内，在外部引用它时，必须给出完整的名称</p>
<ul>
<li>Inner class的名字不能与包含它的外部类类名相同；</li>
</ul>
</li>
<li><p>分类：成员内部类（static成员内部类和非static成员内部类)</p>
<p>​           局部内部类（不谈修饰符）、匿名内部类</p>
</li>
</ul>
<h5 id="7-1-成员内部类"><a href="#7-1-成员内部类" class="headerlink" title="7.1 成员内部类"></a>7.1 成员内部类</h5><ul>
<li><p>成员内部类作为类的成员的角色：</p>
<ul>
<li>和外部类不同，Inner class还可以声明为private或protected；</li>
<li>可以调用外部类的结构</li>
<li>Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；</li>
</ul>
</li>
<li><p>成员内部类作为类的角色：</p>
<ul>
<li>可以在内部定义属性、方法、构造器等结构</li>
<li>可以声明为abstract类 ，因此可以被其它的内部类继承</li>
<li>可以声明为final的</li>
<li>编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员。</li>
<li>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式</li>
<li>成员内部类可以直接使用外部类的所有成员，包括私有的数据</li>
<li>当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的</li>
</ul>
</li>
<li><p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> s;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			s = <span class="number">100</span>;</span><br><span class="line">			System.out.println(<span class="string">&quot;在内部类Inner中s=&quot;</span> + s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ma</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">		i.mb();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">		Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">		o.ma();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> s = <span class="number">111</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> s = <span class="number">222</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mb</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">			System.out.println(s); <span class="comment">// 局部变量s</span></span><br><span class="line">			System.out.println(<span class="keyword">this</span>.s); <span class="comment">// 内部类对象的属性s</span></span><br><span class="line">			System.out.println(Outer.<span class="keyword">this</span>.s); <span class="comment">// 外部类对象属性s</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">		Outer a = <span class="keyword">new</span> Outer();</span><br><span class="line">		Outer.Inner b = a.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">		b.mb(<span class="number">333</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="7-2-局部内部类"><a href="#7-2-局部内部类" class="headerlink" title="7.2 局部内部类"></a>7.2 局部内部类</h5><ul>
<li><p>如何声明局部内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类</span>&#123;</span><br><span class="line">	方法()&#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> 局部内部类</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> 局部内部类</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>如何使用局部内部类</p>
<ul>
<li>只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类</li>
<li>但是它的对象可以通过外部方法的返 回值返回使用，返回值类型只能是局部内部类的父类或父接口类型</li>
</ul>
</li>
<li><p>局部内部类的特点</p>
<ul>
<li>内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，以及数字编号。</li>
<li>只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类。</li>
<li>局部内部类可以使用外部类的成员，包括私有的。</li>
<li>局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局部变量的声明周期不同所致。</li>
<li> 局部内部类和局部变量地位类似，不能使用public,protected,缺省,private</li>
<li>局部内部类不能使用static修饰，因此也不能包含静态成员</li>
</ul>
</li>
</ul>
<h5 id="7-3-匿名内部类"><a href="#7-3-匿名内部类" class="headerlink" title="7.3 匿名内部类"></a>7.3 匿名内部类</h5><p>​          匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。</p>
<ul>
<li><p>格式： </p>
<p>new 父类构造器（实参列表）|  实现接口(){ </p>
<p>​        //匿名内部类的类体部分</p>
<p>}</p>
</li>
<li><p>匿名内部类的特点</p>
<ul>
<li>匿名内部类必须继承父类或实现接口</li>
<li>匿名内部类只能有一个对象</li>
<li>匿名内部类对象只能使用多态形式引用</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Outer().callInner(<span class="keyword">new</span> A()&#123;</span><br><span class="line">			<span class="comment">//接口是不能new但此处比较特殊是子类对象实现接口，只不过没有为对象取名</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(“implement <span class="keyword">for</span> fun1<span class="string">&quot;);</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;);// 两步写成一步了</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	public void callInner(A a) &#123;</span></span><br><span class="line"><span class="string">		a.fun1();</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="7-4-内部类的使用"><a href="#7-4-内部类的使用" class="headerlink" title="7.4 内部类的使用"></a>7.4 内部类的使用</h5><p>成员内部类和局部内部类，在编译以后，都会生成字节码文件。</p>
<p>格式：成员内部类：外部类$内部类名.class</p>
<p>​            局部内部类：外部类$数字 局部内部类名.class （数字用来表示重名的局部内部类中的第几个 （因为为局部内部类，类名只在局部有效，所以可以定义多个相同的名字，数字只是用来做区分））</p>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210705225526.png" alt="image-20210705225524602" style="zoom:150%;" />

<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210705180139.png" alt="image-20210705180138002"></p>
<p><strong>InnerClassTest.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 内部类;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类的内部成员之五：内部类</span></span><br><span class="line"><span class="comment">1.Java中允许将一个类A声明在另一个类B里，则类A就是内部类，类B称为外部类</span></span><br><span class="line"><span class="comment">2.内部类分类：成员内部类（静态、非静态） vs 局部内部类</span></span><br><span class="line"><span class="comment">            成员内部类：定义在类里面，方法外面，构造器外面，代码块外面</span></span><br><span class="line"><span class="comment">            局部内部类：方法内，代码块内，构造器内</span></span><br><span class="line"><span class="comment">3.成员内部类</span></span><br><span class="line"><span class="comment">            一方面作为外部类的成员</span></span><br><span class="line"><span class="comment">                 调用外部内的结构</span></span><br><span class="line"><span class="comment">                 可以被static修饰</span></span><br><span class="line"><span class="comment">                 可以被4种不同的权限修饰符修饰</span></span><br><span class="line"><span class="comment">            另一方面，作为一个类：</span></span><br><span class="line"><span class="comment">                类内部可以定义属性、方法、构造器等</span></span><br><span class="line"><span class="comment">                可以被final修饰，表示此类不能被继承。不使用final就可以被继承</span></span><br><span class="line"><span class="comment">                可以被abstract修饰</span></span><br><span class="line"><span class="comment">4.关注如下的3个问题</span></span><br><span class="line"><span class="comment">    4.1 如何实例化成员内部类的对象</span></span><br><span class="line"><span class="comment">    4.2 如何在成员内部类中区分调节外部类的结构</span></span><br><span class="line"><span class="comment">    4.3 开发中局部内部类的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Dog实例（静态成员内部类）</span></span><br><span class="line">        Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line">        dog.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Bird实例（非静态的成员内部类）</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Person.Bird bird = p.n<span class="function">ew <span class="title">Bird</span><span class="params">()</span></span>;</span><br><span class="line">        bird.sing();</span><br><span class="line">        bird.display(<span class="string">&quot;小鸟&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人：吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态成员内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">        String name = <span class="string">&quot;小狗&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;卡拉是条狗&quot;</span>);</span><br><span class="line">           <span class="comment">// eat();静态方法只能调用静态方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态成员内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>&#123;</span><br><span class="line">        String name = <span class="string">&quot;小猫&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小猫抓老鼠&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">        String name = <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是一只小小鸟&quot;</span>);</span><br><span class="line">            eat();<span class="comment">//完整写法应该为“Person.this.eat();&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在Bird类里调用形参name：name:&quot;</span>+ name);</span><br><span class="line">            System.out.println(<span class="string">&quot;在Bird类里调用Bird类里面的name属性：this.name:&quot;</span>+<span class="keyword">this</span>.name);</span><br><span class="line">            System.out.println(<span class="string">&quot;在Bird类里调用外部类Person的name属性：Person.this.name:&quot;</span>+Person.<span class="keyword">this</span>.name);</span><br><span class="line">            System.out.println(<span class="string">&quot;在Bird类里调用外部类Person的静态Dog类里的name属性：new Dog.name:&quot;</span>+<span class="keyword">new</span> Dog().name);</span><br><span class="line">            System.out.println(<span class="string">&quot;在Bird类里调用外部类Person的非静态Cat类里的name属性：new Cat().name:&quot;</span>+<span class="keyword">new</span> Cat().name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">BB</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">CC</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>卡拉是条狗<br>我是一只小小鸟<br>人：吃饭<br>在Bird类里调用形参name：name:小鸟<br>在Bird类里调用Bird类里面的name属性：this.name:杜鹃<br>在Bird类里调用外部类Person的name属性：Person.this.name:小明<br>在Bird类里调用外部类Person的静态Dog类里的name属性：new Dog.name:小狗<br>在Bird类里调用外部类Person的非静态Cat类里的name属性：new Cat().name:小猫</p>
</blockquote>
<p><strong>InnerClassTest1.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 内部类;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个实现了Comparable接口的类：局部内部类</span></span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyComparable</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyComparable();<span class="comment">//返回一个实现了接口的有名类的匿名对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        return new Comparable() &#123;  //返回一个实现了接口的匿名类的匿名对象</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public int compareTo(Object o) &#123;</span></span><br><span class="line"><span class="comment">                return 0;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="7-5-内部类使用注意事项"><a href="#7-5-内部类使用注意事项" class="headerlink" title="7.5 内部类使用注意事项"></a>7.5 内部类使用注意事项</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;	</span><br><span class="line"><span class="comment">//	public void onCreate()&#123;		</span></span><br><span class="line"><span class="comment">//		int number = 10;		</span></span><br><span class="line"><span class="comment">//		View.OnClickListern listener = new View.OnClickListener()&#123;		//			public void onClick()&#123;</span></span><br><span class="line"><span class="comment">//				System.out.println(&quot;hello!&quot;);</span></span><br><span class="line"><span class="comment">//				System.out.println(number);</span></span><br><span class="line"><span class="comment">//			&#125;	</span></span><br><span class="line"><span class="comment">//		&#125;		</span></span><br><span class="line"><span class="comment">//		button.setOnClickListener(listener);		</span></span><br><span class="line"><span class="comment">//	&#125;		</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在局部内部类的方法中（比如：show）如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,</span></span><br><span class="line"><span class="comment">* 要求此局部变量声明为final的。 </span></span><br><span class="line"><span class="comment">* jdk 7及之前版本：要求此局部变量显式的声明为final的</span></span><br><span class="line"><span class="comment">* jdk 8及之后的版本：可以省略final的声明</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//局部变量</span></span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;		</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//				num = 20;</span></span><br><span class="line">				System.out.println(num);	</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>08-多线程</title>
    <url>/2021/09/17/08%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="08—多线程"><a href="#08—多线程" class="headerlink" title="08—多线程"></a>08—多线程</h3><h4 id="1-基本概念：程序、进程、线程"><a href="#1-基本概念：程序、进程、线程" class="headerlink" title="1. 基本概念：程序、进程、线程"></a>1. 基本概念：程序、进程、线程</h4><ul>
<li><p>程序(Program)是为完成特定任务、用某种语言编写的一组指令的集合。即一段静态的代码，静态对象</p>
</li>
<li><p>进程(Progress)是程序的一次执行过程，或者是正在运行的一个程序。是一个动态的过程：</p>
<p>有他自身的产生、存在和消亡的过程。——生命周期</p>
<ul>
<li>如：运行中的QQ，运行中的MP3播放器</li>
<li>程序是静态的，进程是动态的</li>
<li>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</li>
</ul>
</li>
<li><p>线程(Thread)，进程可以进一步细化为线程，是一个程序内部的一条执行路径。</p>
<ul>
<li>若一个进程同一时间并行执行多个线程，就是支持多线程的</li>
<li>线程作为调度和执行最小的单位，每个线程拥有独立运行栈和程序计数器(pc)，线程切换的开销小</li>
<li>一个进程种的多个线程共享相同的内存单元/内存地址–&gt;他们从同一堆中分配对象，可以访问相同的变量和对象。这就是的线程间的通信更加简便、高效。但多个线程操作共享的系统资源就可能会带来安全隐患。</li>
<li>线程的分类：守护线程与用户线程<ul>
<li>它们唯一的区别就是判断JVM何时离开</li>
<li>守护线程使用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程</li>
<li>Java垃圾回收就是典型的守护线程</li>
<li>若JVM中都是守护线程，当前JVM将退出</li>
<li>形象理解：兔死狗烹</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210711201326.png" alt="image-20210711201323440" style="zoom: 50%;" />

<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210711201619.png" alt="image-20210711201617687" style="zoom: 67%;" />

<ul>
<li><strong>单核CPU和多核CPU</strong><ul>
<li>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有好多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果某个人不想交钱，那么收费人员可以把它”挂起“（晾着他，等它想通了，准备好了钱，再去收费）。但是因为CPU的时间单元特别短，因此感觉不出来。</li>
<li>如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</li>
<li>一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</li>
</ul>
</li>
<li><strong>并行与并发</strong><ul>
<li><strong>并行</strong>：多个CPU同时执行多个任务。比如多个人同时做不同的事。</li>
<li><strong>并发</strong>：一个CPU（采用时间片）同时执行多个任务。比如：秒杀、多个人做同一件事</li>
</ul>
</li>
</ul>
<h4 id="2-线程的创建和使用"><a href="#2-线程的创建和使用" class="headerlink" title="2. 线程的创建和使用"></a>2. 线程的创建和使用</h4><p>​            Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread 类来体现。Thread类的特性 ：①每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体 ；②通过该Thread对象的start()方法来启动这个线程，而非直接调用run()</p>
<p><strong>Thread类</strong></p>
<ul>
<li>构造器<ul>
<li>Thread()：创建新的Thread对象</li>
<li>Thread(String threadname)：创建线程并指定线程实例名</li>
<li>Thread(Runnable target)：指定创建线程的目标对象，它实现了Runnable接口中的run方法</li>
<li>Thread(Runnable target, String name)：创建新的Thread对象</li>
</ul>
</li>
</ul>
<h5 id="2-1-API中创建线程的两种方式"><a href="#2-1-API中创建线程的两种方式" class="headerlink" title="2.1 API中创建线程的两种方式"></a>2.1 API中创建线程的两种方式</h5><ul>
<li>JDK1.5之前创建新执行线程有两种方法：<ul>
<li>继承Thread类的方式 </li>
<li>实现Runnable接口的方式</li>
</ul>
</li>
</ul>
<h6 id="2-1-1-方式一：继承Thread类"><a href="#2-1-1-方式一：继承Thread类" class="headerlink" title="2.1.1 方式一：继承Thread类"></a>2.1.1 方式一：继承Thread类</h6><ol>
<li><p>定义子类继承Thread类。</p>
</li>
<li><p>子类中重写Thread类中的run方法。</p>
</li>
<li><p>创建Thread子类对象，即创建了线程对象。</p>
</li>
<li><p>调用线程对象start方法：启动线程，调用run方法。</p>
</li>
<li><p>mt子线程创建和启动过程</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108161005599.png" alt="image-20210816100524409"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108161006705.png" alt="image-20210816100615856"></p>
</li>
</ol>
<ul>
<li>注意点<ol>
<li>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。</li>
<li>run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU 调度决定。</li>
<li>想要启动多线程，必须调用start方法。</li>
<li>一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上 的异常“IllegalThreadStateException”。</li>
</ol>
</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 创建多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 多线程的创建，方式一：继承于Thread类</span></span><br><span class="line"><span class="comment"> 1.创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="comment"> 2.重写Thread类的run()--&gt;将此线程执行的操作声明在run()中</span></span><br><span class="line"><span class="comment"> 3.创建Thread类的子类的对象</span></span><br><span class="line"><span class="comment"> 4.通过此对象调用start</span></span><br><span class="line"><span class="comment"> &lt;p&gt;</span></span><br><span class="line"><span class="comment"> 例子：使用多线程遍历10以内的偶数</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//        3.创建Thread类的子类的对象</span></span><br><span class="line">        MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line"><span class="comment">//        4.通过此对象调用start():①启动当前线程 ②调用当前线程的run()      </span></span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="comment">//问题1：不能通过直接调用run()的方式启动线程</span></span><br><span class="line">		<span class="comment">//myThread.run(); 直接调用run()方法的话，没有启动线程，该方法仍然是在main方法中顺序执行，这样操作只是体现了对象调用方法</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//问题2：再启动一个MyThread线程</span></span><br><span class="line">        <span class="comment">//myThread.start();不可以让已经start()的线程去执行。会报IllegalThreadStateException</span></span><br><span class="line">        MyThread myThread1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread1.start();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如下的操作仍然是在main线程中执行的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span>+ <span class="string">&quot;---&quot;</span> + i + <span class="string">&quot;---&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">if</span>(i == <span class="number">7</span>)&#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);<span class="comment">//秒</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1.创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"><span class="comment">//    2.重写Thread类的run()</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span>+ i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>main:—1—<br>main:—3—<br>main:—5—<br>main:—7—<br>Thread-0:0<br>Thread-0:2<br>Thread-0:4<br>Thread-0:6<br>Thread-0:8<br>Thread-1:0<br>Thread-1:2<br>Thread-1:4<br>Thread-1:6<br>Thread-1:8<br>main:—9—</p>
</blockquote>
<p>使用Thread类的匿名子类去创建对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 创建多线程练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Thread类的匿名子类对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span>+ i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">6</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.getMessage();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Thread-0:0<br>Thread-1:1<br>Thread-1:3<br>Thread-1:5<br>Thread-1:7<br>Thread-1:9<br>Thread-0:2<br>Thread-0:4<br>Thread-0:6<br>Thread-0:8</p>
</blockquote>
<h6 id="2-2-2-方式二：实现Runnable接口"><a href="#2-2-2-方式二：实现Runnable接口" class="headerlink" title="2.2.2 方式二：实现Runnable接口"></a>2.2.2 方式二：实现Runnable接口</h6><ol>
<li>定义子类，实现Runnable接口。</li>
<li>子类中重写Runnable接口中的run方法。 </li>
<li> 通过Thread类含参构造器创建线程对象。 </li>
<li> 将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。 </li>
<li> 调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。</li>
</ol>
<p><strong>示例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 创建多线程;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建多线程方式二：实现Runnable接口</span></span><br><span class="line"><span class="comment">1.创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="comment">2.实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line"><span class="comment">3.创建实现类的对象</span></span><br><span class="line"><span class="comment">4.将此对象作为参数传递到Thread类的构造器中，创建Thread对象</span></span><br><span class="line"><span class="comment">5.通过Thread类的对象调用start()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.创建一个实现了Runnabl接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnableThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"><span class="comment">//  2.实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplementRunnableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnableThread myRunnableThread = <span class="keyword">new</span> MyRunnableThread();</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(myRunnableThread);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(myRunnableThread);</span><br><span class="line"></span><br><span class="line">        thread.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        thread1.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程1:0<br>线程1:2<br>线程1:4<br>线程1:6<br>线程1:8<br>线程2:0<br>线程2:2<br>线程2:4<br>线程2:6<br>线程2:8</p>
</blockquote>
<h6 id="2-2-3-继承方式和实现方式的联系与区别"><a href="#2-2-3-继承方式和实现方式的联系与区别" class="headerlink" title="2.2.3 继承方式和实现方式的联系与区别"></a>2.2.3 继承方式和实现方式的联系与区别</h6><p>public class Thread extends Object implements Runnable</p>
<ul>
<li>区别<ul>
<li>继承Thread：线程代码存放Thread子类run方法中。 </li>
<li>实现Runnable：线程代码存在接口的子类的run方法。</li>
</ul>
</li>
<li>实现方式的好处<ul>
<li>避免了单继承的局限性</li>
<li>多个线程可以共享同一个接口实现类的对象，非常适合多个相同线 程来处理同一份资源。</li>
</ul>
</li>
</ul>
<h5 id="2-2-Thread类的有关方法"><a href="#2-2-Thread类的有关方法" class="headerlink" title="2.2 Thread类的有关方法"></a>2.2 Thread类的有关方法</h5><p>void start()：启动线程，并执行对象的run()方法</p>
<p>run()：线程在被调度时执行的操作</p>
<p>String getName()：返回线程的名称</p>
<p>void setName(String name)：设置该线程的名称</p>
<p>static Thread currentThread()：返回当前线程。在Thread子类就是this，通常用于主线程和Runnable实现类</p>
<p>static void yield()：线程让步</p>
<ul>
<li>暂停当前正在执行的线程，把执行机会留给优先级相同或者更高的线程</li>
<li>若队列中没有同优先级的线程，忽略此方法</li>
</ul>
<p>join()：当某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到join()方法加入的join线程执行完为止</p>
<ul>
<li>低优先级的线程也可以获得执行</li>
</ul>
<p>static void sleep(long millis)：（指定时间：毫秒)</p>
<ul>
<li>令当前活动线程在指定时间段内放弃对CPU的控制，使其他线程有机会被执行到，时间到后重新排队</li>
<li>抛出InterruptedException异常</li>
</ul>
<p>stop()：强制线程生命期结束，不推荐使用</p>
<p>boolean isAlive()：返回boolean，判断线程是否还活着</p>
<h5 id="2-3-线程的调度"><a href="#2-3-线程的调度" class="headerlink" title="2.3 线程的调度"></a>2.3 线程的调度</h5><ul>
<li><p>调度策略</p>
<ul>
<li><p>时间片</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108161022805.png" alt="image-20210816102221360"> </p>
</li>
<li><p>抢占式：高优先级的线程抢占CPU</p>
</li>
</ul>
</li>
<li><p>Java的调度方法</p>
<ul>
<li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略</li>
<li>对高优先级，使用优先调度的抢占式策略</li>
</ul>
</li>
</ul>
<h6 id="2-3-1-线程优先级"><a href="#2-3-1-线程优先级" class="headerlink" title="2.3.1 线程优先级"></a>2.3.1 线程优先级</h6><ul>
<li>线程的优先等级<ul>
<li>MAX_PRIORITY：10</li>
<li>MIN_PRIORITY：1</li>
<li>NORM_PRIORITY：5</li>
</ul>
</li>
<li>涉及的方法<ul>
<li>getPriority()：返回线程优先值</li>
<li>setPriority(int newPriority)：改变线程的优先级</li>
</ul>
</li>
<li>说明<ul>
<li>线程创建时继承父线程的优先级</li>
<li>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 创建多线程练习;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mythread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">&quot;--&gt;&quot;</span>+Thread.currentThread().getPriority()+ <span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">6</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.getMessage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Mythread mythread = <span class="keyword">new</span> Mythread();</span><br><span class="line">        mythread.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        mythread.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line"></span><br><span class="line">        Mythread mythread1 = <span class="keyword">new</span> Mythread();</span><br><span class="line">        mythread1.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        mythread1.setPriority(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">        mythread.start();</span><br><span class="line">        mythread1.start();</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">        Thread.currentThread().setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;--&gt;&quot;</span>+Thread.currentThread().getPriority()+<span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">3</span>)&#123;</span><br><span class="line">                Thread.currentThread().yield();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">5</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mythread1.join();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.getMessage();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(mythread.isAlive()) System.out.println(mythread.getName() + <span class="string">&quot;  is still alive&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> System.out.println(mythread.getName() + <span class="string">&quot;  is death&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程1–&gt;10:0<br>线程1–&gt;10:2<br>线程1–&gt;10:4<br>线程1–&gt;10:6<br>线程2–&gt;6:0<br>线程2–&gt;6:2<br>线程2–&gt;6:4<br>线程2–&gt;6:6<br>主线程–&gt;1:1<br>主线程–&gt;1:3<br>主线程–&gt;1:5<br>线程1–&gt;10:8<br>线程2–&gt;6:8<br>主线程–&gt;1:7<br>主线程–&gt;1:9<br>线程1  is death</p>
</blockquote>
<h5 id="2-4-使用两种方式实现多窗口卖票"><a href="#2-4-使用两种方式实现多窗口卖票" class="headerlink" title="2.4 使用两种方式实现多窗口卖票"></a>2.4 使用两种方式实现多窗口卖票</h5><p><strong>方式一：继承Thread</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 创建多线程练习;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTicketInherit</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;<span class="comment">//此处需要声明为static，否则将变成每一个线程都拥有10张票</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(getName() + <span class="string">&quot;:&quot;</span> + ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketInheritTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SellTicketInherit sellTicketInherit = <span class="keyword">new</span> SellTicketInherit();</span><br><span class="line">        SellTicketInherit sellTicketInherit1 = <span class="keyword">new</span> SellTicketInherit();</span><br><span class="line">        sellTicketInherit.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        sellTicketInherit1.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        sellTicketInherit.start();</span><br><span class="line">        sellTicketInherit1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程2:10<br>线程2:9<br>线程2:8<br>线程2:7<br>线程2:6<br>线程2:5<br>线程2:4<br>线程2:3<br>线程2:2<br>线程2:1<br>线程1:10</p>
</blockquote>
<p><strong>方式二：实现Runnable</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 创建多线程练习;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SellTicketImplement</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//此处类是以实现接口的方式来实现多线程的，所以不能像继承于Thread的方法那样，直接调用getName()方法</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + ticket);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketImplementTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SellTicketImplement sellTicketImplement = <span class="keyword">new</span> SellTicketImplement();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(sellTicketImplement);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(sellTicketImplement);</span><br><span class="line"></span><br><span class="line">        thread.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        thread.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程2:10<br>Thread-1:10<br>Thread-1:9<br>Thread-1:8<br>Thread-1:7<br>Thread-1:6<br>Thread-1:5<br>Thread-1:4<br>Thread-1:3<br>Thread-1:2<br>Thread-1:1</p>
</blockquote>
<p><strong>比较两种线程的方式</strong></p>
<p>开发中优先选择：Runnable接口的方式</p>
<p>原因：1.实现的方式没有类的单继承的局限性<br>            2.实现的方式更适合来处理多个线程有共享数据的情况</p>
<p>联系：public class THread implements Runnable</p>
<p>相同点：两种方法都需要重写run()，将线程要执行的逻辑声明在run()中</p>
<h4 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3. 线程的生命周期"></a>3. 线程的生命周期</h4><ul>
<li><p>JDK中用Thread.State类定义了线程的几种状态</p>
<p>要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类对象来表示线程，在他的一个完整的生命周期中通常要经历如下的五种状态：</p>
<ul>
<li>新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>
<li>就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源</li>
<li>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run()方法定义了线程的操作和功能</li>
<li>阻塞：在某种特殊的情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态</li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108161028734.png" alt="image-20210712202750902"></p>
<h4 id="4-线程的同步"><a href="#4-线程的同步" class="headerlink" title="4. 线程的同步"></a>4. 线程的同步</h4><h5 id="4-1-问题的提出"><a href="#4-1-问题的提出" class="headerlink" title="4.1 问题的提出"></a>4.1 问题的提出</h5><p>多个线程执行的不确定性引起执行结果的不稳定 多个线程对账本的共享，会造成操作的不完整性，会破坏数据。</p>
<p><strong>例题</strong></p>
<p>模拟火车站售票程序，开启三个窗口售票。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">100</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;售出车票，tick号为：&quot;</span> + tick--);</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Ticket t = <span class="keyword">new</span> Ticket();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(t);</span><br><span class="line">		t1.setName(<span class="string">&quot;t1窗口&quot;</span>);</span><br><span class="line">		t2.setName(<span class="string">&quot;t2窗口&quot;</span>);</span><br><span class="line">		t3.setName(<span class="string">&quot;t3窗口&quot;</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108161051919.png" alt="image-20210816105122820"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108161052260.png" alt="image-20210816105158394"></p>
<ol>
<li>多线程出现了安全问题 </li>
<li> 问题的原因： 当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有 执行完，另一个线程参与进来执行。导致共享数据的错误。 </li>
<li> 解决办法： 对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以 参与执行。</li>
</ol>
<h5 id="4-2-同步方法"><a href="#4-2-同步方法" class="headerlink" title="4.2 同步方法"></a>4.2 同步方法</h5><p>Java对于多线程的安全问题提供了专业的解决方式：同步机制</p>
<ol>
<li><p>同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象)&#123;</span><br><span class="line"><span class="comment">// 需要被同步的代码；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步代码块实现：继承Thread实现多线程的版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynochronizedThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();<span class="comment">//保证锁（对象）只有一个</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(getName() + <span class="string">&quot;:&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                 &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynochronizedThread synochronizedThread = <span class="keyword">new</span> SynochronizedThread();</span><br><span class="line">        SynochronizedThread synochronizedThread1 = <span class="keyword">new</span> SynochronizedThread();</span><br><span class="line">        synochronizedThread.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        synochronizedThread1.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        synochronizedThread.start();</span><br><span class="line">        synochronizedThread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程1:10<br>线程2:9<br>线程2:8<br>线程1:7<br>线程1:6<br>线程2:5<br>线程2:4<br>线程2:3<br>线程1:2<br>线程1:1</p>
</blockquote>
<p>同步代码块实现：Runnable接口实现多线程版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedImplements</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;<span class="comment">//实现Runnable天然只有一个对象，所以可以直接用this来当锁</span></span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.currentThread().sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedImplementsTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedImplements synchronizedImplements = <span class="keyword">new</span> SynchronizedImplements();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(synchronizedImplements);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(synchronizedImplements);</span><br><span class="line">        thread.setName(<span class="string">&quot;窗口1：&quot;</span>);</span><br><span class="line">        thread1.setName(<span class="string">&quot;窗口2：&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>同步方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span> <span class="params">(String name)</span></span>&#123; </span><br><span class="line">	….</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步方法实现：继承Thread实现多线程的版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 线程同步;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            sellTicket();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;<span class="comment">//此处的锁实际上为当前类SynchronizedThread.class</span></span><br><span class="line">        <span class="comment">//private synchronized void sellTicket() 此时的锁为synchronizedThread、synchronizedThread1达不到效果</span></span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;<span class="keyword">else</span> Thread.currentThread().stop();<span class="comment">//解决while的退出问题</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedThreadMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedThread synchronizedThread = <span class="keyword">new</span> SynchronizedThread();</span><br><span class="line">        SynchronizedThread synchronizedThread1 = <span class="keyword">new</span> SynchronizedThread();</span><br><span class="line">        synchronizedThread.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        synchronizedThread1.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        synchronizedThread.start();</span><br><span class="line">        synchronizedThread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>窗口1:10<br>窗口2:9<br>窗口2:8<br>窗口2:7<br>窗口2:6<br>窗口1:5<br>窗口1:4<br>窗口1:3<br>窗口1:2<br>窗口2:1</p>
</blockquote>
<p>同步方法实现：Runnable接口实现多线程版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SynchronizedImplement</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            sellTicket();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;<span class="keyword">else</span> Thread.currentThread().stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedImplementsMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronizedImplement synchronizedImplement = <span class="keyword">new</span> SynchronizedImplement();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(synchronizedImplement);</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(synchronizedImplement);</span><br><span class="line">        thread.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        thread1.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>窗口1:10<br>窗口2:9<br>窗口1:8<br>窗口2:7<br>窗口1:6<br>窗口1:5<br>窗口2:4<br>窗口1:3<br>窗口1:2<br>窗口1:1</p>
</blockquote>
</li>
</ol>
<p>分析同步原理</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108161257867.png" alt="image-20210816125656163"></p>
<h5 id="4-3-同步机制中的锁"><a href="#4-3-同步机制中的锁" class="headerlink" title="4.3 同步机制中的锁"></a>4.3 同步机制中的锁</h5><ul>
<li><p>同步机制</p>
<p>在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。</p>
</li>
<li><p>synchronized的锁是什么？</p>
<ul>
<li>任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。 </li>
<li>同步方法的锁：静态方法（类名.class）、非静态方法（this） </li>
<li>同步代码块：自己指定，很多时候也是指定为this或类名.class</li>
<li>注意<ul>
<li>必须确保使用同一个资源的<u><strong>多个线程共用一把锁</strong></u>，这个非常重要，否则就 无法保证共享资源的安全</li>
<li>一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎）</li>
</ul>
</li>
</ul>
</li>
<li><p>释放锁的操作</p>
<ul>
<li>当前线程的同步方法、同步代码块执行结束。 </li>
<li>当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、 该方法的继续执行。 </li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束 </li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。</li>
</ul>
</li>
<li><p>不会释放锁的操作</p>
<ul>
<li>线程执行同步代码块或同步方法时，程序调用Thread.sleep()、 Thread.yield()方法暂停当前线程的执行</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。<ul>
<li>应尽量避免使用suspend()和resume()来控制线程</li>
</ul>
</li>
</ul>
</li>
<li><p>线程的死锁问题</p>
<ul>
<li><p>死锁</p>
<ul>
<li><p>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</p>
</li>
<li><p>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</p>
</li>
<li><p>死锁演示</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 线程同步;</span><br><span class="line"><span class="comment">//死锁的演示</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(B b)</span> </span>&#123; <span class="comment">//同步监视器：A类的对象：a</span></span><br><span class="line">		System.out.println(<span class="string">&quot;当前线程名: &quot;</span> + Thread.currentThread().getName()</span><br><span class="line">				+ <span class="string">&quot; 进入了A实例的foo方法&quot;</span>); <span class="comment">// ①</span></span><br><span class="line"><span class="comment">//		try &#123;</span></span><br><span class="line"><span class="comment">//			Thread.sleep(200);</span></span><br><span class="line"><span class="comment">//		&#125; catch (InterruptedException ex) &#123;</span></span><br><span class="line"><span class="comment">//			ex.printStackTrace();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		System.out.println(<span class="string">&quot;当前线程名: &quot;</span> + Thread.currentThread().getName()</span><br><span class="line">				+ <span class="string">&quot; 企图调用B实例的last方法&quot;</span>); <span class="comment">// ④</span></span><br><span class="line">		b.last();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">()</span> </span>&#123;<span class="comment">//同步监视器：A类的对象：a</span></span><br><span class="line">		System.out.println(<span class="string">&quot;进入了A类的last方法内部&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(A a)</span> </span>&#123;<span class="comment">//同步监视器：b</span></span><br><span class="line">		System.out.println(<span class="string">&quot;当前线程名: &quot;</span> + Thread.currentThread().getName()</span><br><span class="line">				+ <span class="string">&quot; 进入了B实例的bar方法&quot;</span>); <span class="comment">// ①</span></span><br><span class="line"><span class="comment">//		try &#123;</span></span><br><span class="line"><span class="comment">//			Thread.sleep(200);</span></span><br><span class="line"><span class="comment">//		&#125; catch (InterruptedException ex) &#123;</span></span><br><span class="line"><span class="comment">//			ex.printStackTrace();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line">		System.out.println(<span class="string">&quot;当前线程名: &quot;</span> + Thread.currentThread().getName()</span><br><span class="line">				+ <span class="string">&quot; 企图调用A实例的last方法&quot;</span>); <span class="comment">// ③</span></span><br><span class="line">		a.last();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">last</span><span class="params">()</span> </span>&#123;<span class="comment">//同步监视器：b</span></span><br><span class="line">		System.out.println(<span class="string">&quot;进入了B类的last方法内部&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	A a = <span class="keyword">new</span> A();</span><br><span class="line">	B b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread.currentThread().setName(<span class="string">&quot;主线程&quot;</span>);</span><br><span class="line">		<span class="comment">// 调用a对象的foo方法</span></span><br><span class="line">		a.foo(b);</span><br><span class="line">		System.out.println(<span class="string">&quot;进入了主线程之后&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Thread.currentThread().setName(<span class="string">&quot;副线程&quot;</span>);</span><br><span class="line">		<span class="comment">// 调用b对象的bar方法</span></span><br><span class="line">		b.bar(a);</span><br><span class="line">		System.out.println(<span class="string">&quot;进入了副线程之后&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		DeadLock dl = <span class="keyword">new</span> DeadLock();</span><br><span class="line">		<span class="keyword">new</span> Thread(dl).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		dl.init();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当前线程名: 副线程 进入了B实例的bar方法<br>当前线程名: 主线程 进入了A实例的foo方法<br>当前线程名: 副线程 企图调用A实例的last方法<br>当前线程名: 主线程 企图调用B实例的last方法</p>
</blockquote>
</li>
</ul>
</li>
<li><p>解决方法</p>
<ul>
<li>专门的算法、原则 </li>
<li>尽量减少同步资源的定义 </li>
<li>尽量避免嵌套同步</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4-4-Lock（锁）"><a href="#4-4-Lock（锁）" class="headerlink" title="4.4 Lock（锁）"></a>4.4 Lock（锁）</h5><p>​          从JDK 5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的 工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReenTrantLock();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">//保证线程安全的代码;</span></span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			lock.unlock(); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：如果同步代码有异常，要将unlock()写入finally语句块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//1.实例化ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//参数可以填true或false,默认为false，表示非公平的，以抢占来获得资源，而不是以等待时间长短作为判定依据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//2.调用锁定方法lock()</span></span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：售票，票号为：&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//3.调用解锁方法：unlock()</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window window = <span class="keyword">new</span> Window();</span><br><span class="line"></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(window);</span><br><span class="line">        Thread thread3 = <span class="keyword">new</span> Thread(window);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        thread3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>窗口1：售票，票号为：10<br>窗口2：售票，票号为：9<br>窗口3：售票，票号为：8<br>窗口3：售票，票号为：7<br>窗口3：售票，票号为：6<br>窗口3：售票，票号为：5<br>窗口1：售票，票号为：4<br>窗口2：售票，票号为：3<br>窗口3：售票，票号为：2<br>窗口3：售票，票号为：1</p>
</blockquote>
<h5 id="4-5-利用线程同步解决懒汉单例模式"><a href="#4-5-利用线程同步解决懒汉单例模式" class="headerlink" title="4.5 利用线程同步解决懒汉单例模式"></a>4.5 利用线程同步解决懒汉单例模式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 线程同步;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyBones</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyBones</span><span class="params">()</span></span>&#123;<span class="comment">//声明为私有的，就无法通过外部进行调用</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot; 调用空参构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyBones lazyBones = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;调用run()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazyBones <span class="title">getInstance</span><span class="params">()</span> </span>&#123;<span class="comment">//以继承Thread方式实现时，需要保证此方法只存在一份，故而声明为static</span></span><br><span class="line">            <span class="keyword">if</span> (lazyBones == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//synchronized (LazyBones.class) &#123;</span></span><br><span class="line">                lazyBones = <span class="keyword">new</span> LazyBones();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;调用getInstance()&quot;</span>);</span><br><span class="line">               <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> lazyBones;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyBonesTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LazyBones lazyBones = LazyBones.getInstance();</span><br><span class="line">        LazyBones lazyBones1 = LazyBones.getInstance();</span><br><span class="line">        lazyBones.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        lazyBones1.setName(<span class="string">&quot;线程2&quot;</span>);<span class="comment">// lazyBones与 lazyBones1其实是一个对象，所以最后名字被改成了”线程2“</span></span><br><span class="line">        lazyBones.start();</span><br><span class="line">       <span class="comment">// lazyBones1.start();//同一个对象不能二次start</span></span><br><span class="line">        <span class="keyword">if</span>(lazyBones == lazyBones1)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;懒汉式单例模式的线程安全问题得到解决&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//如果两个对象的引用不一样，则说明new了两个对象</span></span><br><span class="line">            lazyBones1.start();</span><br><span class="line">            System.out.println(<span class="string">&quot;懒汉式单例模式的线程安全问题未得到解决&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>main 调用空参构造器<br>main调用getInstance()<br>懒汉式单例模式的线程安全问题得到解决<br>线程2调用run()</p>
</blockquote>
<h5 id="4-5-synchronized-与-Lock-的对比"><a href="#4-5-synchronized-与-Lock-的对比" class="headerlink" title="4.5 synchronized 与 Lock 的对比"></a>4.5 synchronized 与 Lock 的对比</h5><ol>
<li>Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li>
</ol>
<p><strong>优先使用顺序</strong></p>
<p>Lock –&gt; 同步代码块（已经进入了方法体，分配了相应资源）–&gt; 同步方法 （在方法体之外）</p>
<h4 id="5-线程的通信"><a href="#5-线程的通信" class="headerlink" title="5. 线程的通信"></a>5. 线程的通信</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">涉及到的三个方法：</span><br><span class="line">* wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。</span><br><span class="line">* notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。</span><br><span class="line">* notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。</span><br><span class="line">*</span><br><span class="line">* 说明：</span><br><span class="line">* 1.wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。</span><br><span class="line">* 2.wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。</span><br><span class="line">*    否则，会出现IllegalMonitorStateException异常</span><br><span class="line">* 3.wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。</span><br><span class="line">*</span><br><span class="line">* 面试题：sleep() 和 wait()的异同？</span><br><span class="line">* 1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</span><br><span class="line">* 2.不同点：1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</span><br><span class="line">*          2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</span><br><span class="line">*          3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</span><br></pre></td></tr></table></figure>

<p><strong>经典例题</strong></p>
<ul>
<li>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如：20)，如果生产者试图生产更多的产品，店员就会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品</li>
<li>这里可能会出现两个问题：<ul>
<li>生产者比消费者快时，消费者会漏掉一些数据没有取到</li>
<li>消费者比生产者快时，消费者会取相同的数据</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span></span>&#123;<span class="comment">//店员</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> productNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produceProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(productNum &lt; <span class="number">20</span>)&#123;</span><br><span class="line">            productNum++;<span class="comment">//生产完了数量才输出增加</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;： 开始生产第&quot;</span> + productNum + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consumeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(productNum &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;： 开始消费第&quot;</span> + productNum + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            productNum--;<span class="comment">//消费完了数量才减少</span></span><br><span class="line">            notify();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Produtor</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//生产者</span></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Produtor</span><span class="params">(Clerk clerk)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">&quot;开始生产产品……&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.produceProduct();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cust</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;<span class="comment">//消费者</span></span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Cust</span><span class="params">(Clerk clerk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.consumeProduct();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line">        Cust cust = <span class="keyword">new</span> Cust(clerk);</span><br><span class="line"></span><br><span class="line">        Produtor produtor = <span class="keyword">new</span> Produtor(clerk);</span><br><span class="line">        Thread custThread = <span class="keyword">new</span> Thread(cust);</span><br><span class="line"></span><br><span class="line">        produtor.setName(<span class="string">&quot;生产者&quot;</span>);</span><br><span class="line">        custThread.setName(<span class="string">&quot;消费者&quot;</span>);</span><br><span class="line"></span><br><span class="line">        produtor.start();</span><br><span class="line">        custThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>生产者开始生产产品……<br>生产者： 开始生产第1个产品<br>生产者： 开始生产第2个产品<br>消费者： 开始消费第2个产品<br>消费者： 开始消费第1个产品<br>生产者： 开始生产第1个产品<br>消费者： 开始消费第1个产品<br>生产者： 开始生产第1个产品<br>生产者： 开始生产第2个产品</p>
<p>…………………………………………</p>
</blockquote>
<h4 id="6-JDK5-0新增线程创建方式"><a href="#6-JDK5-0新增线程创建方式" class="headerlink" title="6. JDK5.0新增线程创建方式"></a>6. JDK5.0新增线程创建方式</h4><p>新增实现方式一：实现Callable接口</p>
<ul>
<li>与使用Runnable相比，Callable功能更强大些<ul>
<li>相比使用run()方法，可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>需要借助FutureTask类，比如获取返回结果</li>
<li>Future接口<ul>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等</li>
<li>==FutureTask是Future接口的唯一的实现类==</li>
<li>FutureTask同时实现了Runnable,Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 创建多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建线程的方式三：实现Callable接口————JDK5.0新增</span></span><br><span class="line"><span class="comment">如何理解实现Callable接口的方式创建多线程比实现Runnable解耦创建多线程方式强大？</span></span><br><span class="line"><span class="comment">1.call()可以有返回值</span></span><br><span class="line"><span class="comment">2.call()可以抛出异常，被外面的操作捕获，获取异常信息</span></span><br><span class="line"><span class="comment">3.Callable是支持泛型的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.创建一个实现了Callable的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImplementsCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="comment">//2.重写call()方法，将此线程需要执行的操作总声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImplementsCallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        ImplementsCallable implementsCallable = <span class="keyword">new</span> ImplementsCallable();</span><br><span class="line">        <span class="comment">//4.将Callable接口实现类的对象传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(implementsCallable);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()方法</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()方法的返回值</span></span><br><span class="line">            Object obj = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为： &quot;</span> + obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总和为： 2550</p>
</blockquote>
<p><strong>新增实现方式二：使用线程池</strong></p>
<ul>
<li>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能的影响很大</li>
<li>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回线程池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具</li>
<li>好处：<ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中的线程，不需要每次都创建）</li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maxmumPoolSize：最大线程数</li>
<li>keepALiveTime：线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>线程池相关API</strong></p>
<ul>
<li>JDK5.0起提供了线程池相关API：ExecutorService和Executors</li>
<li>ExecuotrService：真正的线程池接口。常见子类ThreadPoolExecutor<ul>
<li>void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行Runnable</li>
<li><T>Future<T>submit(Callable<T>task)：执行任务，没有返回值，一般用来执行Callable</li>
<li>void shutdown()：关闭连接池</li>
</ul>
</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池<ul>
<li>Executors.newCachsThreadPllo()：创建一个可以根据需要创建新线程的线程池</li>
<li>Executors.newFixedThreadPool(n)：创建一个可以重用固定 线程数的线程池</li>
<li>Executors.newSingleThreadExecutor()：创建一个只有一个线程的线程池</li>
<li>Executors.newScheduledThreadPool(n)：创建一个线程池，它可以安排在给定延迟后运行命令或者定期地执行</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 创建多线程;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberThread1</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.提供指定线程数量的线程池</span></span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需提供实现Runnable接口或者Callable接口实现类的对象</span></span><br><span class="line">        <span class="comment">//实现Runnable接口</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> NumberThread());</span><br><span class="line">        service.execute(<span class="keyword">new</span> FutureTask(<span class="keyword">new</span> NumberThread1()));</span><br><span class="line">        <span class="comment">//实现Callable接口</span></span><br><span class="line">        service.submit(<span class="keyword">new</span> NumberThread1());</span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>pool-1-thread-3:1<br>pool-1-thread-2:1<br>pool-1-thread-3:3<br>pool-1-thread-2:3<br>pool-1-thread-2:5<br>pool-1-thread-3:5<br>pool-1-thread-2:7<br>pool-1-thread-3:7<br>pool-1-thread-3:9<br>pool-1-thread-2:9<br>pool-1-thread-1:0<br>pool-1-thread-1:2<br>pool-1-thread-1:4<br>pool-1-thread-1:6<br>pool-1-thread-1:8</p>
</blockquote>
<p><strong>小结</strong></p>
<p>释放锁的操作</p>
<ul>
<li>当前线程的同步方法、同步代码块执行结束</li>
<li>当前线程在同步代码块、同步方法中遇到了break、return终止了该代码块、该方法的继续执行</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的Error或者Exception，导致异常结束</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁</li>
</ul>
<p>不会释放锁的操作</p>
<ul>
<li>线程执行同步代码块或同步方法时，程序调用Thread,sleep()、Thread.yield()方法暂停当前线程的执行</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）<ul>
<li>应尽量避免使用suspend()和resume()来控制线程</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>13-IO流</title>
    <url>/2021/09/17/13%E2%80%94IO%E6%B5%81/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="13—IO流"><a href="#13—IO流" class="headerlink" title="13—IO流"></a>13—IO流</h3><h4 id="1-File类的使用"><a href="#1-File类的使用" class="headerlink" title="1. File类的使用"></a>1. File类的使用</h4><ul>
<li>java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关</li>
<li>File能新建、删除、重命名文件和目录，但File不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流</li>
<li>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录</li>
<li>File对象可以作为参数传递给流的构造器</li>
</ul>
<h5 id="1-1-常用构造器"><a href="#1-1-常用构造器" class="headerlink" title="1.1 常用构造器"></a>1.1 常用构造器</h5><ul>
<li><p>public File(String pathname)</p>
<p>以pathname为路径创建File对象，可以是绝对路径或相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。</p>
<ul>
<li>绝对路径：是一个固定的路径，从盘符开始</li>
<li>相对路径：是相对于某个位置开始</li>
</ul>
</li>
<li><p>public File(String parent, String child)</p>
<p>以parent为父路径，child为子路径创建File对象</p>
</li>
<li><p>public File(File parent, String child)</p>
<p>根据一个父File对象和子文件路径创建File对象</p>
</li>
<li><p>路径中的每级目录之间用一个路径分隔符隔开</p>
</li>
<li><p>路径分隔符和系统有关：</p>
<ul>
<li>Windows和Dos系统默认使用”\“来表示</li>
<li>UNIX和URL使用”/“来表示</li>
</ul>
</li>
<li><p>Java程序支持跨平台使用，因此路径分隔符要慎用</p>
</li>
<li><p>为了解决这个隐患，File类提供了一个常量：</p>
<p>public static final String separator。根据操作系统，动态提供分隔符</p>
</li>
<li><p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file1 = <span class="keyword">new</span> File(<span class="string">&quot;d:\\Files\\index.txt&quot;</span>);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">&quot;d:&quot;</span>+File.separator+<span class="string">&quot;Files&quot;</span>+File.separator+<span class="string">&quot;index.txt&quot;</span>);</span><br><span class="line">File files = <span class="keyword">new</span> File(<span class="string">&quot;d:/Files/index.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="1-2-常用方法"><a href="#1-2-常用方法" class="headerlink" title="1.2 常用方法"></a>1.2 常用方法</h5><ul>
<li><p>File类的获取功能</p>
<ul>
<li>public String getAbsolutePath()：获取绝对路径</li>
<li>public String getPath()：获取路径</li>
<li>public String getName()：获取名称</li>
<li>public String getParent()：获取上层文件路径。若无，返回null</li>
<li>public long length()：获取文件长度（即：字节数）。不能获取目录的长度</li>
<li>public long lastModified()：获取最后一次的修改时间，毫秒值</li>
<li>public String[] list()：获取指定目录下的所有文件或文件目录的名称数组</li>
<li>public File[] listFiles()：获取指定目录下的所有文件或者文件目录的File数组</li>
</ul>
</li>
<li><p>File类的重命名功能</p>
<ul>
<li>public boolean renameTo(File dest)：把文件重命名为指定的文件路径</li>
</ul>
</li>
<li><p>File类的判断功能</p>
<ul>
<li>public boolean isDirectory()：判断是否是文件目录</li>
<li>public boolean isFile()：判断是否是文件</li>
<li>public boolean exists()：判断是否存在</li>
<li>public boolean canRead()：判断是否可读</li>
<li>public boolean canWrite()：判断是否可写</li>
<li>public boolean isHidden()：判断是否隐藏</li>
</ul>
</li>
<li><p>File类的创建功能</p>
<ul>
<li>public boolean creatNewFile()：创建文件。若文件存在，则不创建，返回false</li>
<li>public boolean mkdir()：创建文件目录，如果此文件目录存在，就不创建了。如果此文件目录的上次目录不存在，也不创建</li>
<li>public boolean mkdirs()：创建文件目录。如果上层文件目录不存在，一并创建</li>
</ul>
<p>注意事项：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下</p>
</li>
<li><p>File类的删除功能</p>
<ul>
<li><p>public boolean delete()：删除文件或文件夹</p>
<p>删除注意事项：Java中的删除不走回收站</p>
<p>要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210730121618.png" alt="image-20210730114658840"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File dir1 = <span class="keyword">new</span> File(<span class="string">&quot;D:/IOTest/dir1&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!dir1.exists()) &#123; <span class="comment">// 如果D:/IOTest/dir1不存在，就创建为目录</span></span><br><span class="line">	dir1.mkdir();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建以dir1为父目录,名为&quot;dir2&quot;的File对象</span></span><br><span class="line">File dir2 = <span class="keyword">new</span> File(dir1, <span class="string">&quot;dir2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!dir2.exists()) &#123; <span class="comment">// 如果还不存在，就创建为目录</span></span><br><span class="line">	dir2.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line">File dir4 = <span class="keyword">new</span> File(dir1, <span class="string">&quot;dir3/dir4&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!dir4.exists()) &#123;</span><br><span class="line">	dir4.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建以dir2为父目录,名为&quot;test.txt&quot;的File对象</span></span><br><span class="line">File file = <span class="keyword">new</span> File(dir2, <span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!file.exists()) &#123; <span class="comment">// 如果还不存在，就创建为文件</span></span><br><span class="line">	file.createNewFile();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><strong>练习</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> File类的使用;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileExer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    利用File构造器，new一个文件目录file</span></span><br><span class="line"><span class="comment">    1）在其中创建多个文件和目录</span></span><br><span class="line"><span class="comment">    2）编写方法，实现删除file中指定文件的操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建多个文件和目录</span></span><br><span class="line">        String str = <span class="string">&quot;file0&quot;</span>;</span><br><span class="line">        StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer(str);</span><br><span class="line">        File file = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                stringBuffer.replace(str.length() - <span class="number">1</span>, stringBuffer.length(), <span class="keyword">new</span> Integer(i).toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stringBuffer.replace(str.length() - <span class="number">1</span>, stringBuffer.length(), <span class="keyword">new</span> Integer(i).toString() + <span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            file = <span class="keyword">new</span> File(<span class="string">&quot;IOTestFile&quot;</span> + File.separator + stringBuffer);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                file.mkdir();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">try</span> &#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//展示当前文件夹下的文件</span></span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">&quot;IOTestFile&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (File listFile : file1.listFiles()) &#123;</span><br><span class="line">            System.out.println(listFile);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除file里的指定文件</span></span><br><span class="line">        System.out.println(<span class="string">&quot;输入你要删除的文件&quot;</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str1 = scanner.next();</span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">&quot;IOTestFile&quot;</span> + File.separator + str1);</span><br><span class="line">        <span class="keyword">if</span> (file2.exists()) &#123;</span><br><span class="line">            file2.delete();</span><br><span class="line">        &#125; <span class="keyword">else</span> System.out.println(<span class="string">&quot;要删除的文件不存在&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建多个文件和文件夹</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> File <span class="title">creat</span><span class="params">(<span class="keyword">int</span> deep)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = deep;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要创建文件的目录&quot;</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        stringBuilder = <span class="keyword">new</span> StringBuilder(scanner.next());</span><br><span class="line">        File file = <span class="keyword">new</span> File(stringBuilder.toString());</span><br><span class="line">        <span class="keyword">if</span>(!file.isDirectory())&#123;</span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        File file1 = <span class="keyword">null</span>;</span><br><span class="line">        File file2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(deep &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            deep--;</span><br><span class="line">            file1 = <span class="keyword">new</span> File(file, <span class="string">&quot;file&quot;</span>+(num - deep));</span><br><span class="line">            file1.mkdir();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= num - deep; i++) &#123;</span><br><span class="line">                file2 = <span class="keyword">new</span> File(file,<span class="string">&quot;file&quot;</span>+i+<span class="string">&quot;.txt&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    file2.createNewFile();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            file = file1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> file;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    判断指定目录下是否有后缀名为.jpg的文件，如果有就输出该文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入查看的目录&quot;</span>);</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        str = scan.next();</span><br><span class="line">        File file = <span class="keyword">new</span> File(str);</span><br><span class="line">        <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">            String[] list = file.list();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (list[i].endsWith(<span class="string">&quot;.jpg&quot;</span>)) &#123;</span><br><span class="line">                    System.out.println(list[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    遍历指定目录所有文件名称，包括子文件目录中的文件。</span></span><br><span class="line"><span class="comment">    拓展1：并计算指定目录占用空间的大小</span></span><br><span class="line"><span class="comment">    拓展2：删除指定文件目录及其下的所有文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历指定目录所有文件，包括子文件目录中的文件</span></span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入查看的目录&quot;</span>);</span><br><span class="line">        Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        str = scan.next();</span><br><span class="line">        File file = <span class="keyword">new</span> File(str);</span><br><span class="line">        ergodic(file);</span><br><span class="line">        System.out.println(<span class="string">&quot;该目录占用空间：&quot;</span>+spaceSize(file)+<span class="string">&quot;Byte，即&quot;</span>+spaceSize(file)/<span class="number">1024</span>+<span class="string">&quot;KB&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String str1 = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;输入删除的目录&quot;</span>);</span><br><span class="line">        Scanner scan1 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        str1 = scan1.next();</span><br><span class="line">        File file1 = <span class="keyword">new</span> File(str1);</span><br><span class="line">        deleteFiles(file1);</span><br><span class="line">        ergodic(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历指定目录所有文件名称，包括子文件目录中的文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ergodic</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            System.out.println(file.getPath());</span><br><span class="line">            String[] list = file.list();</span><br><span class="line">            <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">                File file1 = <span class="keyword">new</span> File(file, s);</span><br><span class="line">                <span class="keyword">if</span> (file1.isDirectory()) &#123;</span><br><span class="line">                    ergodic(file1);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(file1.getPath());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> System.out.println(file.getPath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算指定目录所占用空间大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">spaceSize</span><span class="params">(File file )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            String[] list = file.list();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">                File file1 = <span class="keyword">new</span> File(file, list[i]);</span><br><span class="line">                <span class="keyword">if</span> (file1.isDirectory())&#123;</span><br><span class="line">                    sum += spaceSize(file1);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    sum += file1.length();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum += file.length();</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除指定目录下的所有文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteFiles</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory())&#123;</span><br><span class="line">            String[] list = file.list();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">                File file1 = <span class="keyword">new</span> File(file,list[i]);</span><br><span class="line">                <span class="keyword">if</span>(file1.isDirectory())&#123;</span><br><span class="line">                    deleteFiles(file1);</span><br><span class="line">                    <span class="comment">//file1.delete();//删除子文件夹</span></span><br><span class="line">                &#125;<span class="keyword">else</span> file1.delete();<span class="comment">//删除子文件夹</span></span><br><span class="line">            &#125;</span><br><span class="line">            file.delete();<span class="comment">//最后删除自己</span></span><br><span class="line">        &#125;<span class="keyword">else</span> file.delete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-IO流原理及流的分类"><a href="#2-IO流原理及流的分类" class="headerlink" title="2. IO流原理及流的分类"></a>2. IO流原理及流的分类</h4><h5 id="2-1-Java-IO原理"><a href="#2-1-Java-IO原理" class="headerlink" title="2.1 Java IO原理"></a>2.1 Java IO原理</h5><ul>
<li>I/O是Input/Ouput的缩写，I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等</li>
<li>Java程序中，对于数据的输入/输出操作以”流(stream)“的方式进行</li>
<li>java.io包下提供了各种”流“类和几口，用以获取不同种类的数据，并通过标准的方法输入或输出数据</li>
<li>输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中</li>
<li>输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210730115913.png" alt="image-20210730115911723"></li>
</ul>
<h5 id="2-2-流的分类"><a href="#2-2-流的分类" class="headerlink" title="2.2 流的分类"></a>2.2 流的分类</h5><ul>
<li>按操作数据单位不同分为：字节流(8 bit)，字符流（16 bit)</li>
<li>按数据流的流向不同分为：输入流，输出流</li>
<li>按流的角色不同分为：节点流，处理流</li>
</ul>
<table>
<thead>
<tr>
<th>（抽象基类）</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody></table>
<ol>
<li>Java的IO流共涉及40多个类，实际上非常规则，都是从如下四个抽象基类派生的</li>
<li>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</li>
<li>IO流体系</li>
</ol>
<table>
<thead>
<tr>
<th>分类</th>
<th>字节输入流</th>
<th>字节输出流</th>
<th>字符输入流</th>
<th>字符输出流</th>
</tr>
</thead>
<tbody><tr>
<td>抽象基类</td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader</td>
<td>Writer</td>
</tr>
<tr>
<td>访问文件</td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
<td>FileReader</td>
<td>FileWiter</td>
</tr>
<tr>
<td>访问数组</td>
<td>ByteArayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>CharArrayRead</td>
<td>CharArrayWrite</td>
</tr>
<tr>
<td>访问管道</td>
<td>PipedInputStream</td>
<td>PipedOutputStream</td>
<td>PipedReader</td>
<td>PipedWrite</td>
</tr>
<tr>
<td>访问字符串</td>
<td></td>
<td></td>
<td>StringReader</td>
<td>StringWriter</td>
</tr>
<tr>
<td>缓冲流</td>
<td>BufferedInputStream</td>
<td>BufferedOutputStream</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td>转换流</td>
<td></td>
<td></td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
</tr>
<tr>
<td>对象流</td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>FilterInputStream</td>
<td>FilterOutputStream</td>
<td>FilterReader</td>
<td>FilterWriter</td>
</tr>
<tr>
<td>打印流</td>
<td></td>
<td>PrintStream</td>
<td></td>
<td>PrintWriter</td>
</tr>
<tr>
<td>推回输入流</td>
<td>PushbackInputStream</td>
<td></td>
<td>PushbackReader</td>
<td></td>
</tr>
<tr>
<td>特殊流</td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h5 id="2-3-节点流和处理流"><a href="#2-3-节点流和处理流" class="headerlink" title="2.3 节点流和处理流"></a>2.3 节点流和处理流</h5><ul>
<li><p>节点流：直接从数据源或目的地读取数据</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210730122031.png" alt="image-20210730122030439"></p>
</li>
<li><p>处理流：不直接连接到数据源或目的地，而是”连接“在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更加强大的读写功能</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210730122155.png" alt="image-20210730122153934"></p>
</li>
</ul>
<h5 id="2-4-InputStram-amp-Reader"><a href="#2-4-InputStram-amp-Reader" class="headerlink" title="2.4 InputStram &amp; Reader"></a>2.4 InputStram &amp; Reader</h5><ul>
<li>InputStream和Reader是所有输入流的基类</li>
<li>InputStream（典型实现：FileInputStream）<ul>
<li>int read()</li>
<li>int read(byte[] b)</li>
<li>int read(byte[] b, int off, int len)</li>
</ul>
</li>
<li>Reader（典型实现：FileRead）<ul>
<li>int read()</li>
<li>int read(char[] c)</li>
<li>int read(char[] c, int off, int len)</li>
</ul>
</li>
<li>程序中打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显示的关闭文件IO资源</li>
<li>FileInputStream从文件系统中的某个文件中获得输入字节。FileInputStream用于读取非文本数据之间的原始字节流。要读取字符流，需要使用FileReader</li>
</ul>
<h6 id="2-4-1-InptuStream"><a href="#2-4-1-InptuStream" class="headerlink" title="2.4.1 InptuStream"></a>2.4.1 InptuStream</h6><ul>
<li><p>int read()</p>
<p>从输入流中读取数据的下一字节。返回0-255返回内的int字节值。如果因为已经到达流末尾而没有可用的字节，则返回-1</p>
</li>
<li><p>int read(byte[] b)</p>
<p>从此输入流中将最多b.length个字节的数据读入下一个byte数组中。如果因已经到达流末尾而没有可用的字节，则返回-1。否则以整数形式返回实际读取的字节数</p>
</li>
<li><p>int read(byte[] b, int off, int len)</p>
<p>将输入流中最多len个数据字节读入byte数组。尝试读取len个字节，但读取的字节也可能小于该值。以整数形式返沪实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回-1</p>
</li>
<li><p>public void close() throws IOException</p>
<p>关闭此输入流并释放与该流相关联的所有系统资源</p>
</li>
</ul>
<h6 id="2-4-2-Reader"><a href="#2-4-2-Reader" class="headerlink" title="2.4.2 Reader"></a>2.4.2 Reader</h6><ul>
<li><p>int read()</p>
<p>读取单个字符。作为整数读取的字符，返回在0到65535之间(0x00-0xffff)(两个字节码的Unicode码)，如果已经到达流的末尾，则返回-1</p>
</li>
<li><p>int read(char[] cbuf)</p>
<p>将字符读入数组，如果已经到流的末尾，则返回-1，否则返回本次读取的字符数</p>
</li>
<li><p>int read(char[] cbuf, int off, int len)</p>
<p>将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读取len个字符。如果已经到达流的末尾，则返回-1 。否则返回本次读取的字符数</p>
</li>
<li><p>public void close() throws IOExecption</p>
<p>关闭此输入流并释放与该流关联的所有系统资源</p>
</li>
</ul>
<h5 id="2-5-OutputSream-amp-Writer"><a href="#2-5-OutputSream-amp-Writer" class="headerlink" title="2.5 OutputSream &amp; Writer"></a>2.5 OutputSream &amp; Writer</h5><ul>
<li><p>OutputStream和Write也非常相似</p>
<ul>
<li>void write(int b/int c)</li>
<li>void write(byte[] b/char[] cbuf)</li>
<li>void write(byte[] b/char[] buff, int off, int len)</li>
<li>void flush()</li>
<li>void close() 需要先刷新再关闭此流</li>
</ul>
</li>
<li><p>因为字符流直接以字符为操作单位，所以Write可以用字符串来替换字符数组，即以String对象作为参数</p>
<p>void write(String str)</p>
<p>void write(String str, int off, int len)</p>
</li>
<li><p>FileOutputStream从文件系统中的某个文件中获得输出字节。FileOutputStream用于写出非文本数据之类的原始字节流。要写出字符流。需要使用FileWrite</p>
</li>
</ul>
<h6 id="2-5-1-OutputStream"><a href="#2-5-1-OutputStream" class="headerlink" title="2.5.1 OutputStream"></a>2.5.1 OutputStream</h6><ul>
<li><p>void write(int b)</p>
<p>将指定的字节写入此输入流。write的常规协定是：向输出流写入一个字节。要写入的字节是参数b的低八位。b的24个高位将被忽略。即写入0-255范围</p>
</li>
<li><p>void write(byte[] b)</p>
<p>将b.length个字节从指定的byte数组写入此输入流。write(b)的常规协定是：应该与调用write(b,0,b.length)的效果完全相同</p>
</li>
<li><p>void write(byte[] b, int off, int len)</p>
<p>将指定byte数组中从偏移量off开始的len个字节写入此输入流</p>
</li>
<li><p>public void flush() throws IOException</p>
<p>刷新此输入流并强制写出所哟缓冲的输出字节，调用此方法指示应将这些字节立即写入他们预期的目标</p>
</li>
<li><p>public void close() throws IOException</p>
<p>关闭此输出流并释放与该流关联的所有系统资源</p>
</li>
</ul>
<h6 id="2-5-2-Write"><a href="#2-5-2-Write" class="headerlink" title="2.5.2 Write"></a>2.5.2 Write</h6><ul>
<li><p>void write(int c)</p>
<p>写入单个字符。要写入的字符包含再给定数值的16个低位中，16个高位被忽略。即写入0-65535之间的Unicode码</p>
</li>
<li><p>void write(char[] cbuf)</p>
<p>写入字符数组</p>
</li>
<li><p>void write(char[] cbuf, int off, int len)</p>
<p>写入字符串的某一部分</p>
</li>
<li><p>void flush()</p>
<p>刷新该流的缓冲，则立即将他们写入预期目标</p>
</li>
<li><p>public void close() throws IOException</p>
<p>关闭此输入流并释放与该流关联的所有系统资源</p>
</li>
</ul>
<h4 id="3-节点流（或流文件）"><a href="#3-节点流（或流文件）" class="headerlink" title="3.节点流（或流文件）"></a>3.节点流（或流文件）</h4><h5 id="3-1-读取文件"><a href="#3-1-读取文件" class="headerlink" title="3.1 读取文件"></a>3.1 读取文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 建立一个流对象，将已存在的文件加载进流</span><br><span class="line">FileReader fr &#x3D; new FileReader(new File(&quot;Test.txt&quot;));</span><br><span class="line"></span><br><span class="line">2.创建一个临时存放数据的数组</span><br><span class="line">char[] ch &#x3D; new char[1024];</span><br><span class="line"></span><br><span class="line">3.调用流对象的读取方法将流中的数据读到数组中</span><br><span class="line">fr.read(ch);</span><br><span class="line"></span><br><span class="line">4.关闭资源</span><br><span class="line">fr.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileReader fr = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fr = <span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">&quot;c:\\test.txt&quot;</span>));</span><br><span class="line">    <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = fr.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.print(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;read-Exception :&quot;</span> + e.getMessage());</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fr != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fr.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;close-Exception :&quot;</span>+ e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-写入文件"><a href="#3-2-写入文件" class="headerlink" title="3.2 写入文件"></a>3.2 写入文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.创建流对象，建立数据存放文件</span><br><span class="line">FileWrite fw &#x3D; new FileWrite(new File(&quot;Test.txt&quot;));</span><br><span class="line"></span><br><span class="line">2.调用流对象的写入方法，将数据写入流</span><br><span class="line">fw.write(&quot;XiongZhuo&quot;);</span><br><span class="line"></span><br><span class="line">3.关闭流资源，并将流中的数据清空到文件中</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileWrite fw = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fw = <span class="keyword">new</span> FileWrite(<span class="keyword">new</span> File(<span class="string">&quot;Test.txt&quot;</span>));</span><br><span class="line">    fw.write(<span class="string">&quot;XiongZhuo&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fw != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            fw.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.pritnStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-注意点"><a href="#3-3-注意点" class="headerlink" title="3.3 注意点"></a>3.3 注意点</h5><ul>
<li>定义文件路径时，可以用”/“或”//“</li>
<li>在写入一个文件时，如果使用构造器FileOutputStrean(file)，则目录下有同名文件将被覆盖</li>
<li>如果使用构造器FileOutputStream(file, true)，则目录下的同名文件不会被覆盖，在文件内容末尾追加内容</li>
<li>在读取文件时，必须保证该文件以存在，否则报异常</li>
<li>字节流操作字节，比如：.mp3，.avi, .rmvb, .mp4, .jpg, .doc, .ppt</li>
<li>字符流操作字符，只能操作普通文本文件。最常见的文本文件：.txt, .java, .c, .cpp等语言的源代码。尤其注意.doc, .excel, .ppt这些不是文本文件</li>
</ul>
<h4 id="4-缓冲流"><a href="#4-缓冲流" class="headerlink" title="4. 缓冲流"></a>4. 缓冲流</h4><ul>
<li><p>为了提高数据的读写速度，Java API提供了带缓冲功能的流类，在使用这些流时，会创建一个内部缓冲数组，缺省使用8192个字节（8Kb）的缓冲区</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFALUT_BUFFER_SIZE = <span class="number">8192</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>缓冲流要”套接“在相应的节点流之上，根据数据操作单位可以把缓冲流分为：</p>
<ul>
<li>BufferedInputStream和BufferedOutputStream</li>
<li>BufferedReader和BufferedWriter</li>
</ul>
</li>
<li><p>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区</p>
</li>
<li><p>当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个（8Kb）存在缓冲区中，直到缓冲区满了，才重新从文件中读取下一个8192个字节数组</p>
</li>
<li><p>向流中写入字节时，不会直接写到文件，先写道缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区内的内容全部写到输入流</p>
</li>
<li><p>关闭流的顺序和打开流的顺序相反。只要关闭最外层的流即可，关闭最外层流也会相应关闭内层节点流</p>
</li>
<li><p>flush()方法的使用：手动将buffer中内容写入文件</p>
</li>
<li><p>如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭以后不能再写出</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210730151021.png" alt="image-20210730151019053"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//创建缓冲流对象：他是处理流，是对节点流的包装</span></span><br><span class="line">    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;source.txt&quot;</span>));</span><br><span class="line">    bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;dest.txt&quot;</span>));</span><br><span class="line">    String str;</span><br><span class="line">    <span class="keyword">while</span>((str = br.readline()) != <span class="keyword">null</span>)&#123;<span class="comment">//一次读取字符文本文件的一行字符</span></span><br><span class="line">        bw.writer(str);<span class="comment">//一次写入一行字符</span></span><br><span class="line">        bw.newLine();<span class="comment">//写入分隔符</span></span><br><span class="line">    &#125;</span><br><span class="line">    bw.flush();<span class="comment">//刷新缓冲区</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.pritnStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//关闭IO流对象</span></span><br><span class="line">    <span class="keyword">if</span>(bw != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            bw.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(br != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            br.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-转换流"><a href="#5-转换流" class="headerlink" title="5. 转换流"></a>5. 转换流</h4><ul>
<li>转换流提供了再字节流和字符流之间的转换</li>
<li>Java API提供了两个转换流<ul>
<li>InputStreamReader：将InputStream转化为Reader</li>
<li>OutputStreamWriter：将OutputStream转换为Writer</li>
</ul>
</li>
<li>字节流中的数据都是字符时，转换成字符流操作更高效</li>
<li>很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能</li>
</ul>
<h5 id="5-1-InputStreamReader"><a href="#5-1-InputStreamReader" class="headerlink" title="5.1 InputStreamReader"></a>5.1 InputStreamReader</h5><ul>
<li><p>实现将字节的输入流按指定字符集转化为字符的输入流</p>
</li>
<li><p>需要和InputStream”套接”</p>
</li>
<li><p>构造器</p>
<ul>
<li><p>public InputStreamReader(InputStream in)</p>
</li>
<li><p>public InputStreamReader(InputStream in, String charsetName)</p>
<p>如：Reader isr = new InputStreamRead(System.in, “gbk”);</p>
</li>
</ul>
</li>
</ul>
<h5 id="5-2-OutputStreamWriter"><a href="#5-2-OutputStreamWriter" class="headerlink" title="5.2 OutputStreamWriter"></a>5.2 OutputStreamWriter</h5><ul>
<li>实现将字符的输入流按指定字符集转化为字节的输出流</li>
<li>需要实现和OutputStream”套接“</li>
<li>构造器<ul>
<li>public OutputStreamWriter(OutputStream out)</li>
<li>public OutputStreamWriter(OutputSream out, String charsetName)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyInput</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;dbcp5.txt&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">    BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(osw);</span><br><span class="line">    </span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>((str = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">        bw.write(str);</span><br><span class="line">        bw.newLine();</span><br><span class="line">        bw.flush;</span><br><span class="line">    &#125;</span><br><span class="line">    bw.close;</span><br><span class="line">    br.close;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-补充：字符编码"><a href="#5-3-补充：字符编码" class="headerlink" title="5.3 补充：字符编码"></a>5.3 补充：字符编码</h5><ul>
<li><p>编码表的由来</p>
<p>计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让他可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是常见的编码表</p>
</li>
<li><p>常见编码表</p>
<ul>
<li><p>ASCII：美国标准信息交换码</p>
<p>​            用一个字节的7位可以表示</p>
</li>
<li><p>ISO8859-1：拉丁码表。欧洲码表</p>
<p>​            用一个字节的8位表示</p>
</li>
<li><p>GB2312：中国的中文编码表。最多两个字节编码所有字符</p>
</li>
<li><p>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</p>
</li>
<li><p>Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示</p>
</li>
<li><p>UTF-8：变长的编码方式，可用1-4个字节表示一个字符</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210730154605.png" alt="image-20210730154602941"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 在Unicode出现之前，所有的字符集都是和具体编码方案绑定在一起的（即字符集≈编码方式），都是直接将字符和最终字节流绑定死了。</span><br><span class="line"> GBK等双字节编码方式，用最高位是1或0表示两个字节和一个字节。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Unicode不完美，这里就有三个问题，一个是，我们已经知道英文字母子要一个字节表示就够了，第二个问题是如何才能区别Unicode和ASCII?计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？第三个，如果GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。Unicode在很长一段时间内无法推广，知道互联网的出现</p>
</li>
<li><p>面向传输的众多UTF(USC Transfer Format)标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界所有的文化字符了</p>
</li>
<li><p>Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210730155603.png" alt="image-20210730155601319"></p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210730155847.png" alt="image-20210730155845697"></p>
</li>
<li><p>编码：字符串–&gt;字节数组</p>
</li>
<li><p>解码：字节数组–&gt;字符串</p>
</li>
<li><p>转化流的编码应用</p>
<ul>
<li>可以将字符按指定编码格式存储</li>
<li>可以对文本数据按指定编码格式来解读</li>
<li>指定编码表的动作由构造器完成</li>
</ul>
</li>
</ul>
<h4 id="6-标准输入输出流"><a href="#6-标准输入输出流" class="headerlink" title="6. 标准输入输出流"></a>6. 标准输入输出流</h4><ul>
<li>System.in和System.out分别代表了系统标准的输入和输出设备</li>
<li>默认输入设备是：键盘。输出设备是：显示器</li>
<li>System.in的类型是InputStream</li>
<li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream的子类</li>
<li>重定向：通过System类的setIn,setOut方法对默认设备进行改变<ul>
<li>public static void setIn(InputStream in)</li>
<li>public static void setOut(PrintStream out)</li>
</ul>
</li>
</ul>
<p><strong>题目：</strong></p>
<p>从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续 进行输入操作，直至当输入“e”或者“exit”时，退出程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;请输入信息（退出输入e或者exit）：&quot;</span>);</span><br><span class="line"><span class="comment">//把“标准”输入流（键盘输入）这个字节流包装成字符流，再包装成缓冲流</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>((s = br.readLine) != <span class="keyword">null</span>)&#123;<span class="comment">//读取用户输入的一行数据</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;e&quot;</span>.equalsIgonreCase(s) || <span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(s))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;安全退出&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将读到的整行字符串转为大写输出</span></span><br><span class="line">        System.out.println(<span class="string">&quot;---&gt;: &quot;</span>+s.toUpperCase());</span><br><span class="line">        System.out.println(<span class="string">&quot;继续输入信息&quot;</span>)；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(br != <span class="keyword">null</span>)&#123;</span><br><span class="line">            br.close();<span class="comment">//关闭过滤流时，会自动关闭它的包装类的底层节点流</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOExecption e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-打印流"><a href="#7-打印流" class="headerlink" title="7. 打印流"></a>7. 打印流</h4><ul>
<li>实现将基本数据类型的数据格式转化为字符串输出</li>
<li>打印流：PrintStream和PrintWriter<ul>
<li>提供了一系列的重载的print()和println()方法，用于多种数据类型的输出</li>
<li>PrintStream和PrintWriter的输出不会抛出IOException异常</li>
<li>PrintStream和PrintWriter有自动flush功能</li>
<li>PrintStream打印的所有字符都使用平台默认的字符编码转化为字节。在需要写入的字符而不是写入字节的情况下应该使用PrintWriter类</li>
<li>System.out返回的是PrintStream的实例</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintStream ps = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;text.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//创建打印输出流，设置为自动刷新模式（写入换行符或字节&#x27;\n&#x27;时都会刷新缓冲区）</span></span><br><span class="line">    ps = <span class="keyword">new</span> PrintStream(fos, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span>(ps != <span class="keyword">null</span>)&#123;<span class="comment">//把标准输出流（控制台输出）改为文件</span></span><br><span class="line">        System.setOut(ps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++)&#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>)i);</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">50</span> == <span class="number">0</span>)&#123;<span class="comment">//每50个数据一行</span></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ps != <span class="keyword">null</span>)&#123;</span><br><span class="line">        ps.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-数据流"><a href="#8-数据流" class="headerlink" title="8. 数据流"></a>8. 数据流</h4><ul>
<li><p>为了方便地操作Java语言的基本上数据类型和String的数据，可以使用数据流</p>
</li>
<li><p>数据流有两类：（用于读取和写出的基本数据类型、String类的数据）</p>
<ul>
<li>DataInputStream和DataOutputStream</li>
<li>分别“套接”在InputStream和OutputStream子类的流上</li>
</ul>
</li>
<li><p>DataInputStream中的方法</p>
<p>boolean readBoolean()        byte readByte()</p>
<p>char readChar()                     float readFloat()</p>
<p>double readDouble()            short readShort()</p>
<p>long readLong()                     int readInt()</p>
<p>String readUTF()                    void readFully(byte[] b)</p>
</li>
<li><p>DataOutputStream中的方法</p>
<ul>
<li>将上述的方法的read改为相应的write即可</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;<span class="comment">//创建连接到指定文件的数据输出流对象</span></span><br><span class="line">    dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;destData.dat&quot;</span>));</span><br><span class="line">    dos.writeUTF(<span class="string">&quot;我和我的祖国&quot;</span>);<span class="comment">//写UTF字符串</span></span><br><span class="line">    dos.writeBoolean(<span class="keyword">false</span>);<span class="comment">//写入布尔值</span></span><br><span class="line">    dos.writeLong(<span class="number">12432442323L</span>);<span class="comment">//写入长整数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;写入文件成功&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;<span class="comment">//关闭流对象</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dos != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//关闭过滤时，会自动关闭它包装类的底层节点流</span></span><br><span class="line">            dos.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateInputStream dis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;destData.dat&quot;</span>));</span><br><span class="line">    String info = dis.readUTF();</span><br><span class="line">    <span class="keyword">boolean</span> flag = dis.readBoolean();</span><br><span class="line">    <span class="keyword">long</span> time = dis.readLong();</span><br><span class="line">    System.out.print(info);</span><br><span class="line">    System.out.print(flag);</span><br><span class="line">    System.out.print(time);</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dis != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            dis.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">            e.pritnStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-对象流"><a href="#9-对象流" class="headerlink" title="9. 对象流"></a>9. 对象流</h4><ul>
<li>ObjectInputStream和ObjectOutputStream<ul>
<li>用于存储读取基本数据类型数据或对象的处理流。它可以把Java中的对象写到数据源中，也能把对象从数据源中还原出来</li>
</ul>
</li>
<li>序列化：用ObjectOutputStream类保存基本数据类型数据或对象的机制</li>
<li>反序列化：用ObjectInputStream类读取基本数据类型数据或对象的机制</li>
<li>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</li>
<li>对象序列化机制允许把内存中的Java对象转换成为平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其他程序获取了这种二进制流，就可以恢复成原来的Java对象</li>
<li>序列化的好处在于可以将任何实现了Serializable接口的对象转化为字节数据，使其保存和传输时可以被还原</li>
<li>序列化是RMI(Remote Method Invoke - 远程方法调用)过程的参数和返回值都必须实现的机制，而RMI是JavaEE的基础。因此序列化机制是JavaEE平台的基础</li>
<li>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出NotSerializableExceotion异常<ul>
<li>Serializable</li>
<li>Externalizable</li>
</ul>
</li>
<li>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：<ul>
<li>private static final long serialVersionUID;</li>
<li>serialVersionUID用来表明类的不同版本间的兼容性。简而言之，其目的是以序列化对象进行版本控制，有关个版本反序列化时是否兼容</li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID可能发生变化。故建议显示声明</li>
</ul>
</li>
<li>简单来说，Java的序列化机制是通过在运行是判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVresionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。（InvalidCastException）</li>
<li>若某个类实现类Serializable接口，该类就是可序列化的：<ul>
<li>创建一个ObjectOutputStream</li>
<li>调用ObjectOutputStream对象的writeObject(对象)方法输出可序列化的对象</li>
<li>注意写出一次，操作一次flush()一次</li>
</ul>
</li>
<li>反序列化<ul>
<li>创建一个ObjectInputStream</li>
<li>调用readObjec()方法读取流中的对象</li>
</ul>
</li>
<li>强调：如果某个类的属性不是基本数据类型或String类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field的类不能序列化</li>
</ul>
<p>//序列化：将对象写入到磁盘或者进行网络传输</p>
<p>//要求对象必须实现序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectOutputSream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;data.txt&quot;</span>));Person p = <span class="keyword">new</span> Person(<span class="string">&quot;xiong&quot;</span>,<span class="number">23</span>,<span class="string">&quot;花江&quot;</span>,<span class="keyword">new</span> Pet());oos.writeObject(p);oos.flush();oos.close();</span><br></pre></td></tr></table></figure>

<p>//反序列化：将磁盘中的对象数据源读出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;data.txt&quot;</span>));Person p1 = (Person)ois.readObject();System.out.println(p1.toString());ois.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">谈谈对java.io.Serializable接口的理解，我们知道它用于序列化，还是空方法接口，还有其他认识吗？实现了Serializable接口的对象，可将它们转化成一系列字节，并可以在以后完全恢复回来原来的样子。这一过程亦可以通过网络进行。这意味着序列化机制能自动补偿操作系统间的差异，换句话说，可以先在Windows机器上创建一个对象，对其序列化，然后通过网络发给一台Unix机器，然后在那里准确无误地重新“装配”。不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节 由于大部分作为参数的类如String、Integer等都实现了java.io.Serializable的接口，也可以利用多态的性质，作为参数使接口更灵活</span><br></pre></td></tr></table></figure>

<h4 id="10-随机存取文件流"><a href="#10-随机存取文件流" class="headerlink" title="10. 随机存取文件流"></a>10. 随机存取文件流</h4><h5 id="10-1-RandomAccessFile类"><a href="#10-1-RandomAccessFile类" class="headerlink" title="10.1 RandomAccessFile类"></a>10.1 RandomAccessFile类</h5><ul>
<li>RandomAccessFile声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了DateInput、DataOutput这两个接口，也就意味着这个类既可以读又可以写</li>
<li>RandomAccessFile类支持“随机访问”的方式，程序可以直接跳到文件的任意地方来读、写文件<ul>
<li>支持只访问部分内容</li>
<li>可以向已存在的文件后追加内容</li>
</ul>
</li>
<li>RandomAccessFile对象包括记录指针，用以标识当前读写处的位置。RandomAccessFile类对象可以自由移动记录指针：<ul>
<li>long getFilePointer()：获取文件记录指针当前位置</li>
<li>void seek(long pos)：将文件记录指针定位到pos位置</li>
</ul>
</li>
<li>构造器<ul>
<li>public RandomAccessFile(File file, String mode)</li>
<li>public RandomAccessFile(String name, String mode)</li>
</ul>
</li>
<li>创建RandomAccesFile类的实例需要指定一个mode参数，该参数指定RandomAccessFile的访问模式：<ul>
<li>r：以只读的方式打开</li>
<li>rw：打开以便读取和写入</li>
<li>rwd：打开以便读取和写入；同步文件内容的更新</li>
<li>rws：打开以便读取和写入；同步文件内容和元数据的更新</li>
</ul>
</li>
<li>如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。如果模式为rw读写，如果文件不存在则会去创建文件，如果存在则不会创建</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们可以用RandomAccessFile这个类，来实现一个多线程断点下载的功能，用过下载工具的朋友们都知道，下载前都会建立两个临时文件，一个是与被下载文件大小相同的空文件，另一个是记录文件指针的位置文件，每次暂停的时候，都会保存上一次的指针，然后断点下载的时候，会继续从上一次的地方下载，从而实现断点下载或上传的功能</span><br></pre></td></tr></table></figure>

<p><strong>读取文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAcessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">raf.seek(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> off = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">5</span>;</span><br><span class="line">raf.read(b,off,len);</span><br><span class="line"></span><br><span class="line">String str = <span class="keyword">new</span> String(b,<span class="number">0</span>,len);</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">raf.close();</span><br></pre></td></tr></table></figure>

<p><strong>写入文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">raf.seek(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//先读出来</span></span><br><span class="line">String temp = raf.readLine();</span><br><span class="line"></span><br><span class="line">raf.seek(<span class="number">5</span>);</span><br><span class="line">raf.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line">raf.write(temp.getBytes());</span><br><span class="line"></span><br><span class="line">raf.close();</span><br></pre></td></tr></table></figure>

<h4 id="11-NIO-2中Path、Paths、Files类的使用"><a href="#11-NIO-2中Path、Paths、Files类的使用" class="headerlink" title="11. NIO.2中Path、Paths、Files类的使用"></a>11. NIO.2中Path、Paths、Files类的使用</h4><h5 id="11-1-NIO-2"><a href="#11-1-NIO-2" class="headerlink" title="11.1 NIO.2"></a>11.1 NIO.2</h5><ul>
<li><p>Java NIO(New IO, Non-Blocking IO)是从Java1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的（IO是面型流的）、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作</p>
</li>
<li><p>Java API中提供了两套NIO,一套是针对标准输入输出的NIO,另一套就是网络编程的NIO</p>
<ul>
<li><p>|—–java.nio.channels.Channel</p>
<p>​        |—–FileChannel：处理本地文件</p>
<p>​        |—–SocketChannel：TCP网络编程的客户端的Channel</p>
<p>​        |—–ServerSocketChannel：TCP网络编程的服务器端的Channel</p>
<p>​        |—–DatagramChannel：UDP网络编程中发送端和接收端的Channel</p>
</li>
</ul>
</li>
<li><p>随着JDK7的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件西永特性的支持，以至于我们称他们为NIO2.0。因为NIO提供的一些功能，NIO已经成为文件处理中越来越重要的部分</p>
</li>
</ul>
<h5 id="11-2-Path、Paths和Files核心API"><a href="#11-2-Path、Paths和Files核心API" class="headerlink" title="11.2 Path、Paths和Files核心API"></a>11.2 Path、Paths和Files核心API</h5><ul>
<li><p>早期的Java只提供一个File类来访问文件系统，但File类的功能都比较有限，所以提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息</p>
</li>
<li><p>NIO.2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版，实际引用的资源也可以不存在</p>
</li>
<li><p>在以前IO操作都是这样写的：</p>
<p>import java.io.File;</p>
<p>File file = new File(“index.html”);</p>
</li>
<li><p>但在Java7中，我们可以这样写：</p>
<p>import java.nio.file.Path;</p>
<p>import java.nio.file.Paths;</p>
<p>Path path = Paths.get(“index.html”);</p>
</li>
<li><p>同时，NIO.2在java.nio.file包下还提供了Files、Paths工具类。Files包含了大量的静态工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法</p>
</li>
<li><p>Paths类提供的静态get()方法用来获取Path对象：</p>
<ul>
<li>static Path get(String first, String … more)：用于将多个字符串连成路径</li>
<li>static Path get(URI uri)：返回指定uri对应的Path路径</li>
</ul>
</li>
</ul>
<h5 id="11-3-Path接口"><a href="#11-3-Path接口" class="headerlink" title="11.3 Path接口"></a>11.3 Path接口</h5><ul>
<li>Path常用方法：<ul>
<li>String toString()：返回调用Path对象的字符串表示形式</li>
<li>boolean startsWith(String path)：判断是否以path路径开始</li>
<li>boolean endsWith(String path) : 判断是否以 path 路径结束</li>
<li>boolean isAbsolute() : 判断是否是绝对路径</li>
<li>Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</li>
<li>Path getRoot() ：返回调用 Path 对象的根路径</li>
<li>Path getFileName() : 返回与调用 Path 对象关联的文件名</li>
<li>int getNameCount() : 返回Path 根目录后面元素的数量</li>
<li>Path getName(int idx) : 返回指定索引位置 idx 的路径名称</li>
<li>Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</li>
<li>Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象</li>
<li>File toFile(): 将Path转化为File类的对象</li>
</ul>
</li>
</ul>
<h5 id="11-4-File类"><a href="#11-4-File类" class="headerlink" title="11.4 File类"></a>11.4 File类</h5><ul>
<li>java.nio.file.Files用于操作文件或目录的工具类</li>
<li>Files常用方法：<ul>
<li>Path copy(Path src, Path dest, CopyOption … how) : 文件的复制</li>
<li>Path createDirectory(Path path, FileAttribute … attr) : 创建一个目录</li>
<li>Path createFile(Path path, FileAttribute … arr) : 创建一个文件</li>
<li>void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错</li>
<li>void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除</li>
<li>Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置</li>
<li>long size(Path path) : 返回 path 指定文件的大小</li>
</ul>
</li>
<li>Files常用方法：用于判断<ul>
<li>boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</li>
<li>boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</li>
<li>boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件</li>
<li>boolean isHidden(Path path) : 判断是否是隐藏文件</li>
<li>boolean isReadable(Path path) : 判断文件是否可读</li>
<li>boolean isWritable(Path path) : 判断文件是否可写</li>
<li>boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</li>
</ul>
</li>
<li>Files常用方法：用于操作内容<ul>
<li>SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。</li>
<li>DirectoryStream newDirectoryStream(Path path) : 打开 path 指定的目录</li>
<li>InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</li>
<li>OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>17-Java9-11新特性</title>
    <url>/2021/09/17/17%E2%80%94Java9-11%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="17—Java9—11新特性"><a href="#17—Java9—11新特性" class="headerlink" title="17—Java9—11新特性"></a>17—Java9—11新特性</h3><h4 id="1-Java9的特性"><a href="#1-Java9的特性" class="headerlink" title="1. Java9的特性"></a>1. Java9的特性</h4><h5 id="1-1-JDK9的发布"><a href="#1-1-JDK9的发布" class="headerlink" title="1.1 JDK9的发布"></a>1.1 JDK9的发布</h5><p>经过4次跳票，历经曲折的Java 9 终于终于在2017年9月21日发布。从Java 9 这个版本开始，Java 的计划发布周期是 6 个月，下一个 Java 的主版 本将于 2018 年 3 月发布，命名为 Java 18.3，紧接着再过六个月将发布 Java  18.9。这意味着Java的更新从传统的以特性驱动的发布周期，转变为以时间驱动的 （6 个月为周期）发布模式，并逐步的将 Oracle JDK 原商业特性进行开源。针对企业客户的需求，Oracle 将以三年为周期发布长期支持版本（long term  support）。Java 9 提供了超过150项新功能特性，包括备受期待的模块化系统、可交互 的 REPL 工具：jshell，JDK 编译工具，Java 公共 API 和私有代码，以及安 全增强、扩展提升、性能管理改善等。可以说Java 9是一个庞大的系统工程， 完全做了一个整体改变。</p>
<h5 id="1-2-Java9中新特性"><a href="#1-2-Java9中新特性" class="headerlink" title="1.2 Java9中新特性"></a>1.2 Java9中新特性</h5><p>①模块化系统</p>
<p>②jShell命令</p>
<p>③多版本兼容jar包</p>
<p>④接口的私有方法</p>
<p>⑤钻石操作符的升级使用</p>
<p>⑥语法改进：try语句</p>
<p>⑦String存储结构变更</p>
<p>⑧便利的集合特性：of()</p>
<p>⑨增强的Stream API</p>
<p>⑩全新的HTTP客户端API</p>
<p>其他：javadoc的HTML 5支持、Javascript引擎升级：Nashorn、java的动态编译器</p>
<p><a href="https://docs.oracle.com/javase/9/whatsnew/toc.htm#JSNEW-GUID-C23AFD78-C777-460B-8ACE-58BE5EA681F6">官方提供的新特性列表</a></p>
<p><a href="http://openjdk.java.net/projects/jdk9/">JDK 9 (java.net)</a></p>
<p><a href="https://docs.oracle.com/javase/9/">Oracle JDK 9 Documentation</a></p>
<h5 id="1-3-JDK和JRE目录结构的改变"><a href="#1-3-JDK和JRE目录结构的改变" class="headerlink" title="1.3 JDK和JRE目录结构的改变"></a>1.3 JDK和JRE目录结构的改变</h5><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108080917519.png" alt="JDK_HOME(JDK8)" style="zoom: 33%;" />

<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bin目录</td>
<td>包括命令行开发和调试工具，如javac,jar和javadoc</td>
</tr>
<tr>
<td>include目录</td>
<td>包含在编译本地代码时使用的C/C++头文件</td>
</tr>
<tr>
<td>lib目录</td>
<td>包含JDK的几个JAR和其他类型的文件。他有一个tools.jar文件，其中包含javac编译器的Java类</td>
</tr>
<tr>
<td>jre/bin目录</td>
<td>包含基本命令，如java命令。在Windows平台上，他包含系统的运行时动态链接库(DLL)</td>
</tr>
<tr>
<td>jre/lib目录</td>
<td>包含用户可编辑的配置文件，如.properties和.policy文件。包含了几个JAR。rt.jar文件包含运行时的Java类和资源文件</td>
</tr>
</tbody></table>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108080941534.png" alt="JDK_HOME(JDK9)" style="zoom:33%;" />

<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bin目录</td>
<td>包含所有命令。 在Windows平台上，它继续包含系统的运行时动态链接库。</td>
</tr>
<tr>
<td>conf 目录</td>
<td>包含用户可编辑的配置文件，例如以前位于jre\lib目录中的.properties和.policy文件</td>
</tr>
<tr>
<td>include 目录</td>
<td>包含要在以前编译本地代码时使用的C/C++头文件。 它只存在于JDK中</td>
</tr>
<tr>
<td>jmods 目录</td>
<td>包含JMOD格式的平台模块。 创建自定义运行时映像时需要它。 它只存在于JDK中</td>
</tr>
<tr>
<td>legal 目录</td>
<td>包含法律声明</td>
</tr>
<tr>
<td>lib 目录</td>
<td>包含非Windows平台上的动态链接本地库。 其子目录和文件不应由开发人员直接编辑或使用</td>
</tr>
</tbody></table>
<h5 id="1-4-模块化系统：Jigsaw-gt-Modularity"><a href="#1-4-模块化系统：Jigsaw-gt-Modularity" class="headerlink" title="1.4 模块化系统：Jigsaw -&gt; Modularity"></a>1.4 模块化系统：Jigsaw -&gt; Modularity</h5><ul>
<li>谈到 Java 9 大家往往第一个想到的就是 Jigsaw 项目。众所周知，Java 已经发展超过 20 年（95 年最初发布），Java 和相关生态在不断丰富的同时也越 来越暴露出一些问题：<ul>
<li>Java 运行环境的膨胀和臃肿。每次JVM启动的时候，至少会有30～60MB的内存加载，主要原因是JVM需要加载rt.jar，不管其中的类是否被classloader加载，第 一步整个jar都会被JVM加载到内存当中去（而模块化可以根据模块的需要加载程 序运行需要的class）</li>
<li>当代码库越来越大，创建复杂，盘根错节的“意大利面条式代码”的几率呈指数级的 增长。不同版本的类库交叉依赖导致让人头疼的问题，这些都阻碍了 Java 开发和运行效率的提升。</li>
<li>很难真正地对代码进行封装, 而系统并没有对不同部分（也就是 JAR 文件）之间的依赖关系有个明确的概念。每一个公共类都可以被类路径之下任何其它的公共 类所访问到，这样就会导致无意中使用了并不想被公开访问的 API。</li>
</ul>
</li>
<li>本质上讲也就是说，用模块来管理各个package，通过声明某个package 暴露，，模块(module)的概念，其实就是package外再裹一层，不声明默 认就是隐藏。因此，模块化使得代码组织上更安全，因为它可以指定哪 些部分可以暴露，哪些部分隐藏。</li>
<li>实现目标<ul>
<li>模块化的主要目的在于减少内存的开销</li>
<li>只须必要模块，而非全部jdk模块，可简化各种类库和大型应用的开 发和维护</li>
<li>改进 Java SE 平台，使其可以适应不同大小的计算设备</li>
<li>改进其安全性，可维护性，提高性能</li>
</ul>
</li>
</ul>
<p>模块将由通常的类和新的模块声明文件（module-info.java）组成。该文件是位于 java代码结构的顶层，该模块描述符明确地定义了我们的模块需要什么依赖关系， 以及哪些模块被外部使用。在exports子句中未提及的所有包默认情况下将封装在 模块中，不能在外部使用。</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108080957522.png" alt="image-20210808095732377"></p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108080957918.png" alt="image-20210808095749411"></p>
<p>要想在java9demo模块中调用java9test模块下包中的结构，需要在java9test 的module-info.java中声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> java9test &#123;</span><br><span class="line">	<span class="comment">//package we export</span></span><br><span class="line">	<span class="keyword">exports</span> com.atguigui.bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exports：控制着哪些包可以被其它模块访问到。所有不被导出的包默认 都被封装在模块里面。对应在java 9demo 模块的src 下创建module-info.java文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> java9demo &#123;</span><br><span class="line">	<span class="keyword">requires</span> java9test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>requires：指明对其它模块的依赖。</p>
<h5 id="1-5-Java的REPL工具：jShell命令"><a href="#1-5-Java的REPL工具：jShell命令" class="headerlink" title="1.5 Java的REPL工具：jShell命令"></a>1.5 Java的REPL工具：jShell命令</h5><ul>
<li><p>产生背景</p>
<p>像Python 和 Scala 之类的语言早就有交互式编程环境 REPL (read - evaluate - print - loop)了，以交互式的方式对语句和表达式进行求值。开发者只需要输入一些代码， 就可以在编译前获得对程序的反馈。而之前的Java版本要想执行代码，必须创建文 件、声明类、提供测试方法方可实现。</p>
</li>
<li><p>设计理念</p>
<p>即写即得、快速运行</p>
</li>
<li><p>实现目标</p>
<ul>
<li>Java 9 中终于拥有了 REPL工具：jShell。让Java可以像脚本语言一样运行，从 控制台启动jShell，利用jShell在没有创建类的情况下直接声明变量，计算表达式， 执行语句。即开发时可以在命令行里直接运行Java的代码，而无需创建Java文 件，无需跟人解释”public static void main(String[] args)”这句废话。</li>
<li>jShell也可以从文件中加载语句或者将语句保存到文件中。</li>
<li>jShell也可以是tab键进行自动补全和自动添加分号。</li>
</ul>
</li>
<li><p>调出jShell、获取帮助</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081013971.png" alt="image-20210808101348839"></p>
</li>
<li><p>基本使用</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081043772.png" alt="image-20210808104328412"></p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081043200.png" alt="image-20210808104353880"></p>
</li>
<li><p>列出当前session里所有有效的代码片段</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081036316.png" alt="image-20210808103614357"></p>
</li>
<li><p>查看当前session下所有创建过的变量和方法</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081048714.png" alt="image-20210808104838265"></p>
</li>
<li><p>使用外部代码编辑器来编写Java代码</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081053467.png" alt="image-20210808105331336"></p>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081050436.png" alt="image-20210808105026135" style="zoom: 67%;" />

<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081053129.png" alt="image-20210808105301293" style="zoom:67%;" />
</li>
<li><p>使用/open命令调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGUET</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello,GUET!&quot;</span>);	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloGUET.main(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081104251.png" alt="image-20210808110426385"></p>
</li>
<li><p>没有受检异常</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081107445.png" alt="image-20210808110710663"></p>
<p>说明：本来应该强迫我们捕获一个IOException，但却没有出现。因为jShell在 后台为我们隐藏了。</p>
</li>
<li><p>退出jShell</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081108538.png" alt="image-20210808110759934"></p>
</li>
</ul>
<h5 id="1-6-语法改进："><a href="#1-6-语法改进：" class="headerlink" title="1.6 语法改进："></a>1.6 语法改进：</h5><p><strong>接口的私有方法</strong></p>
<p>Java 8中规定接口中的方法除了抽象方法之外，还可以定义静态方法 和默认的方法。一定程度上，扩展了接口的功能，此时的接口更像是 一个抽象类。</p>
<p>在Java 9中，接口更加的灵活和强大，连方法的访问权限修饰符都可 以声明为private的了，此时方法将不会成为你对外暴露的API的一部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">normalInterfaceMethod</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	init();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">methodDefault2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		init();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">// This method is not part of the public API exposed by MyInterface</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;默认方法中的通用操作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">normalInterfaceMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;实现接口的方法&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyInterfaceImpl impl = <span class="keyword">new</span> MyInterfaceImpl();</span><br><span class="line">		impl.methodDefault1();</span><br><span class="line">		<span class="comment">// impl.init();//不能调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>钻石操作符升级使用</strong></p>
<p>我们能够与匿名实现类共同使用钻石操作符（diamond operator）在Java 8中如下的操作是会报错的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Object&gt; com = <span class="keyword">new</span> Comparator&lt;&gt;()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>编译报错信息：Cannot use “&lt;&gt;” with anonymous inner classes.</p>
<p>Java 9中如下操作可以正常执行通过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// anonymous classes can now use type inference</span></span><br><span class="line">Comparator&lt;Object&gt; com = <span class="keyword">new</span> Comparator&lt;&gt;()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>try语法</strong></p>
<p>Java 8 中，可以实现资源的自动关闭，但是要求执行后必须关闭的所有资源必 须在try子句中初始化，否则编译不通过。如下例所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in))&#123;</span><br><span class="line">	<span class="comment">//读取数据细节省略</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 9 中，用资源语句编写try将更容易，我们可以在try子句中使用已经初始 化过的资源，此时的资源是final的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InputStreamReader reader = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">OutputStreamWriter writer = <span class="keyword">new</span> OutputStreamWriter(System.out);</span><br><span class="line"><span class="keyword">try</span> (reader; writer) &#123;</span><br><span class="line">	<span class="comment">//reader是final的，不可再被赋值</span></span><br><span class="line">	<span class="comment">//reader = null;</span></span><br><span class="line">	<span class="comment">//具体读写操作省略</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-7-String存储结构变更"><a href="#1-7-String存储结构变更" class="headerlink" title="1.7 String存储结构变更"></a>1.7 String存储结构变更</h5><p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081122668.png" alt="image-20210808112226517"></p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081125124.png" alt="image-20210808112513884"></p>
<h5 id="1-8-集合工厂方法：快速创建只读集合"><a href="#1-8-集合工厂方法：快速创建只读集合" class="headerlink" title="1.8 集合工厂方法：快速创建只读集合"></a>1.8 集合工厂方法：快速创建只读集合</h5><p>要创建一个只读、不可改变的集合，必须构造和分配它，然后添加元素，最后 包装成一个不可修改的集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; namesList = <span class="keyword">new</span> ArrayList &lt;&gt;();</span><br><span class="line">namesList.add(<span class="string">&quot;Joe&quot;</span>);</span><br><span class="line">namesList.add(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">namesList.add(<span class="string">&quot;Bill&quot;</span>);</span><br><span class="line">namesList = Collections.unmodifiableList(namesList);</span><br><span class="line">System.out.println(namesList);</span><br></pre></td></tr></table></figure>

<p>缺点：我们一下写了五行。即：它不能表达为单个表达式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Collections.unmodifiableList(Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>));</span><br><span class="line">Set&lt;String&gt; set = Collections.unmodifiableSet(<span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">&quot;a&quot;</span>, </span><br><span class="line"><span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>)));</span><br><span class="line"><span class="comment">// 如下操作不适用于jdk 8 及之前版本,适用于jdk 9</span></span><br><span class="line">Map&lt;String, Integer&gt; map = Collections.unmodifiableMap(<span class="keyword">new</span> HashMap&lt;&gt;() &#123;</span><br><span class="line">&#123;</span><br><span class="line">	put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">	put(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">	put(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">map.forEach((k, v) -&gt; System.out.println(k + <span class="string">&quot;:&quot;</span> + v));</span><br></pre></td></tr></table></figure>

<p>Java 9因此引入了方便的方法，这使得类似的事情更容易表达。</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081131794.png" alt="image-20210808113143689"></p>
<p>List firsnamesList = List.of(“Joe”,”Bob”,”Bill”); 调用集合中静态方法of()，可以将不同数量的参数传输到此工厂方法中。此功能 可用于Set和List，也可用于Map的类似形式。此时得到的集合，是不可变的：在 创建后，继续添加元素到这些集合会导致 “UnsupportedOperationException” 。 由于Java 8中接口方法的实现，可以直接在List，Set和Map的接口内定义这些方法， 便于调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Set&lt;String&gt; set = Set.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map1 = Map.of(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="number">21</span>, <span class="string">&quot;Lilei&quot;</span>, <span class="number">33</span>, </span><br><span class="line"><span class="string">&quot;HanMeimei&quot;</span>, <span class="number">18</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map2 = Map.ofEntries(Map.entry(<span class="string">&quot;Tom&quot;</span>, <span class="number">89</span>), </span><br><span class="line">Map.entry(<span class="string">&quot;Jim&quot;</span>, <span class="number">78</span>), Map.entry(<span class="string">&quot;Tim&quot;</span>, <span class="number">98</span>));</span><br></pre></td></tr></table></figure>

<h5 id="1-9-InputStream加强"><a href="#1-9-InputStream加强" class="headerlink" title="1.9 InputStream加强"></a>1.9 InputStream加强</h5><p>InputStream 终于有了一个非常有用的方法：transferTo，可以用来将数据直接 传输到 OutputStream，这是在处理原始数据流时非常常见的一种用法，如下 示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader cl = <span class="keyword">this</span>.getClass().getClassLoader();</span><br><span class="line"><span class="keyword">try</span> (InputStream is = cl.getResourceAsStream(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">	OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src\\hello1.txt&quot;</span>)) &#123;</span><br><span class="line">	is.transferTo(os); <span class="comment">// 把输入流中的所有数据直接自动地复制到输出流中</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-10-增强的-Stream-API"><a href="#1-10-增强的-Stream-API" class="headerlink" title="1.10 增强的 Stream API"></a>1.10 增强的 Stream API</h5><ul>
<li>Java 的 Steam API 是java标准库最好的改进之一，让开发者能够快速运算， 从而能够有效的利用数据并行计算。Java 8 提供的 Steam 能够利用多核架构 实现声明式的数据处理。</li>
<li>在 Java 9 中，Stream API 变得更好，Stream 接口中添加了 4 个新的方法： takeWhile, dropWhile, ofNullable，还有个 iterate 方法的新重载方法，可以 让你提供一个 Predicate (判断条件)来指定什么时候结束迭代。</li>
<li>除了对 Stream 本身的扩展，Optional 和 Stream 之间的结合也得到了改进。 现在可以通过 Optional 的新方法 stream() 将一个 Optional 对象转换为一个 (可能是空的) Stream 对象。</li>
</ul>
<h6 id="takeWhile-的使用"><a href="#takeWhile-的使用" class="headerlink" title="takeWhile()的使用"></a><strong>takeWhile()的使用</strong></h6><p>用于从 Stream 中获取一部分数据，接收一个 Predicate 来进行选择。在有序的 Stream 中，takeWhile 返回从开头开始的尽量多的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>);</span><br><span class="line">list.stream().takeWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line">list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">list.stream().takeWhile(x -&gt; x &lt; <span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><strong>dropWhile()的使用</strong></p>
<p>dropWhile 的行为与 takeWhile 相反，返回剩余的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">45</span>, <span class="number">43</span>, <span class="number">76</span>, <span class="number">87</span>, <span class="number">42</span>, <span class="number">77</span>, <span class="number">90</span>, <span class="number">73</span>, <span class="number">67</span>, <span class="number">88</span>);</span><br><span class="line">list.stream().dropWhile(x -&gt; x &lt; <span class="number">50</span>).forEach(System.out::println);</span><br><span class="line">System.out.println();</span><br><span class="line">list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">list.stream().dropWhile(x -&gt; x &lt; <span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><strong>ofNullable()的使用</strong></p>
<p>Java 8 中 Stream 不能完全为null，否则会报空指针异常。而 Java 9 中的 ofNullable 方 法允许我们创建一个单元素 Stream，可以包含一个非空元素，也可以创建一个空 Stream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报NullPointerException</span></span><br><span class="line"><span class="comment">// Stream&lt;Object&gt; stream1 = Stream.of(null);</span></span><br><span class="line"><span class="comment">// System.out.println(stream1.count());</span></span><br><span class="line"><span class="comment">// 不报异常，允许通过</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">System.out.println(stringStream.count());<span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 不报异常，允许通过</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">list.add(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(list.stream().count());<span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ofNullable()：允许值为null</span></span><br><span class="line">Stream&lt;Object&gt; stream1 = Stream.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(stream1.count());<span class="comment">// 0</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.ofNullable(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">System.out.println(stream.count());<span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><strong>iterator()重载使用</strong></p>
<p>这个 iterate 方法的新重载方法，可以让你提供一个 Predicate (判断条件)来指定什 么时候结束迭代。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来的控制终止方式：</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 现在的终止方式：</span></span><br><span class="line">Stream.iterate(<span class="number">1</span>, i -&gt; i &lt; <span class="number">100</span>, i -&gt; i + <span class="number">1</span>).forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>Optional类中stream()的使用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Tim&quot;</span>);</span><br><span class="line">Optional&lt;List&lt;String&gt;&gt; optional = Optional.ofNullable(list);</span><br><span class="line">Stream&lt;List&lt;String&gt;&gt; stream = optional.stream();</span><br><span class="line">stream.flatMap(x -&gt; x.stream()).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h5 id="1-11-Javascript引擎升级：Nashorn"><a href="#1-11-Javascript引擎升级：Nashorn" class="headerlink" title="1.11 Javascript引擎升级：Nashorn"></a>1.11 Javascript引擎升级：Nashorn</h5><ul>
<li>Nashorn 项目在 JDK 9 中得到改进，它为 Java 提供轻量级的 Javascript 运行时。 Nashorn 项目跟随 Netscape 的 Rhino 项目，目的是为了在 Java 中实现一个高 性能但轻量级的 Javascript 运行时。Nashorn 项目使得 Java 应用能够嵌入 Javascript。它在 JDK 8 中为 Java 提供一个 Javascript 引擎。</li>
<li>JDK 9 包含一个用来解析 Nashorn 的 ECMAScript 语法树的 API。这个 API 使得 IDE 和服务端框架不需要依赖 Nashorn 项目的内部实现类，就能够分析 ECMAScript 代码。</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081148488.png" alt="image-20210808114855330"></li>
</ul>
<h4 id="2-Java10的新特性"><a href="#2-Java10的新特性" class="headerlink" title="2. Java10的新特性"></a>2. Java10的新特性</h4><p>2018年3月21日，Oracle官方宣布Java10正式发布。需要注意的是 Java 9 和 Java 10 都不是 LTS (Long-Term-Support) 版本。和 过去的 Java 大版本升级不同，这两个只有半年左右的开发和维护期。而未 来的 Java 11，也就是 18.9 LTS，才是 Java 8 之后第一个 LTS 版本。JDK10一共定义了109个新特性，其中包含12个JEP（对于程序员来讲，真 正的新特性其实就一个），还有一些新API和JVM规范以及JAVA语言规范上 的改动。JDK10的12个JEP（JDK Enhancement Proposal特性加强提议）参阅官方 文档：<a href="http://openjdk.java.net/projects/jdk/10/">http://openjdk.java.net/projects/jdk/10/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">286</span>: Local-Variable Type Inference 局部变量类型推断</span><br><span class="line"><span class="number">296</span>: Consolidate the JDK Forest into a Single Repository JDK库的合并</span><br><span class="line"><span class="number">304</span>: Garbage-Collector Interface 统一的垃圾回收接口</span><br><span class="line"><span class="number">307</span>: Parallel Full GC <span class="keyword">for</span> G1 为G1提供并行的Full GC</span><br><span class="line"><span class="number">310</span>: Application Class-Data Sharing 应用程序类数据（AppCDS）共享</span><br><span class="line"><span class="number">312</span>: Thread-Local Handshakes ThreadLocal握手交互</span><br><span class="line"><span class="number">313</span>: Remove the Native-<span class="function">Header Generation <span class="title">Tool</span> <span class="params">(javah)</span> 移除JDK中附带的javah工具</span></span><br><span class="line"><span class="function">314: Additional Unicode Language-Tag Extensions 使用附加的Unicode语言标记扩展</span></span><br><span class="line"><span class="function">316: Heap Allocation on Alternative Memory Devices 能将堆内存占用分配给用户指定</span></span><br><span class="line"><span class="function">的备用内存设备</span></span><br><span class="line"><span class="function">317: Experimental Java-Based JIT Compiler 使用基于Java的JIT编译器</span></span><br><span class="line"><span class="function">319: Root Certificates 根证书</span></span><br><span class="line"><span class="function">322: Time-Based Release Versioning 基于时间的发布版本</span></span><br></pre></td></tr></table></figure>

<h5 id="2-1-局部变量类型推断"><a href="#2-1-局部变量类型推断" class="headerlink" title="2.1 局部变量类型推断"></a>2.1 局部变量类型推断</h5><ul>
<li><p>产生背景</p>
<p>开发者经常抱怨Java中引用代码的程度。局部变量的显示类型声明，常常被认为 是不必须的，给一个好听的名字经常可以很清楚的表达出下面应该怎样继续。</p>
</li>
<li><p>好处</p>
<p>减少了啰嗦和形式的代码，避免了信息冗余，而且对齐了变量名，更容易阅读！</p>
</li>
<li><p>举例如下：</p>
<ul>
<li><p>场景一：类实例化时</p>
<p>作为 Java开发者，在声明一个变量时，我们总是习惯了敲打两次变量类型，第 一次用于声明变量类型，第二次用于构造器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedHashSet&lt;Integer&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>场景二：返回值类型含复杂泛型结构</p>
<p>变量的声明类型书写复杂且较长，尤其是加上泛型的使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;Map.Entry&lt;Integer, Student&gt;&gt; iterator = set.iterator();</span><br></pre></td></tr></table></figure>
</li>
<li><p>场景三：</p>
<p>我们也经常声明一种变量，它只会被使用一次，而且是用在下一行代码中， 比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.atguigu.com&quot;</span>);</span><br><span class="line">URLConnection connection = url.openConnection();</span><br><span class="line">Reader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span></span><br><span class="line">InputStreamReader(connection.getInputStream()));</span><br></pre></td></tr></table></figure>

<p>尽管 IDE可以帮我们自动完成这些代码，但当变量总是跳来跳去的时候，可读 性还是会受到影响，因为变量类型的名称由各种不同长度的字符组成。而且， 有时候开发人员会尽力避免声明中间变量，因为太多的类型声明只会分散注意 力，不会带来额外的好处。</p>
</li>
</ul>
</li>
</ul>
<p><strong>适用于以下情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.局部变量的初始化</span></span><br><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//2.增强for循环中的索引</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> v : list) &#123;</span><br><span class="line">	System.out.println(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.传统for循环中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">100</span>;i++) &#123;</span><br><span class="line">	System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在局部变量中使用时，如下情况不适用</strong></p>
<p>初始值为null</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081156419.png" alt="image-20210808115641177"></p>
<p>Lambda表达式</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081157689.png" alt="image-20210808115720405"></p>
<p>方法引用</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081157245.png" alt="image-20210808115752683"></p>
<p>为静态数组初始化</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081158219.png" alt="image-20210808115845045"></p>
<p><strong>不适用于以下的结构中</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 情况1：没有初始化的局部变量声明</span><br><span class="line"> 情况2：方法的返回类型</span><br><span class="line"> 情况3：方法的参数类型</span><br><span class="line"> 情况4：构造器的参数类型</span><br><span class="line"> 情况5：属性</span><br><span class="line"> 情况6：catch块</span><br></pre></td></tr></table></figure>

<p><strong>工作原理</strong></p>
<p>在处理 var时，编译器先是查看表达式右边部分，并根据右边变量值的类型进行 推断，作为左边变量的类型，然后将该类型写入字节码当中。</p>
<p><strong>注意</strong></p>
<ul>
<li><p>var不是一个关键字</p>
<p>你不需要担心变量名或方法名会与 var发生冲突，因为 var实际上并不是一个关键字， 而是一个类型名，只有在编译器需要知道类型的地方才需要用到它。除此之外，它 就是一个普通合法的标识符。也就是说，除了不能用它作为类名，其他的都可以， 但极少人会用它作为类名。</p>
</li>
<li><p>这不是JavaScript</p>
<p>首先我要说明的是，var并不会改变Java是一门静态类型语言的事实。编译器负责推 断出类型，并把结果写入字节码文件，就好像是开发人员自己敲入类型一样。 下面是使用 IntelliJ（实际上是 Fernflower的反编译器）反编译器反编译出的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> connection = url.openConnection();</span><br><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line"><span class="keyword">new</span> InputStreamReader(connection.getInputStream()));</span><br></pre></td></tr></table></figure>

<p>反编译后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://www.baidu.com&quot;</span>);</span><br><span class="line">URLConnection connection = url.openConnection();</span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(</span><br><span class="line"><span class="keyword">new</span> InputStreamReader(connection.getInputStream()));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>从代码来看，就好像之前已经声明了这些类型一样。事实上，这一特性只发 生在编译阶段，与运行时无关，所以对运行时的性能不会产生任何影响。所 以请放心，这不是 JavaScript。</p>
</blockquote>
</li>
</ul>
<h5 id="2-2-集合新增创建不可变集合的方法"><a href="#2-2-集合新增创建不可变集合的方法" class="headerlink" title="2.2 集合新增创建不可变集合的方法"></a>2.2 集合新增创建不可变集合的方法</h5><p>自 Java 9 开始，Jdk 里面为集合（List / Set / Map）都添加了 of (jdk9新增)和 copyOf (jdk10新增)方法，它们两个都用来创建不可变的集合，来看下它们的 使用和区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例1：</span></span><br><span class="line"><span class="keyword">var</span> list1 = List.of(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> copy1 = List.copyOf(list1);</span><br><span class="line">System.out.println(list1 == copy1); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//示例2：</span></span><br><span class="line"><span class="keyword">var</span> list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">var</span> copy2 = List.copyOf(list2);</span><br><span class="line">System.out.println(list2 == copy2); <span class="comment">// false</span></span><br><span class="line"><span class="comment">//示例1和2代码基本一致，为什么一个为true,一个为false?</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从源码分析 ,可以看出 copyOf 方法会判断来源集合是不是 AbstractImmutableList 类型的，如果是，就直接返回，如果不是，则调用 of 创 建一个新的集合。 示例2因为用的 new 创建的集合，不属于不可变 AbstractImmutableList 类的子类， 所以 copyOf 方法又创建了一个新的实例，所以为false。 注意：使用of和copyOf创建的集合为不可变集合，不能进行添加、删除、替换、 排序等操作，不然会报 java.lang.UnsupportedOperationException 异常。 上面演示了 List 的 of 和 copyOf 方法，Set 和 Map 接口都有。</p>
<h4 id="3-Java11的新特性"><a href="#3-Java11的新特性" class="headerlink" title="3. Java11的新特性"></a>3. Java11的新特性</h4><p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081204031.png" alt="image-20210808120416252"></p>
<p>JDK 11 将是一个 企业不可忽视的版本。从时间节点来看，JDK 11 的发布正 好处在 JDK 8 免费更新到期的前夕，同时 JDK 9、10 也陆续成为“历史版 本” ，下面是 Oracle JDK 支持路线图：</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081204464.png" alt="image-20210808120443550"></p>
<p><strong>JDK 11 是一个长期支持版本（LTS, Long-Term-Support）</strong></p>
<ul>
<li><p>对于企业来说，选择 11 将意味着长期的、可靠的、可预测的技术路线图。 其中免费的OpenJDK11 确定将得到 OpenJDK 社区的长期支持， LTS 版本将 是可以放心选择的版本。</p>
</li>
<li><p>从 JVM GC 的角度，JDK11 引入了两种新的 GC，其中包括也许是划时代意义 的 ZGC，虽然其目前还是实验特性，但是从能力上来看，这是 JDK 的一个巨 大突破，为特定生产环境的苛刻需求提供了一个可能的选择。例如，对部 分企业核心存储等产品，如果能够保证不超过 10ms 的 GC 暂停，可靠性会 上一个大的台阶，这是过去我们进行 GC 调优几乎做不到的，是能与不能的问题</p>
<p>按照官方的说法，新的发布周 期会严格遵循时间点，将于每 年的3月份和9月份发布。所 以 Java 11 的版本号是 18.9(LTS)。</p>
<p>不过与 Java 9 和 Java 10 这 两个被称为“功能性的版本” 不同（两者均只提供半年的技 术支持），Java 11 不仅提供 了长期支持服务，还将作为 Java 平台的参考实现。 Oracle 直到2023年9月都会为 Java 11 提供技术支持，而补 丁和安全警告等扩展支持将持 续到2026年。</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081206960.png" alt="image-20210808120618484"></p>
</li>
</ul>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108081206006.png" alt="image-20210808120638010"></p>
<blockquote>
<p>新的长期支持版本每三年发布一次，根据后续的发布计划，下一 个长期支持版 Java 17 将于2021年发布。</p>
</blockquote>
<p><strong>官网公开的 17 个 JEP（JDK Enhancement Proposal 特性增强提议）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">181</span>: Nest-Based Access Control（基于嵌套的访问控制）</span><br><span class="line"><span class="number">309</span>: Dynamic Class-File Constants（动态的类文件常量）</span><br><span class="line"><span class="number">315</span>: Improve Aarch64 Intrinsics（改进 Aarch64 Intrinsics）</span><br><span class="line"><span class="number">318</span>: Epsilon: A No-Op Garbage Collector（Epsilon 垃圾回收器，又被称为<span class="string">&quot;No-Op（无操作）&quot;</span>回收器）</span><br><span class="line"><span class="number">320</span>: Remove the Java EE and CORBA Modules（移除 Java EE 和 CORBA 模块，JavaFX 也已被移除）</span><br><span class="line"><span class="number">321</span>: <span class="function">HTTP <span class="title">Client</span> <span class="params">(Standard)</span></span></span><br><span class="line"><span class="function">323: Local-Variable Syntax <span class="keyword">for</span> Lambda Parameters（用于 Lambda 参数的局部变量语法）</span></span><br><span class="line"><span class="function">324: Key Agreement with Curve25519 and Curve448（采用Curve25519和Curve448 算法实现的密钥协议）</span></span><br><span class="line"><span class="function">327: Unicode 10</span></span><br><span class="line"><span class="function">328: Flight Recorder（飞行记录仪）</span></span><br><span class="line"><span class="function">329: ChaCha20 and Poly1305 Cryptographic Algorithms（实现 ChaCha20 和 Poly1305 加密算法）</span></span><br><span class="line"><span class="function">330: Launch Single-File Source-Code Programs（启动单个 Java 源代码文件的程序）</span></span><br><span class="line"><span class="function">331: Low-Overhead Heap Profiling（低开销的堆分配采样方法）</span></span><br><span class="line"><span class="function">332: Transport Layer <span class="title">Security</span> <span class="params">(TLS)</span> 1.3（对 TLS 1.3 的支持）</span></span><br><span class="line"><span class="function">333: ZGC: A Scalable Low-Latency Garbage <span class="title">Collector</span> <span class="params">(Experimental)</span>（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）</span></span><br><span class="line"><span class="function">335: Deprecate the Nashorn JavaScript Engine（弃用 Nashorn JavaScript 引擎）</span></span><br><span class="line"><span class="function">336: Deprecate the Pack200 Tools and API（弃用 Pack200 工具及其 API）</span></span><br></pre></td></tr></table></figure>

<h5 id="3-1-新增了一系列字符串处理方法"><a href="#3-1-新增了一系列字符串处理方法" class="headerlink" title="3.1 新增了一系列字符串处理方法"></a>3.1 新增了一系列字符串处理方法</h5><table>
<thead>
<tr>
<th>描述</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>判断字符串是否为空白</td>
<td>“ “.isBlank(); // true</td>
</tr>
<tr>
<td>去除首尾空白</td>
<td>“ Javastack “.strip(); // “Javastack”</td>
</tr>
<tr>
<td>去除尾部空格</td>
<td>“ Javastack “.stripTrailing(); // “ Javastack”</td>
</tr>
<tr>
<td>去除首部空格</td>
<td>“ Javastack “.stripLeading(); // “Javastack “</td>
</tr>
<tr>
<td>复制字符串</td>
<td>“Java”.repeat(3);// “JavaJavaJava”</td>
</tr>
<tr>
<td>行数统计</td>
<td>“A\nB\nC”.lines().count(); // 3</td>
</tr>
</tbody></table>
<h5 id="3-2-Optional加强"><a href="#3-2-Optional加强" class="headerlink" title="3.2 Optional加强"></a>3.2 Optional加强</h5><p>Optional 也增加了几个非常酷的方法，现在可以很方便的将一个 Optional 转换 成一个 Stream, 或者当一个空 Optional 时给它一个替代的。</p>
<table>
<thead>
<tr>
<th>新增方法</th>
<th>描述</th>
<th>新增的版本</th>
</tr>
</thead>
<tbody><tr>
<td>boolean isEmpty()</td>
<td>判断value是否为空</td>
<td>JDK 11</td>
</tr>
<tr>
<td>ifPresentOrElse(Consumer &lt;? super T&gt;action, Runnable emptyAction)</td>
<td>value非空，执行参数1功能；如果value 为空，执行参数2功能</td>
<td>JDK 9</td>
</tr>
<tr>
<td>Optional<T> or(Supplier&lt;? extends Optional&lt;? extends T&gt;&gt; supplier)</td>
<td>value非空，返回对应的Optional； value为空，返回形参封装的Optional</td>
<td>JDK 9</td>
</tr>
<tr>
<td>Stream<T> stream()</td>
<td>value非空，返回仅包含此value的 Stream；否则，返回一个空的Stream</td>
<td>JDK 9</td>
</tr>
<tr>
<td>T orElseThrow()</td>
<td>value非空，返回value；否则抛异常 NoSuchElementException</td>
<td>JDK 10</td>
</tr>
</tbody></table>
<h5 id="3-3-局部变量类型推断升级"><a href="#3-3-局部变量类型推断升级" class="headerlink" title="3.3 局部变量类型推断升级"></a>3.3 局部变量类型推断升级</h5><p>在var上添加注解的语法格式，在jdk10中是不能实现的。在JDK11中加入了这样 的语法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误的形式: 必须要有类型, 可以加上var</span></span><br><span class="line"><span class="comment">//Consumer&lt;String&gt; con1 = (@Deprecated t) -&gt; </span></span><br><span class="line">System.out.println(t.toUpperCase());</span><br><span class="line"><span class="comment">//正确的形式:</span></span><br><span class="line"><span class="comment">//使用var的好处是在使用lambda表达式时给参数加上注解。</span></span><br><span class="line">Consumer&lt;String&gt; con2 = (<span class="meta">@Deprecated</span> <span class="keyword">var</span> t) -&gt; System.out.println(t.toUpperCase());</span><br></pre></td></tr></table></figure>

<h5 id="3-4-全新的HTTP-客户端API"><a href="#3-4-全新的HTTP-客户端API" class="headerlink" title="3.4 全新的HTTP 客户端API"></a>3.4 全新的HTTP 客户端API</h5><ul>
<li><p>HTTP，用于传输网页的协议，早在1997年就被采用在目前的1.1版本中。直 到2015年，HTTP2才成为标准。</p>
</li>
<li><p>HTTP/1.1和HTTP/2的主要区别是如何在客户端和服务器之间构建和传输数据。 HTTP/1.1依赖于请求/响应周期。 HTTP/2允许服务器“push”数据：它可以发 送比客户端请求更多的数据。这使得它可以优先处理并发送对于首先加载 网页至关重要的数据。</p>
</li>
<li><p>这是 Java 9 开始引入的一个处理 HTTP 请求的的 HTTP Client API，该 API 支持同步和异步，而在 Java 11 中已经为正式可用状态，你可以在 java.net 包中找到这个 API。</p>
</li>
<li><p>它 将 替 代 仅 适 用 于 blocking 模式的 HttpURLConnection （HttpURLConnection是在HTTP 1.0的时代创建的，并使用了协议无关的 方法），并提供对WebSocket 和 HTTP/2的支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">HttpRequest request = </span><br><span class="line">HttpRequest.newBuilder(URI.create(<span class="string">&quot;http://127.0.0.1:8080/test/&quot;</span>)).build();</span><br><span class="line">BodyHandler&lt;String&gt; responseBodyHandler = BodyHandlers.ofString();</span><br><span class="line">HttpResponse&lt;String&gt; response = client.send(request, responseBodyHandler);</span><br><span class="line">String body = response.body();</span><br><span class="line">System.out.println(body);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpClient client = HttpClient.newHttpClient();</span><br><span class="line">HttpRequest request = </span><br><span class="line">HttpRequest.newBuilder(URI.create(<span class="string">&quot;http://127.0.0.1:8080/test/&quot;</span>)).build();</span><br><span class="line">BodyHandler&lt;String&gt; responseBodyHandler = BodyHandlers.ofString();</span><br><span class="line">CompletableFuture&lt;HttpResponse&lt;String&gt;&gt; sendAsync = </span><br><span class="line">client.sendAsync(request, responseBodyHandler);</span><br><span class="line">sendAsync.thenApply(t -&gt; t.body()).thenAccept(System.out::println);</span><br><span class="line"><span class="comment">//HttpResponse&lt;String&gt; response = sendAsync.get();</span></span><br><span class="line"><span class="comment">//String body = response.body();</span></span><br><span class="line"><span class="comment">//System.out.println(body);</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="3-5-更简化的编译运行程序"><a href="#3-5-更简化的编译运行程序" class="headerlink" title="3.5 更简化的编译运行程序"></a>3.5 更简化的编译运行程序</h5><p>看下面的代码。<br>// 编译<br>javac Javastack.java<br>// 运行<br>java Javastack<br>在我们的认知里面，要运行一个 Java 源代码必须先编译，再运行，两步执行动作。 而在未来的 Java 11 版本中，通过一个 java 命令就直接搞定了，如以下所示： java Javastack.java</p>
<p> 一个命令编译运行源代码的注意点：</p>
<ul>
<li>执行源文件中的第一个类, 第一个类必须包含主方法。</li>
<li>并且不可以使用其它源文件中的自定义类, 本文件中的自定义类是可以使用的。</li>
</ul>
<h5 id="3-6-废弃Nashorn引擎"><a href="#3-6-废弃Nashorn引擎" class="headerlink" title="3.6 废弃Nashorn引擎"></a>3.6 废弃Nashorn引擎</h5><p>废除Nashorn javascript引擎，在后续版本准备移除掉，有需要的 可以考虑使用GraalVM。</p>
<h5 id="3-7-ZGC"><a href="#3-7-ZGC" class="headerlink" title="3.7 ZGC"></a>3.7 ZGC</h5><ul>
<li>GC是java主要优势之一。 然而, 当GC停顿太长, 就会开始影响应用的响应时 间。消除或者减少GC停顿时长, java将对更广泛的应用场景是一个更有吸引力 的平台。此外, 现代系统中可用内存不断增长,用户和程序员希望JVM能够以高 效的方式充分利用这些内存, 并且无需长时间的GC暂停时间。</li>
<li>ZGC, A Scalable Low-Latency Garbage Collector(Experimental) ZGC, 这应该是JDK11最为瞩目的特性, 没有之一。 但是后面带了Experimental, 说明这还不建议用到生产环境。</li>
<li>ZGC是一个并发, 基于region, 压缩型的垃圾收集器, 只有root扫描阶段会 STW(stop the world), 因此GC停顿时间不会随着堆的增长和存活对象的增长 而变长。</li>
<li>优势：<ul>
<li>GC暂停时间不会超过10ms</li>
<li>既能处理几百兆的小堆, 也能处理几个T的大堆(OMG)</li>
<li>和G1相比, 应用吞吐能力不会下降超过15%</li>
<li>为未来的GC功能和利用colord指针以及Load barriers优化奠定基础</li>
<li>初始只支持64位系统</li>
</ul>
</li>
<li>ZGC的设计目标是：支持TB级内存容量，暂停时间低（&lt;10ms），对整个 程序吞吐量的影响小于15%。 将来还可以扩展实现机制，以支持不少令人 兴奋的功能，例如多层堆（即热对象置于DRAM和冷对象置于NVMe闪存）， 或压缩堆。</li>
</ul>
<h5 id="3-8-其他新特性"><a href="#3-8-其他新特性" class="headerlink" title="3.8 其他新特性"></a>3.8 其他新特性</h5><ul>
<li>Unicode 10</li>
<li>Deprecate the Pack200 Tools and API</li>
<li>新的Epsilon垃圾收集器</li>
<li>完全支持Linux容器（包括Docker）</li>
<li>支持G1上的并行完全垃圾收集</li>
<li>最新的HTTPS安全协议TLS 1.3</li>
<li>Java Flight Recorder</li>
</ul>
<p><strong>在当前JDK中看不到什么？</strong></p>
<p><strong>一个标准化和轻量级的JSON API</strong></p>
<p>一个标准化和轻量级的JSON API被许多Java开发人员所青睐。但是由于资金问 题无法在Java当前版本中见到，但并不会削减掉。Java平台首席架构师Mark Reinhold在JDK 9邮件列中说：“这个JEP将是平台上的一个有用的补充，但是在 计划中，它并不像Oracle资助的其他功能那么重要，可能会重新考虑JDK 10或 更高版本中实现。 ”</p>
<p><strong>新的货币 API</strong></p>
<ul>
<li><p>对许多应用而言货币价值都是一个关键的特性，但JDK对此却几乎没有任何支持。 严格来讲，现有的java.util.Currency类只是代表了当前ISO 4217货币的一个数据结构， 但并没有关联的值或者自定义货币。JDK对货币的运算及转换也没有内建的支持， 更别说有一个能够代表货币值的标准类型了。</p>
</li>
<li><p>此前，Oracle 公布的JSR 354定义了一套新的Java货币API：JavaMoney，计划会在Java 9中正式引入。但是目前没有出现在JDK 新特性 中。</p>
</li>
<li><p>不过，如果你用的是Maven的话，可以做如下的添加，即可使用相关的API处理货币：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.javamoney&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;moneta&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.9&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>展望</strong></p>
<ul>
<li>随着云计算和 AI 等技术浪潮，当前的计算模式和场景正在发生翻天覆地的变 化，不仅对 Java 的发展速度提出了更高要求，也深刻影响着 Java 技术的发展 方向。传统的大型企业或互联网应用，正在被云端、容器化应用、模块化的微 服务甚至是函数(FaaS， Function-as-a-Service)所替代。</li>
<li>Java虽然标榜面向对象编程，却毫不顾忌的加入面向接口编程思想，又扯出匿 名对象之概念，每增加一个新的东西，对Java的根本所在的面向对象思想的一 次冲击。反观Python，抓住面向对象的本质，又能在函数编程思想方面游刃有 余。Java对标C/C++，以抛掉内存管理为卖点，却又陷入了JVM优化的噩梦。选 择比努力更重要，选择Java的人更需要对它有更清晰的认识。</li>
<li>Java 需要在新的计算场景下，改进开发效率。这话说的有点笼统，我谈一些自 己的体会，Java 代码虽然进行了一些类型推断等改进，更易用的集合 API 等， 但仍然给开发者留下了过于刻板、形式主义的印象，这是一个长期的改进方向</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>DJ音标——辅音</title>
    <url>/2021/09/17/%E9%9F%B3%E6%A0%87-%E8%BE%85%E9%9F%B3/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="2-辅音"><a href="#2-辅音" class="headerlink" title="2. 辅音"></a>2. 辅音</h3><h4 id="2-1-爆破音"><a href="#2-1-爆破音" class="headerlink" title="2.1 爆破音"></a>2.1 爆破音</h4><h5 id="p-b"><a href="#p-b" class="headerlink" title="/p/ /b/"></a>/p/ /b/</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108292042618.png" alt="image-20210829204250371" style="zoom:50%;" /> 

<p><code>p</code>eak    <code>p</code>et    <code>p</code>ig</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWRrWkl6V3h3OU04ZEhuYlE_ZT1oM05BcVk.mp3"></audio></p>
<p><code>b</code>eak    <code>b</code>ed    <code>b</code>ig</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWdSNUhqVGFNSmJxVUlGb0E_ZT1QazVYYkc.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>/p/,/b/的音标符号分别是小写字母p，b</li>
<li>他们在DJ音标和KK音标中符号相同</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301036048.png" alt="image-20210830103650322"></p>
<blockquote>
<p>双唇紧闭，气流挡在口腔内，形成一定的气之后，猛张开双唇，气流爆发而出<br>[p]有气无声，[b]有声有气</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<p><strong>/p/发音技巧</strong></p>
<ul>
<li>如果p后有元音<ul>
<li>比如：<code>p</code>eak</li>
<li>送气音(aspirated)</li>
<li>国际音标：[p^h^]</li>
<li>普通话“婆”的声母</li>
</ul>
</li>
<li>如果p紧跟s<ul>
<li>比如：s<code>p</code>eak</li>
<li>不送气音(unaspirated)</li>
<li>国际音标：[p]</li>
<li>普通话“菠”的声母(汉语拼音b) != 英语/b/</li>
<li>speak不读做/sbi:k/</li>
</ul>
</li>
<li>如果p后紧跟某些辅音<ul>
<li>嘴巴闭上就基本完成发音</li>
<li>国际音标：[p^┐^]</li>
<li>比如：tra<code>p</code> door,hel<code>p</code> me,lea<code>p</code> year</li>
<li>无声除阻音(unreleased stop)(也称“不完全爆破音”)</li>
</ul>
</li>
<li>这些不同发音被称作“同位异音”或者“音位变体”(allophone)</li>
<li>请再听以下单词中字母p发音的区别：<ul>
<li>peak  [p^h^]</li>
<li>speak  [p]</li>
<li>trapdoor  [p^┐^]</li>
</ul>
</li>
</ul>
<p><strong>/b/发音技巧</strong></p>
<ul>
<li>/b/在中文普通话中并不存在</li>
<li>/b/是浊辅音(voiced consonant),声带是振动</li>
<li>中文的“菠”的声母(汉语拼音b)是清音，国际音标为[p]</li>
<li>汉语拼音b相当于speak中的/p/，而不是英语的/b/</li>
<li>所以外国人学中文常常也落入误区：“北京”，“我不知道”，“皮包”，“旁边”</li>
<li>发英语/b/时，需加强声带振动(把手放在喉咙处检查)</li>
<li>请听以下发音区别：<ul>
<li>不可 b</li>
<li>book  /b/</li>
</ul>
</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108292125152.png" alt="image-20210829212541909"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108292039986.png" alt="image-20210829203946921"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108292040927.png" alt="image-20210829204015892"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>在以辅音结尾的单词后面加上一个不存在的元音</li>
<li>以下是错误读音，请避免：<ul>
<li>speak  <del>死比克</del></li>
<li>lap       <del>辣普</del></li>
<li>lab       <del>辣不</del></li>
</ul>
</li>
<li>这点在发无声除阻音时，尤其要避免：<ul>
<li>trapdoor    <del>tra普door</del></li>
<li>help me     <del>hel普me</del></li>
<li>leap year    <del>lea普year</del></li>
</ul>
</li>
</ul>
<hr>
<h5 id="t-d"><a href="#t-d" class="headerlink" title="/t/ /d/"></a>/t/ /d/</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108292140775.png" alt="image-20210829213959192" style="zoom:67%;" /> 

<p><code>t</code>ip    <code>t</code>ea    <code>t</code>est</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWRzbzMtdkZ1dTZsb0s2Rmc_ZT1mblNmR0o.mp3"></audio></p>
<p><code>d</code>ip    <code>d</code>eep  <code>d</code>esk</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWRqdXNhMUl2YnFkU1JIRUE_ZT1NNXRIOWg.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>/t/,/d/的音标符号分别是小写字母t，d</li>
<li>他们在DJ音标和KK音标中符号相同</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301043944.png" alt="image-20210830104350647"></p>
<blockquote>
<p>舌尖抵住上齿龈，然后放开，使气流爆破而出，吐气很强<br>[t]有气无声，[d]有声有气</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<p><strong>/t/的发音技巧</strong></p>
<ul>
<li>如果t后有元音<ul>
<li>比如：<code>t</code>op</li>
<li>送气音(aspirated)</li>
<li>国际音标：[t^h^]</li>
<li>普通话“兔”的声母</li>
</ul>
</li>
<li>如果t紧跟s<ul>
<li>比如：s<code>t</code>op</li>
<li>不送气音(unaspirated)</li>
<li>国际音标：[t]</li>
<li>普通话“刀”的声母(汉语拼音d) != 英语/d/</li>
<li>stop不读做/sdɒp/</li>
</ul>
</li>
<li>如果t后紧跟某些辅音<ul>
<li>嘴巴闭上就基本完成发音</li>
<li>国际音标：[t^┐^]</li>
<li>比如：se<code>t</code>back,forge<code>t</code> me</li>
<li>无声除阻音(unreleased stop)(也称“不完全爆破音”)</li>
</ul>
</li>
<li>美式英语中，元音之间的字母t(尤其是非重读音节中)，读作闪音(flap)<ul>
<li>国际音标：[ɾ]</li>
<li>舌尖在上牙齿上方硬腭处，阻挡气流，轻轻一弹</li>
<li>比如：water,batter,little</li>
<li>在标准英音中仍然读作“正常的t”：water,better,little</li>
</ul>
</li>
<li>美式英语中，鼻音/n/之前的t往往读作“喉塞音”(glottal stop)<ul>
<li>国际音标：[ʔ]</li>
<li>声门阻住气流，像是把声音“卡在喉咙”里一样</li>
<li>比如：certain,important,button</li>
<li>在标准英音中仍读作“正常t”：certain,important,button</li>
</ul>
</li>
<li>美式英语中，鼻音/n/之后的t往往基本听不见<ul>
<li>比如：winter ≈ winner, interview ≈ innerview</li>
<li>甚至有的词中，t前后都有鼻音，比如：mountain</li>
<li>在标准英音中仍然读作“正常t”：winter,interview,mountain</li>
</ul>
</li>
<li>这些不同发音被称作“同位异音”或“音位变体”(allophone)</li>
<li>请再听一下单词总字母t的发音区别<ul>
<li>top    [t^h^]</li>
<li>stop  [t]</li>
<li>setback    [t^┐^]</li>
<li>better       [ɾ] (美音)</li>
<li>button      [ʔ] (美音)</li>
<li>winter       [] (美音)</li>
</ul>
</li>
</ul>
<p><strong>/d/的发音技巧</strong></p>
<ul>
<li>/d/在中文普通话中并不存在</li>
<li>/d/是浊辅音(voiced consonant)，声带振动</li>
<li>中文中的“刀”的声母(汉语拼音d)是清音，国际音标为[t]</li>
<li>汉语拼音d相当于stop中的/t/，而不是英语的/d/</li>
<li>汉语拼音之所以使用d，主要是为了实用和书写方便</li>
<li>所以外国人在学中文常常也落入误区：“很大”，“很多”；“特别”，“太好了”</li>
<li>发英语/d/时，需加强声带振动(把手放在喉咙处检查)</li>
<li>请听以下发音区别：<ul>
<li>菜刀  d</li>
<li>dog   /d/</li>
</ul>
</li>
<li>在美音中，/d/和/t/一样会有闪音的读法：metal ≈ medal;鼻音也会影响/d/的读音：abandon</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108292230363.png" alt="image-20210829223023074"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108292231613.png" alt="image-20210829223137545"></p>
<p> <strong>常见错误</strong></p>
<ul>
<li>在以辅音结尾的单词后面加上一个不存在的元音</li>
<li>以下是错误读音，请避免：<ul>
<li>bat    <del>爸特</del></li>
<li>bad   <del>爸的</del></li>
<li>bet   <del>拜特</del></li>
<li>bed   <del>拜的</del></li>
</ul>
</li>
<li>这点在发无声除阻音时，尤其要避免：<ul>
<li>setback    <del>塞特百科</del></li>
<li>batman    <del>白特曼</del></li>
<li>forget me  <del>forge特米</del></li>
</ul>
</li>
</ul>
<hr>
<h5 id="k-ɡ"><a href="#k-ɡ" class="headerlink" title="/k/ /ɡ/"></a>/k/ /ɡ/</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301054778.png" alt="image-20210830105357626" style="zoom:67%;" /> 

<p><code>k</code>it    <code>K</code>ate    <code>c</code>up</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWRyRHNnelNBenh4aVRIaHc_ZT1SUHFkYkk.mp3"></audio></p>
<p><code>g</code>it    <code>g</code>ate    <code>g</code>ut</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWRpRnFnUnNpVWREd3JmNXc_ZT1keXdOSFM.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>/k/,/g/的音标符号分别是小写字母k，g</li>
<li>他们在DJ音标和KK音标中符号相同</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301112036.png" alt="image-20210830111230363"></p>
<blockquote>
<p>舌后位向上升，抵住软腭，然后放开，使气流爆破而出，吐气较强<br>[k]有气无声，[g]有气有声</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<p><strong>/k/的发音技巧</strong></p>
<ul>
<li><p>如果k后有元音</p>
<ul>
<li>比如：<code>k</code>ite</li>
<li>送气音(aspirated)</li>
<li>国际音标：[k^h^]</li>
<li>普通话“开”的声母</li>
</ul>
</li>
<li><p>如果k紧跟s</p>
<ul>
<li>比如：sky</li>
<li>不送气音(unaspirated)</li>
<li>国际音标：[k]</li>
<li>普通话“该”的声母(汉语拼音g) != 英语/g/</li>
<li>/sky/不读做/sgaɪ/</li>
</ul>
</li>
<li><p>如果k后紧跟某些辅音</p>
<ul>
<li>把嘴巴闭上基本完成发音</li>
<li>国际音标：[k^┐^]</li>
<li>比如：do<code>c</code>tor,ba<code>ck</code>door,ma<code>ke</code> dinner</li>
<li>无声除阻音(unreleased stop)(也称“不完全爆破音”)</li>
</ul>
</li>
<li><p>这些不同发音被称作“同位异音”或“音位变体”(allophone)</p>
</li>
<li><p>请再听一下单词中字母k的发音区别：</p>
<ul>
<li>kite    [k^h^]</li>
<li>sky     [k]</li>
<li>dictor [k^┐^]</li>
</ul>
</li>
</ul>
<p><strong>/ɡ/的发音技巧</strong></p>
<ul>
<li>/ɡ/在中文普通话里并不存在</li>
<li>/ɡ/是浊辅音(voiced consonant)，声带振动</li>
<li>中文的“该”的声母(汉语拼音g)是清音，国际音标为[k]</li>
<li>汉语拼音g相当于sky中的/k/，而不是英语的/ɡ/</li>
<li>汉语拼音之所以使用g，主要是为了使用和书写方便</li>
<li>所以外国人学中文也常常落入误区：“国家”，“故事”；“可以”，“我看看”</li>
<li>发英语/ɡ/时，需要加强声带振动(把手放在喉咙处检查)</li>
<li>请听以下发音<ul>
<li>哥哥  g</li>
<li>goose  /ɡ/</li>
</ul>
</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301203997.png" alt="image-20210830120317686"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301204643.png" alt="image-20210830120415614"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>在以辅音结尾的单词后面加一个不存在的元音</li>
<li>以下是错误读音，请避免：<ul>
<li>pick  <del>匹克</del></li>
<li>pig    <del>匹格</del></li>
</ul>
</li>
<li>这点在发无声除阻音时，尤其要避免：<ul>
<li>doctor    <del>刀客特</del></li>
<li>backdoor <del>爸刻刀</del></li>
<li>make dinner  <del>没课滴呢</del></li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-2-摩擦音"><a href="#2-2-摩擦音" class="headerlink" title="2.2 摩擦音"></a>2.2 摩擦音</h4><h5 id="f-v"><a href="#f-v" class="headerlink" title="/f/ /v/"></a>/f/ /v/</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301210305.png" alt="image-20210830121003813" style="zoom:67%;" /> 

<p><code>f</code>at    <code>f</code>it    <code>f</code>erry</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWR4MVk5WEkxNGhGejlZVVE_ZT1ibHBLTTM.mp3"></audio></p>
<p><code>v</code>alley  <code>v</code>isit    <code>v</code>ery</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWR1bFg3RTJSZFRZUGZiOVE_ZT02dm0ycU8.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>/f/,/v/的音标符号分别是小写字母f，v</li>
<li>他们在DJ音标和KK音标中符号相同</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301215669.png" alt="image-20210830121521233"></p>
<blockquote>
<p>上齿轻触下唇：气流从唇齿之间的空隙通过，唇齿发出摩擦而成<br>[f]有气无声，[v]有声有气</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>/f/和普通话“夫”的声母(汉语拼音f)基本一样</li>
<li>/v/是“声带振动版的”/f/</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301223086.png" alt="image-20210830122309491"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>在以辅音结尾的单词后面加一个不存在的元音</li>
<li>以下是错误读音，请避免：<ul>
<li>life   <del>来福</del></li>
<li>drive  <del>拽乌</del></li>
<li>leaf    <del>力福</del></li>
<li>live    <del>力乌</del></li>
</ul>
</li>
</ul>
<hr>
<h5 id="s-z"><a href="#s-z" class="headerlink" title="/s/ /z/"></a>/s/ /z/</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301237131.png" alt="image-20210830123709608" style="zoom:67%;" /> 

<p><code>s</code>ip    <code>s</code>oon  <code>s</code>oup</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWR0UFBHTGxOcjE2WjdudkE_ZT1RYnNpNWY.mp3"></audio></p>
<p><code>z</code>ip    <code>z</code>oom <code>z</code>oo</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWRxalo4NllmQ0Zmbnh0eUE_ZT1vZXdzRVQ.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>/s/,/z/的音标符号分别是小写字母s，z</li>
<li>他们在DJ音标和KK音标中符号相同</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301240761.png" alt="image-20210830124025527"></p>
<blockquote>
<p>舌尖接近上齿龈，舌尖与上齿龈之间的距离较小；气流从舌头与硬腭和齿龈之间通过，发生摩擦<br>[s]有气无声，[z]有声有气</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<p><strong>/s/的发音技巧</strong></p>
<ul>
<li>英语的/s/，/z/都属于所谓的“摩擦音”，不同于爆破音</li>
<li>/s/和普通话“斯”的声母(汉语拼音s)一样</li>
<li>/s/和/z/很像，区别就在于/z/发音时声带振动</li>
</ul>
<p><strong>/z/的发音技巧</strong></p>
<ul>
<li>/z/在普通话里不存在，不同于汉语拼音z</li>
<li>汉语拼音z属于“破擦音”，国际音标为[ts]</li>
<li>汉语拼音之所以使用z，主要是为了实现和书写便利</li>
<li>所以外国人学中文也常落入误区：“再见”，“请坐”</li>
<li>可以把英语/z/想作浊音版声带振动的/s/</li>
<li>请听以下发音的区别；<ul>
<li>再见 z</li>
<li>zoo  /z/</li>
</ul>
</li>
<li>英语中大量的字母s其实发/z/的音而不是/s/，比如大多数复数词尾s，以及whose,goose,days,boys等</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301250709.png" alt="image-20210830125034633"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>因为英语字母s经常发/z/而不是/s/，所以也容易混读</li>
<li>以下是错误读音，请避免<ul>
<li>lose   <del>露丝</del></li>
<li>please  <del>普里斯</del></li>
<li>whose  <del>胡思</del></li>
</ul>
</li>
<li>在英语/s/，/z/结尾的音节后加上一个不存在的元音</li>
<li>也就是普通话“斯”和“资”的韵母(它和 /ɪ/的发音不太一样)</li>
<li>以下是错误读音，请避免：<ul>
<li>books    <del>不可斯</del></li>
<li>peace     <del>匹斯</del></li>
<li>once       <del>万斯</del></li>
<li>lose        <del>露字</del></li>
<li>please    <del>普利兹</del></li>
<li>whose    <del>胡子</del></li>
</ul>
</li>
</ul>
<hr>
<h5 id="θ-ð"><a href="#θ-ð" class="headerlink" title="/θ/ /ð/"></a>/θ/ /ð/</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301300949.png" alt="image-20210830130012095" style="zoom:67%;" /> 

<p><code>th</code>ree    <code>th</code>in    <code>th</code>ank</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWRuZWhsVDNhTjFqaHFNeUE_ZT1ac2JqdTU.mp3"></audio></p>
<p><code>th</code>ere    <code>th</code>at    <code>th</code>ose</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWRtNlZadTkyNlQxWGd0Nmc_ZT1HQVFia3A.mp3"></audio></p>
<hr>
<p><strong>音标符号</strong></p>
<ul>
<li>/θ/是希腊字母Theta(读作/`θiːtə/或 /`θeɪtə/)，经常在数学里用到</li>
<li>/ð/古英语字母，也经常在数学中用到</li>
<li>他们在DJ音标和KK音标中符号相同</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301302932.png" alt="image-20210830130213752"></p>
<blockquote>
<p>舌头放在略微张开的上下齿之间，并略微接触，舌尖精灵向下齿用力，其流通过舌尖和上下齿尖的缝隙发生摩擦而发音；两唇之间的距离很窄<br>/θ/不振动声带，/ð/振动声带</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>/θ/,/ð/和/s/,/z/一样，属于摩擦音</li>
<li>不同在于舌尖不在上下牙齿后方，而是在上下牙齿之间，被轻轻咬住</li>
<li>可以把/θ/想作是普通话“斯”声母(汉语拼音s)的“大舌头版本”</li>
<li>/ð/和/θ/的区别在于/ð/的发音要求声带振动</li>
<li>/ð/和/θ/在普通话里不存在</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301314885.png" alt="image-20210830131452818"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301315737.png" alt="image-20210830131532341"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>最常见错误就是把它们当作/s/和/z/来读</li>
<li>不要觉得“伸舌头被牙齿咬住”这个动作很麻烦，故而省略</li>
<li>这个音的发音往往能体现语音好坏</li>
<li>请比较下列单词中/s/和/θ/,/z/和/ð/的区别<ul>
<li>sank       thank</li>
<li>sin          thin</li>
<li>truce      truth</li>
<li>breeze   breathe</li>
<li>buzz       bathe</li>
<li>zip          this</li>
</ul>
</li>
</ul>
<hr>
<h5 id="ʃ-ʒ"><a href="#ʃ-ʒ" class="headerlink" title="/ʃ/  /ʒ/"></a>/ʃ/  /ʒ/</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301321913.png" alt="image-20210830132111566" style="zoom:67%;" /> 

<p>me<code>sh</code>    fre<code>sh</code>   har<code>sh</code></p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWRwT1RQRHdFR0RsWlREMFE_ZT1LUWdnVm0.mp3"></audio></p>
<p>mea<code>s</code>ure    plea<code>s</code>ure   gara<code>ge</code></p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWRvR0hOTDBDeVhxb1hlREE_ZT1ZS08zVms.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>/ʃ/的符号像是拉长的字母s，注意它不是微积分里的∫</li>
<li>/ʒ/的符号像字母z的下方加上一个“小钩子”，甚至像数字3</li>
<li>他们在DJ音标和KK音标中符号相同</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301324898.png" alt="image-20210830132413871"></p>
<blockquote>
<p>舌尖端接近上齿龈后，舌身要向上抬向硬腭，气流从舌和硬腭及上齿龈间的缝隙中通过，发出摩擦音<br>/ʃ/不振动声带，/ʒ/振动声带</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<p><strong>/ʃ/ 的发音技巧</strong></p>
<ul>
<li>/ʃ/,/ʒ/都属于所谓的“摩擦音</li>
<li>/ʃ/和普通话“史”的声母(汉语拼音的sh)非常像</li>
<li>汉语拼音sh(国际音标[ʂ])的发音舌端更靠后</li>
</ul>
<p><strong>/ʒ/的发音诀窍</strong></p>
<ul>
<li>/ʒ/和/ʃ/的区别就在于声带振动</li>
<li>/ʒ/听上去虽然和普通话的“日”的声母(汉语拼音r)很相似，但他们并不相同</li>
<li>汉语拼音的r(国际音标[ɻ])的发音舌头更往后卷</li>
<li>请听以下发音区别<ul>
<li>然后  r</li>
<li>measure  /ʒ/</li>
</ul>
</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301348642.png" alt="image-20210830134833604"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>有人会把/ʃ/发成汉语拼音的s，就是所谓的“普通话平翘舌不分”，请避免<ul>
<li>mesh    <del>mes</del></li>
<li>fresh     <del>fres</del></li>
<li>leash     <del>leas</del></li>
</ul>
</li>
<li>有人会把/ʒ/当作汉语拼音的zh<ul>
<li>measure    <del>mea着</del></li>
<li>pleasure    <del>plea着</del></li>
<li>dicision     <del>deci振</del></li>
</ul>
</li>
<li>在/ʃ/和/ʒ/结尾的音节后面加上一个不存在的元音<ul>
<li>mesh  <del>me史</del></li>
<li>fresh   <del>fre史</del></li>
<li>leash   <del>lea史</del></li>
</ul>
</li>
</ul>
<hr>
<h5 id="h"><a href="#h" class="headerlink" title="/h/"></a>/h/</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301359279.png" alt="image-20210830135944830" style="zoom:67%;" /> 

<p><code>h</code>at   <code>h</code>ot    <code>h</code>igh</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWRsY0tMRFUtbGJNd1loX3c_ZT10SUcyeHE.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>/h/的音标符号分别是小写字母h</li>
<li>他们在DJ音标和KK音标中符号相同</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301402047.png" alt="image-20210830140247188"></p>
<blockquote>
<p>舌身平放于口腔中并使其保持松弛状态，气流通过声门时发生轻微摩擦，然后从口腔中出去；声带不振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>舌面后部抬起接近软腭，形成缝隙，让气流向外通过，声带不振动</li>
<li>和中文普通话“哈”的声母(汉语拼音h)相似，但是不完全相同</li>
<li>普通话h舌位比英语的/h/的舌位要更高<ul>
<li>后 h</li>
<li>home /h/</li>
</ul>
</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301409053.png" alt="image-20210830140949778"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>注意不要发成“粗犷”的“喉音”<ul>
<li>have   <del>khave</del></li>
<li>happy    <del>khappi</del></li>
<li>Halloween   <del>khalloween</del></li>
</ul>
</li>
</ul>
<hr>
<h5 id="r"><a href="#r" class="headerlink" title="/r/"></a>/r/</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301412571.png" alt="image-20210830141250791" style="zoom:67%;" /> 

<p><code>r</code>at    <code>r</code>ed    <code>r</code>ead</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWR2ODN2cjFVNkVnMzM2RXc_ZT1Hbk81Nnk.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>/r/的音标符号分别是小写字母r</li>
<li>他们在DJ音标和KK音标中符号相同</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301414107.png" alt="image-20210830141450791"></p>
<blockquote>
<p>舌尖向后齿龈后部与硬腭连接处翘起，气流在卷起的舌尖与连接处划过；声带振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<p><strong>英音</strong></p>
<ul>
<li>当字母r出现在元音之前<ul>
<li>双唇突出并圆唇，舌尖上扬，气流从舌面上方滑出，声带振动</li>
<li>和普通话“日”的声母(汉语拼音r)相似，但是并不相同</li>
<li>发英音/r/的音时，有圆唇动作<ul>
<li>日  r</li>
<li>right  /r/</li>
</ul>
</li>
<li>发英语/r/的音时，舌尖指向上齿龈，而不是普通话r那样指向后一定的硬腭</li>
</ul>
</li>
<li>当字母r出现在元音之后<ul>
<li>一般不发音或读作中央元音(/ə/)</li>
<li>如果r出现在单词末尾，而下一个单词以元音开头，则连读时一般读出<ul>
<li>bear it</li>
<li>fear us</li>
<li>gear up</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>美音</strong></p>
<ul>
<li>美音和英音的区别在于：当字母r出现在元音之后，字母r往往会让元音“r化”(r-coloring),而在英音中则一般不发音或读作中央元音(/ə/)</li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301426825.png" alt="image-20210830142626588" style="zoom:67%;" /> </li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301426327.png" alt="image-20210830142554567" style="zoom:67%;" /> 

</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301427103.png" alt="image-20210830142700928"></p>
<p><strong>英音</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301427905.png" alt="image-20210830142752769"></p>
<p><strong>美音</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301428298.png" alt="image-20210830142832818"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>最常见的错误就是用汉语拼音r来取代它</li>
<li>汉语拼音的r的发音是不需要圆唇的，而英语/r/需要圆唇</li>
<li>如果用拼音r来读英语，就会有以下错误读音<ul>
<li>red      <del>日ed</del></li>
<li>read    <del>日ead</del></li>
<li>right    <del>日ight</del></li>
</ul>
</li>
<li>这个区别导致外国人读中文r经常读错</li>
</ul>
<hr>
<h4 id="2-3-破擦音"><a href="#2-3-破擦音" class="headerlink" title="2.3 破擦音"></a>2.3 破擦音</h4><h5 id="tʃ-dʒ"><a href="#tʃ-dʒ" class="headerlink" title="/tʃ/  /dʒ/"></a>/tʃ/  /dʒ/</h5><p><code>ch</code>uck    <code>ch</code>op    <code>ch</code>oke</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWQyTThzUGhZalUyajBGaGc_ZT14YmtzSUc.mp3"></audio></p>
<p><code>j</code>ug        <code>j</code>ob      <code>j</code>oke</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWQxbTJBZ1JQYWtYSnllY1E_ZT1XcG1lYjE.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>/tʃ/的符号是/t/和/ʃ/连在一起，而/dʒ/的符号是/d/和/ʒ/连在一起</li>
<li>他们在DJ音标和KK音标中符号相同</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301719736.png" alt="image-20210830171939657"></p>
<blockquote>
<p>双唇稍微张开，舌前端向上置于牙龈后，用力把气压送出去，<br>/tʃ/无需振动声带， /dʒ/需要震动声带</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>/tʃ/可以理解由/t/和/ʃ/构成，爆破音/t/和摩擦音/ʃ/“同时发出”，声带不振动</li>
<li>/dʒ/可以理解由/d/和/ʒ/构成，爆破音/d/和摩擦音/ʒ/“同时发出”，声带不振动</li>
<li>所以这两个音被归类为所谓的“破擦音”(爆破+摩擦)</li>
<li>/tʃ/和普通话“吃”的声母(汉语拼音ch)非常像，但ch舌端更靠后</li>
<li>/dʒ/和/tʃ/的区别就在于声带振动</li>
<li>/dʒ/和普通话“知”的声母(汉语拼音的zh)相似，但zh舌端更靠后</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108301729849.png" alt="image-20210830172923020"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>在英语/tʃ/,/dʒ/结尾的音节后加上一个不存在的元音<ul>
<li>catch    <del>开吃</del></li>
<li>pitch     <del>匹吃</del></li>
<li>page      <del>配知</del></li>
</ul>
</li>
</ul>
<hr>
<h5 id="ts-dz"><a href="#ts-dz" class="headerlink" title="/ts/  /dz/"></a>/ts/  /dz/</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108302056812.png" alt="image-20210830205635725" style="zoom:67%;" /> 

<p>ba<code>ts</code>    da<code>tes</code>    ki<code>tes</code></p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWQwVVNQX0pqTGM0cUYtdXc_ZT1IQmFMcHg.mp3"></audio></p>
<p>ban<code>ds</code>    dee<code>ds</code>    ki<code>ds</code></p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWR3RE9xcTR1Qmw5Zlg2cXc_ZT12ZFFRUjI.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>/ts/的符号是/t/和/s/连在一起，而/dz/的符号是/d/和/z/连在一起</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108302107371.png" alt="image-20210830210746656"></p>
<blockquote>
<p>发音时舌前端抵住上齿龈，堵住气流，然后略下降，气流送出口腔<br>/ts/是清辅音，/dz/是浊辅音</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>/ts/可以理解为由/t/和/s/构成，爆破音/t/和摩擦音/s/“同时”发出，声带不振动</li>
<li>/dz/可以理解为由/d/和/z/构成，爆破音/d/和摩擦音/z/“同时”发出，声带振动</li>
<li>所以这两个音被归类为所谓的“破擦音”(爆破+摩擦)</li>
<li>/ts/和普通话的“词”的声母(汉语拼音c)基本一致</li>
<li>/dz/和/ts/的区别就在于声带振动</li>
<li>/dz/和普通话“资”的声母(汉语拼音的z)相似，但并不完全一样</li>
<li>汉语拼音的z国际音标写作[ts]，是[t]和[s]构成，不送气，是个“清”音</li>
<li>但是英语/dz/是的“浊”音<ul>
<li>资本    z</li>
<li>kids    /dz/</li>
</ul>
</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109011214736.png" alt="image-20210901121357291"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>有些人会把/ts/读成/tʃ/，把/dz/读成/dʒ/，也就是所谓的“平翘舌不分”</li>
<li>发/ts/和/dz/时，上下牙齿基本闭合，舌尖不卷，而发/tʃ/和/dʒ/时，上下齿不闭合，而且卷舌</li>
<li>以下是错误读音：<ul>
<li>bats     <del>白吃</del></li>
<li>dates   <del>带齿</del></li>
<li>deeds  <del>地址</del></li>
</ul>
</li>
<li>在英语/ts/，/dz/结尾的音节后加上一个不存在的元音</li>
<li>也就是普通话“吃”和“知”的韵母(它和/ɪ/的发音不一样)</li>
<li>请注意英语中辅音结尾的发音要干脆，以下是错误读音，请避免：<ul>
<li>bats      <del>白词</del></li>
<li>dates    <del>带词</del></li>
<li>deeds   <del>地字</del></li>
</ul>
</li>
</ul>
<hr>
<h5 id="tr-dr"><a href="#tr-dr" class="headerlink" title="/tr/  /dr/"></a>/tr/  /dr/</h5><p><code>tr</code>ip    <code>tr</code>ue    <code>tr</code>ee</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWR6M0lMZnhydkFpbWVveEE_ZT1QYUZuZWE.mp3"></audio></p>
<p><code>dr</code>ip    <code>dr</code>ew   <code>dr</code>eam</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWR5QjAtUWlZbmh4LVZjN2c_ZT1rVG1KeHQ.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>/tr/的符号是/t/和/r/连在一起，而/dr/的符号是/d/和/r/连在一起</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109011242142.png" alt="image-20210901124224066"></p>
<blockquote>
<p>/tr/，/dr/分别是tr，dr的发音，齿龈后部破擦辅音，发音时舌身与/r/相似，舌尖贴齿龈后部，气流冲破阻碍发出短促的/t/(/d/)后立即发/r/，/tr/是清辅音，/dr/是浊辅音</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>/tr/可以理解为由/t/和/r/构成，爆破音/t/和摩擦音/r/“同时”发出，声带不振动</li>
<li>/dr/可以理解为由/d/和/r/构成，爆破音/d/和摩擦音/r/“同时”发出，声带振动</li>
<li>所以这两个音被归类为所谓的“破擦音”(爆破+摩擦)</li>
<li>/dr/和/tr/的区别在于声带振动</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109011258050.png" alt="image-20210901125841890"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>/tr/和/dr/最常见的错误就是把他们同/tʃ/和/dʒ/弄混</li>
<li>我们可以把/tr/理解为比/tʃ/“更卷舌”，而/dr/比/dʒ/“更卷舌”</li>
<li>请听以下单词的区别：<ul>
<li>train chain</li>
<li>drive  jive</li>
<li>true   choose</li>
<li>drop  job</li>
<li>tribe  chime</li>
<li>drian  Jane</li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>“破擦音”最早的版本包括：/tʃ/和/dʒ/，/ts/和/dz/，/tr/和/dr/</li>
<li>有些语音学家主张把/ts/和/dz/，/tr/和/dr/从音标里“除名”，把他们归入“辅音连缀”(像speak中的sp，sky中的sk，great中的gr一样)</li>
<li>中国大陆的英语教学中的DJ音标一直还保留着这四个音标</li>
<li>KK音标从美国传入台湾，其中也没有/ts/和/dz/，/tr/和/dr/</li>
</ul>
<hr>
<h4 id="2-4-鼻音"><a href="#2-4-鼻音" class="headerlink" title="2.4 鼻音"></a>2.4 鼻音</h4><h5 id="m-n-ŋ"><a href="#m-n-ŋ" class="headerlink" title="/m/  /n/  /ŋ/"></a>/m/  /n/  /ŋ/</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021420468.png" alt="image-20210902142025591" style="zoom:67%;" /> 

<p> m<code>a</code>p m<code>e</code>t roo<code>m</code></p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWQ1V0RmTVc4Mk9valFoZFE_ZT1NSUNXbU0.mp3"></audio></p>
<p>  <code>n</code>   ap <code>n</code>et <code>n</code>oo<code>n</code></p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWQ0Xzh0MWhocTB4SnpkSWc_ZT02Nm5VRFI.mp3"></audio></p>
<p>sin<code>g</code> lon<code>g</code>  su<code>ng</code></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWQzNW1kcnBBUFBkS01jRVE_ZT1HdWFHUDk.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>/m/,/n/的音标符号分别是小写字母m，n</li>
<li>/ŋ/的音标符号像是字母n右边往下延伸再往回勾一下</li>
<li>他们在DJ音标和KK音标中符号相同</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><strong>/m/</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109011357995.png" alt="image-20210901135710659"></p>
<blockquote>
<p>舌身平放在口腔内，双唇紧闭，软腭下垂，气流在口腔内形成一定的气压，和发/b/和/p/音时的舌位一样，气流从鼻孔中出来，声带振动</p>
</blockquote>
<p><strong>/n/</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109011924513.png" alt="image-20210901135742047"></p>
<blockquote>
<p>舌尖抵住上齿龈，软腭下垂，气流从鼻孔出来，声带振动</p>
</blockquote>
<p><strong>/ŋ/</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109011358073.png" alt="image-20210901135824993"></p>
<blockquote>
<p>舌后部升起抵住软腭，同时软腭下垂气流从鼻腔中出来，声带振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<p><strong>/m/</strong></p>
<ul>
<li>在元音之前，和普通话“妈”的声母(汉语拼音m)相似</li>
<li>在元音之后，发音方式相似，但只是双唇闭拢发鼻音</li>
</ul>
<p><strong>/n/</strong></p>
<ul>
<li>在元音之前，和普通话“拿”的声母(汉语拼音n)相似</li>
<li>/n/要比/m/的舌位高，尤其是舌端部分</li>
<li>在元音之后，发音方式相似，轻微通过鼻子出气</li>
</ul>
<p><strong>/ŋ/</strong></p>
<ul>
<li>和/n/相似，但舌后端抵住软腭，而不像/n/一样舌前端抵住上齿龈</li>
<li>普通话中的后鼻音往往没有英语中那么清晰明显</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021230932.png" alt="image-20210902123033389"></p>
<p><strong>常见错误</strong></p>
<p><strong>/m/</strong></p>
<ul>
<li>元音之前的/m/大多数人不会犯太大错</li>
<li>/m/在元音之后，有些人会加一个不存在的元音/uː/  或者/ʊ/，读成“母”</li>
<li>以下是错误读音，请避免<ul>
<li>room     <del>乳母</del></li>
<li>home    <del>后母</del></li>
<li>tomb    <del>兔母</del></li>
</ul>
</li>
</ul>
<p><strong>/n/</strong></p>
<ul>
<li>元音之前的/n/大多数人不会犯太大错</li>
<li>有些地区的人容易”n,l”不分，请比较<ul>
<li>nice    lice</li>
<li>no      low</li>
<li>need  lead</li>
</ul>
</li>
<li>/n/在元音之后(an,en,in,on,un)，请勿照搬拼音<ul>
<li>an在汉语里读安，英语里重读时多半读/æn/，bank不要读成半颗</li>
<li>en在汉语里读恩，英语里重度时多半读/en/，enter不要读成嗯特</li>
<li>in在汉语拼音里读因，英语里重读时多半读/ɪn/，两者相似，但是汉语的鼻音没有英语重，所以英语的/n/要读明显，tin不要读成听</li>
<li>on在汉语里不存在，但是汉语拼音里有ong和ang，很多人用来代替英语的on，而on在英语里重读多半读  /ʌn/，ton不要读成痛或者烫</li>
<li>un在汉语拼音里读un，英语里重读时多半读/ʌn/，trunk不要读成春克</li>
</ul>
</li>
</ul>
<p><strong>/ŋ/</strong>  </p>
<ul>
<li><p>普通话也有后鼻音，其中也包含/ŋ/ ，但是没有英语那么明显</p>
</li>
<li><p>英语国家的人为了强调，会发音明显，比如</p>
<ul>
<li>sing   /sɪŋ/</li>
<li>sung   /sʌŋ/</li>
</ul>
</li>
<li><p>请比较</p>
<ul>
<li>long   龙</li>
</ul>
</li>
<li><p>ing后如果出现元音字母，连读，这个音就更明显，比如：</p>
<ul>
<li>singer    /`sɪŋə/</li>
<li>singing  /`sɪŋɪŋ/</li>
<li>sing it    /sɪŋ ɪt/</li>
</ul>
</li>
<li><p>很多人发音不到位，不读甚至把ing当in来读：</p>
<ul>
<li>sing    <del>sin</del></li>
<li>singer  <del>sin er</del></li>
<li>singing <del>sin in</del></li>
<li>sing it    <del>sin it</del></li>
</ul>
</li>
<li><p>也有人把ng拼写的末尾g当作/ɡ/来读，比如把ing拆分成in + g，而不是正确的i + ng</p>
<ul>
<li>singer    <del>sin-ger</del></li>
<li>singing  <del>sin-ging</del></li>
</ul>
</li>
<li><p>/ŋ/在平时口语(非正式场合)的ing里经常被省略</p>
</li>
<li><p>歌词，影视剧里也会听到：</p>
<ul>
<li>dancin`</li>
<li>rainin`</li>
<li>movin`</li>
<li>what`s goin` on</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-5-舌边音"><a href="#2-5-舌边音" class="headerlink" title="2.5 舌边音"></a>2.5 舌边音</h4><h5 id="l"><a href="#l" class="headerlink" title="/l/"></a>/l/</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021420802.png" alt="image-20210902142052174" style="zoom:67%;" /> 

<p><code>l</code>ack    a<code>ll</code> schoo<code>l</code></p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWQ2TlZveDREWVRnWlpyeWc_ZT13bUZBUzY.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>/l/的音标符号分别是小写字母l</li>
<li>他们在DJ音标和KK音标中符号相同</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021308613.png" alt="image-20210902130855408"></p>
<blockquote>
<p>可以分为清晰舌边音（出现在元音之前）和含糊舌边音（出现在辅音或词尾）。发清晰舌边音时舌尖及舌端紧贴上齿龈，舌前部向硬腭抬起，气流从舌旁边泄出，声带振动；发含糊舌边音时舌端紧贴上齿龈，舌前下陷，舌后上抬，舌面形成凹型，气流在此发出共鸣的声音，声带振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>如果l后有元音<ul>
<li>舌尖抵住上牙齿后方，让气流从舌两边（两侧）滑出，同时舌尖离开上牙齿后，声带振动，所以/l/被叫做“舌边音”或“舌侧音”</li>
<li>和普通话“了”的声母（汉语拼音l）基本一致，国际音标写作[l]</li>
</ul>
</li>
<li>如果l后没有元音<ul>
<li>舌位和元音前的[l]一致，但是舌尖不离开上下牙齿，声带振动</li>
<li>可以理解为[l]发音“发一半”，国际音标写作[ɫ]</li>
</ul>
</li>
<li>/l/的不同“版本”被称作“同位异音”或“音位变体”(allophone)</li>
<li>第一个版本被叫做“清晰舌边音”或“清晰L”(light L)；第二个版本被称作“模糊L”(dark L)，“模糊舌边音”，“含糊舌边音”等等</li>
</ul>
<p><strong>单词练习</strong></p>
<p><strong>清晰L</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021329095.png" alt="image-20210902132907768"></p>
<p><strong>模糊L</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021329724.png" alt="image-20210902132937761"></p>
<p><strong>绕口令</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021330353.png" alt="image-20210902133035040"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>“清晰L”对于大多数人来说不算困难，除非方言里有n,l不分的情况<ul>
<li>n,l不分在英语中的歧义更大：如lack发成knack，lice发成nice，look发成nook</li>
<li>发/l/时，气流主要是从舌两侧发出，而/n/是鼻音，气流从鼻腔出去</li>
</ul>
</li>
<li>“模糊L”在普通话中不存在，所以是一大难点<ul>
<li>错误一：省略，比如all只读/ɔː/，girl只读/ɡɜː/</li>
<li>错误二：近似音代替，读成“尔”，“欧”，“要”，“奥”，比如full读福尔，tool读兔欧，help读还要普</li>
</ul>
</li>
<li>以下是错误读音，请避免<ul>
<li>school    <del>schoo, schoo尔</del></li>
<li>ball         <del>包，包尔</del></li>
<li>tool         <del>兔，兔尔</del></li>
<li>golf         <del>高夫，高尔夫</del></li>
<li>mile        <del>买药，卖噢</del></li>
</ul>
</li>
<li>其实字母L本身的发音，/el/的末尾就是个“模糊L”，不要说成“艾尔”</li>
</ul>
<p><strong>“模糊L”对连读的重要性</strong></p>
<ul>
<li>“模糊L”要发到位，否则导致连读时不顺畅，或者没法连读</li>
<li>比如all of中，模糊音不发到位容易说成“哦哦夫”</li>
</ul>
<p><strong>不发音L</strong></p>
<ul>
<li>字母l还有一个版本：不发音(silent L)</li>
<li>英语中不少单词的l都是不发音的，比如：<ul>
<li>calm  /kɑːm/</li>
<li>palm /pɑːm/</li>
<li>salmon   /`sæmən/</li>
<li>colonel   /`kɜːnl/</li>
<li>folk    /fəʊk/</li>
</ul>
</li>
</ul>
<p><strong>英音美音发音区别</strong></p>
<ul>
<li>有的包含l的词在英式英语(英音)和美式英语(美音)中的发音不同</li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021349501.png" alt="image-20210902134933241"></li>
<li>主要原因：音节划分，比如million</li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021350151.png" alt="image-20210902135009088"></li>
</ul>
<hr>
<h4 id="2-6-半元音"><a href="#2-6-半元音" class="headerlink" title="2.6 半元音"></a>2.6 半元音</h4><h5 id="j"><a href="#j" class="headerlink" title="/j/"></a>/j/</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021421908.png" alt="image-20210902142120772" style="zoom:67%;" /> 

<p><code>y</code>es    <code>y</code>ard    <code>y</code>ellow</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWQ4RHNGbktoVldwSVAySWc_ZT10MU9tYjk.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>/j/的音标符号分别是小写字母j</li>
<li>他们在DJ音标和KK音标中符号相同</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021314197.png" alt="image-20210902131416070"></p>
<blockquote>
<p>舌前部抬向硬腭，近似发/iː/的舌位；展唇；气流从抬起的舌身与硬腭之间通过，产生摩擦，声带振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>舌端往上抬向硬腭，与元音/iː/的舌位相似，但是更高一些</li>
<li>气流从舌面和硬腭之间通过，产生摩擦出声，声带振动</li>
<li>和中文普通话“叶”的声母(汉语拼音y)相似</li>
<li>/j/往往听上去像元音/iː/或/ɪ/，所以又被称作半元音</li>
<li>舌端和硬腭靠的更近，有“摩擦”的感觉</li>
<li>请听区别：<ul>
<li>yeast   east  /jiːst  iːst/</li>
<li>year     ear  /jɪə  ɪə/</li>
</ul>
</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021358906.png" alt="image-20210902135852433"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>字母j的发音往往是/dʒ/(比如just)，而/j/一般代表的是字母y的发音</li>
</ul>
<p><strong>/j/的省略</strong></p>
<ul>
<li>在美式英语(美音)中，有些辅音(如/t/,/d/,/n/)后的/j/经常被省略，这个被称作yod-dropping(yod就是/j/)</li>
<li>请比较以下单词在英音和美音中的区别</li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021403320.png" alt="image-20210902140320590"></li>
</ul>
<p><strong>/j/的融合</strong></p>
<ul>
<li>/j/和之前的辅音经常“合在一起读”，这个被称作yod-coalescene</li>
<li>请听下列单词的发音区别</li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021404061.png" alt="image-20210902140455155"></li>
<li>这样的发音在口语中(尤其是英音口语中)常见，“标准”英语一般尽量避免</li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021407996.png" alt="image-20210902140705659"></li>
<li>yod-coalescence也是适用于单词之间，比如：<ul>
<li>Nice to meet you!</li>
<li>Would you do it?</li>
</ul>
</li>
<li>如果说成meet you /miːt jʊ/,would you/wʊd jʊ/也不算错</li>
</ul>
<hr>
<h5 id="w"><a href="#w" class="headerlink" title="/w/"></a>/w/</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021421615.png" alt="image-20210902142147674" style="zoom:67%;" /> 

<p><code>w</code>as   <code>wh</code>y    <code>w</code>ide</p>
<p><strong>发音</strong></p>
<p><audio src="https://link.jscdn.cn/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBaTYycll2WjU2VXNoWWQ3eUZDTlN2eGp2WWlUakE_ZT1UVG5PUmE.mp3"></audio></p>
<p><strong>音标符号</strong></p>
<ul>
<li>/w/的音标符号分别是小写字母w</li>
<li>他们在DJ音标和KK音标中符号相同</li>
<li>他们在句中书写时放在一头一尾的斜杠里，以免和字母混淆</li>
</ul>
<p><strong>舌位图</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021314527.png" alt="image-20210902131445338"></p>
<blockquote>
<p>舌后部向软腭抬起，形成发元音/uː/时的状态，双唇呈圆形突出；气流从抬起的后舌与软腭之间的空隙通过，产生摩擦，声带振动</p>
</blockquote>
<p><strong>发音技巧</strong></p>
<ul>
<li>双唇圈起，向外凸出，气流冲出发音，声带振动</li>
<li>和中文普通话“呜”的声母(汉语拼音w)相似，但是不完全相同</li>
<li>/w/往往听上去像元音/uː/或/ʊ/  ，所以又被称作半元音</li>
<li>英语w开头的单词基本都是/w/开始，而不是/uː/或/ʊ/</li>
</ul>
<p><strong>单词练习</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021414912.png" alt="image-20210902141442497"></p>
<p><strong>绕口令</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202109021415720.png" alt="image-20210902141511552"></p>
<p><strong>常见错误</strong></p>
<ul>
<li>一般不易发错</li>
</ul>
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>IPA</tag>
      </tags>
  </entry>
  <entry>
    <title>09-Java常用类补充：正则表达式</title>
    <url>/2021/09/17/09%E2%80%94Java%E5%B8%B8%E7%94%A8%E7%B1%BB%E8%A1%A5%E5%85%85%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="09—Java常用类补充：正则表达式"><a href="#09—Java常用类补充：正则表达式" class="headerlink" title="09—Java常用类补充：正则表达式"></a>09—Java常用类补充：正则表达式</h3><h4 id="1-底层实现"><a href="#1-底层实现" class="headerlink" title="1. 底层实现"></a>1. 底层实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiongzhuo.regexp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析java的正则表达式的底层实现(重要)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegTheory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String content = <span class="string">&quot;1998年12月8日，第二代Java平台的企业版J2EE发布。1999年6月，Sun公司发布了&quot;</span> +</span><br><span class="line">                <span class="string">&quot;第二代Java平台（简称为Java2）的3个版本：J2ME（Java2 Micro Edition，Java2平台的微型&quot;</span> +</span><br><span class="line">                <span class="string">&quot;版），应用于移动、无线及有限资源的环境；J2SE（Java 2 Standard Edition，Java 2平台的&quot;</span> +</span><br><span class="line">                <span class="string">&quot;标准版），应用于桌面环境；J2EE（Java 2Enterprise Edition，Java 2平台的企业版），应&quot;</span> +</span><br><span class="line">                <span class="string">&quot;用3443于基于Java的应用服务器。Java 2平台的发布，是Java发展过程中最重要的一个&quot;</span> +</span><br><span class="line">                <span class="string">&quot;里程碑，标志着Java的应用开始普及9889 &quot;</span>;</span><br><span class="line">        <span class="comment">//目标：匹配所有四个数字</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1. \\d 表示一个任意的数字</span></span><br><span class="line">        String regStr = <span class="string">&quot;(\\d\\d)(\\d\\d)&quot;</span>;</span><br><span class="line">        <span class="comment">//2. 创建模式对象[即正则表达式对象]</span></span><br><span class="line">        Pattern pattern = Pattern.compile(regStr);</span><br><span class="line">        <span class="comment">//3. 创建匹配器</span></span><br><span class="line">        <span class="comment">//说明：创建匹配器matcher， 按照 正则表达式的规则 去匹配 content字符串</span></span><br><span class="line">        Matcher matcher = pattern.matcher(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.开始匹配</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * matcher.find() 完成的任务 （考虑分组）</span></span><br><span class="line"><span class="comment">         * 什么是分组，比如  (\d\d)(\d\d) ,正则表达式中有() 表示分组,第1个()表示第1组,第2个()表示第2组...</span></span><br><span class="line"><span class="comment">         * 1. 根据指定的规则 ,定位满足规则的子字符串(比如(19)(98))</span></span><br><span class="line"><span class="comment">         * 2. 找到后，将 子字符串的开始的索引记录到 matcher对象的属性 int[] groups;</span></span><br><span class="line"><span class="comment">         *    2.1 groups[0] = 0 , 把该子字符串的结束的索引+1的值记录到 groups[1] = 4</span></span><br><span class="line"><span class="comment">         *    2.2 记录1组()匹配到的字符串 groups[2] = 0  groups[3] = 2</span></span><br><span class="line"><span class="comment">         *    2.3 记录2组()匹配到的字符串 groups[4] = 2  groups[5] = 4</span></span><br><span class="line"><span class="comment">         *    2.4.如果有更多的分组.....</span></span><br><span class="line"><span class="comment">         * 3. 同时记录oldLast 的值为 子字符串的结束的 索引+1的值即35, 即下次执行find时，就从35开始匹配</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * matcher.group(0) 分析</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 源码:</span></span><br><span class="line"><span class="comment">         * public String group(int group) &#123;</span></span><br><span class="line"><span class="comment">         *         if (first &lt; 0)</span></span><br><span class="line"><span class="comment">         *             throw new IllegalStateException(&quot;No match found&quot;);</span></span><br><span class="line"><span class="comment">         *         if (group &lt; 0 || group &gt; groupCount())</span></span><br><span class="line"><span class="comment">         *             throw new IndexOutOfBoundsException(&quot;No group &quot; + group);</span></span><br><span class="line"><span class="comment">         *         if ((groups[group*2] == -1) || (groups[group*2+1] == -1))</span></span><br><span class="line"><span class="comment">         *             return null;</span></span><br><span class="line"><span class="comment">         *         return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();</span></span><br><span class="line"><span class="comment">         *     &#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *CharSequence getSubSequence(int beginIndex, int endIndex) &#123;</span></span><br><span class="line"><span class="comment">         *        return text.subSequence(beginIndex, endIndex);</span></span><br><span class="line"><span class="comment">         * &#125;</span></span><br><span class="line"><span class="comment">         *  CharSequence text;//The original string being matched.</span></span><br><span class="line"><span class="comment">         *  1. 根据 groups[0]=31 和 groups[1]=35 的记录的位置，从content开始截取子字符串返回</span></span><br><span class="line"><span class="comment">         *     就是 [31,35) 包含 31 但是不包含索引为 35的位置</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  如果再次指向 find方法.仍然安上面分析来执行</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            <span class="comment">//小结</span></span><br><span class="line">            <span class="comment">//1. 如果正则表达式有() 即分组</span></span><br><span class="line">            <span class="comment">//2. 取出匹配的字符串规则如下</span></span><br><span class="line">            <span class="comment">//3. group(0) 表示匹配到的子字符串</span></span><br><span class="line">            <span class="comment">//4. group(1) 表示匹配到的子字符串的第一组字串</span></span><br><span class="line">            <span class="comment">//5. group(2) 表示匹配到的子字符串的第2组字串</span></span><br><span class="line">            <span class="comment">//6. ... 但是分组的数不能越界.</span></span><br><span class="line">            System.out.println(<span class="string">&quot;找到: &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第1组()匹配到的值=&quot;</span> + matcher.group(<span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第2组()匹配到的值=&quot;</span> + matcher.group(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>找到: 1998<br>第1组()匹配到的值=19<br>第2组()匹配到的值=98<br>找到: 1999<br>第1组()匹配到的值=19<br>第2组()匹配到的值=99<br>找到: 3443<br>第1组()匹配到的值=34<br>第2组()匹配到的值=43<br>找到: 9889<br>第1组()匹配到的值=98<br>第2组()匹配到的值=89</p>
</blockquote>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108161729388.png" alt="image-20210718104008335"></p>
<h4 id="2-正则表达式的语法"><a href="#2-正则表达式的语法" class="headerlink" title="2. 正则表达式的语法"></a>2. 正则表达式的语法</h4><p><strong>基本介绍</strong></p>
<p>如果想要灵活的运用正则表达式，必须了解其中各种元字符的功能，元字符从功能上大致分为</p>
<ol>
<li>限定符</li>
<li>选择匹配符</li>
<li>分组组合和反向引用符号</li>
<li>特殊字符</li>
<li>字符匹配符</li>
<li>定位符</li>
</ol>
<p><strong>元字符(Metacharacter)-转义号 \\</strong></p>
<p>\\符号说明：在我们使用正则表达式区检索某些特殊字符的时候，需要用到转义符号，否则检索不到结果，甚至会报错。案例：用$区匹配”abc$(“会怎样？用(去匹配”abc$(“会怎样？</p>
<p>再次提示：在java的正则表达式中，两个\\代表其他语言中的一个\</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hspedu.regexp; </span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher; </span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExp02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;abc$(a.bc(123( )&quot;</span>;</span><br><span class="line">        <span class="comment">//匹配( =&gt; \\(</span></span><br><span class="line">        <span class="comment">//匹配. =&gt; \\.</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;\\.&quot;;</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;\\d\\d\\d&quot;;</span></span><br><span class="line">        String regStr = <span class="string">&quot;\\d&#123;3&#125;&quot;</span>;</span><br><span class="line">        Pattern pattern = Pattern.compile(regStr);</span><br><span class="line">        Matcher matcher = pattern.matcher(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到 &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>找到 123</p>
</blockquote>
<p>需要用到转义符号的字符有以下：.*+()$/?[]^{}</p>
<p><strong>元字符-字符匹配符</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
<th>解释</th>
<th>匹配输入</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>可接收的字符列表</td>
<td>[efgh]</td>
<td>e、f、g、h中的任意1个字符</td>
<td>e</td>
</tr>
<tr>
<td>[^]</td>
<td>不可接收的字符列表</td>
<td>[^abc]</td>
<td>除a、b、c之外的任意1个字符，包括数字和特殊符号</td>
<td>4</td>
</tr>
<tr>
<td>-</td>
<td>连字符</td>
<td>A-Z</td>
<td>任意单个大写字母</td>
<td>F</td>
</tr>
<tr>
<td>.</td>
<td>匹配除\n以外的任何字符</td>
<td>a..b</td>
<td>以a开头，b结尾，中间包括2个任意字符的长度为4的字符串</td>
<td>akjb</td>
</tr>
<tr>
<td>\\d</td>
<td>匹配单个数字字符，相当于[0-9]</td>
<td>\\d{3}(\\d)?</td>
<td>包含3个或4个数字的字符串</td>
<td>123</td>
</tr>
<tr>
<td>\\D</td>
<td>匹配单个非数字字符，相当于[^0-9]</td>
<td>\\D(\\d)*</td>
<td>以单个非数字字符开头，后接任意个数字字符串</td>
<td>a</td>
</tr>
<tr>
<td>\\w</td>
<td>匹配单个非数字、大小写字母符，相当于[0-9a-zA-Z]</td>
<td>\\d{3}\\w{4}</td>
<td>以3个数字字符开头长度为7的数字字符字母串符</td>
<td>234abcd</td>
</tr>
<tr>
<td>\\W</td>
<td>匹配单个非数字、大小写字母符，相当于[^0-9a-zA-Z]</td>
<td>\\W+\\d{2}</td>
<td>以至少1个非数字字母字符开头，2个数字字符结尾的字符串</td>
<td>#34</td>
</tr>
<tr>
<td>\\s</td>
<td>匹配任何空白字符(空格，制表符等)</td>
<td>\\W+\\s\\d{2}</td>
<td>以至少1个非数字字母字符开头，中间是空白字符，2个数字字符结尾的字符串</td>
<td># 34</td>
</tr>
<tr>
<td>\\S</td>
<td>匹配任何非空白字符</td>
<td>\\W+\\S\d{2}</td>
<td>以至少1个非数字字母字符开头，中间是非空白字符，2个数字字符结尾的字符串</td>
<td>#234</td>
</tr>
</tbody></table>
<p>应用实例</p>
<p>java正则表达式默认是区分字母大小写的，如何实现不区分大小写</p>
<ul>
<li>(?i)abc 表示abc都不区分大小写</li>
<li>a(?i)bc 表示bc不区分大小写</li>
<li>a((?i)b)c 表示只有b不区分大小写</li>
<li>Pattern pat = Pattern.compile(regEx, Pattern.CASE_INSENSITIVE);</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">演示字符匹配符的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExp03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;abc11c8ABC&quot;</span>;</span><br><span class="line"><span class="comment">//        String regStr = &quot;[a-z]&quot;;//匹配a-z之间任意一个字符</span></span><br><span class="line"><span class="comment">//        String regStr = &quot;[A-Z]&quot;;//匹配A-Z之间任意一个字符</span></span><br><span class="line">        String regStr = <span class="string">&quot;(?i)abc&quot;</span>;<span class="comment">//匹配abc字符串[不区分大小写]</span></span><br><span class="line">        <span class="comment">//1. 先创建一个Pattern对象 ， 模式对象, 可以理解成就是一个正则表达式对象</span></span><br><span class="line">        Pattern pattern = Pattern.compile(regStr);</span><br><span class="line">        <span class="comment">//2. 创建一个匹配器对象</span></span><br><span class="line">        <span class="comment">//理解： 就是 matcher 匹配器按照 pattern(模式/样式), 到 content 文本中去匹配</span></span><br><span class="line">        <span class="comment">//找到就返回true, 否则就返回false</span></span><br><span class="line">        Matcher matcher = pattern.matcher(content);</span><br><span class="line">        <span class="comment">//3. 可以开始循环匹配</span></span><br><span class="line">        <span class="keyword">while</span> (matcher.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到 &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String cont = <span class="string">&quot;abc12323ABC&quot;</span>;</span><br><span class="line">        String reg = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="comment">//将模式对象设置为大小写不敏感的</span></span><br><span class="line">        Pattern pattern1 = Pattern.compile(reg,Pattern.CASE_INSENSITIVE);</span><br><span class="line">        Matcher matcher1 = pattern1.matcher(cont);</span><br><span class="line">        <span class="keyword">while</span> (matcher1.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;方式二找到: &quot;</span> + matcher1.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>找到 abc<br>找到 ABC<br>方式二找到: abc<br>方式二找到: ABC</p>
</blockquote>
<p><strong>元字符-选择匹配符</strong></p>
<p>在匹配某个字符串的时候是选择性的，即：既可以匹配这个又可以匹配那个，这时需要用到选择匹配符</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>|</td>
<td>匹配”|”之前或者之后的表达式</td>
<td>ab|cd</td>
<td>ab|cd</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExpSelect</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;xiongzhuo 熊卓 (￣(工)￣) 🐻&quot;</span>;</span><br><span class="line">        String regStr = <span class="string">&quot;xiong|熊|\\(￣\\(工\\)￣\\)|🐻&quot;</span>;</span><br><span class="line">        Pattern pat = Pattern.compile(regStr);</span><br><span class="line">        Matcher mat = pat.matcher(content);</span><br><span class="line">        <span class="keyword">while</span> (mat.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到 &quot;</span> + mat.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>找到 xiong<br>找到 熊<br>找到 (￣(工)￣)<br>找到 🐻</p>
</blockquote>
<p>*元字符-限定符**</p>
<p>用于指定其前面的字符和组合项连续出现多少次</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
<th>说明</th>
<th>匹配输入</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>指定字符重复0此或n次（无要求）</td>
<td>(abc)*</td>
<td>仅包含任意个abc的字符串</td>
<td>abcabcabc</td>
</tr>
<tr>
<td>+</td>
<td>指定字符重复1次或n次（至少1次）</td>
<td>m+(abc)*</td>
<td>以至少1个m开头，后接任意个abc的字符串</td>
<td>mabcabc</td>
</tr>
<tr>
<td>?</td>
<td>指定字符重复0次或1次（最多1次）</td>
<td>m+abc?</td>
<td>以至少一个m开头，后接ab或abc的字符串</td>
<td>mab</td>
</tr>
<tr>
<td>{n}</td>
<td>只能输入n个字符</td>
<td>[abcd]{3}</td>
<td>由abcd中字母组成任意长度为3的字符串</td>
<td>aaa</td>
</tr>
<tr>
<td>{n,}</td>
<td>指定至少n个匹配</td>
<td>[abcd]{3,}</td>
<td>由abcd中字母组成的任意长度不小于3的字符串</td>
<td>aabcc</td>
</tr>
<tr>
<td>{n,m}</td>
<td>指定至少n个但不多于m个匹配</td>
<td>[abcd]{3,5}</td>
<td>由abcd中字母组成的任意长度不小于3，不大于5的字符串</td>
<td>abccc</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiongzhuo.regexp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示限定符的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExp05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;a211111aaaaaahello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//a&#123;3&#125;,1&#123;4&#125;,\\d&#123;2&#125;</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;a&#123;3&#125;&quot;;// 表示匹配 aaa</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;1&#123;4&#125;&quot;;// 表示匹配 1111</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;\\d&#123;2&#125;&quot;;// 表示匹配 两位的任意数字字符</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//a&#123;3,4&#125;,1&#123;4,5&#125;,\\d&#123;2,5&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//细节：java匹配默认贪婪匹配，即尽可能匹配多的</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;a&#123;3,4&#125;&quot;; //表示匹配 aaa 或者 aaaa</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;1&#123;4,5&#125;&quot;; //表示匹配 1111 或者 11111</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;\\d&#123;2,5&#125;&quot;; //匹配2位数或者3,4,5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1+</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;1+&quot;; //匹配一个1或者多个1</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;\\d+&quot;; //匹配一个数字或者多个数字</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1*</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;1*&quot;; //匹配0个1或者多个1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示?的使用, 遵守贪婪匹配</span></span><br><span class="line">        String regStr = <span class="string">&quot;a1?&quot;</span>; <span class="comment">//匹配 a 或者 a1</span></span><br><span class="line">        Pattern pattern = Pattern.compile(regStr<span class="comment">/*, Pattern.CASE_INSENSITIVE*/</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(content);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到 &quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**元字符-定位符    **</p>
<p>定位符，规定要匹配的字符串出现的位置，比如在字符串的开始还是结束的位置</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
<th>说明</th>
<th>匹配输入</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>指定起始字符</td>
<td>^[0-9]+[a-z]*</td>
<td>以至少1个数字开头，后接任意个小写字母的字符串</td>
<td>12dfsa</td>
</tr>
<tr>
<td>$</td>
<td>指定结束字符</td>
<td>^[0-9]\\-[a-z]+$</td>
<td>以1个数字开头后接连字符”-“，并以至少1个小写字母结尾的字符串</td>
<td>1-a</td>
</tr>
<tr>
<td>\\b</td>
<td>匹配目标字符串的边界</td>
<td>zhuo\\b</td>
<td>这里说的字符串的边界指的是子串间有空格，或者是目标字符串的结束位置</td>
<td>xiong<u>zhuo zhuo zhuo</u></td>
</tr>
<tr>
<td>\\B</td>
<td>匹配目标字符串的非边界</td>
<td>xiong\\B</td>
<td>和\b的含义相反</td>
<td><u>xiong</u>zhuo zhuo zhuo</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExpLocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;1998-xiongzhuo&quot;</span>;</span><br><span class="line">        String regStr = <span class="string">&quot;^[0-9]+\\-[a-z]+$&quot;</span>;</span><br><span class="line">        Pattern pat = Pattern.compile(regStr);</span><br><span class="line">        Matcher mat = pat.matcher(content);</span><br><span class="line">        <span class="keyword">while</span>(mat.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到 &quot;</span> + mat.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>找到 1998-xiongzhuo</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExpLocation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;1998-xiongzhuoxiongzhuo xiongzhuo xiongzzz zzzxiong&quot;</span>;</span><br><span class="line">        <span class="comment">//String regStr = &quot;^[0-9]+\\-[a-z]+$&quot;;</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;zhuo\\b&quot;;</span></span><br><span class="line">        String regStr = <span class="string">&quot;xiong\\B&quot;</span>;</span><br><span class="line">        Pattern pat = Pattern.compile(regStr);</span><br><span class="line">        Matcher mat = pat.matcher(content);</span><br><span class="line">        <span class="keyword">while</span>(mat.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到 &quot;</span> + mat.group());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>找到 xiong<br>找到 xiong<br>找到 xiong<br>找到 xiong</p>
</blockquote>
<p><strong>分组</strong></p>
<table>
<thead>
<tr>
<th>常用分组构造形式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>(pattern)</td>
<td>非命名捕获。捕获匹配的子字符串。编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其他捕获结果则是更具左括号的顺序从1开始自动编号</td>
</tr>
<tr>
<td>(?<name>pattern)</td>
<td>命名捕获。将匹配的子字符串捕获到一个组名称或者编号名称中。用于name的字符不能包含任何标点符号，并且不能以数字开头。可以使用单引号代替尖括号，例如(?’name’)</td>
</tr>
<tr>
<td>(?:pattern)</td>
<td>匹配pattern但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符(|)组合模式部件的情况很有用。例如，’industr(?:y|ies)’是比‘industry|industries’更经济的表达式</td>
</tr>
<tr>
<td>(?=pattern)</td>
<td>他是一个非捕获匹配。例如，’Windows(?=95|98|NT|2000)’匹配”Windows 2000”中的”Windows”,但不匹配”Windows 3.1”中的”Windows”</td>
</tr>
<tr>
<td>(?!pattern)</td>
<td>该表达式匹配不处于匹配pattern的字符串的起始点的搜索字符串。他是一个非捕获匹配。例如，‘Windows(?!95|98|NT|2000)’匹配”Windows 3.1”中的”Windows”,但不匹配”Windows 2000”中的”Windows”</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExpGrouping</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;xiongzhuo 1998 0415&quot;</span>;</span><br><span class="line">        String regStr = <span class="string">&quot;(?&lt;group1&gt;\\d\\d)(?&lt;group2&gt;\\d)(?&lt;group3&gt;\\d)&quot;</span>;</span><br><span class="line">        Pattern pat = Pattern.compile(regStr);</span><br><span class="line">        Matcher mat = pat.matcher(content);</span><br><span class="line">        <span class="keyword">while</span> (mat.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;按条件找到 &quot;</span> + mat.group(<span class="number">0</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第一组中按默认编号查找内容 &quot;</span> + mat.group(<span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第一组中按命名进行查找结果 &quot;</span> + mat.group(<span class="string">&quot;group1&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第二组中按默认编号查找内容 &quot;</span> + mat.group(<span class="number">2</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第二组中按命名进行查找结果 &quot;</span> + mat.group(<span class="string">&quot;group2&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第三组中按默认编号查找内容 &quot;</span> + mat.group(<span class="number">3</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;第三组中按命名进行查找结果 &quot;</span> + mat.group(<span class="string">&quot;group3&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>按条件找到 1998<br>第一组中按默认编号查找内容 19<br>第一组中按命名进行查找结果 19<br>第二组中按默认编号查找内容 9<br>第二组中按命名进行查找结果 9<br>第三组中按默认编号查找内容 8<br>第三组中按命名进行查找结果 8<br>按条件找到 0415<br>第一组中按默认编号查找内容 04<br>第一组中按命名进行查找结果 04<br>第二组中按默认编号查找内容 1<br>第二组中按命名进行查找结果 1<br>第三组中按默认编号查找内容 5<br>第三组中按命名进行查找结果 5</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExp04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String cont = <span class="string">&quot;Windows98 WindowsXP Windows7 Windows8 Windows10 Windows11&quot;</span>;</span><br><span class="line">        <span class="comment">//String regStr = &quot;Windows(?:98|XP|7|8|10|11)&quot;;//Windows98 WindowsXP Windows7 Windows8 Windows10 Windows11</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;Windows(?=98|XP)&quot;;//Windows Windows 只捕获了98和XP的Windows</span></span><br><span class="line">        String regStr = <span class="string">&quot;Windows(?!98|XP)&quot;</span>;<span class="comment">//Windows Windows Windows Windows 捕获了非98和XP的Windows</span></span><br><span class="line">        Pattern pat = Pattern.compile(regStr);</span><br><span class="line">        Matcher mat = pat.matcher(cont);</span><br><span class="line">        <span class="keyword">while</span> (mat.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;非捕获匹配 &quot;</span> + mat.group(<span class="number">0</span>));</span><br><span class="line">            <span class="comment">//未捕获 所以不能分组输出</span></span><br><span class="line">            <span class="comment">//System.out.println(&quot;非捕获匹配 &quot; + mat.group(1));//No group 1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>非贪婪匹配</strong></p>
<p>?      当此字符紧随任何其他限定符（*、+、?、{*n*}、{*n*,}、{*n*,*m*}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExp05</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String cont = <span class="string">&quot;xionggggggg&quot;</span>;</span><br><span class="line">        <span class="comment">//String regStr = &quot;[g]+&quot;;//默认是贪婪匹配 输出ggggggg</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;[g]+?&quot;;//非贪婪匹配 按最小的匹配 g g g g g g g</span></span><br><span class="line">        String regStr = <span class="string">&quot;[g]&#123;2,3&#125;?&quot;</span>;<span class="comment">//gg gg gg</span></span><br><span class="line">        Pattern pat = Pattern.compile(regStr);</span><br><span class="line">        Matcher mat = pat.matcher(cont);</span><br><span class="line">        <span class="keyword">while</span>(mat.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到 &quot;</span> + mat.group(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-应用实例"><a href="#3-应用实例" class="headerlink" title="3. 应用实例"></a>3. 应用实例</h4><p><strong>1.汉字</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExp06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String cont = <span class="string">&quot;熊卓的正则学习&quot;</span>;</span><br><span class="line">        String regStr = <span class="string">&quot;^[\u0391-\uffe5]+$&quot;</span>;</span><br><span class="line">        Pattern pat = Pattern.compile(regStr);</span><br><span class="line">        Matcher mat = pat.matcher(cont);</span><br><span class="line">        <span class="keyword">if</span>(mat.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;满足格式&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不满足格式&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>满足格式</p>
</blockquote>
<p><strong>2.邮政编码</strong></p>
<p>​    要求：是1-9开头的一个6位数。比如：123890</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExp06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String cont = <span class="string">&quot;123456 789879787&quot;</span>;</span><br><span class="line">        String regStr = <span class="string">&quot;^[1-9]\\d&#123;5&#125;$&quot;</span>;</span><br><span class="line">        Pattern pat = Pattern.compile(regStr);</span><br><span class="line">        Matcher mat = pat.matcher(cont);</span><br><span class="line">        <span class="keyword">if</span>(mat.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;满足格式&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不满足格式&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.QQ号码</strong></p>
<p>​    要求：是1-9开头的一个（5-10位）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExp06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String cont = <span class="string">&quot;501039430&quot;</span>;</span><br><span class="line">        String regStr = <span class="string">&quot;^[1-9]\\d&#123;4,9&#125;$&quot;</span>;</span><br><span class="line">        Pattern pat = Pattern.compile(regStr);</span><br><span class="line">        Matcher mat = pat.matcher(cont);</span><br><span class="line">        <span class="keyword">if</span>(mat.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;满足格式&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不满足格式&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4.手机号码</strong></p>
<p>​    要求：必须以13，14，15，18开头的11位数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExp06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String cont = <span class="string">&quot;15477449565&quot;</span>;</span><br><span class="line">        String regStr = <span class="string">&quot;^(1(?:3|4|5|8))\\d&#123;9&#125;$&quot;</span>;</span><br><span class="line">        Pattern pat = Pattern.compile(regStr);</span><br><span class="line">        Matcher mat = pat.matcher(cont);</span><br><span class="line">        <span class="keyword">if</span>(mat.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;满足格式&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不满足格式&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5.URL：</strong><a href="https://www.bilibili.com/video/BV1fh411y7R8?from=search&amp;seid=1831060912083761326">https://www.bilibili.com/video/BV1fh411y7R8?from=search&amp;seid=1831060912083761326</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExp11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String content = &quot;https://www.bilibili.com/video/BV1fh411y7R8?from=search&amp;seid=1831060912083761326&quot;;</span></span><br><span class="line">        String content = <span class="string">&quot;http://edu.3dsmax.tech/yg/bilibili/my6652/pc/qg/05-51/index.html#201211-1?track_id=jMc0jn-hm-yHrNfVad37YdhOUh41XYmjlss9zocM26gspY5ArwWuxb4wYWpmh2Q7GzR7doU0wLkViEhUlO1qNtukyAgake2jG1bTd23lR57XzV83E9bAXWkStcAh4j9Dz7a87ThGlqgdCZ2zpQy33a0SVNMfmJLSNnDzJ71TU68Rc-3PKE7VA3kYzjk4RrKU&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 思路</span></span><br><span class="line"><span class="comment">         * 1. 先确定 url 的开始部分 https:// | http://</span></span><br><span class="line"><span class="comment">         * 2.然后通过 ([\w-]+\.)+[\w-]+ 匹配 www.bilibili.com</span></span><br><span class="line"><span class="comment">         * 3. /video/BV1fh411y7R8?from=sear 匹配(\/[\w-?=&amp;/%.#]*)?</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String regStr = <span class="string">&quot;^((http|https)://)?([\\w-]+\\.)+[\\w-]+(\\/[\\w-?=&amp;/%.#]*)?$&quot;</span>;<span class="comment">//注意：[. ? *]表示匹配就是.本身</span></span><br><span class="line"></span><br><span class="line">        Pattern pattern = Pattern.compile(regStr);</span><br><span class="line">        Matcher matcher = pattern.matcher(content);</span><br><span class="line">        <span class="keyword">if</span>(matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;满足格式&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;不满足格式&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里如果使用Pattern的matches 整体匹配 比较简洁</span></span><br><span class="line">        System.out.println(Pattern.matches(regStr, content));<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>满足格式<br>true</p>
</blockquote>
<h4 id="4-正则表达式三个常用类"><a href="#4-正则表达式三个常用类" class="headerlink" title="4.正则表达式三个常用类"></a>4.正则表达式三个常用类</h4><p>java.util.regx包主要包括以下三个类Pattern类、Matcher类和PatternSyntaxException</p>
<ul>
<li><p>Pattern类</p>
<p>pattern对象是一份正则表达式的对象。Pattern类没有公共构造方法。要创建一个Pattern对象，调用其公共静态方法，他返回一个Pattern对象。该方法接收一个正则表达式作为它的第一个参数，比如：Pattern r = Pattern.compile(pattern);</p>
</li>
<li><p>Matcher类</p>
<p>Matcher对象是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法。你需要调用Pattern对象的Matcher方法来获得一个Matcher对象</p>
</li>
<li><p>PatternSyntaxException</p>
<p>PatternSyntaxException是一个非强制异常类，他表示一个正则表达式模式中的语法错误</p>
</li>
<li><p>Pattern类的方法matches</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;I am xiongzhuo from GUET.huajiang&quot;</span>;</span><br><span class="line">        String pattern = <span class="string">&quot;.*GUET.*&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isMatch = Pattern.matches(pattern,content);</span><br><span class="line">        System.out.println(<span class="string">&quot;是否整体匹配成功 &quot;</span> + isMatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>是否整体匹配成功 true</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex, CharSequence input)</span> </span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(regex);</span><br><span class="line">        Matcher m = p.matcher(input);</span><br><span class="line">        <span class="keyword">return</span> m.matches();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> match(from, ENDANCHOR);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Matcher类</p>
<p>方法一览</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法及说明</th>
</tr>
</thead>
<tbody><tr>
<td>public int start() 返回以前匹配的初始索引</td>
</tr>
<tr>
<td>public int start(int group) 返回在以前的匹配操作期间，由给定组所捕获的子序列的初始索引</td>
</tr>
<tr>
<td>public int end() 返回最后匹配字符之后的偏移量</td>
</tr>
<tr>
<td>public int end(int group) 返回在以前的匹配操作期间，由给定组所捕获子序列的最后字符之后的偏移量</td>
</tr>
<tr>
<td>public boolean lookingAt() 尝试将从区域开头开始的输入序列与该模式匹配</td>
</tr>
<tr>
<td>public boolean find() 尝试查找与该模式匹配的输入序列的下一个子序列</td>
</tr>
<tr>
<td>public boolean find(int start) 重置此匹配器，然后尝试查找匹配该模式、从指定索引开始的输入序列的下一个子序列</td>
</tr>
<tr>
<td>public boolean matchers() 尝试将整个区域与模式匹配</td>
</tr>
<tr>
<td>public Matcher appendReplacement(StringBuffer sb, String replacement)实现非终端添加和替换步骤</td>
</tr>
<tr>
<td>public StringBuffer appendTail(StringBuffer sb) 实现终端添加和替换步骤</td>
</tr>
<tr>
<td>public String replaceAll(String replacement) 替换模式与给定替换字符串相匹配的输入序列的每个子序列</td>
</tr>
<tr>
<td>public String replaceFirst(String replacement) 替换模式与给定替换字符串匹配的输入序列的第一个子序列</td>
</tr>
<tr>
<td>public statix String quoteReplacement(String s)返回指定字符串的字面替换字符串。这个方法返回一个字符串，就像传递给Matcher类的appendReplacement方法一个字面字符串一样工作</td>
</tr>
<tr>
<td>public Matcher appendReplacement(StringBuffer sb, String replacement)实现非终端添加和替换步骤</td>
</tr>
<tr>
<td>public StringBuffer appendTial(StringBuffer sb) 实现终端添加和替换步骤</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiongzhuo.regexp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * Matcher 类的常用方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatcherMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;hello xiongzhuotom hello smith hello xiongzhuo xiongzhuo&quot;</span>;</span><br><span class="line">        String regStr = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Pattern pattern = Pattern.compile(regStr);</span><br><span class="line">        Matcher matcher = pattern.matcher(content);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;————————————&quot;</span>);</span><br><span class="line">            System.out.println(matcher.start());</span><br><span class="line">            System.out.println(matcher.end());</span><br><span class="line">            System.out.println(<span class="string">&quot;找到: &quot;</span> + content.substring(matcher.start(), matcher.end()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//整体匹配方法，常用于，去校验某个字符串是否满足某个规则</span></span><br><span class="line">        System.out.println(<span class="string">&quot;整体匹配=&quot;</span> + matcher.matches());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成如果content 有 xiongzhuo 替换成 xiongzhuo</span></span><br><span class="line">        regStr = <span class="string">&quot;xiongzhuo&quot;</span>;</span><br><span class="line">        pattern = Pattern.compile(regStr);</span><br><span class="line">        matcher = pattern.matcher(content);</span><br><span class="line">        <span class="comment">//注意：返回的字符串才是替换后的字符串 原来的 content 不变化</span></span><br><span class="line">        String newContent = matcher.replaceAll(<span class="string">&quot;熊卓&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;newContent=&quot;</span> + newContent);</span><br><span class="line">        System.out.println(<span class="string">&quot;content=&quot;</span> + content);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>————————————<br>0<br>5<br>找到: hello<br>————————————<br>19<br>24<br>找到: hello<br>————————————<br>31<br>36<br>找到: hello<br>整体匹配=false<br>newContent=hello 熊卓tom hello smith hello 熊卓 熊卓<br>content=hello xiongzhuotom hello smith hello xiongzhuo xiongzhuo</p>
</blockquote>
<h4 id="5-分组、捕获、反向引用"><a href="#5-分组、捕获、反向引用" class="headerlink" title="5.分组、捕获、反向引用"></a>5.分组、捕获、反向引用</h4><ul>
<li><p>介绍</p>
<p>要解决前面的问题，我们需要了解正则表达式的几个概念：</p>
<ol>
<li><p>分组</p>
<p>我们可以用圆括号组成一个比较复杂的匹配模式，那么圆括号的部分我们可以看作是一个子表达式/一个分组</p>
</li>
<li><p>捕获</p>
<p>把正则表达式中子表达式/分组匹配的内容，保存到内存中以数字编号或显示命名的组里，方便后面引用，从左到右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，并以此类推。组0代表的是整个正则式</p>
</li>
<li><p>反向引用</p>
<p>圆括号的内容被捕获后，可以在这个括号后被使用，从而写出一个比较实用的匹配模式，这个我么称为反向引用，这种引用既可以是在正则表达式的内部，也可以是在正则表达式的外部，内部反向引用\\分组号，外部反向引用$分组号</p>
</li>
</ol>
</li>
<li><p>案例</p>
<ol>
<li><p>要匹配两个连续相同的数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RexExpBackReference</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;112342455 66 77 4654&quot;</span>;</span><br><span class="line">        String regStr = <span class="string">&quot;(\\d)\\1&quot;</span>;</span><br><span class="line">        Pattern pat = Pattern.compile(regStr);</span><br><span class="line">        Matcher mat = pat.matcher(content);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (mat.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;————————————&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;起始索引 &quot;</span>+mat.start());</span><br><span class="line">            System.out.println(<span class="string">&quot;结束索引 &quot;</span>+mat.end());</span><br><span class="line">            System.out.println(<span class="string">&quot;找到：   &quot;</span> + mat.group(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>————————————<br>起始索引 0<br>结束索引 2<br>找到：   11<br>————————————<br>起始索引 7<br>结束索引 9<br>找到：   55<br>————————————<br>起始索引 10<br>结束索引 12<br>找到：   66<br>————————————<br>起始索引 13<br>结束索引 15<br>找到：   77</p>
</blockquote>
</li>
<li><p>要匹配五个连续相同的数字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RexExpBackReference</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;111112342455555 66666 77777 4654&quot;</span>;</span><br><span class="line">        String regStr = <span class="string">&quot;(\\d)\\1&#123;4&#125;&quot;</span>;</span><br><span class="line">        Pattern pat = Pattern.compile(regStr);</span><br><span class="line">        Matcher mat = pat.matcher(content);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (mat.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;————————————&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;起始索引 &quot;</span>+mat.start());</span><br><span class="line">            System.out.println(<span class="string">&quot;结束索引 &quot;</span>+mat.end());</span><br><span class="line">            System.out.println(<span class="string">&quot;找到：   &quot;</span> + mat.group(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>————————————<br>起始索引 10<br>结束索引 15<br>找到：   55555<br>————————————<br>起始索引 16<br>结束索引 21<br>找到：   66666<br>————————————<br>起始索引 22<br>结束索引 27<br>找到：   77777</p>
</blockquote>
</li>
<li><p>要匹配个位与千位相同，十位与百位相同的数 5225 1551</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RexExpBackReference</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;12211234245665 6336 7007 4654&quot;</span>;</span><br><span class="line">        String regStr = <span class="string">&quot;(\\d)(\\d)\\2\\1&quot;</span>;</span><br><span class="line">        Pattern pat = Pattern.compile(regStr);</span><br><span class="line">        Matcher mat = pat.matcher(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (mat.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;————————————&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;起始索引 &quot;</span>+mat.start());</span><br><span class="line">            System.out.println(<span class="string">&quot;结束索引 &quot;</span>+mat.end());</span><br><span class="line">            System.out.println(<span class="string">&quot;找到：   &quot;</span> + mat.group(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>————————————<br>起始索引 0<br>结束索引 4<br>找到：   1221<br>————————————<br>起始索引 10<br>结束索引 14<br>找到：   5665<br>————————————<br>起始索引 15<br>结束索引 19<br>找到：   6336<br>————————————<br>起始索引 20<br>结束索引 24<br>找到：   7007</p>
</blockquote>
</li>
<li><p>请在字符串中检索商品编号，形式如：12321-333999111这样的号码，要求满足前面是一个五位数，然后一个-号，然后是这样一个九位数，连续的每三位要相同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 练习;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RexExpBackReference</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;321412321-333999111&quot;</span>;</span><br><span class="line">        <span class="comment">//以下表达方式等价 每多一个括号就多一个组</span></span><br><span class="line">        String regStr = <span class="string">&quot;\\d&#123;5&#125;-(\\d)\\1&#123;2&#125;(\\d)\\2&#123;2&#125;(\\d)\\3&#123;2&#125;&quot;</span>;</span><br><span class="line">        <span class="comment">//String regStr = &quot;(\\d)&#123;5&#125;-(\\d)\\2&#123;2&#125;(\\d)\\3&#123;2&#125;(\\d)\\4&#123;2&#125;&quot;;</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;((\\d)&#123;5&#125;)-(\\d)\\3&#123;2&#125;(\\d)\\4&#123;2&#125;(\\d)\\5&#123;2&#125;&quot;;</span></span><br><span class="line">        <span class="comment">//String regStr = &quot;(((\\d)&#123;5&#125;))-(\\d)\\4&#123;2&#125;(\\d)\\5&#123;2&#125;(\\d)\\6&#123;2&#125;&quot;;</span></span><br><span class="line">        Pattern pat = Pattern.compile(regStr);</span><br><span class="line">        Matcher mat = pat.matcher(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (mat.find())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;————————————&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;起始索引 &quot;</span>+mat.start());</span><br><span class="line">            System.out.println(<span class="string">&quot;结束索引 &quot;</span>+mat.end());</span><br><span class="line">            System.out.println(<span class="string">&quot;找到：   &quot;</span> + mat.group(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>————————————<br>起始索引 4<br>结束索引 19<br>找到：   12321-333999111</p>
</blockquote>
</li>
<li><p>结巴去重 我我我…..我要….学学学…学java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiongzhuo.regexp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegExp13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;我....我要....学学学学....编程java!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 去掉所有的.</span></span><br><span class="line"></span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(content);</span><br><span class="line">        content = matcher.replaceAll(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//       System.out.println(&quot;content=&quot; + content);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 去掉重复的字  我我要学学学学编程java!</span></span><br><span class="line">        <span class="comment">// 思路</span></span><br><span class="line">        <span class="comment">//(1) 使用 (.)\\1+</span></span><br><span class="line">        <span class="comment">//(2) 使用 反向引用$1 来替换匹配到的内容</span></span><br><span class="line">        <span class="comment">// 注意：因为正则表达式变化，所以需要重置 matcher</span></span><br><span class="line"><span class="comment">//        pattern = Pattern.compile(&quot;(.)\\1+&quot;);//分组的捕获内容记录到$1</span></span><br><span class="line"><span class="comment">//        matcher = pattern.matcher(content);</span></span><br><span class="line"><span class="comment">//        while (matcher.find()) &#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(&quot;找到=&quot; + matcher.group(0));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //使用 反向引用$1 来替换匹配到的内容</span></span><br><span class="line"><span class="comment">//        content = matcher.replaceAll(&quot;$1&quot;);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;content=&quot; + content);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 使用一条语句 去掉重复的字  我我要学学学学编程java!</span></span><br><span class="line">        content = Pattern.compile(<span class="string">&quot;(.)\\1+&quot;</span>).matcher(content).replaceAll(<span class="string">&quot;$1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;content=&quot;</span> + content);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>content=我要学编程java!</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h4 id="6-String类中使用正则表达式"><a href="#6-String类中使用正则表达式" class="headerlink" title="6.String类中使用正则表达式"></a>6.String类中使用正则表达式</h4><ul>
<li><p>替换功能</p>
<p>StringReg.java</p>
<p>String类public String replaceAll(String regx, String replacement)</p>
</li>
<li><p>判断功能</p>
<p>String类public boolean matchers(String regx){}</p>
<p>要求验证一个手机号，必须是以138 139开头的</p>
</li>
<li><p>分割功能</p>
<p>String类public String[] split(String regx)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiongzhuo.regexp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 韩顺平</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringReg</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;2000年5月，JDK1.3、JDK1.4和J2SE1.3相继发布，几周后其&quot;</span> +</span><br><span class="line">                <span class="string">&quot;获得了Apple公司Mac OS X的工业标准的支持。2001年9月24日，J2EE1.3发&quot;</span> +</span><br><span class="line">                <span class="string">&quot;布。&quot;</span> +</span><br><span class="line">                <span class="string">&quot;2002年2月26日，J2SE1.4发布。自此Java的计算能力有了大幅提升&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用正则表达式方式，将 JDK1.3 和 JDK1.4 替换成JDK</span></span><br><span class="line">        content = content.replaceAll(<span class="string">&quot;JDK1\\.3|JDK1\\.4&quot;</span>, <span class="string">&quot;JDK&quot;</span>);</span><br><span class="line">        System.out.println(content);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要求 验证一个 手机号， 要求必须是以138 139 开头的</span></span><br><span class="line">        content = <span class="string">&quot;13888889999&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (content.matches(<span class="string">&quot;1(38|39)\\d&#123;8&#125;&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;验证成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;验证失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//要求按照 # 或者 - 或者 ~ 或者 数字 来分割</span></span><br><span class="line">        System.out.println(<span class="string">&quot;——————————&quot;</span>);</span><br><span class="line">        content = <span class="string">&quot;hello#abc-jack12smith~北京&quot;</span>;</span><br><span class="line">        String[] split = content.split(<span class="string">&quot;#|-|~|\\d+&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : split) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>2000年5月，JDK、JDK和J2SE1.3相继发布，几周后其获得了Apple公司Mac OS X的工业标准的支持。2001年9月24日，J2EE1.3发布。2002年2月26日，J2SE1.4发布。自此Java的计算能力有了大幅提升<br>验证成功<br>——————————<br>hello<br>abc<br>jack<br>smith<br>北京</p>
</blockquote>
<h4 id="7-练习"><a href="#7-练习" class="headerlink" title="7.练习"></a>7.练习</h4><p>1.验证电子邮件格式是否合法</p>
<p>规定电子邮件规则为</p>
<ol>
<li>只能有一个@</li>
<li>@前面是用户名，可以是a-z A-Z 0-9 _-字符</li>
<li>@后面是域名，并且域名只能是英文字母，比如sohu.com 或者 tsinghua.org.cn</li>
<li>写出对应的正则表达式，验证输入的字符串是否满足规则</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiongzhuo.regexp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Homework01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String content = <span class="string">&quot;hsp@tsinghua.org.cn kkk&quot;</span>;</span><br><span class="line">        String regStr = <span class="string">&quot;^[\\w-]+@([a-zA-Z]+\\.)+[a-zA-Z]+$&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. String 的 matches 是整体匹配</span></span><br><span class="line">        <span class="comment">//2. 看看这个matches 底层</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * String 的 matches</span></span><br><span class="line"><span class="comment">         *  public boolean matches(String regex) &#123;</span></span><br><span class="line"><span class="comment">         *         return Pattern.matches(regex, this);</span></span><br><span class="line"><span class="comment">         *     &#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  Pattern</span></span><br><span class="line"><span class="comment">         *  public static boolean matches(String regex, CharSequence input) &#123;</span></span><br><span class="line"><span class="comment">         *         Pattern p = Pattern.compile(regex);</span></span><br><span class="line"><span class="comment">         *         Matcher m = p.matcher(input);</span></span><br><span class="line"><span class="comment">         *         return m.matches();</span></span><br><span class="line"><span class="comment">         *     &#125;</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *  Mather类 match</span></span><br><span class="line"><span class="comment">         *  Attempts to match the entire region against the pattern</span></span><br><span class="line"><span class="comment">         *  public boolean matches() &#123;</span></span><br><span class="line"><span class="comment">         *         return match(from, ENDANCHOR);</span></span><br><span class="line"><span class="comment">         *     &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (content.matches(regStr)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.要求验证是不是整数或者小数<br>    提示： 这个题要考虑正数和负数<br>    比如： 123 -345 34.89 -87.9 -0.01 0.45 等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiongzhuo.regexp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Homework02</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. 先写出简单的正则表达式</span></span><br><span class="line"><span class="comment">         * 2. 在逐步的完善[根据各种情况来完善]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String content = <span class="string">&quot;-0.89&quot;</span>; <span class="comment">//</span></span><br><span class="line">        String regStr = <span class="string">&quot;^[-+]?([1-9]\\d*|0)(\\.\\d+)?$&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(content.matches(regStr)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配成功 是整数或者小数&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.对一个url进行解析</p>
<p>   <a href="https://www.souhu.com:8080/abc/index.htm">https://www.souhu.com:8080/abc/index.htm</a></p>
<p>a)要求得到的协议是什么？http</p>
<p>b)域名是什么？                   <a href="http://www.sohu.com/">www.sohu.com</a></p>
<p>c)端口是什么？                   8080</p>
<p>d)文件名是什么？              index.htm</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xiongzhuo.regexp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Homework03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String content = <span class="string">&quot;http://www.sohu.com:8080/abc/xxx/yyy/////inde@#$%x.htm&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为正则表达式是根据要求来编写的，所以，如果需求需要的话，可以改进.</span></span><br><span class="line">        String regStr = <span class="string">&quot;^([a-zA-Z]+)://([a-zA-Z.]+):(\\d+)[\\w-/]*/([\\w.@#$%]+)$&quot;</span>;</span><br><span class="line"></span><br><span class="line">        Pattern pattern = Pattern.compile(regStr);</span><br><span class="line">        Matcher matcher = pattern.matcher(content);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(matcher.matches()) &#123;<span class="comment">//整体匹配, 如果匹配成功，可以通过group(x), 获取对应分组的内容</span></span><br><span class="line">            System.out.println(<span class="string">&quot;整体匹配=&quot;</span> + matcher.group(<span class="number">0</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;协议: &quot;</span> + matcher.group(<span class="number">1</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;域名: &quot;</span> + matcher.group(<span class="number">2</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;端口: &quot;</span> + matcher.group(<span class="number">3</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;文件: &quot;</span> + matcher.group(<span class="number">4</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有匹配成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="8-转义字符详细说明"><a href="#8-转义字符详细说明" class="headerlink" title="8.转义字符详细说明"></a><strong>8.转义字符详细说明</strong></h4><table>
<thead>
<tr>
<th><strong>字符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>\</strong></td>
<td><strong>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符。序列”\\“匹配”\“，”\(“匹配”(“。</strong></td>
</tr>
<tr>
<td><strong>^</strong></td>
<td><strong>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。</strong></td>
</tr>
<tr>
<td><strong>$</strong></td>
<td><strong>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配。</strong></td>
</tr>
<tr>
<td>*****</td>
<td><strong>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</strong></td>
</tr>
<tr>
<td><strong>+</strong></td>
<td><strong>一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</strong></td>
</tr>
<tr>
<td><strong>?</strong></td>
<td><strong>零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</strong></td>
</tr>
<tr>
<td><strong>{*n*}</strong></td>
<td><strong><em>n\</em></strong> <strong>是非负整数。正好匹配 *n* 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</strong></td>
</tr>
<tr>
<td><strong>{*n*,}</strong></td>
<td><strong><em>n\</em></strong> <strong>是非负整数。至少匹配 *n* 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*“。</strong></td>
</tr>
<tr>
<td><strong>{*n*,*m*}</strong></td>
<td><strong><em>m\</em></strong> <strong>和 *n* 是非负整数，其中 *n* &lt;= *m*。匹配至少 *n* 次，至多 *m* 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于  ‘o?’。注意：您不能将空格插入逗号和数字之间。</strong></td>
</tr>
<tr>
<td><strong>?</strong></td>
<td><strong>当此字符紧随任何其他限定符（*、+、?、{*n*}、{*n*,}、{*n*,*m*}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</strong></td>
</tr>
<tr>
<td><strong>.</strong></td>
<td><strong>匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</strong></td>
</tr>
<tr>
<td><strong>(*pattern*)</strong></td>
<td><strong>匹配 *pattern* 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。</strong></td>
</tr>
<tr>
<td><strong>(?:*pattern*)</strong></td>
<td><strong>匹配 *pattern* 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’  更经济的表达式。</strong></td>
</tr>
<tr>
<td><strong>(?=*pattern*)</strong></td>
<td><strong>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 *pattern* 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?=95|98|NT|2000)’ 匹配”Windows  2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</strong></td>
</tr>
<tr>
<td><strong>(?!*pattern*)</strong></td>
<td><strong>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 *pattern* 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows  3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</strong></td>
</tr>
<tr>
<td><strong><em>x**</em></strong>|*y***</td>
<td><strong>匹配 *x* 或 *y*。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。</strong></td>
</tr>
<tr>
<td><strong>[*xyz*]</strong></td>
<td><strong>字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</strong></td>
</tr>
<tr>
<td><strong>[^*xyz*]</strong></td>
<td><strong>反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</strong></td>
</tr>
<tr>
<td><strong>[*a-z*]</strong></td>
<td><strong>字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</strong></td>
</tr>
<tr>
<td><strong>[^*a-z*]</strong></td>
<td><strong>反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</strong></td>
</tr>
<tr>
<td><strong>\b</strong></td>
<td><strong>匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</strong></td>
</tr>
<tr>
<td><strong>\B</strong></td>
<td><strong>非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</strong></td>
</tr>
<tr>
<td><strong>\c*x*</strong></td>
<td><strong>匹配 *x* 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。*x* 的值必须在 A-Z 或  a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</strong></td>
</tr>
<tr>
<td><strong>\d</strong></td>
<td><strong>数字字符匹配。等效于  [0-9]。</strong></td>
</tr>
<tr>
<td><strong>\D</strong></td>
<td><strong>非数字字符匹配。等效于  [^0-9]。</strong></td>
</tr>
<tr>
<td><strong>\f</strong></td>
<td><strong>换页符匹配。等效于  \x0c 和 \cL。</strong></td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td><strong>换行符匹配。等效于  \x0a 和 \cJ。</strong></td>
</tr>
<tr>
<td><strong>\r</strong></td>
<td><strong>匹配一个回车符。等效于  \x0d 和 \cM。</strong></td>
</tr>
<tr>
<td><strong>\s</strong></td>
<td><strong>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</strong></td>
</tr>
<tr>
<td><strong>\S</strong></td>
<td><strong>匹配任何非空白字符。与  [^ \f\n\r\t\v] 等效。</strong></td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td><strong>制表符匹配。与  \x09 和 \cI 等效。</strong></td>
</tr>
<tr>
<td><strong>\v</strong></td>
<td><strong>垂直制表符匹配。与  \x0b 和 \cK 等效。</strong></td>
</tr>
<tr>
<td><strong>\w</strong></td>
<td><strong>匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</strong></td>
</tr>
<tr>
<td><strong>\W</strong></td>
<td><strong>与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</strong></td>
</tr>
<tr>
<td><strong>\x*n*</strong></td>
<td><strong>匹配 *n*，此处的 *n* 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</strong></td>
</tr>
<tr>
<td><strong>*num*</strong></td>
<td><strong>匹配 *num*，此处的 *num* 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</strong></td>
</tr>
<tr>
<td><strong>*n*</strong></td>
<td><strong>标识一个八进制转义码或反向引用。如果 *n* 前面至少有 *n* 个捕获子表达式，那么 *n* 是反向引用。否则，如果 *n* 是八进制数 (0-7)，那么 *n* 是八进制转义码。</strong></td>
</tr>
<tr>
<td><strong>*nm*</strong></td>
<td><strong>标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 *nm* 个捕获子表达式，那么 *nm* 是反向引用。如果 *nm* 前面至少有 *n* 个捕获，则 *n* 是反向引用，后面跟有字符 *m*。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 *nm*，其中 *n* 和 *m* 是八进制数字 (0-7)。</strong></td>
</tr>
<tr>
<td><strong>\nml</strong></td>
<td><strong>当 *n* 是八进制数  (0-3)，*m* 和 *l* 是八进制数 (0-7) 时，匹配八进制转义码 *nml*。</strong></td>
</tr>
<tr>
<td><strong>\u*n*</strong></td>
<td><strong>匹配 *n*，其中 *n* 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</strong></td>
</tr>
</tbody></table>
<h4 id="9-正则表达式参考"><a href="#9-正则表达式参考" class="headerlink" title="9.正则表达式参考"></a>9.正则表达式参考</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一、校验数字的表达式</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> 数字：^[<span class="number">0</span>-<span class="number">9</span>]*$</span><br><span class="line"><span class="number">2</span> n位的数字：^\d&#123;n&#125;$</span><br><span class="line"><span class="number">3</span> 至少n位的数字：^\d&#123;n,&#125;$</span><br><span class="line"><span class="number">4</span> m-n位的数字：^\d&#123;m,n&#125;$</span><br><span class="line"><span class="number">5</span> 零和非零开头的数字：^(<span class="number">0</span>|[<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]*)$</span><br><span class="line"><span class="number">6</span> 非零开头的最多带两位小数的数字：^([<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]*)+(.[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line"><span class="number">7</span> 带<span class="number">1</span>-<span class="number">2</span>位小数的正数或负数：^(\-)?\d+(\.\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$</span><br><span class="line"><span class="number">8</span> 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$</span><br><span class="line"><span class="number">9</span> 有两位小数的正实数：^[<span class="number">0</span>-<span class="number">9</span>]+(.[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">2</span>&#125;)?$</span><br><span class="line"><span class="number">10</span> 有<span class="number">1</span>~<span class="number">3</span>位小数的正实数：^[<span class="number">0</span>-<span class="number">9</span>]+(.[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;)?$</span><br><span class="line"><span class="number">11</span> 非零的正整数：^[<span class="number">1</span>-<span class="number">9</span>]\d*$ 或 ^([<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]*)&#123;<span class="number">1</span>,<span class="number">3</span>&#125;$ 或 ^\+?[<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]*$</span><br><span class="line"><span class="number">12</span> 非零的负整数：^\-[<span class="number">1</span>-<span class="number">9</span>][]<span class="number">0</span>-<span class="number">9</span><span class="string">&quot;*$ 或 ^-[1-9]\d*$</span></span><br><span class="line"><span class="string">13 非负整数：^\d+$ 或 ^[1-9]\d*|0$</span></span><br><span class="line"><span class="string">14 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</span></span><br><span class="line"><span class="string">15 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</span></span><br><span class="line"><span class="string">16 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</span></span><br><span class="line"><span class="string">17 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</span></span><br><span class="line"><span class="string">18 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</span></span><br><span class="line"><span class="string">19 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">二、校验字符的表达式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1 汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$</span></span><br><span class="line"><span class="string">2 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]&#123;4,40&#125;$</span></span><br><span class="line"><span class="string">3 长度为3-20的所有字符：^.&#123;3,20&#125;$</span></span><br><span class="line"><span class="string">4 由26个英文字母组成的字符串：^[A-Za-z]+$</span></span><br><span class="line"><span class="string">5 由26个大写英文字母组成的字符串：^[A-Z]+$</span></span><br><span class="line"><span class="string">6 由26个小写英文字母组成的字符串：^[a-z]+$</span></span><br><span class="line"><span class="string">7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$</span></span><br><span class="line"><span class="string">8 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w&#123;3,20&#125;$</span></span><br><span class="line"><span class="string">9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$</span></span><br><span class="line"><span class="string">10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;$</span></span><br><span class="line"><span class="string">11 可以输入含有^%&amp;&#x27;,;=?$\&quot;等字符：[^%&amp;&#x27;,;=?$\x22]+</span></span><br><span class="line"><span class="string">12 禁止输入含有~的字符：[^~\x22]+</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">三、特殊需求表达式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span></span><br><span class="line"><span class="string">2 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</span></span><br><span class="line"><span class="string">3 InternetURL：[a-zA-z]+://[^\s]* 或 ^https://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</span></span><br><span class="line"><span class="string">4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$</span></span><br><span class="line"><span class="string">5 电话号码(&quot;</span>XXX-XXXXXXX<span class="string">&quot;、&quot;</span>XXXX-XXXXXXXX<span class="string">&quot;、&quot;</span>XXX-XXXXXXX<span class="string">&quot;、&quot;</span>XXX-XXXXXXXX<span class="string">&quot;、&quot;</span>XXXXXXX<span class="string">&quot;和&quot;</span>XXXXXXXX)：^(\(\d&#123;<span class="number">3</span>,<span class="number">4</span>&#125;-)|\d&#123;<span class="number">3.4</span>&#125;-)?\d&#123;<span class="number">7</span>,<span class="number">8</span>&#125;$ </span><br><span class="line"><span class="number">6</span> 国内电话号码(<span class="number">0511</span>-<span class="number">4405222</span>、<span class="number">021</span>-<span class="number">87888822</span>)：\d&#123;<span class="number">3</span>&#125;-\d&#123;<span class="number">8</span>&#125;|\d&#123;<span class="number">4</span>&#125;-\d&#123;<span class="number">7</span>&#125;</span><br><span class="line"><span class="number">7</span> 身份证号：</span><br><span class="line">		<span class="number">15</span>或<span class="number">18</span>位身份证：^\d&#123;<span class="number">15</span>&#125;|\d&#123;<span class="number">18</span>&#125;$</span><br><span class="line">		<span class="number">15</span>位身份证：^[<span class="number">1</span>-<span class="number">9</span>]\d&#123;<span class="number">7</span>&#125;((<span class="number">0</span>\d)|(<span class="number">1</span>[<span class="number">0</span>-<span class="number">2</span>]))(([<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>]\d)|<span class="number">3</span>[<span class="number">0</span>-<span class="number">1</span>])\d&#123;<span class="number">3</span>&#125;$</span><br><span class="line">		<span class="number">18</span>位身份证：^[<span class="number">1</span>-<span class="number">9</span>]\d&#123;<span class="number">5</span>&#125;[<span class="number">1</span>-<span class="number">9</span>]\d&#123;<span class="number">3</span>&#125;((<span class="number">0</span>\d)|(<span class="number">1</span>[<span class="number">0</span>-<span class="number">2</span>]))(([<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>]\d)|<span class="number">3</span>[<span class="number">0</span>-<span class="number">1</span>])\d&#123;<span class="number">4</span>&#125;$</span><br><span class="line"><span class="number">8</span> 短身份证号码(数字、字母x结尾)：^([<span class="number">0</span>-<span class="number">9</span>])&#123;<span class="number">7</span>,<span class="number">18</span>&#125;(x|X)?$ 或 ^\d&#123;<span class="number">8</span>,<span class="number">18</span>&#125;|[<span class="number">0</span>-9x]&#123;<span class="number">8</span>,<span class="number">18</span>&#125;|[<span class="number">0</span>-9X]&#123;<span class="number">8</span>,<span class="number">18</span>&#125;?$</span><br><span class="line"><span class="number">9</span> 帐号是否合法(字母开头，允许<span class="number">5</span>-<span class="number">16</span>字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;<span class="number">4</span>,<span class="number">15</span>&#125;$</span><br><span class="line"><span class="number">10</span> 密码(以字母开头，长度在<span class="number">6</span>~<span class="number">18</span>之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;<span class="number">5</span>,<span class="number">17</span>&#125;$</span><br><span class="line"><span class="number">11</span> 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在<span class="number">8</span>-<span class="number">10</span>之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;<span class="number">8</span>,<span class="number">10</span>&#125;$ </span><br><span class="line"><span class="number">12</span> 日期格式：^\d&#123;<span class="number">4</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;-\d&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line"><span class="number">13</span> 一年的<span class="number">12</span>个月(<span class="number">01</span>～09和<span class="number">1</span>～<span class="number">12</span>)：^(<span class="number">0</span>?[<span class="number">1</span>-<span class="number">9</span>]|<span class="number">1</span>[<span class="number">0</span>-<span class="number">2</span>])$</span><br><span class="line"><span class="number">14</span> 一个月的<span class="number">31</span>天(<span class="number">01</span>～09和<span class="number">1</span>～<span class="number">31</span>)：^((<span class="number">0</span>?[<span class="number">1</span>-<span class="number">9</span>])|((<span class="number">1</span>|<span class="number">2</span>)[<span class="number">0</span>-<span class="number">9</span>])|<span class="number">30</span>|<span class="number">31</span>)$ </span><br><span class="line"><span class="number">15</span> 钱的输入格式：</span><br><span class="line"><span class="number">16</span> <span class="number">1.</span>有四种钱的表示形式我们可以接受:<span class="string">&quot;10000.00&quot;</span> 和 <span class="string">&quot;10,000.00&quot;</span>, 和没有 <span class="string">&quot;分&quot;</span> 的 <span class="string">&quot;10000&quot;</span> 和 <span class="string">&quot;10,000&quot;</span>：^[<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]*$ </span><br><span class="line"><span class="number">17</span> <span class="number">2.</span>这表示任意一个不以<span class="number">0</span>开头的数字,但是,这也意味着一个字符<span class="string">&quot;0&quot;</span>不通过,所以我们采用下面的形式：^(<span class="number">0</span>|[<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]*)$ </span><br><span class="line"><span class="number">18</span> <span class="number">3.</span>一个<span class="number">0</span>或者一个不以<span class="number">0</span>开头的数字.我们还可以允许开头有一个负号：^(<span class="number">0</span>|-?[<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]*)$ </span><br><span class="line"><span class="number">19</span> <span class="number">4.</span>这表示一个<span class="number">0</span>或者一个可能为负的开头不为<span class="number">0</span>的数字.让用户以<span class="number">0</span>开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[<span class="number">0</span>-<span class="number">9</span>]+(.[<span class="number">0</span>-<span class="number">9</span>]+)?$ </span><br><span class="line"><span class="number">20</span> <span class="number">5.</span>必须说明的是,小数点后面至少应该有<span class="number">1</span>位数,所以<span class="string">&quot;10.&quot;</span>是不通过的,但是 <span class="string">&quot;10&quot;</span> 和 <span class="string">&quot;10.2&quot;</span> 是通过的：^[<span class="number">0</span>-<span class="number">9</span>]+(.[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">2</span>&#125;)?$ </span><br><span class="line"><span class="number">21</span> <span class="number">6.</span>这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[<span class="number">0</span>-<span class="number">9</span>]+(.[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$ </span><br><span class="line"><span class="number">22</span> <span class="number">7.</span>这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(,[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">3</span>&#125;)*(.[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$ </span><br><span class="line"><span class="number">23</span> <span class="number">8.1</span>到<span class="number">3</span>个数字,后面跟着任意个 逗号+<span class="number">3</span>个数字,逗号成为可选,而不是必须：^([<span class="number">0</span>-<span class="number">9</span>]+|[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;(,[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">3</span>&#125;)*)(.[<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)?$ </span><br><span class="line"><span class="number">24</span> 备注：这就是最终结果了,别忘了<span class="string">&quot;+&quot;</span>可以用<span class="string">&quot;*&quot;</span>替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里</span><br><span class="line"><span class="number">25</span> xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-<span class="number">9</span>]+\\.[x|X][m|M][l|L]$</span><br><span class="line"><span class="number">26</span> 中文字符的正则表达式：[\u4e00-\u9fa5]</span><br><span class="line"><span class="number">27</span> 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计<span class="number">2</span>，ASCII字符计<span class="number">1</span>))</span><br><span class="line"><span class="number">28</span> 空白行的正则表达式：\n\s*\r (可以用来删除空白行)</span><br><span class="line"><span class="number">29</span> HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</span><br><span class="line"><span class="number">30</span> 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</span><br><span class="line"><span class="number">31</span> 腾讯QQ号：[<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">4</span>,&#125; (腾讯QQ号从<span class="number">10000</span>开始)</span><br><span class="line"><span class="number">32</span> 中国邮政编码：[<span class="number">1</span>-<span class="number">9</span>]\d&#123;<span class="number">5</span>&#125;(?!\d) (中国邮政编码为<span class="number">6</span>位数字)</span><br><span class="line"><span class="number">33</span> IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>11-Java集合</title>
    <url>/2021/09/17/11%E2%80%94Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="11—Java集合"><a href="#11—Java集合" class="headerlink" title="11—Java集合"></a>11—Java集合</h3><h4 id="1-Java集合框架概述"><a href="#1-Java集合框架概述" class="headerlink" title="1. Java集合框架概述"></a>1. Java集合框架概述</h4><ul>
<li>一方面，面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java集合就像一种容器，可以动态的把多个对象引用放入容器中<ul>
<li><strong>数组在内存存储方面的特点：</strong><ul>
<li>数组初始化以后，长度就确定了</li>
<li>数组声明的类型，就决定了进行元素初始化时的类型</li>
</ul>
</li>
<li><strong>数组在存储数据方面的弊端</strong><ul>
<li>数组初始化以后，长度就不可变了，不便于扩展</li>
<li>数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高，无法直接获取存储元素的个数</li>
<li>数字存储的数据是有序的、可以重复的。—&gt;存储数据的特点单一</li>
</ul>
</li>
</ul>
</li>
<li>Java集合类可以用于存储数量不等的多个对象，还可以用来保存具有映射关系的关联数组</li>
<li>使用场景<ul>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210724170615.png" alt="image-20210724151314780" style="zoom:67%;" /></li>
</ul>
</li>
<li>Java集合可以分为Collection和Map两种体系<ul>
<li>Collection接口：单列数据，定义了存取一组对象的方法的集合<ul>
<li>List：元素有序、可重复的集合</li>
<li>Set：元素无序、不可重复的集合</li>
<li>Collection接口继承树</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210724151638.png" alt="image-20210724151637427" style="zoom:80%;" /></li>
</ul>
</li>
<li>Map接口：双列数据，保存具有映射关系”key=value”的集合<ul>
<li>Map接口继承树</li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108161808047.jpg" alt="Inked20210724151733_LI"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-Collection接口方法"><a href="#2-Collection接口方法" class="headerlink" title="2. Collection接口方法"></a>2. Collection接口方法</h4><p><strong>Collection接口</strong></p>
<ul>
<li>Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可以用于操作Set集合，也可以用于操作List和Queue集合</li>
<li>JDK不提供此接口的任何直接实现，而是提供更加具体的子接口（如：Set和List）实现</li>
<li>在Java5之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成Object类型处理；从JDK5.0增加泛型以后，Java集合可以记住容器中对象的数据类型</li>
</ul>
<p><strong>Collection接口方法</strong></p>
<ol>
<li>添加<ol>
<li>add(Object obj)</li>
<li>addAll(Collection coll)</li>
</ol>
</li>
<li>删除<ol>
<li>boolean remove(Object obj)：通过元素的equals方法判断是否要删除那个元素。只会删除找到的第一个元素</li>
<li>boolean removeAll(Collection coll)：取当前集合的差集</li>
</ol>
</li>
<li>清空集合<ol>
<li>void clear()</li>
</ol>
</li>
<li>获取有效元素的个数<ol>
<li>int size()</li>
</ol>
</li>
<li>取两个集合的交集<ol>
<li>boolean retainAll(Collection coll)：把交集的结果存在当前集合中，不影响coll</li>
</ol>
</li>
<li>集合是否相等<ol>
<li>boolean equals(Object obj)</li>
</ol>
</li>
<li>是否包含某个元素<ol>
<li>boolean contains(Object obj)：是通过元素的equals方法来判断是否是同一个对象</li>
<li>boolean containsAll(Collection c)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较</li>
</ol>
</li>
<li>是否是空集<ol>
<li>boolean isEmpty()</li>
</ol>
</li>
<li>转成对象数组<ol>
<li>Object[] toArray()</li>
</ol>
</li>
<li>获取集合对象的哈希值<ol>
<li>hashCode()</li>
</ol>
</li>
<li>遍历<ol>
<li>iterator()：返回迭代器对象，用于集合遍历</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectoionTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Collection coll2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//添加：add(Object obj)  add(Collection coll)</span></span><br><span class="line">        coll1.add(<span class="number">123</span>);</span><br><span class="line">        coll1.add(<span class="string">&quot;xiong&quot;</span>);</span><br><span class="line">        coll1.add(<span class="keyword">new</span> Person(<span class="string">&quot;zhuo&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        coll1.add(<span class="keyword">false</span>);</span><br><span class="line">        coll1.add(<span class="keyword">new</span> String(<span class="string">&quot;GUET&quot;</span>));</span><br><span class="line"></span><br><span class="line">        coll2.addAll(coll1);</span><br><span class="line">        coll2.add(<span class="keyword">new</span> Student(<span class="string">&quot;sut&quot;</span>,<span class="number">22</span>,<span class="number">87.5</span>));</span><br><span class="line">        System.out.println(coll1);<span class="comment">//[123, xiong, Person&#123;name=&#x27;zhuo&#x27;, age=23&#125;, false, GUET]</span></span><br><span class="line">        System.out.println(coll2);<span class="comment">//[123, xiong, Person&#123;name=&#x27;zhuo&#x27;, age=23&#125;, false, GUET, Student&#123;name=&#x27;sut&#x27;, age=22, score=87.5&#125;]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除：remove(Object obj)  remove(Collection coll) clear()</span></span><br><span class="line">        coll1.remove(<span class="keyword">new</span> Person(<span class="string">&quot;zhuo&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        System.out.println(coll1);<span class="comment">//[123, xiong, Person&#123;name=&#x27;zhuo&#x27;, age=23&#125;, false, GUET]</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        结果：未能删除</span></span><br><span class="line"><span class="comment">        原因：remove使用的是equals方法来比较二者的异同，而此时Person类中未重写equals方法，</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        coll2.remove(<span class="keyword">new</span> Student(<span class="string">&quot;sut&quot;</span>,<span class="number">22</span>,<span class="number">87.5</span>));</span><br><span class="line">        System.out.println(coll2);<span class="comment">//[123, xiong, Person&#123;name=&#x27;zhuo&#x27;, age=23&#125;, false, GUET]</span></span><br><span class="line"></span><br><span class="line">        coll1.remove(<span class="number">123</span>);</span><br><span class="line">        coll2.removeAll(coll1);</span><br><span class="line">        System.out.println(coll1);<span class="comment">//[xiong, Person&#123;name=&#x27;zhuo&#x27;, age=23&#125;, false, GUET]</span></span><br><span class="line">        System.out.println(coll2);<span class="comment">//[123]</span></span><br><span class="line"></span><br><span class="line">        coll2.clear();</span><br><span class="line">        System.out.println(coll2);<span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//查询：</span></span><br><span class="line">        <span class="comment">//是否是空集：isEmpty()</span></span><br><span class="line">        System.out.println(coll2.isEmpty());<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//获取有效元素的个数 size()</span></span><br><span class="line">        System.out.println(coll1.size());<span class="comment">//4</span></span><br><span class="line">        <span class="comment">//是否包含某个元素 contains(Object obj) containsAll(Collection coll) 二者也是用equals来进行比较</span></span><br><span class="line">        System.out.println(coll1.contains(<span class="string">&quot;xiong&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(coll1.containsAll(coll2));<span class="comment">//true</span></span><br><span class="line">        <span class="comment">//取两集合的交集 retainAll(Colleciton coll) 把交集结果存在当前集合中，不影响coll</span></span><br><span class="line">        Collection coll3 = Arrays.asList(<span class="string">&quot;xiong&quot;</span>);</span><br><span class="line">        System.out.println(coll1.retainAll(coll3) + <span class="string">&quot;  coll1: &quot;</span> + coll1);<span class="comment">//true  coll1: [xiong]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//转换为数组对象 toArray()</span></span><br><span class="line">        Object[] objects = coll1.toArray();</span><br><span class="line">        <span class="keyword">for</span> (Object o:</span><br><span class="line">             objects) &#123;</span><br><span class="line">            System.out.println(o); <span class="comment">//xiong</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取对象的哈希值 hashCode</span></span><br><span class="line">        System.out.println(coll1.hashCode());<span class="comment">//114060790</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历：iterator()</span></span><br><span class="line">        Iterator iter = coll1.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">            System.out.println(iter.next());<span class="comment">//xiong</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">double</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getAge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getAge() == student.getAge() &amp;&amp; Objects.equals(<span class="keyword">this</span>.getName(), student.getName()) &amp;&amp; Double.compare(student.score, score) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +<span class="string">&quot;name=&#x27;&quot;</span> + <span class="keyword">super</span>.getName() + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + <span class="keyword">super</span>.getAge() +</span><br><span class="line">                <span class="string">&quot;, score=&quot;</span> + score +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[123, xiong, Person{name=’zhuo’, age=23}, false, GUET]<br>[123, xiong, Person{name=’zhuo’, age=23}, false, GUET, Student{name=’sut’, age=22, score=87.5}]<br>[123, xiong, Person{name=’zhuo’, age=23}, false, GUET]<br>[123, xiong, Person{name=’zhuo’, age=23}, false, GUET]<br>[xiong, Person{name=’zhuo’, age=23}, false, GUET]<br>[123]<br>[]<br>true<br>4<br>true<br>true<br>true  coll1: [xiong]<br>xiong<br>114060790<br>xiong</p>
</blockquote>
<h4 id="3-Iterator迭代器接口"><a href="#3-Iterator迭代器接口" class="headerlink" title="3. Iterator迭代器接口"></a>3. Iterator迭代器接口</h4><p><strong>使用Iterator接口遍历集合元素</strong></p>
<ul>
<li><p>Iterator对象称为迭代器（设计模式的一种），主要用于遍历Collection集合中的元素</p>
</li>
<li><p>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需要暴露内部细节。<strong>迭代器模式，就是为容器而生</strong>。类似于“公交车上的售票员”、”火车上的乘务员”</p>
</li>
<li><p>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator对象</p>
</li>
<li><p>Iterator仅用于遍历集合，Iterator本身并不提供承装对象的能力。如果需要创建Iterator对象，则必须有一个被迭代的集合</p>
</li>
<li><p>集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前</p>
</li>
<li><p>在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且在下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108161753231.png" alt="image-20210816175355777"></p>
</li>
<li><p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210724175455.png" alt="image-20210724175448962"></p>
</li>
<li><p>Iterator接口remove()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator ter = coll.iterator();<span class="comment">//回到起点</span></span><br><span class="line"><span class="keyword">while</span>(iter.hasNext())&#123;</span><br><span class="line">    Object obj = iter.next();</span><br><span class="line">    <span class="keyword">if</span>(obj.equals(<span class="string">&quot;Tom&quot;</span>))&#123;</span><br><span class="line">        iter.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Iterator可以删除集合的元素，但是是遍历过程中普通迭代器对象的remove方法，不是集合对象的remove方法</li>
<li>如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllegalStateException</li>
</ul>
</li>
</ul>
<p><strong>使用foreach循环遍历集合元素</strong></p>
<ul>
<li><p>Java5.0提供了foreach循环迭代访问Collection和数组</p>
</li>
<li><p>遍历操作不需要获得Collection或数组长度，无需使用索引访问元素</p>
</li>
<li><p>遍历集合的底层调用Iterator完成操作</p>
</li>
<li><p>foreach还可以用来遍历数组</p>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210724180207.png" alt="image-20210724180206697" style="zoom: 80%;" />

</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">        coll.add(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Iterator iter = coll.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一遍历</span></span><br><span class="line">        System.out.println(iter.next());</span><br><span class="line">        System.out.println(iter.next());</span><br><span class="line">        System.out.println(iter.next());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二遍历</span></span><br><span class="line">        iter = coll.iterator();<span class="comment">//每次使用迭代器都需将游标复位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coll.size(); i++) &#123;</span><br><span class="line">            System.out.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式三遍历</span></span><br><span class="line">        iter = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">            System.out.println(iter.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式四遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Object c :</span><br><span class="line">                coll) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式五遍历</span></span><br><span class="line">        Object[] objects = coll.toArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.length; i++) &#123;</span><br><span class="line">            System.out.println(objects[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除集合中元素</span></span><br><span class="line">        iter = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">            Object obj = iter.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;123&quot;</span>.equals(obj))&#123;</span><br><span class="line">                iter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(coll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-Collection子接口一：List"><a href="#4-Collection子接口一：List" class="headerlink" title="4. Collection子接口一：List"></a>4. Collection子接口一：List</h4><h5 id="4-1-List接口概述"><a href="#4-1-List接口概述" class="headerlink" title="4.1 List接口概述"></a>4.1 List接口概述</h5><ul>
<li>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</li>
<li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素</li>
<li>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector</li>
</ul>
<h5 id="4-2-List接口方法"><a href="#4-2-List接口方法" class="headerlink" title="4.2 List接口方法"></a>4.2 List接口方法</h5><ul>
<li>List除了从Collection集合继承的方法外，List集合里添加了一些根据索引来操作集合元素的方法<ul>
<li>void add(int indexm Object ele)：在index位置插入ele元素</li>
<li>boolean addAll(int index, Collection eles)：从index位置开始将eles中的所有元素添加进来</li>
<li>Object get(int index)：获取指定index位置的元素</li>
<li>int indexOf(Object obj)：返回obj在当前集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置</li>
<li>Object set(int index, Object ele)：设置指定index位置的元素为ele</li>
<li>List subList(int formIndex, int toIndex)：返回从fromIndex到toIndex位置的子集</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Collection.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">常用方法：</span></span><br><span class="line"><span class="comment">增：add(Object obj)</span></span><br><span class="line"><span class="comment">删：remove(int index)  remove(Object obj)</span></span><br><span class="line"><span class="comment">改：set(int index, Object obj)</span></span><br><span class="line"><span class="comment">查：get(int index) indexOf(Object obj) lastIndexOf(Object obj)</span></span><br><span class="line"><span class="comment">插：add(int index, Object obj) addAll(int index, Collection coll)</span></span><br><span class="line"><span class="comment">长度：size()</span></span><br><span class="line"><span class="comment">遍历：①Iterator迭代器方式</span></span><br><span class="line"><span class="comment">     ②增强for循环</span></span><br><span class="line"><span class="comment">     ③普通循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Collection arrayList1 =  Arrays.asList(<span class="string">&quot;GUET&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增：add(Object obj)</span></span><br><span class="line">        arrayList.add(<span class="number">123</span>);</span><br><span class="line">        arrayList.add(<span class="string">&quot;xiong&quot;</span>);</span><br><span class="line">        arrayList.add(<span class="keyword">false</span>);</span><br><span class="line">        arrayList.add(<span class="number">0</span>);</span><br><span class="line">        arrayList.add(arrayList1);</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[123, xiong, false, 0, [GUET, true]]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删：remove(int index, Object obj) remove(Object obj)</span></span><br><span class="line">        arrayList.remove(<span class="number">0</span>);</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[xiong, false, 0, [GUET, true]]</span></span><br><span class="line">        arrayList.remove(<span class="keyword">new</span> Integer(<span class="number">0</span>));</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[xiong, false, [GUET, true]]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//查：get(int index) indexOf(Object obj) lastIndexOf(Object obj)</span></span><br><span class="line">        Object o = arrayList.get(<span class="number">1</span>);</span><br><span class="line">        System.out.println(o);<span class="comment">//false</span></span><br><span class="line">        System.out.println(arrayList.indexOf(<span class="string">&quot;xiong&quot;</span>));<span class="comment">//0</span></span><br><span class="line">        System.out.println(arrayList.lastIndexOf(<span class="string">&quot;xiong&quot;</span>));<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//改：set(int index, Object obj)</span></span><br><span class="line">        System.out.println(arrayList.set(<span class="number">1</span>, <span class="string">&quot;zhuo&quot;</span>));<span class="comment">//false 返回被替换的元素</span></span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[xiong, false, [GUET, true]]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//插：add(int index, Object obj)</span></span><br><span class="line">        arrayList.add(<span class="number">3</span>, <span class="string">&quot;computer&quot;</span>);</span><br><span class="line">        arrayList.addAll(<span class="number">4</span>,arrayList1);</span><br><span class="line">        System.out.println(arrayList);<span class="comment">//[xiong, zhuo, [GUET, true], computer, GUET, true]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//长度：size()</span></span><br><span class="line">        System.out.println(arrayList.size());<span class="comment">//6</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        Iterator iterator = arrayList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取子串</span></span><br><span class="line">        System.out.println(arrayList.subList(<span class="number">0</span>, <span class="number">1</span>));<span class="comment">//[xiong]  区间为[0,1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="4-2-1-List实现类之一：ArrayList"><a href="#4-2-1-List实现类之一：ArrayList" class="headerlink" title="4.2.1 List实现类之一：ArrayList"></a>4.2.1 List实现类之一：ArrayList</h6><ul>
<li><p>Array是List接口的典型实现类、主要实现类、</p>
</li>
<li><p>本质上，ArratList是对象引用的一个”变长“数组</p>
</li>
<li><p>ArrayList的JDK1.8之前与之后的实现区别</p>
<ul>
<li>JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组</li>
<li>JDK1.8：ArrayList像懒汉式，一开始直接创建一个长度为0的数组，当添加第一个元素时再创建一个容量为10的数组</li>
</ul>
</li>
<li><p>Arrays.asList(…)方法返回的List集合，既不是ArrayList实例，也不是Vector实例。Arrays.asList(…)返回值是一个固定长度的List集合</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210724214132.png" alt="image-20210724214130848"></p>
</li>
</ul>
<h6 id="4-2-2-List实现类之二：LinkedList"><a href="#4-2-2-List实现类之二：LinkedList" class="headerlink" title="4.2.2 List实现类之二：LinkedList"></a>4.2.2 List实现类之二：LinkedList</h6><ul>
<li><p>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高</p>
</li>
<li><p>新增方法：</p>
<ul>
<li>void addFirst(Object obj)</li>
<li>void addLast(Object obj)</li>
<li>Object getFirst()</li>
<li>Object getLast()</li>
<li>Object removeFirst()</li>
<li>Object removeLast()</li>
</ul>
</li>
<li><p>LinkedList：双向链表，内部是没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基本结构。Node除了保存数据，还定义了两个变量：</p>
<ul>
<li><p>prev变量记录前一个元素的位置</p>
</li>
<li><p>next变量记录下一个元素的位置</p>
</li>
<li><pre><code class="java">private static class Node&lt;E&gt; &#123;
    E item;
    Node&lt;E&gt; next;
    Node&lt;E&gt; prev;
    
    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next)&#123;
        this.item = element;
        this.next = next;
        this.prev = prev;
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    ![image-20210724215014951](https:&#x2F;&#x2F;gitee.com&#x2F;xiongzero&#x2F;alienware_-pic-go&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210724215016.png)</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">package Collection.List;</span><br><span class="line"></span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.util.LinkedList;</span><br><span class="line"></span><br><span class="line">public class LinkedListTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test1()&#123;</span><br><span class="line">        LinkedList linkedList &#x3D; new LinkedList();</span><br><span class="line">        linkedList.add(123);</span><br><span class="line">        linkedList.addFirst(&quot;xiong&quot;);</span><br><span class="line">        linkedList.addLast(&quot;end&quot;);</span><br><span class="line">        System.out.println(linkedList);&#x2F;&#x2F;[xiong, 123, end]</span><br><span class="line"></span><br><span class="line">        System.out.println(linkedList.getFirst());&#x2F;&#x2F;xiong</span><br><span class="line">        System.out.println(linkedList.getLast());&#x2F;&#x2F;end</span><br><span class="line">        System.out.println(linkedList.removeFirst());&#x2F;&#x2F;xiong</span><br><span class="line">        System.out.println(linkedList);&#x2F;&#x2F;[123, end]</span><br><span class="line">        System.out.println(linkedList.removeLast());&#x2F;&#x2F;end</span><br><span class="line">        System.out.println(linkedList);&#x2F;&#x2F;[123]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ul>
<h6 id="4-2-3-List实现类之三：Vector"><a href="#4-2-3-List实现类之三：Vector" class="headerlink" title="4.2.3 List实现类之三：Vector"></a>4.2.3 List实现类之三：Vector</h6><ul>
<li>Vector是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的</li>
<li>在各种list中，最好把ArryList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用</li>
<li>新增方法：<ul>
<li>void addElement(Object obj)</li>
<li>void insertElementAt(Object obj, int index)</li>
<li>void setElementAt(Object obj, int index)</li>
<li>void removeElement(Object obj)</li>
<li>void removeAllElements()</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Collection.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Vector vector = <span class="keyword">new</span> Vector();</span><br><span class="line">        <span class="comment">//增：addElement(Object obj)</span></span><br><span class="line">        vector.addElement(<span class="number">123</span>);</span><br><span class="line">        vector.addElement(<span class="string">&quot;xiong&quot;</span>);</span><br><span class="line">        System.out.println(vector);<span class="comment">//[123, xiong]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删：removeElement(Object obj)</span></span><br><span class="line">        vector.remove(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line">        System.out.println(vector);<span class="comment">//[xiong]</span></span><br><span class="line">        vector.remove(<span class="string">&quot;xiong&quot;</span>);</span><br><span class="line">        System.out.println(vector);<span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//插：insertElementAt(Object obj,int index)</span></span><br><span class="line">        vector.insertElementAt(<span class="string">&quot;Guet&quot;</span>,<span class="number">0</span>);</span><br><span class="line">        System.out.println(vector);<span class="comment">//[Guet]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//改：setElement(Object obj)</span></span><br><span class="line">        vector.set(<span class="number">0</span>,<span class="string">&quot;newString&quot;</span>);</span><br><span class="line">        System.out.println(vector);<span class="comment">//[newString]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>面试题</strong></p>
<p>请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制是什么？Vector和ArrayList的最大区别？</p>
<ul>
<li><p>ArrayList和LinkedList的异同</p>
<p>二者都是线程不安全的，相对于线程安全的Vector，执行效率高。</p>
<p>此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。对于随机访问get和set，ArrayList优于LinkedList，因为LinkedList要移动指针。对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据</p>
</li>
<li><p>ArrayList和Vector的区别</p>
<p>Vector和ArrayList几乎是完全相同的，唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下，大多数的Java程序员使用ArrayList而不是Vector，因为同步完全可以由程序员自己控制。Vectro每次请求扩容其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack</p>
</li>
</ul>
<h4 id="5-Collection子接口二：Set"><a href="#5-Collection子接口二：Set" class="headerlink" title="5. Collection子接口二：Set"></a>5. Collection子接口二：Set</h4><h5 id="5-1-Set接口概述"><a href="#5-1-Set接口概述" class="headerlink" title="5.1 Set接口概述"></a>5.1 Set接口概述</h5><ul>
<li>Set接口是Collection的子接口，set接口没有提供给额外的方法</li>
<li>Set集合不允许包含相同的元素，如果试着把两个相同的元素加到同一个Set集合中，则添加操作失败</li>
<li>Set判断两个对象是否相同不是使用==运算符，而是根据equals()方法</li>
</ul>
<h5 id="5-2-Set接口方法"><a href="#5-2-Set接口方法" class="headerlink" title="5.2 Set接口方法"></a>5.2 Set接口方法</h5><h6 id="5-2-1-Set实现类之一：HashSet"><a href="#5-2-1-Set实现类之一：HashSet" class="headerlink" title="5.2.1 Set实现类之一：HashSet"></a>5.2.1 Set实现类之一：HashSet</h6><ul>
<li>HashSet是Set接口的典型实现，大多数时候使用Set集合时都使用这个实现类。</li>
<li>HashSet按Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除性能</li>
<li>HashSet具有以下特点<ul>
<li>不能保证元素排列的顺序</li>
<li>HashSet不是线程安全的</li>
<li>集合元素可以是null</li>
</ul>
</li>
<li>HashSet集合判断两个元素相等的标准：两个对象通过hashCode()方法比较相等，并且两个对象的equals()方法返回值也相等</li>
<li>对于存放在Set容器中的对象，对应的类一定要重写equals()和hasCode(Object obj)方法，以实现对象相等规则。即：”相等的对象必须有相等的散列码”</li>
<li>向HashSet中添加元素的过程：<ul>
<li>当向HashSet集合中存入一个元素时，HashSet会调用该对象的hasCode()方法来得到该对象的hashCode值，然后根据hashCode值，通过某种散列函数决定该对象在HashSet底层数组中的存储位置。（<u>这个散列函数会与底层数组的长度相计算得到在数组中的下表，并且这种散列函数计算还尽可能保证均匀存储元素，越是散列分布，该散列函数设计的越好</u></li>
<li>如果两个元素的hashCode()值相等，会再继续调用equals方法，如果equals方法结果为true，添加失败；如果结果为false，那么会保存该元素，但是该数组的位置已经有元素了，那么会通过链表的方式继续连接</li>
<li>如果有两个元素的equals()方法返回true，但他们的hashCode()返回值不相等，hashSet将会把他们存储在不同的位置，但依然可以添加成功</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210726145851.png" alt="image-20210726145841304"></li>
</ul>
</li>
</ul>
<p><strong>重写hashCode()方法的基本原则</strong></p>
<ul>
<li>在程序运行时，同一个对象多次调用hashCode()方法应该返回相同的值</li>
<li>当两个对象的equals()方法比较返回true时，这两个对象的hashCode()方法的返回值也应相等</li>
<li>对象中用作equals()方法比较的Field，都应该用来计算hashCode值</li>
</ul>
<p><strong>重写equals()方法的基本原则</strong></p>
<ul>
<li>当一个类有自己特有的“逻辑相等”概念，当改写equals()的时候，总是要改写hashCode(),根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，他们不仅仅是两个对象</li>
<li>因此，违反了“相等的对象必须具有相等的散列码”</li>
<li>结论：复写equals方法的时候一般都需要同时复写hashCode方法，通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Collection.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        set.add(<span class="number">123</span>);</span><br><span class="line">        set.add(<span class="string">&quot;xiong&quot;</span>);</span><br><span class="line">        set.add(<span class="number">2345</span>);</span><br><span class="line">        set.add(<span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        Iterator iterator = set.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果不是按照添加顺序进行输出</p>
<blockquote>
<p>2345<br>123<br>xiong<br>true</p>
</blockquote>
<p><strong>Eclipse/IDEA工具里的hashCode()的重写</strong></p>
<p>以Eclipse/IDEA为例，在自定义类中可以调用工具自动重写equals和hashCode。问题：为什么用Eclipse/IDEA复写hashCode方法，有31这个数字？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.hashCode(values);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(Object a[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object element : a)</span><br><span class="line">            result = <span class="number">31</span> * result + (element == <span class="keyword">null</span> ? <span class="number">0</span> : element.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>选择系数的收要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少。查找起来效率也会提高。（减少冲突）</li>
<li>并且31只占用5bits，相乘造成数据溢出的概率小较小</li>
<li>31可以由i*31==(i&lt;&lt;5)-1来表示，现在很多虚拟机里都有做相关优化。（提高算法效率）</li>
<li>31是一个素数，素数的作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除（减少冲突）</li>
</ul>
<h6 id="5-2-2-Set实现类之二：LinkedHashSet"><a href="#5-2-2-Set实现类之二：LinkedHashSet" class="headerlink" title="5.2.2 Set实现类之二：LinkedHashSet"></a>5.2.2 Set实现类之二：LinkedHashSet</h6><ul>
<li>LinkedHashSet是HashSet的子类</li>
<li>LinkedHashSet根据元素的hashCode值来确定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的</li>
<li>LinkedHashSet插入性能略低于HashSet，但在迭代器访问Set全部元素时有很好的性能</li>
<li>LinkedHashSet不允许集合元素重复</li>
</ul>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210726152025.png" alt="image-20210726152024176"></p>
<ul>
<li><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Collection.Set;<span class="keyword">import</span> org.junit.Test;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">import</span> java.util.LinkedHashSet;<span class="keyword">import</span> java.util.Set;<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetTest</span> </span>&#123;    <span class="meta">@Test</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;        Set set = <span class="keyword">new</span> LinkedHashSet();        set.add(<span class="number">123</span>);        set.add(<span class="string">&quot;xiong&quot;</span>);        set.add(<span class="number">2345</span>);        set.add(<span class="keyword">true</span>);        Iterator iterator = set.iterator();        <span class="keyword">while</span> (iterator.hasNext())&#123;            System.out.println(iterator.next());        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>结果按照添加顺序进行输出</p>
<blockquote>
<p>123<br>xiong<br>2345<br>true</p>
</blockquote>
<p><strong>面试题</strong>：考察存储方式：先算hashCode再进行equals()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Collection.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">&quot;xiong&quot;</span>, <span class="number">23</span>);</span><br><span class="line">        Person person2 = <span class="keyword">new</span> Person(<span class="string">&quot;zhuo&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        Set set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        set.add(person1);</span><br><span class="line">        set.add(person2);</span><br><span class="line">        person1.setName(<span class="string">&quot;Guet&quot;</span>);</span><br><span class="line">        set.remove(person1);</span><br><span class="line">        System.out.println(set);<span class="comment">//[Person&#123;name=&#x27;Guet&#x27;, age=23&#125;, Person&#123;name=&#x27;zhuo&#x27;, age=12&#125;]</span></span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="string">&quot;Guet&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        System.out.println(set);<span class="comment">//[Person&#123;name=&#x27;Guet&#x27;, age=23&#125;, Person&#123;name=&#x27;Guet&#x27;, age=23&#125;, Person&#123;name=&#x27;zhuo&#x27;, age=12&#125;]</span></span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> Person(<span class="string">&quot;xiong&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        System.out.println(set);<span class="comment">//[Person&#123;name=&#x27;Guet&#x27;, age=23&#125;, Person&#123;name=&#x27;xiong&#x27;, age=23&#125;, Person&#123;name=&#x27;Guet&#x27;, age=23&#125;, Person&#123;name=&#x27;zhuo&#x27;, age=12&#125;]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中Person类中重写了hashCode()和equal()方法</p>
<blockquote>
<p>[Person{name=’Guet’, age=23}, Person{name=’zhuo’, age=12}]<br>[Person{name=’Guet’, age=23}, Person{name=’Guet’, age=23}, Person{name=’zhuo’, age=12}]<br>[Person{name=’Guet’, age=23}, Person{name=’xiong’, age=23}, Person{name=’Guet’, age=23}, Person{name=’zhuo’, age=12}]</p>
</blockquote>
<h6 id="Set实现类之三：TreeSet"><a href="#Set实现类之三：TreeSet" class="headerlink" title="Set实现类之三：TreeSet"></a>Set实现类之三：TreeSet</h6><ul>
<li>TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。</li>
<li>TreeSet底层使用红黑树结构存储数据</li>
<li>新增的方法如下：（了解）<ul>
<li>Comparator comparator()</li>
<li>Object first()</li>
<li>Object last()</li>
<li>Object lower(Object e)</li>
<li>Object higher(Object e)</li>
<li>SortedSet subSet(fromElement, toElement)</li>
<li>SortedSet headSet(toElement)</li>
<li>SortedSet tailSet(fromElement)</li>
</ul>
</li>
<li>TreeSet两种排序方法：自然排序和定制排序。默认情况下，TreeSet采用自然排序</li>
</ul>
<p><strong>排序——自然排序</strong></p>
<ul>
<li>自然排序：TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序（默认情况）排列</li>
<li>如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口<ul>
<li>实现Comparable的类必须实现compareTo(Object obj)方法，两个对象即通过compareTo(Object obj)方法的返回值来比较大小</li>
</ul>
</li>
<li>Comparable的典型实现：<ul>
<li>BigDecimal、BigInteger以及所有的数值型对应的包装类：按他们对应的数值大小进行比较</li>
<li>Character：按字符的unicode值来进行比较</li>
<li>Boolean：true对应的包装类实例大于false对应包装类的实例</li>
<li>String：按字符串中字符的unicode值进行比较</li>
<li>Date、Time：后边的时间、日期比前面的时间、日期大</li>
</ul>
</li>
<li>向TreeSet中添加元素时，只有第一个元素无需比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较</li>
<li>因为只有相同类的两个实例才会比较大小，所以向TreeSet中添加的应该是同一个类的对象</li>
<li>对于TreeSet集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过compareTo(Object obj)方法比较返回值</li>
<li>当需要把一个对象放入TreeSet中，重写该对象对应的equals()方法时，应保证该方法与compareTo(Object obj)方法有一致的结果：如果两个对象通过equals()方法比较返回true，则通过compareTo(Object obj)方法比较应该返回0</li>
</ul>
<p><strong>排序——定制排序</strong></p>
<ul>
<li>TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序（默认情况）的方式排列元素或希望按照其他属性大小来进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来实现。需要重写compare(T o1, T o2)方法</li>
<li>利用int compare(T o1, T 02)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回负整数，表示o1小于o2</li>
<li>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet构造器</li>
<li>此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常</li>
<li>使用定制排序判断两个元素相等的标准是：通过Comparator比较返回值是否为0</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Collection.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">            先按姓名排序，当出现同名时，按照年龄大小进行排序</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;比较对象不能为空&quot;</span>);</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.name.compareTo(person.name) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -Integer.compare(<span class="keyword">this</span>.age, person.age);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Collection.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Set treeSet = <span class="keyword">new</span> TreeSet();</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">32</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Mike&quot;</span>,<span class="number">65</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Mary&quot;</span>,<span class="number">33</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>,<span class="number">33</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>,<span class="number">56</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(treeSet);</span><br><span class="line">        <span class="comment">//使用类实现的CompareTo()方法：按名字升序，年龄降序进行排列</span></span><br><span class="line">        Iterator iterator = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        定制排序：按照年龄升序，名字降序排列</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Comparator com = <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Person &amp;&amp; o2 <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">                    Person p1 = (Person) o1;</span><br><span class="line">                    Person p2 = (Person) o2;</span><br><span class="line">                    <span class="keyword">int</span> co =  Integer.compare(p1.getAge(),p2.getAge());</span><br><span class="line">                    <span class="keyword">if</span>(co == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> -p1.getName().compareTo(p2.getName());</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">return</span> co;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不匹配&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Set treeSet = <span class="keyword">new</span> TreeSet(com);</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">32</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Mike&quot;</span>,<span class="number">65</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Mary&quot;</span>,<span class="number">33</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>,<span class="number">33</span>));</span><br><span class="line">        treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>,<span class="number">56</span>));</span><br><span class="line"></span><br><span class="line">        Iterator iterator = treeSet.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-Map接口"><a href="#6-Map接口" class="headerlink" title="6. Map接口"></a>6. Map接口</h4><p><strong>Map接口继承树</strong></p>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210726210625.png" alt="image-20210726210624429" style="zoom:80%;" />

<h5 id="6-1-Map接口概述"><a href="#6-1-Map接口概述" class="headerlink" title="6.1 Map接口概述"></a>6.1 Map接口概述</h5><ul>
<li>Map与Collection并列存在。用于保存具有映射关系的数据：key-value</li>
<li>Map中的key和value都可以是任何引用类型的数据</li>
<li>Map里的key用Set来存放，不允许重复，即同一个Map对象所对应的类，需重写hashCOde()和equals()方法</li>
<li>常用Sting类作为Map的”键”</li>
<li>key和value之间存在单向一对一关系，即能通过指定的key总能找到唯一的、确定的value</li>
<li>Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是Map接口使用频率最高的实现类</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210726211324.png" alt="image-20210726211323587" style="zoom:80%;" />

</li>
</ul>
<h5 id="6-2-Map接口：常用方法"><a href="#6-2-Map接口：常用方法" class="headerlink" title="6.2 Map接口：常用方法"></a>6.2 Map接口：常用方法</h5><ul>
<li>添加、删除、修改操作<ul>
<li>Object put(Object key, Object value)：将指定key-value添加到（或修改）当前那map对象中</li>
<li>void putAll(Map m)：将m中的所有key-value对存放到当前map中</li>
<li>Object remove(Object key)：移除指定的key的key-value对，并返回value</li>
<li>void clear()：清空当前map中的所有数据</li>
</ul>
</li>
<li>元素查询的操作<ul>
<li>Object get(Object key)：获取指定key对应的value</li>
<li>boolean containsKey(Object key)：是否包含指定的key</li>
<li>boolean containsValue(Object value)：是否包含指定的value</li>
<li>int size()：返回map中key-value对的个数</li>
<li>boolean isEmpty()：判断当前的Map是否为空</li>
<li>boolean equals(Object obj)：判断当前map和参数对象obj是否相等</li>
</ul>
</li>
<li>元视图操作的方法<ul>
<li>Set keySet()：返回所有key构成的Set集合</li>
<li>Collection values()：返回所有value构成的Collection集合</li>
<li>Set entrySet()：返回所有key-value对所构成的Set集合</li>
</ul>
</li>
</ul>
<h5 id="6-3-Map实现类之一：HashMap"><a href="#6-3-Map实现类之一：HashMap" class="headerlink" title="6.3 Map实现类之一：HashMap"></a>6.3 Map实现类之一：HashMap</h5><ul>
<li>HashMap是Map接口使用频率最高的实现类</li>
<li>允许使用null键和null值，与HashSet一样，不保证映射的顺序</li>
<li>所有的key构成的集合是Set：无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode()</li>
<li>一个key-value构成一个entry</li>
<li>所有的entry构成的集合是Set：无序的、不可重复的</li>
<li>HashMap判断两个key相等的标准是：两个key通过equals()方法返回true,hashCode值也相等</li>
<li>HashMap判断两个value相等的标准是：两个value通过equals()方法返回true</li>
</ul>
<h6 id="6-3-1-HashMap的存储结构"><a href="#6-3-1-HashMap的存储结构" class="headerlink" title="6.3.1 HashMap的存储结构"></a>6.3.1 HashMap的存储结构</h6><p>JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法)</p>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210726213051.png" alt="image-20210726213049926" style="zoom:80%;" />

<p>JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。</p>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210726213132.png" alt="image-20210726213131468" style="zoom:80%;" />

<h6 id="6-3-2-HashMap源码中的重要常量"><a href="#6-3-2-HashMap源码中的重要常量" class="headerlink" title="6.3.2 HashMap源码中的重要常量"></a>6.3.2 HashMap源码中的重要常量</h6><p>DEFAULT_INITIAL_CAPACITY：HashMap的默认容量，16</p>
<p>MAXMUN_CAPACITY：HashMap的最大支持容量，2^30</p>
<p>DEFAULT_LOAD_FACTOR：HashMap的默认加载因子</p>
<p>TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树</p>
<p>UNTREEIFY_THRESHOLD：Bucket中红黑树存储的Node小于该默认值，转化为链表</p>
<p>MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量。（当桶中Node的 数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行 resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4 倍。）</p>
<p>table：存储元素的数组，总是2的n次幂 </p>
<p>entrySet：存储具体元素的集 </p>
<p>size：HashMap中存储的键值对的数量 </p>
<p>modCount：HashMap扩容和结构改变的次数。 </p>
<p>threshold：扩容的临界值，=容量*填充因子 </p>
<p>loadFactor：填充因子</p>
<h6 id="6-3-3-HashMap的存储结构：JDK-1-8之前"><a href="#6-3-3-HashMap的存储结构：JDK-1-8之前" class="headerlink" title="6.3.3 HashMap的存储结构：JDK 1.8之前"></a>6.3.3 HashMap的存储结构：JDK 1.8之前</h6><ul>
<li>HashMap的内部存储结构其实是数组和链表的结合。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组红可以存放元素的位置我们称为”桶“(bucket)，每个bucket都有自己的索引，系统更可以更具索引快速的查找bucket中的元素</li>
<li>每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head</li>
<li>添加元素的过程<br>向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据 key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数 组中要存储的位置i。如果位置i上没有元素，则entry1直接添加成功。如果位置i上 已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次 比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。如果 hash值不同，继续比较二者是否equals。如果返回值为true，则使用entry1的value 去替换equals为true的entry的value。如果遍历一遍以后，发现所有的equals返回都 为false,则entry1仍可添加成功。entry1指向原有的entry元素。</li>
</ul>
<p><strong>HashMap的扩容</strong></p>
<p>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的 长度是固定的。所以为了提高查询的效率，就要对HashMap的数组进行扩容，而在 HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算 其在新数组中的位置，并放进去，这就是resize。</p>
<p><strong>那么HashMap什么时候进行扩容呢？</strong></p>
<p>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数 size)* loadFactor 时 ， 就 会 进 行 数 组 扩 容 ， loadFactor 的默认 值 (DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况 下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数 超过16* 0.75=12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把 数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置， 而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数， 那么预设元素的个数能够有效的提高HashMap的性能</p>
<h6 id="6-3-4-HashMap的存储结构：JDK-1-8"><a href="#6-3-4-HashMap的存储结构：JDK-1-8" class="headerlink" title="6.3.4 HashMap的存储结构：JDK 1.8"></a>6.3.4 HashMap的存储结构：JDK 1.8</h6><ul>
<li>HashMap的内部存储结构其实是数组+链表+树的结合。当实例化一个 HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系 时，系统会创建一个长度为initialCapacity的Node数组，这个长度在哈希表 中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为 “桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查 找bucket中的元素。</li>
<li>每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带 一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能 生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象 可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个 TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。</li>
</ul>
<p><strong>那么HashMap什么时候进行扩容和树形化呢？</strong></p>
<p>​        当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数 size)* loadFactor 时 ， 就会进行数组扩容 ， loadFactor 的默认 值 (DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认 情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中 元素个数超过16* 0.75=12（这个值就是代码中的threshold值，也叫做临界值） 的时候，就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元 素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。 当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有 达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成 树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后， 下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。</p>
<p><strong>关于映射关系的key是否可以修改？answer：不要修改</strong></p>
<p>​        映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算 每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关 系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。</p>
<h6 id="6-3-5-总结：JDK1-8相较于之前的变化："><a href="#6-3-5-总结：JDK1-8相较于之前的变化：" class="headerlink" title="6.3.5 总结：JDK1.8相较于之前的变化："></a>6.3.5 总结：JDK1.8相较于之前的变化：</h6><p>1.HashMap map = new HashMap();//默认情况下，先不创建长度为16的数组 </p>
<p>2.当首次调用map.put()时，再创建长度为16的数组 </p>
<p>3.数组为Node类型，在jdk7中称为Entry类型 </p>
<p>4.形成链表结构时，新添加的key-value对在链表的尾部（七上八下）</p>
<p>5.当数组指定索引位置的链表长度&gt;8时，且map中的数组的长度&gt; 64时，此索引位置 上的所有key-value对使用红黑树进行存储</p>
<p><strong>面试题：负载因子值的大小，对HashMap有什么影响</strong></p>
<ul>
<li>负载因子的大小决定了HashMap的数据密度。</li>
<li>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长, 造成查询或插入时的比较次数增多，性能会下降。</li>
<li>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间。</li>
<li>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此 时平均检索长度接近于常数。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Map提供的方法进行测试</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map map1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map map2 = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="comment">//添加：put(Obejct key, Object value) putAll(Map m)</span></span><br><span class="line">        map1.put(<span class="string">&quot;xiong&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        map1.put(<span class="string">&quot;zhuo&quot;</span>, <span class="number">24</span>);</span><br><span class="line">        map2.putAll(map1);</span><br><span class="line">        System.out.println(map1);<span class="comment">//&#123;zhuo=24, xiong=23&#125;</span></span><br><span class="line">        System.out.println(map2);<span class="comment">//&#123;zhuo=24, xiong=23&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除：remove(Object key) remove(Object key, Object value)</span></span><br><span class="line">        System.out.println(map1.remove(<span class="string">&quot;xiong&quot;</span>));<span class="comment">//23</span></span><br><span class="line">        System.out.println(map1.remove(<span class="string">&quot;zhuo&quot;</span>, <span class="number">24</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(map1);<span class="comment">//&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//修改：put(Object key,Object value)</span></span><br><span class="line">        System.out.println(map2.put(<span class="string">&quot;xiong&quot;</span>, <span class="number">22</span>));<span class="comment">//23</span></span><br><span class="line">        System.out.println(map2);<span class="comment">//&#123;zhuo=24, xiong=22&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//清空：clear()</span></span><br><span class="line">        System.out.println(map1.put(<span class="string">&quot;Guet&quot;</span>, <span class="string">&quot;花江&quot;</span>));<span class="comment">//null</span></span><br><span class="line">        System.out.println(map1.put(<span class="string">&quot;Guet&quot;</span>, <span class="string">&quot;花江&quot;</span>));<span class="comment">//花江</span></span><br><span class="line">        map1.clear();</span><br><span class="line">        System.out.println(map1);<span class="comment">//&#123;&#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//元素查询操作</span></span><br><span class="line">        System.out.println(map2.get(<span class="string">&quot;xiong&quot;</span>));<span class="comment">//22</span></span><br><span class="line">        System.out.println(map2.containsKey(<span class="string">&quot;xiong&quot;</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(map2.containsValue(<span class="number">22</span>));<span class="comment">//true</span></span><br><span class="line">        System.out.println(map2.size());<span class="comment">//2</span></span><br><span class="line">        System.out.println(map2.isEmpty());<span class="comment">//false</span></span><br><span class="line">        System.out.println(map2.equals(map1));<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//元视图操作</span></span><br><span class="line">        Set set = map2.keySet();</span><br><span class="line">        System.out.println(set);<span class="comment">//[zhuo, xiong]</span></span><br><span class="line">        Collection coll = map2.values();</span><br><span class="line">        System.out.println(coll);<span class="comment">//[24, 22]</span></span><br><span class="line">        Set set1 = map2.entrySet();</span><br><span class="line">        System.out.println(set1);<span class="comment">//[zhuo=24, xiong=22]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="comment">//遍历所有的key集</span></span><br><span class="line">        Set set2 = map2.keySet();</span><br><span class="line">        Iterator iterator = set2.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());<span class="comment">//zhuo  xiong</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历所有的value集</span></span><br><span class="line">        Collection collection = map2.values();</span><br><span class="line">        iterator = collection.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());<span class="comment">//24 22</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历所有的key-value</span></span><br><span class="line">        <span class="comment">//方式一：entrySet()</span></span><br><span class="line">        Set set3 = map2.entrySet();</span><br><span class="line">        iterator = set3.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object obj = iterator.next();</span><br><span class="line">            <span class="comment">//entrySet集合中的元素都是entry</span></span><br><span class="line">            Map.Entry entry = (Map.Entry)obj;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;----&gt;&quot;</span> + entry.getValue());</span><br><span class="line">            <span class="comment">//zhuo----&gt;24 xiong----&gt;22</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//方式二；</span></span><br><span class="line">        Set set4 = map2.keySet();</span><br><span class="line">        iterator = set4.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            Object key = iterator.next();</span><br><span class="line">            Object value = map2.get(key);</span><br><span class="line">            System.out.println(key + <span class="string">&quot;---&gt;&quot;</span> + value);<span class="comment">//zhuo---&gt;24 xiong---&gt;22</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="6-4-Map实现类之二：LinkedHashMap"><a href="#6-4-Map实现类之二：LinkedHashMap" class="headerlink" title="6.4 Map实现类之二：LinkedHashMap"></a>6.4 Map实现类之二：LinkedHashMap</h5><ul>
<li><p>LinkedHashMap是HashMap的子类</p>
</li>
<li><p>在HashMap存储结构的基础上，使用了一对双向链表来记录添加的顺序</p>
</li>
<li><p>与LinkedHashSet类似，LinkedHashMap可以维护Map的迭代顺序：迭代顺序与Key-Value对的插入顺序一致</p>
</li>
<li><p>HashMap中的内部类：Node</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">	<span class="keyword">final</span> K key;</span><br><span class="line">	V value;</span><br><span class="line">	Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinkedHashMap中的内部类：Entry</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">	Entry&lt;K,V&gt; before, after;</span><br><span class="line">	Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">	<span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">        map.put(<span class="string">&quot;zhuo&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        map.put(<span class="string">&quot;xiong&quot;</span>,<span class="number">24</span>);</span><br><span class="line">        map.put(<span class="string">&quot;熊&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        System.out.println(map);<span class="comment">//&#123;zhuo=23, xiong=24, 熊=23&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h6 id="6-4-1-Map实现类之三：TreeMap"><a href="#6-4-1-Map实现类之三：TreeMap" class="headerlink" title="6.4.1 Map实现类之三：TreeMap"></a>6.4.1 Map实现类之三：TreeMap</h6><ul>
<li>TreeMap存储Key-Value对时，需要根据key-value对进行排序。TreeMap可以保证所有的Key-Value对处于有序状态</li>
<li>TreeSet底层使用红黑树结构存储数据</li>
<li>TreeMap的Key排序：<ul>
<li>自然排序：TreeMap的所有Key必须实现Comparable接口，而且所有的Key应该时同一个类的对象，否则将会抛出ClassCastException</li>
<li>定制排序： 创建TreeMap时，传入一个Comparator对象，该对象负责对TreeMap中的所有key进行排序。此时不需要Map的Key实现Comparable接口</li>
</ul>
</li>
<li>TreeMap判断两个key相等的标准：两个key通过compareTo()方法或者compare()方法返回0</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map treeMap = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>),<span class="number">98</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>),<span class="number">89</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>,<span class="number">20</span>),<span class="number">76</span>);</span><br><span class="line">        treeMap.put(<span class="keyword">new</span> Person(<span class="string">&quot;Rose&quot;</span>,<span class="number">18</span>),<span class="number">100</span>);</span><br><span class="line">        System.out.println(treeMap);</span><br><span class="line">        <span class="comment">//&#123;Person&#123;name=&#x27;Jack&#x27;, age=20&#125;=76, Person&#123;name=&#x27;Jerry&#x27;, age=32&#125;=89, Person&#123;name=&#x27;Rose&#x27;, age=18&#125;=100, Person&#123;name=&#x27;Tom&#x27;, age=23&#125;=98&#125;</span></span><br><span class="line"></span><br><span class="line">        Comparator comparable = <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 == o2) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(o1 == <span class="keyword">null</span> || o2 == <span class="keyword">null</span> || o1.getClass() != o2.getClass()) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;二者类型不匹配&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Person &amp;&amp; o2 <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">                    Person p1 = (Person) o1;</span><br><span class="line">                    Person p2 = (Person) o2;</span><br><span class="line">                    <span class="keyword">int</span> com = p1.getName().compareTo(p2.getName());</span><br><span class="line">                    <span class="keyword">if</span>(com != <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> -com;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">return</span> -Integer.compare(p1.getAge(),p2.getAge());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入参数类型有误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Map map = <span class="keyword">new</span> TreeMap(comparable);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">23</span>),<span class="number">98</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>),<span class="number">89</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>,<span class="number">20</span>),<span class="number">76</span>);</span><br><span class="line">        map.put(<span class="keyword">new</span> Person(<span class="string">&quot;Rose&quot;</span>,<span class="number">18</span>),<span class="number">100</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">//&#123;Person&#123;name=&#x27;Tom&#x27;, age=23&#125;=98, Person&#123;name=&#x27;Rose&#x27;, age=18&#125;=100, Person&#123;name=&#x27;Jerry&#x27;, age=32&#125;=89, Person&#123;name=&#x27;Jack&#x27;, age=20&#125;=76&#125;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不同数据类型无法比较&quot;</span>);</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">int</span> com = name.compareTo(person.name);</span><br><span class="line">        <span class="keyword">if</span>(com != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> com;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> Integer.compare(age, person.age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp; Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h6 id="6-4-2-Map实现类之四：Hashtable"><a href="#6-4-2-Map实现类之四：Hashtable" class="headerlink" title="6.4.2 Map实现类之四：Hashtable"></a>6.4.2 Map实现类之四：Hashtable</h6><ul>
<li>Hashtable是一个古老的Map实现类，JDK1.0就提供了。不同于HashMap，Hashtable时线程安全的</li>
<li>Hatable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用</li>
<li>与HashMap不同，Hashtable不允许使用null作为key和value</li>
<li>与HashMap一样，Hashtable也不能保证其中Key-Value的顺序</li>
<li>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Hashtable;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashtableTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Map Hashtable = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        Hashtable.put(<span class="string">&quot;xiong&quot;</span>,<span class="string">&quot;tianmen&quot;</span>);</span><br><span class="line">        Hashtable.put(<span class="string">&quot;zhuo&quot;</span>,<span class="string">&quot;guangxi&quot;</span>);</span><br><span class="line">        Hashtable.put(<span class="string">&quot;guet&quot;</span>,<span class="string">&quot;huajaing&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Hashtable);<span class="comment">//&#123;zhuo=guangxi, xiong=tianmen, guet=huajaing&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="6-4-3-Map实现类之五：Properties"><a href="#6-4-3-Map实现类之五：Properties" class="headerlink" title="6.4.3 Map实现类之五：Properties"></a>6.4.3 Map实现类之五：Properties</h6><ul>
<li>Properties类是Hashtable的子类，该对象用于处理属性文件</li>
<li>由于属性文件里的key、value都是字符串类型，所以Properties里的key和value都是字符串类型</li>
<li>存取数据时，建议使用setProperty(String key, String value)方法和getProperty(String key)方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Properties:常用来处理配置文件。key和value都是String类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;C:\\Users\\xiong\\IdeaProjects\\out\\jdbc.properties&quot;</span>);</span><br><span class="line"><span class="comment">//            fis = new FileInputStream(&quot;jdbc.properties&quot;);</span></span><br><span class="line">            pros.load(fis);<span class="comment">//加载流对应的文件</span></span><br><span class="line"></span><br><span class="line">            String name = pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            String password = pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, password = &quot;</span> + password);<span class="comment">//name = 熊卓, password = abc123</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fis != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210728112559.png" alt="image-20210728112549093"></p>
<h4 id="7-Collections工具类"><a href="#7-Collections工具类" class="headerlink" title="7. Collections工具类"></a>7. Collections工具类</h4><ul>
<li>Collection是操作Set、List和Map等集合的工具类</li>
<li>Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作。还提供了对集合对象设置不可变、对集合对象实现同步控制的方法</li>
<li>排序操作：（均为static方法）<ul>
<li>reverse(List)：反转List中元素的顺序</li>
<li>shuffle(List)：对List集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定List集合元素按升序排序</li>
<li>sort(LIst, Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序</li>
<li>swap(List, int, int)：将指定list集合中的i处元素和j处元素进行交换</li>
</ul>
</li>
</ul>
<h5 id="7-1-Collections常用方法"><a href="#7-1-Collections常用方法" class="headerlink" title="7.1 Collections常用方法"></a>7.1 Collections常用方法</h5><p><strong>查找、替换</strong></p>
<ul>
<li>Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</li>
<li>Object max(Collection, Comparator)：根据Comparator指定的顺序，返回给定集合中的最大元素</li>
<li>Object min(Collection)</li>
<li>Object min(Collection, Comparator)</li>
<li>int frequency(Collection, Object)：返回指定集合中指定元素的出现次数</li>
<li>void copy(List dest, List src)：将src中的内容复制到dest中</li>
<li>boolean replaceAll(List list, Object oldVal, Object newVal)：使用新值替换List对象的所有旧值</li>
</ul>
<p><strong>同步控制</strong></p>
<p>Collection类中提供了多个synchronizedXxx()方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</p>
<table>
<thead>
<tr>
<th>方法修饰符和返回值</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>static <T> Collection <T></td>
<td>synchronizedCollection(Collection<T> c) <br />Return a synchronized(thread-safe) collection backed by the spacified collection</td>
</tr>
<tr>
<td>static <T> List <T></td>
<td>synchronizedList(List<T> list)<br />Return a synchronized(thread-safe)list backed by the specified list</td>
</tr>
<tr>
<td>static &lt;K,V&gt; Map &lt;K,V&gt;</td>
<td>synchronizedMap(Map&lt;K,V&gt; m)<br />Return a synchronized(thread-safe) map backed by the specified map</td>
</tr>
<tr>
<td>static <T> Set <T></td>
<td>synchronizedSet(Set<T> s)<br />Return a synchronized(thread-safe) set backed by the specified set</td>
</tr>
<tr>
<td>static &lt;K,V&gt; SotredMap &lt;K,V&gt;</td>
<td>synchronizedSortedMap(SortedMap &lt;K,V&gt; m) <br />Return a synchronized(thread-safe)sorted map backed by the specified sorted map</td>
</tr>
<tr>
<td>static<T> SortedSet<T></td>
<td>synchronizedSortedSet(SortedSet<T> s)<br />Return a synchronized(thread-safe) sorted set backed by the specified sorted set</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionsTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="number">123</span>);</span><br><span class="line">        list.add(<span class="number">32</span>);</span><br><span class="line">        list.add(<span class="number">12</span>);</span><br><span class="line">        list.add(<span class="number">45</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[123, 32, 12, 45]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="comment">//反转</span></span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        System.out.println(list);<span class="comment">//[45, 12, 32, 123]</span></span><br><span class="line">        <span class="comment">//随机排序</span></span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        System.out.println(list);<span class="comment">//[12, 45, 123, 32]</span></span><br><span class="line">        <span class="comment">//自然顺序升序</span></span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        System.out.println(list);<span class="comment">//[12, 32, 45, 123]</span></span><br><span class="line">        <span class="comment">//按脚标交换元素</span></span><br><span class="line">        Collections.swap(list,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">        System.out.println(list);<span class="comment">//[45, 32, 12, 123]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找、替换</span></span><br><span class="line">        System.out.println(Collections.max(list));<span class="comment">//123</span></span><br><span class="line">        System.out.println(Collections.min(list));<span class="comment">//12</span></span><br><span class="line">        System.out.println(Collections.frequency(list, <span class="number">123</span>));<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//拷贝</span></span><br><span class="line">        <span class="comment">//报异常：IndexOutOfBoundsException(&quot;Source does not fit in dest&quot;)</span></span><br><span class="line"><span class="comment">//        List dest = new ArrayList();</span></span><br><span class="line"><span class="comment">//        Collections.copy(dest,list);</span></span><br><span class="line">        <span class="comment">//正确的：</span></span><br><span class="line">        List dest = Arrays.asList(<span class="keyword">new</span> Object[list.size()]);</span><br><span class="line">        Collections.copy(dest,list);</span><br><span class="line">        System.out.println(dest);<span class="comment">//[45, 32, 12, 123]</span></span><br><span class="line">        Collections.replaceAll(dest,<span class="number">123</span>,<span class="number">777</span>);</span><br><span class="line">        System.out.println(dest);<span class="comment">//[45, 32, 12, 777]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使得线程安全</span></span><br><span class="line">        List listSafe = Collections.synchronizedList(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>补充</strong></p>
<ul>
<li>Enumeration接口时Iterator迭代器的“古老版本”</li>
<li></li>
</ul>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>hasMoreElements()<br />Tests if this enumeration contains more elements</td>
</tr>
<tr>
<td>E</td>
<td>nextElement()<br />Return the next element of this enumeration if this enumeration object has at least one more element to provide</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enumeration stringEnum = <span class="keyword">new</span> StringTokenizer(<span class="string">&quot;a-b*c-d-e-g&quot;</span>, <span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(stringEnum.hasMoreElements())&#123;</span><br><span class="line">Object obj = stringEnum.nextElement();</span><br><span class="line">System.out.println(obj); </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>16-Java8的其他新特性</title>
    <url>/2021/09/17/16%E2%80%94Java8%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="16—Java8的其他新特性"><a href="#16—Java8的其他新特性" class="headerlink" title="16—Java8的其他新特性"></a>16—Java8的其他新特性</h3><p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108071505555.png" alt="16-Java8新特性"></p>
<h4 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1. Lambda表达式"></a>1. Lambda表达式</h4><p>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java语言表达能力得到了提升</p>
<ul>
<li><p>从匿名类到Lambda的转换举例1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">Runnable r1 = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Lambda表达式</span></span><br><span class="line">Runnable r1 = () -&gt; System.out.println(<span class="string">&quot;hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>从匿名类到Lambda的转换举例2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原来使用匿名内部类作为参数传递</span></span><br><span class="line">TreeSet&lt;String&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(o1.length(),o2.length())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Lambda 表达式作为参数传递</span></span><br><span class="line">TreeSet&lt;String&gt; ts2 = <span class="keyword">new</span> TreeSet&lt;&gt;(</span><br><span class="line">    (o1,o2) -&gt; Integer.compare(o1.length(), o2.length())</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Lambda表达式：在Java8语言中引入的一种新的语法元素和操作符。这个操作符为“-&gt;”，该操作符被称为Lambda操作符或箭头操作符。他将Lambda分为两个部分：</p>
<p>左侧：指定了Lambda表达式需要的参数列表</p>
<p>右侧：指定了Lambda体，是抽象方法的实现逻辑，也即Lambda表达式要执行的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//语法格式一：无参，无返回值</span></span><br><span class="line">Runnable r1= ()-&gt;&#123;System.out.println(<span class="string">&quot;Hello Lambda&quot;</span>);&#125;;</span><br><span class="line"><span class="comment">//语法格式二：Lambda需要一个参数，但是没有返回值</span></span><br><span class="line">Consumer&lt;String&gt; con = (String str) -&gt; &#123;System.out.println(str);&#125;;</span><br><span class="line"><span class="comment">//语法格式三：数据类型可以省略，因为可以由编译器推断得出，称为“类型推断”</span></span><br><span class="line">Consumer&lt;String&gt; con = (str) -&gt; &#123;System.out.println(str);&#125;;</span><br><span class="line"><span class="comment">//语法格式四：Lambda只需要一个参数时，参数的小括号可以省略</span></span><br><span class="line">Consumer&lt;String&gt; con = str -&gt; &#123;System.out.println(str);&#125;;</span><br><span class="line"><span class="comment">//语法格式五：Lambda需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class="line">Comparator&lt;Integer&gt; com = (x,y) -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;实现函数式接口方法&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(x,y);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//语法格式六：当Lambda体只有一条语句时，return与大括号若有，都可以省略</span></span><br><span class="line">Comparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(x,y);</span><br></pre></td></tr></table></figure>

<p><strong>类型推断</strong></p>
<p>上述Lambda表达式中的参数类型都是由编译器推断得出的。Lambda表达式中无需指定类型，程序依然可以编译，这是因为javac根据程序的上下文，在后台推断出了参数的类型。Lambda表达式的类型依赖于上下文的环境，是由编译器推断出来的。</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108071535176.png" alt="image-20210807153542725"></p>
<h5 id="1-1-示例"><a href="#1-1-示例" class="headerlink" title="1.1 示例"></a>1.1 示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Lambda表达式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Runnable r1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我在花江学计算机&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        r1.run();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Runnable r2 = () -&gt; System.out.println(<span class="string">&quot;I love GUET&quot;</span>);</span><br><span class="line">        r2.run();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> compare1 = com1.compare(<span class="number">12</span>,<span class="number">21</span>);</span><br><span class="line">        System.out.println(compare1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|++++++++++++++++++++++++++|&quot;</span>);</span><br><span class="line">        <span class="comment">//Lambda表达式写法</span></span><br><span class="line">        Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; Integer.compare(o1,o2);</span><br><span class="line">        <span class="keyword">int</span> compare2 = com2.compare(<span class="number">12</span>,<span class="number">21</span>);</span><br><span class="line">        System.out.println(compare2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|++++++++++++++++++++++++++|&quot;</span>);</span><br><span class="line">        <span class="comment">//方法引用</span></span><br><span class="line">        Comparator&lt;Integer&gt; com3 = Integer :: compare;</span><br><span class="line">        <span class="keyword">int</span> compare3 = com3.compare(<span class="number">12</span>,<span class="number">21</span>);</span><br><span class="line">        System.out.println(compare3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Lambda表达式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Lambda表达式的使用</span></span><br><span class="line"><span class="comment">1.举例：(o1, o2) -&gt; Integer.compare(o1, o2);</span></span><br><span class="line"><span class="comment">2.格式：</span></span><br><span class="line"><span class="comment">    -：lambda操作符</span></span><br><span class="line"><span class="comment">    -：左边：lambda形参列表（其实就是接口中的抽象方法的新参列表）</span></span><br><span class="line"><span class="comment">    -：右边：lambda体（其实就是重写抽象方法的方法体）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.Lambda表达式的使用：（分为六种情况）</span></span><br><span class="line"><span class="comment">总结：</span></span><br><span class="line"><span class="comment">-：左边：lambda形参列表的参数类型可以省略（类型推断）；如果lambda形参列表只有一个参数，其中一堆()也可以省略</span></span><br><span class="line"><span class="comment">-：右边：lambda体应该使用一对&#123;&#125;包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对&#123;&#125;和return关键字</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4.Lambda表达式的本质：作为函数式接口的实例</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5.如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上使用@FunctionalInterface注解。</span></span><br><span class="line"><span class="comment">这样就可以做检查它是否是一个函数式接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6.所以以前使用匿名实现类表示的现在都可以用Lambda表达式来写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambadTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式一：无参无返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Runnable r1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我在金鸡岭写代码&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        r1.run();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Runnable r2 = () -&gt; &#123;System.out.println(<span class="string">&quot;我在金鸡岭写代码&quot;</span>);&#125;;</span><br><span class="line">        r2.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式二：Lambda需要一个参数，但是没有返回值 正常写法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; con = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;你在哪儿&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con2 = (String s) -&gt;&#123;System.out.println(s); &#125; ;</span><br><span class="line">        con2.accept(<span class="string">&quot;我在这儿&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式三：Lambda需要一个参数，但是没有返回值 数据类型可以省略，因为可以由编译器推断得出，称为”类型推断“</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; con = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;你在哪儿&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con2 = (s) -&gt;&#123;System.out.println(s); &#125; ;</span><br><span class="line">        con2.accept(<span class="string">&quot;我在这儿&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式四：Lambda需要一个参数，但是没有返回值 数据类型可以省略，因为可以由编译器推断得出，称为”类型推断“，参数的小括号也可以省略</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; con = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;你在哪儿&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con2 = s -&gt;&#123;System.out.println(s); &#125; ;</span><br><span class="line">        con2.accept(<span class="string">&quot;我在这儿&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式五：Lambda需要一个参数，数据类型可以省略，因为可以由编译器推断得出，称为”类型推断“，参数的小括号也可以省略</span></span><br><span class="line">    <span class="comment">//但是没有返回值 只有一条语句，方法体的&#123;&#125;也可以省略</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; con = <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;你在哪儿&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer&lt;String&gt; con2 = s -&gt;System.out.println(s);</span><br><span class="line">        con2.accept(<span class="string">&quot;我在这儿&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式五：:Lambda需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                System.out.println(o1);</span><br><span class="line">                System.out.println(o2);</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(com1.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(o2);</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(com2.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式六：当Lambda体只有一条语句时，return(若有)与大括号都可以省略；</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; Integer.compare(o1,o2);</span><br><span class="line">        System.out.println(com1.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Lambda表达式;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Java内置的四大核心函数式接口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">消费型接口 Consumer&lt;T&gt;       void accept(T t)</span></span><br><span class="line"><span class="comment">供给型接口 Supplier&lt;T&gt;       T get()</span></span><br><span class="line"><span class="comment">函数型接口 Function&lt;T,R&gt;     R apply(T t)</span></span><br><span class="line"><span class="comment">断定型接口 Predicate&lt;T&gt;      boolean test(T t)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        relax(<span class="string">&quot;打篮球&quot;</span>, <span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;学习太累了，&quot;</span> + s + <span class="string">&quot;放松一下&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        relax(<span class="string">&quot;看Bilibili&quot;</span>,method -&gt; System.out.println(<span class="string">&quot;学习太累了，&quot;</span>+method+<span class="string">&quot;放松一下&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">relax</span><span class="params">(String method, Consumer&lt;String&gt; con)</span></span>&#123;</span><br><span class="line">        con.accept(method);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;南京&quot;</span>,<span class="string">&quot;天津&quot;</span>,<span class="string">&quot;东京&quot;</span>,<span class="string">&quot;西京&quot;</span>,<span class="string">&quot;普京&quot;</span>);</span><br><span class="line">        List&lt;String&gt; filterStrs = filterString(list, <span class="keyword">new</span> Predicate&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s.contains(<span class="string">&quot;京&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(filterStrs);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; filterStr1 = filterString(list,s -&gt; s.contains(<span class="string">&quot;京&quot;</span>));</span><br><span class="line">        System.out.println(filterStr1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt;  <span class="title">filterString</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; predicate)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; filterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(predicate.test(s))&#123;</span><br><span class="line">                filterList.add(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> filterList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="2-函数式-Functional-接口"><a href="#2-函数式-Functional-接口" class="headerlink" title="2. 函数式(Functional)接口"></a>2. 函数式(Functional)接口</h4><h5 id="2-1-什么是函数式-Funcional-接口"><a href="#2-1-什么是函数式-Funcional-接口" class="headerlink" title="2.1 什么是函数式(Funcional)接口"></a>2.1 什么是函数式(Funcional)接口</h5><ul>
<li>只包含一个抽象方法的接口，称为函数式接口</li>
<li>你可以通过Lambda表达式来创建该接口的对象。（若Lambda表达式抛出一个受检异常（即：非运行时异常），那么该异常需要在目标接口的抽象方法上进行声明）</li>
<li>我们可以在一个接口上使用@FuncionalInterface注解，这样做可以检查它是否是一个函数式接口。同时javadoc也会包含一条声明，说明这个接口是一个函数是接口</li>
<li>在java.util.function包下定义了Java8的丰富的函数式接口</li>
</ul>
<h5 id="2-2-如何理解函数式接口"><a href="#2-2-如何理解函数式接口" class="headerlink" title="2.2 如何理解函数式接口"></a>2.2 如何理解函数式接口</h5><ul>
<li>Java从诞生日起就是一直倡导“一切皆对象”，在Java里面面向对象(OOP) 编程是一切。但是随着python、scala等语言的兴起和新技术的挑战，Java不得不做出调整以便支持更加广泛的技术要求，也即java不但可以支持OOP还 可以支持OOF（面向函数编程）</li>
<li>在函数式编程语言当中，函数被当做一等公民对待。在将函数作为一等公民的编程语言中，Lambda表达式的类型是函数。但是在Java8中，有所不同。在 Java8中，Lambda表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——函数式接口</li>
<li>简单的说，在Java8中，Lambda表达式就是一个函数式接口的实例。这就是 Lambda表达式和函数式接口的关系。也就是说，只要一个对象是函数式接口 的实例，那么该对象就可以用Lambda表达式来表示</li>
<li>所以以前用匿名实现类表示的现在都可以用Lambda表达式来写</li>
</ul>
<h5 id="2-3-函数式接口举例"><a href="#2-3-函数式接口举例" class="headerlink" title="2.3 函数式接口举例"></a>2.3 函数式接口举例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &#123;<span class="doctag">@code</span> Runnable&#125; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> run&#125; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &#123;<span class="doctag">@code</span> run&#125; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-4-自定义函数式接口"><a href="#2-4-自定义函数式接口" class="headerlink" title="2.4 自定义函数式接口"></a>2.4 自定义函数式接口</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FuncitonalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mynumber</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数式接口中使用泛型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunc</span>&lt;<span class="title">t</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-作为参数传递Lambda表达式"><a href="#2-5-作为参数传递Lambda表达式" class="headerlink" title="2.5 作为参数传递Lambda表达式"></a>2.5 作为参数传递Lambda表达式</h5><p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108071557432.png" alt="image-20210807155726164"></p>
<h5 id="2-6-Java内置四大核心函数式接口"><a href="#2-6-Java内置四大核心函数式接口" class="headerlink" title="2.6 Java内置四大核心函数式接口"></a>2.6 Java内置四大核心函数式接口</h5><table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer<T> 消费型接口</td>
<td>T</td>
<td>void</td>
<td>对类型为T的对象应用操作，包含方法：void accept(T t)</td>
</tr>
<tr>
<td>Supplier<T> 供给型接口</td>
<td>无</td>
<td>T</td>
<td>返回类型为T的对象，包含方法：T get()</td>
</tr>
<tr>
<td>Function&lt;T,R&gt; 函数类型接口</td>
<td>T</td>
<td>R</td>
<td>对类型为T的对象应用操作，并返回结果。结果是R类型的对象。包含方法：R apply(T t)</td>
</tr>
<tr>
<td>Predicate<T> 断定型接口</td>
<td>T</td>
<td>boolean</td>
<td>确定类型为T的对象是否满足某约束，并返回boolean值。包含方法：boolean test(T t)</td>
</tr>
</tbody></table>
<h5 id="2-7-其他接口"><a href="#2-7-其他接口" class="headerlink" title="2.7 其他接口"></a>2.7 其他接口</h5><table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>BiFunction&lt;T,U,R&gt;</td>
<td>T,U</td>
<td>R</td>
<td>对类型为T,U参数应用操作，返回R类型的结果。包含方法为：R apply(T t, U u);</td>
</tr>
<tr>
<td>UnaryOperator<T> (Function子接口)</td>
<td>T</td>
<td>T</td>
<td>对类型为T的对象进行一元运算，并返回T类型的结果。包含方法为：T apply(T t)</td>
</tr>
<tr>
<td>BinaryOperator<T> (BiFunction子接口)</td>
<td>T,T</td>
<td>T</td>
<td>对类型为T的对象进行二元运算，并返回T类型的结果。包含方法为：T apply(T t1, T t2)</td>
</tr>
<tr>
<td>BiConsumer&lt;T,U&gt;</td>
<td>T,U</td>
<td>void</td>
<td>对类型为T,U参数应用操作<br />包含方法为：void accept(T t, U u)</td>
</tr>
<tr>
<td>BiPredicate&lt;T,U&gt;</td>
<td>T,U</td>
<td>boolean</td>
<td>包含方法为：boolean test(T t, Uu)</td>
</tr>
<tr>
<td>ToIntFuction<T></td>
<td>T</td>
<td>int</td>
<td>计算int值的函数</td>
</tr>
<tr>
<td>ToLongFunction<T></td>
<td>T</td>
<td>long</td>
<td>计算long值的函数</td>
</tr>
<tr>
<td>ToDoubleFunction<T></td>
<td>T</td>
<td>double</td>
<td>计算double值的函数</td>
</tr>
<tr>
<td>IntFunction<R></td>
<td>int</td>
<td>R</td>
<td>参数为int类型的函数</td>
</tr>
<tr>
<td>LongFunction<R></td>
<td>long</td>
<td>R</td>
<td>参数为long类型的函数</td>
</tr>
<tr>
<td>DoubleFunction<R></td>
<td>double</td>
<td>R</td>
<td>参数为double类型的函数</td>
</tr>
</tbody></table>
<h4 id="3-方法引用与构造器引用"><a href="#3-方法引用与构造器引用" class="headerlink" title="3. 方法引用与构造器引用"></a>3. 方法引用与构造器引用</h4><h5 id="3-1-方法引用-Method-References"><a href="#3-1-方法引用-Method-References" class="headerlink" title="3.1 方法引用(Method References)"></a>3.1 方法引用(Method References)</h5><ul>
<li><p>当要传递给Lambda体的操作时，已经有实现的方法了，可以使用方法引用</p>
</li>
<li><p>方法引用可以看作是Lambda表达式深层次的表达。换句话说，方法引用就是Lambda表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是Lambda表达式的一个语法糖</p>
</li>
<li><p>要求：实现接口的抽象方法的参数列表和返回值类型，必须与方法引用的方法的参数列表和返回值类型保持一致</p>
</li>
<li><p>格式：使用操作符“::”将类（或对象）与方法名分隔开</p>
</li>
<li><p>如下三种主要使用情况：</p>
<ul>
<li>对象::实例方法名</li>
<li>类::静态方法名</li>
<li>类::实例方法名</li>
</ul>
</li>
<li><p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Consume&lt;String&gt; con1 = System.out::println;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line">Comparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(x,y);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Comparator&lt;Integer&gt; com1 = Integer::compare;</span><br><span class="line"><span class="keyword">int</span> value = com.compare(<span class="number">12</span>,<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line">BiPredicate&lt;String,String&gt; bp = (x,y) -&gt; x.equals(y);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">BiPredicate&lt;String,String&gt; bp1 = String::equals;</span><br><span class="line"><span class="keyword">boolean</span> falg= bp1.test(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二 个参数是需要引用方法的参数(或无参数)时：ClassName::methodName</p>
</blockquote>
</li>
</ul>
<h5 id="3-2-构造器引用"><a href="#3-2-构造器引用" class="headerlink" title="3.2 构造器引用"></a>3.2 构造器引用</h5><p>格式：ClassName::new</p>
<p>与函数式接口相结合，自动与函数式接口中的方法兼容。</p>
<p>可以把构造器引用赋值给定义的方法，要求构造器参数列表要与接口中抽象方法的参数列表一致，且方法的返回值即为构造器对应类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">Function&lt;Integer, MyClass&gt; fun = (n) -&gt; <span class="keyword">new</span> MyClass(n);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Function&lt;Integer, MyClass&gt; fun = MyClass::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-数组引用"><a href="#3-3-数组引用" class="headerlink" title="3.3 数组引用"></a>3.3 数组引用</h5><p>格式：type[]::new</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">Function&lt;Integer, Integer[]&gt; fun = (n) -&gt; <span class="keyword">new</span> Integer[n];</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">Function&lt;Integer, Integer[]&gt; fun = Integer[]::<span class="keyword">new</span>;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-示例"><a href="#3-4-示例" class="headerlink" title="3.4 示例"></a>3.4 示例</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108162144944.png" alt="image-20210816214443373"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 方法引用与构造器引用;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSalary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSalary</span><span class="params">(<span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Employee().....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">int</span> id, String name, <span class="keyword">int</span> age, <span class="keyword">double</span> salary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Employee&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, salary=&quot;</span> + salary +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Employee employee = (Employee) o;</span><br><span class="line">        <span class="keyword">return</span> id == employee.id &amp;&amp; age == employee.age &amp;&amp; Double.compare(employee.salary, salary) == <span class="number">0</span> &amp;&amp; Objects.equals(name, employee.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(id, name, age, salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 方法引用与构造器引用;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeData</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Employee&gt; <span class="title">getEmployee</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1001</span>, <span class="string">&quot;马化腾&quot;</span>, <span class="number">34</span>, <span class="number">6000.38</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1002</span>, <span class="string">&quot;马云&quot;</span>, <span class="number">12</span>, <span class="number">9876.12</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1003</span>, <span class="string">&quot;刘强东&quot;</span>, <span class="number">33</span>, <span class="number">3000.82</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1004</span>, <span class="string">&quot;雷军&quot;</span>, <span class="number">26</span>, <span class="number">7657.37</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1005</span>, <span class="string">&quot;李彦宏&quot;</span>, <span class="number">65</span>, <span class="number">5555.32</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1006</span>, <span class="string">&quot;比尔盖茨&quot;</span>, <span class="number">42</span>, <span class="number">9500.43</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1007</span>, <span class="string">&quot;任正非&quot;</span>, <span class="number">26</span>, <span class="number">4333.32</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1008</span>, <span class="string">&quot;扎克伯格&quot;</span>, <span class="number">35</span>, <span class="number">2500.32</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 方法引用与构造器引用;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.PrintStream;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiPredicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法的引用</span></span><br><span class="line"><span class="comment">1.使用情景：当要传递给Lambda体的操作，已经有实现的方法了，可以使用方法引用</span></span><br><span class="line"><span class="comment">2.方法引用，本质上就是Lambda表达式，而Lambda表达式作为函数式接口的实例。所以方法引用也是函数式接口的实例</span></span><br><span class="line"><span class="comment">3.使用格式：类（或对象）：：方法名</span></span><br><span class="line"><span class="comment">4.具体分为如下三种情况：</span></span><br><span class="line"><span class="comment">情况1；对象 :: 非静态方法</span></span><br><span class="line"><span class="comment">情况2：类  ::  静态方法</span></span><br><span class="line"><span class="comment">情况3：类  ::  非静态方法</span></span><br><span class="line"><span class="comment">5.方法引用的使用要求：要求接口中的抽象方法的形参列表和返回值类类型与方法引用的形参列表和返回值类型相同（针对情况1和2）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodRefTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况一：对象 :: 实例方法</span></span><br><span class="line">    <span class="comment">//Consumer中的void accept(T t)</span></span><br><span class="line">    <span class="comment">//PrintStream中的void println(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Consumer&lt;String&gt; con = str -&gt; System.out.println(str);</span><br><span class="line">        con.accept(<span class="string">&quot;花江&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line">        PrintStream ps = System.out;</span><br><span class="line">        Consumer&lt;String&gt; con1 = ps :: println;</span><br><span class="line">        con1.accept(<span class="string">&quot;金鸡岭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Supplier中的T get()</span></span><br><span class="line">    <span class="comment">//Employee中的String getName()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Employee emp = <span class="keyword">new</span> Employee(<span class="number">1001</span>,<span class="string">&quot;xiong&quot;</span>,<span class="number">23</span>,<span class="number">15000</span>);</span><br><span class="line"></span><br><span class="line">        Supplier&lt;String &gt; supplier = () -&gt; emp.getName();</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line">        Supplier&lt;String&gt; stringSupplier = emp :: getName;</span><br><span class="line">        System.out.println(stringSupplier.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况二：类 :: 静态方法</span></span><br><span class="line">    <span class="comment">//Comparator中的int compare(T t1, T t2)</span></span><br><span class="line">    <span class="comment">//Interger中的int comapra(T t1, T t2)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);</span><br><span class="line">        System.out.println(com1.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Integer&gt; com2 = Integer :: compare;</span><br><span class="line">        System.out.println(com2.compare(<span class="number">12</span>, <span class="number">21</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">    <span class="comment">//Math中的Long round(double d)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Function&lt;Double,Long&gt; func = <span class="keyword">new</span> Function&lt;Double, Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Long <span class="title">apply</span><span class="params">(Double aDouble)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Math.round(aDouble);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(func.apply(<span class="number">12.8</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line">        Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class="line">        System.out.println(func1.apply(<span class="number">12.3</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line">        Function&lt;Double,Long&gt; func2 = Math :: round;</span><br><span class="line">        System.out.println(func2.apply(<span class="number">12.4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况三：类 :: 实例方法</span></span><br><span class="line">    <span class="comment">//Comparator中的int compare(T t1, T t2)</span></span><br><span class="line">    <span class="comment">//String中的int t1.compareTo(t2)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Comparator&lt;String&gt; com1 = (s1, s2) -&gt; s1.compareTo(s2);</span><br><span class="line">        System.out.println(com1.compare(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abd&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line">        Comparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class="line">        System.out.println(com2.compare(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abd&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class="line">    <span class="comment">//String中的boolean t1.equals(t2)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt;s1.equals(s2);</span><br><span class="line">        System.out.println(pre1.test(<span class="string">&quot;ab&quot;</span>, <span class="string">&quot;ab&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line">        BiPredicate&lt;String,String&gt; pre2 = String :: equals;</span><br><span class="line">        System.out.println(pre2.test(<span class="string">&quot;ax&quot;</span>, <span class="string">&quot;az&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Fuction中的R apply(T t) 传一个参数，返回另一个数据</span></span><br><span class="line">    <span class="comment">//Employee中的String T.getName();</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee(<span class="number">1001</span>,<span class="string">&quot;zhuo&quot;</span>,<span class="number">23</span>,<span class="number">15000</span>);</span><br><span class="line"></span><br><span class="line">        Function&lt;Employee,String&gt; fun1 = e -&gt; e.getName();</span><br><span class="line">        System.out.println(fun1.apply(employee));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line">        Function&lt;Employee,String&gt; fun2 = Employee :: getName;</span><br><span class="line">        System.out.println(fun2.apply(employee));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 方法引用与构造器引用;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiFunction;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一、构造器引用</span></span><br><span class="line"><span class="comment">        和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。</span></span><br><span class="line"><span class="comment">        抽象方法的返回值类型即为构造器所属的类的类型</span></span><br><span class="line"><span class="comment">二、数组引用</span></span><br><span class="line"><span class="comment">        大家可以把数组看作是一个特殊的类。则写法与构造器引用一致</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造器引用</span></span><br><span class="line">    <span class="comment">//Supperlier中的T get()</span></span><br><span class="line">    <span class="comment">//Employee的空参构造器：Employee()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Supplier&lt;Employee&gt; sup = <span class="keyword">new</span> Supplier&lt;Employee&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Employee <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Employee();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(sup.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line">        Supplier&lt;Employee&gt; sup1 = () -&gt; <span class="keyword">new</span> Employee();</span><br><span class="line">        System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line">        Supplier&lt;Employee&gt; sup2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">        System.out.println(sup2.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Function&lt;Integer,Employee&gt; func1 = id -&gt; <span class="keyword">new</span> Employee(id);</span><br><span class="line">        Employee em1 = func1.apply(<span class="number">1002</span>);</span><br><span class="line">        System.out.println(em1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line">        Function&lt;Integer,Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">        System.out.println(func2.apply(<span class="number">1003</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BiFunction中的R apply(T t, U u)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; <span class="keyword">new</span> Employee(id,name);</span><br><span class="line">        System.out.println(func1.apply(<span class="number">1004</span>, <span class="string">&quot;xiong&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line">        BiFunction&lt;Integer,String,Employee&gt; func2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">        System.out.println(func2.apply(<span class="number">1005</span>, <span class="string">&quot;zhuo&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组引用</span></span><br><span class="line">    <span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Function&lt;Integer,String[]&gt; func1 = length -&gt; <span class="keyword">new</span> String[length];</span><br><span class="line">        String[] arr1 = func1.apply(<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;|+++++++++++++++++++++|&quot;</span>);</span><br><span class="line">        Function&lt;Integer,String[]&gt; func2 = String[] :: <span class="keyword">new</span>;</span><br><span class="line">        String[] arr2 = func2.apply(<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="4-强大的Stream-API"><a href="#4-强大的Stream-API" class="headerlink" title="4. 强大的Stream API"></a>4. 强大的Stream API</h4><h5 id="4-1-Stream-API说明"><a href="#4-1-Stream-API说明" class="headerlink" title="4.1 Stream API说明"></a>4.1 Stream API说明</h5><ul>
<li>Java8中有两大最为重要的改变。第一个是 Lambda 表达式；另外一个则是 Stream API。</li>
<li>Stream API ( java.util.stream) 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</li>
<li>Stream 是Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用 Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。 也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</li>
</ul>
<h5 id="4-2-为什么要使用Stream-API"><a href="#4-2-为什么要使用Stream-API" class="headerlink" title="4.2 为什么要使用Stream API"></a>4.2 为什么要使用Stream API</h5><ul>
<li>实际开发中，项目中多数数据源都来自于Mysql，Oracle等。但现在数据源可以更多了，有MongDB，Radis等，而这些NoSQL的数据就需要 Java层面去处理。</li>
<li>Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据 结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中， 后者主要是面向 CPU，通过 CPU 实现计算。</li>
</ul>
<h5 id="4-3-什么是Stream"><a href="#4-3-什么是Stream" class="headerlink" title="4.3 什么是Stream"></a>4.3 什么是Stream</h5><p><strong>Stream到底是什么呢？</strong></p>
<p>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。 “集合讲的是数据，Stream讲的是计算！”</p>
<p>注意： ①Stream 自己不会存储元素。 ②Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。 ③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p>
<h5 id="4-4-Stream的操作三个步骤"><a href="#4-4-Stream的操作三个步骤" class="headerlink" title="4.4 Stream的操作三个步骤"></a>4.4 Stream的操作三个步骤</h5><ul>
<li><p>1- 创建 Stream</p>
<p>一个数据源（如：集合、数组），获取一个流</p>
</li>
<li><p>2- 中间操作</p>
<p>一个中间操作链，对数据源的数据进行处理</p>
</li>
<li><p>3- 终止操作(终端操作)</p>
<p>一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108072106954.png" alt="image-20210807210657432"></p>
</li>
</ul>
<h5 id="4-5-创建Stream的方式"><a href="#4-5-创建Stream的方式" class="headerlink" title="4.5 创建Stream的方式"></a>4.5 创建Stream的方式</h5><h6 id="4-5-1-方式一：通过集合"><a href="#4-5-1-方式一：通过集合" class="headerlink" title="4.5.1 方式一：通过集合"></a>4.5.1 方式一：通过集合</h6><p>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：</p>
<ul>
<li>default Stream stream() : 返回一个顺序流</li>
<li>default Stream parallelStream() : 返回一个并行流</li>
</ul>
<h6 id="4-5-2-方式二：通过数组"><a href="#4-5-2-方式二：通过数组" class="headerlink" title="4.5.2 方式二：通过数组"></a>4.5.2 方式二：通过数组</h6><p>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：</p>
<ul>
<li>static  Stream stream(T[] array): 返回一个流</li>
<li>重载形式，能够处理对应基本类型的数组：<ul>
<li>public static IntStream stream(int[] array)</li>
<li>public static LongStream stream(long[] array)</li>
<li>public static DoubleStream stream(double[] array)</li>
</ul>
</li>
</ul>
<h6 id="4-5-3-方式三：通过Stream的of"><a href="#4-5-3-方式三：通过Stream的of" class="headerlink" title="4.5.3 方式三：通过Stream的of()"></a>4.5.3 方式三：通过Stream的of()</h6><p>可以调用Stream类静态方法of()，通过显示值创建一个流。它可以接收任意数量的参数</p>
<ul>
<li>public static Stream of(T… values) : 返回一个流</li>
</ul>
<h6 id="4-5-4-方式四：创建无限流"><a href="#4-5-4-方式四：创建无限流" class="headerlink" title="4.5.4 方式四：创建无限流"></a>4.5.4 方式四：创建无限流</h6><p>可以使用静态方法 Stream.iterate() 和 Stream.generate(),  创建无限流。</p>
<ul>
<li><p>迭代</p>
<p>public static Stream iterate(final T seed, final UnaryOperator f) </p>
</li>
<li><p>生成</p>
<p>public static Stream generate(Supplier s) </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式四：创建无限流</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 迭代</span></span><br><span class="line">	<span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final</span></span><br><span class="line">	<span class="comment">// UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">	Stream&lt;Integer&gt; stream = Stream.iterate(<span class="number">0</span>, x -&gt; x + <span class="number">2</span>);</span><br><span class="line">	stream.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">	<span class="comment">// 生成</span></span><br><span class="line">	<span class="comment">// public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">	Stream&lt;Double&gt; stream1 = Stream.generate(Math::random);</span><br><span class="line">	stream1.limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-6-Stream的中间操作"><a href="#4-6-Stream的中间操作" class="headerlink" title="4.6 Stream的中间操作"></a>4.6 Stream的中间操作</h5><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理。而在中止操作时一次性全部处理，称为“惰性求值”</p>
<p>1-筛选与切片</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>filter(Predicate p)</td>
<td>接收Lambda，从流中排除某些元素</td>
</tr>
<tr>
<td>distinct()</td>
<td>筛选，通过流所生成元素的hashCode()和equals()去除重复元素</td>
</tr>
<tr>
<td>limit(long maxSize)</td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td>skip(long n)</td>
<td>跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回了一个空流。与limit(n)互补</td>
</tr>
</tbody></table>
<p>2-映射</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>map(Function f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</td>
</tr>
<tr>
<td>mapToDouble(ToDoubleFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。</td>
</tr>
<tr>
<td>mapToInt(ToIntFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。</td>
</tr>
<tr>
<td>mapToLong(ToLongFunction f)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。</td>
</tr>
<tr>
<td>flatMap(Function f)</td>
<td>接收一个函数作为参数，将流中的每个值都换成另 一个流，然后把所有流连接成一个流。</td>
</tr>
</tbody></table>
<p>3-排序</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sorted()</td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td>sorted(Comparator com)</td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
</tbody></table>
<h5 id="4-7-Streasm的终止操作"><a href="#4-7-Streasm的终止操作" class="headerlink" title="4.7 Streasm的终止操作"></a>4.7 Streasm的终止操作</h5><ul>
<li>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例 如：List、Integer，甚至是 void 。</li>
<li>流进行了终止操作后，不能再次使用。</li>
</ul>
<p>1-匹配与查找</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>allMatch(Predicate p)</td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td>anyMatch(Predicate p)</td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td>noneMatch(Predicate p)</td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td>findFirst()</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>findAny()</td>
<td>返回当前流中的任意元素</td>
</tr>
<tr>
<td>count()</td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td>max(Comparator c)</td>
<td>返回流中最大值</td>
</tr>
<tr>
<td>min(Comparator c)</td>
<td>返回流中最小值</td>
</tr>
<tr>
<td>forEach(Consumer c)</td>
<td>内部迭代(使用 Collection 接口需要用户去做迭代， 称为外部迭代。相反，Stream API 使用内部迭 代——它帮你把迭代做了)</td>
</tr>
</tbody></table>
<p>2-规约</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>reduce(T iden, BinaryOperator b)</td>
<td>可以将流中元素反复结合起来，得到一 个值。返回 T</td>
</tr>
<tr>
<td>reduce(BinaryOperator b)</td>
<td>可以将流中元素反复结合起来，得到一 个值。返回 Optional</td>
</tr>
</tbody></table>
<blockquote>
<p>备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google  用它来进行网络搜索而出名。</p>
</blockquote>
<p>3-收集</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>collect(Collector c)</td>
<td>将流转换为其他形式。接收一个 Collector 接口的实现，用于给Stream中元素做汇总 的方法</td>
</tr>
</tbody></table>
<p>Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、 Map)。另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例， 具体方法与实例如下表：</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108072226502.png" alt="image-20210807222605618"></p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/202108072226730.png" alt="image-20210807222624794"></p>
<h5 id="4-8-示例"><a href="#4-8-示例" class="headerlink" title="4.8 示例"></a>4.8 示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> StreamAPI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> 方法引用与构造器引用.Employee;</span><br><span class="line"><span class="keyword">import</span> 方法引用与构造器引用.EmployeeData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.IntStream;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.Stream关注的是对数据的运算，与CPU打交道，集合关注的的是数据的存储</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">①Stream 自己不会存储元素</span></span><br><span class="line"><span class="comment">②Stream 不会改变源对象，相反，他们会返回一个持有结果的新Stream</span></span><br><span class="line"><span class="comment">③Stream 操作是延迟执行的。这意味着他们会等到徐娅结果的时候才执行</span></span><br><span class="line"><span class="comment">3.Stream执行流程</span></span><br><span class="line"><span class="comment">①Stream的实例化</span></span><br><span class="line"><span class="comment">②一系列的中间操作（过滤、映射）</span></span><br><span class="line"><span class="comment">③终止操作</span></span><br><span class="line"><span class="comment">4.说明：</span></span><br><span class="line"><span class="comment">4.1 一个中间操作链，对数据源的数据进行处理</span></span><br><span class="line"><span class="comment">4.2 一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">测试Stream的实例化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPITest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建Stream方式一：通过集合</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employeeList = EmployeeData.getEmployee();</span><br><span class="line">        <span class="comment">//default Stream&lt;E&gt; stream()：返回一个顺序流</span></span><br><span class="line">        Stream&lt;Employee&gt; stream = employeeList.stream();</span><br><span class="line">        <span class="comment">//default Stream&lt;E&gt; parallelStream()：返回一个并行流</span></span><br><span class="line">        Stream&lt;Employee&gt; paralleStream = employeeList.parallelStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建方式二：通过数组</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="comment">//调用Arrays类的static&lt;T&gt; Stream&lt;T&gt; stream(T[] array)：返回一个流</span></span><br><span class="line">        IntStream stream = Arrays.stream(arr);</span><br><span class="line"></span><br><span class="line">        Employee e1 = <span class="keyword">new</span> Employee(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        Employee e2 = <span class="keyword">new</span> Employee(<span class="number">102</span>,<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        Employee[] arr1 = <span class="keyword">new</span> Employee[]&#123;e1,e2&#125;;</span><br><span class="line">        Stream&lt;Employee&gt; stream1 = Arrays.stream(arr1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建方式三：通过Stream的of()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建方式四：创建无限流</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//迭代</span></span><br><span class="line">        <span class="comment">//public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">        <span class="comment">//遍历前10个偶数</span></span><br><span class="line">        Stream.iterate(<span class="number">0</span>,t-&gt;t+<span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成</span></span><br><span class="line">        <span class="comment">//public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">        Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> StreamAPI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> 方法引用与构造器引用.Employee;</span><br><span class="line"><span class="keyword">import</span> 方法引用与构造器引用.EmployeeData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamAPITest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1-筛选与切片</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; list = EmployeeData.getEmployee();</span><br><span class="line">        <span class="comment">//排除元素：filter(Predicate p)——接收Lambda，从流中排除某些元素</span></span><br><span class="line">        Stream&lt;Employee&gt;stream = list.stream();</span><br><span class="line">        <span class="comment">//练习：查询员工表中薪资大于7000的员工信息</span></span><br><span class="line">        stream.filter(e -&gt; e.getSalary()&gt;<span class="number">7000</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//截断流：limt(n)使其元素不超过给定数量</span></span><br><span class="line">        list.stream().limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳过元素：skip(n)返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。与limit(n)互补</span></span><br><span class="line">        list.stream().skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//筛选元素：distinct()——筛选，通过流所生成元素的hashCode()和equals()去除重复元素</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">41</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Employee(<span class="number">1010</span>,<span class="string">&quot;刘强东&quot;</span>,<span class="number">40</span>,<span class="number">8000</span>));</span><br><span class="line">        list.stream().distinct().forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.映射</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//map(Function f)——接收一个函数作为参数，将元素转换成其他形式的值或者提取信息，该函数会被引用到每个元素上，并将其映射成一个新的元素</span></span><br><span class="line">        List&lt;String&gt; stringList = Arrays.asList(<span class="string">&quot;aa&quot;</span>,<span class="string">&quot;bb&quot;</span>,<span class="string">&quot;cc&quot;</span>,<span class="string">&quot;dd&quot;</span>);</span><br><span class="line">        stringList.stream().map(String :: toUpperCase).forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//练习1：将流中的每个值都换成另一个流，然后把所有流连接成一个流。</span></span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        Stream&lt;Stream&lt;Character&gt;&gt; streamStream = stringList.stream().map(StreamAPITest1::fromStringToStream);</span><br><span class="line">        streamStream.forEach(s -&gt; s.forEach(System.out::println));</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//方式二:</span></span><br><span class="line">        Stream&lt;Character&gt; stream = stringList.stream().flatMap(StreamAPITest1::fromStringToStream);</span><br><span class="line">        stream.forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//练习2：获取员工姓名长度大于3的员工姓名</span></span><br><span class="line">        List&lt;Employee&gt; employeeList = EmployeeData.getEmployee();</span><br><span class="line">        Stream&lt;String&gt; nameStream = employeeList.stream().map(Employee :: getName);</span><br><span class="line">        nameStream.filter(s -&gt; s.length()&gt;<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">fromStringToStream</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        ArrayList&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Character c :</span><br><span class="line">                str.toCharArray()) &#123;</span><br><span class="line">            list.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.stream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ArrayList list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        list1.add(<span class="number">2</span>);</span><br><span class="line">        list1.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        ArrayList list2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list2.add(<span class="number">4</span>);</span><br><span class="line">        list2.add(<span class="number">5</span>);</span><br><span class="line">        list2.add(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        list1.add(list2);</span></span><br><span class="line">        list1.addAll(list2);</span><br><span class="line">        System.out.println(list1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//自然排序</span></span><br><span class="line">         List&lt;Integer&gt; list = Arrays.asList(<span class="number">12</span>,<span class="number">21</span>,<span class="number">78</span>,<span class="number">34</span>,<span class="number">32</span>,<span class="number">54</span>,<span class="number">0</span>,-<span class="number">3</span>);</span><br><span class="line">         list.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//sorted(Comprator com)——定制排序</span></span><br><span class="line">         List&lt;Employee&gt; list1 = EmployeeData.getEmployee();</span><br><span class="line">         list1.stream().sorted((e1,e2) -&gt; &#123;</span><br><span class="line">             <span class="keyword">int</span> ageValue = Integer.compare(e1.getAge(),e2.getAge());</span><br><span class="line">             <span class="keyword">if</span>(ageValue != <span class="number">0</span>)&#123;</span><br><span class="line">                 <span class="keyword">return</span> ageValue;</span><br><span class="line">             &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">return</span> - Double.compare(e1.getSalary(),e2.getSalary());</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;).forEach(System.out::println);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> StreamAPI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> 方法引用与构造器引用.Employee;</span><br><span class="line"><span class="keyword">import</span> 方法引用与构造器引用.EmployeeData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试Stream的终止操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.匹配与查找</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employeeList = EmployeeData.getEmployee();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//allMatch(Predicate p)——检查是否匹配所有元素</span></span><br><span class="line">        <span class="comment">//练习：是否所有员工年龄都大于18</span></span><br><span class="line">        <span class="keyword">boolean</span> allMatch = employeeList.stream().allMatch(employee -&gt; employee.getAge() &gt;<span class="number">18</span>);</span><br><span class="line">        System.out.println(allMatch);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//anyMatch(Predicate p)——检查是否至少匹配一个元素</span></span><br><span class="line">        <span class="comment">//练习：是否存在员工工资大于10000</span></span><br><span class="line">        <span class="keyword">boolean</span> anyMatch = employeeList.stream().anyMatch(employee -&gt; employee.getSalary()&gt;<span class="number">10000</span>);</span><br><span class="line">        System.out.println(anyMatch);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//noneMatch(Predicate p)——检查是否没有匹配元素</span></span><br><span class="line">        <span class="comment">//练习：是否存在员工姓名姓“雷”</span></span><br><span class="line">        <span class="keyword">boolean</span> noneMatch = employeeList.stream().noneMatch(s -&gt; s.getName().startsWith(<span class="string">&quot;类&quot;</span>));</span><br><span class="line">        System.out.println(noneMatch);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//findFirst——返回第一个元素</span></span><br><span class="line">        Optional&lt;Employee&gt; first = employeeList.stream().findFirst();</span><br><span class="line">        System.out.println(first);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//findAny——返回当前流中的任意元素</span></span><br><span class="line">        Optional&lt;Employee&gt; any = employeeList.stream().findAny();</span><br><span class="line">        System.out.println(any);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Employee&gt; employeeList = EmployeeData.getEmployee();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//count——返回流中元素的总个数</span></span><br><span class="line">        <span class="keyword">long</span> count = employeeList.stream().count();</span><br><span class="line">        System.out.println(count);<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//max(Comparator c)——返回流中最大值</span></span><br><span class="line">        <span class="comment">//返回最高工资</span></span><br><span class="line">        Stream&lt;Double&gt; salaryStream = employeeList.stream().map(e -&gt; e.getSalary());</span><br><span class="line">        Optional&lt;Double&gt; maxSalary = salaryStream.max(Double::compare);</span><br><span class="line">        System.out.println(maxSalary);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//min(Comparator c)——返回流中最小值</span></span><br><span class="line">        <span class="comment">//返回最低工资</span></span><br><span class="line">        Stream&lt;Double&gt; salary = employeeList.stream().map(e -&gt; e.getSalary());</span><br><span class="line">        Optional&lt;Double&gt; minSalary= salary.min(Double::compare);</span><br><span class="line">        System.out.println(minSalary);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//forEach(Consumer c)——内部迭代</span></span><br><span class="line">        employeeList.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用集合遍历操作</span></span><br><span class="line">        employeeList.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2-规约</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//reduce(T identity, BinaryOperator)——可以将流中的元素反复结合起来，得到一个值。返回T</span></span><br><span class="line">        <span class="comment">//练习1：计算1-10的自然数的和</span></span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">        Integer sum = list.stream().reduce(<span class="number">0</span>,Integer :: sum);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//reduce(BinaryOperator)——可以将流中的元素反复结合起来，得到一个值。返回Optional&lt;T&gt;</span></span><br><span class="line">        <span class="comment">//练习2：计算公司所有员工工资的总和</span></span><br><span class="line">        List&lt;Employee&gt; employeeList = EmployeeData.getEmployee();</span><br><span class="line">        Stream&lt;Double&gt; saralyStream = employeeList.stream().map(e -&gt; e.getSalary());</span><br><span class="line">        Optional&lt;Double&gt; sumSalary = saralyStream.reduce((s1,s2)-&gt;s1 + s2);</span><br><span class="line">        System.out.println(sumSalary.get());<span class="comment">//48424.08 不用.get会输出Optional[48424.08]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3-收集</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//collect(Collector c)——将流转化为其他形式。接收一个Collection接口的实现类，用于给Stream中元素做汇总的方法</span></span><br><span class="line">        <span class="comment">//查找工资大于6000的员工，结果返回为一个List或Set</span></span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployee();</span><br><span class="line">        List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary()&gt;<span class="number">6000</span>).collect(Collectors.toList());</span><br><span class="line">        employeeList.forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        Set&lt;Employee&gt; employeeSet = employees.stream().filter(e -&gt; e.getSalary()&gt;<span class="number">6000</span>).collect(Collectors.toSet());</span><br><span class="line">        employeeSet.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="5-Optional类"><a href="#5-Optional类" class="headerlink" title="5. Optional类"></a>5. Optional类</h4><ul>
<li>到目前为止，臭名昭著的空指针异常是导致Java应用程序失败的最常见原因。 以前，为了解决空指针异常，Google公司著名的Guava项目引入了Optional类， Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代 码。受到Google Guava的启发，Optional类已经成为Java 8类库的一部分。</li>
<li>Optional 类(java.util.Optional) 是一个容器类，它可以保存类型T的值，代表这个值存在。或者仅仅保存null，表示这个值不存在。原来用 null 表示一个值不 存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</li>
<li>Optional类的Javadoc描述如下：这是一个可以为null的容器对象。如果值存在 则isPresent()方法会返回true，调用get()方法会返回该对象。</li>
<li>Optional提供很多有用的方法，这样我们就不用显式进行空值检测</li>
<li>创建Optional类对象的方法：<ul>
<li>Optional.of(T t) : 创建一个 Optional 实例，t必须非空；</li>
<li>Optional.empty() : 创建一个空的 Optional 实例</li>
<li>Optional.ofNullable(T t)：t可以为null</li>
</ul>
</li>
<li>判断Optional容器中是否包含对象：<ul>
<li>boolean isPresent() : 判断是否包含对象</li>
<li>void ifPresent(Consumer consumer) ：如果有值，就执行Consumer 接口的实现代码，并且该值会作为参数传给它。</li>
</ul>
</li>
<li>获取Optional容器的对象：<ul>
<li>T get(): 如果调用对象包含值，返回该值，否则抛异常</li>
<li>T orElse(T other) ：如果有值则将其返回，否则返回指定的other对象。</li>
<li>T orElseGet(Supplier other) ：如果有值则将其返回，否则返回由 Supplier接口实现提供的对象。</li>
<li>T orElseThrow(Supplier exceptionSupplier) ：如果有值则将其返 回，否则抛出由Supplier接口实现提供的异常。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Boy b = <span class="keyword">new</span> Boy(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGrilFriend());</span><br><span class="line">	<span class="comment">// 如果女朋友存在就打印女朋友的信息</span></span><br><span class="line">	opt.ifPresent(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Boy b = <span class="keyword">new</span> Boy(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">	Optional&lt;Girl&gt; opt = Optional.ofNullable(b.getGrilFriend());</span><br><span class="line">	<span class="comment">// 如果有女朋友就返回他的女朋友，否则只能欣赏“嫦娥”了</span></span><br><span class="line">	Girl girl = opt.orElse(<span class="keyword">new</span> Girl(<span class="string">&quot;嫦娥&quot;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;他的女朋友是：&quot;</span> + girl.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Optional&lt;Employee&gt; opt = Optional.of(<span class="keyword">new</span> Employee(<span class="string">&quot;张三&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">	<span class="comment">//判断opt中员工对象是否满足条件，如果满足就保留，否则返回空</span></span><br><span class="line">	Optional&lt;Employee&gt; emp = opt.filter(e -&gt; e.getSalary()&gt;<span class="number">10000</span>);</span><br><span class="line">	System.out.println(emp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Optional&lt;Employee&gt; opt = Optional.of(<span class="keyword">new</span> Employee(<span class="string">&quot;张三&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">	<span class="comment">//如果opt中员工对象不为空，就涨薪10%</span></span><br><span class="line">	Optional&lt;Employee&gt; emp = opt.map(</span><br><span class="line">        e -&gt; &#123;e.setSalary(e.getSalary()%<span class="number">1.1</span>);<span class="keyword">return</span> e;&#125;);</span><br><span class="line">	System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Optional类;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Girl girl;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Boy&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;girl=&quot;</span> + girl +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Girl <span class="title">getGirl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> girl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGirl</span><span class="params">(Girl girl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.girl = girl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boy</span><span class="params">(Girl girl)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.girl = girl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Optional类;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Girl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Girl&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Girl</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Girl</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Optional类;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Optional;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Optional类：为了在程序中避免出现空指针异常而创建的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 常用的方法：ofNullable(T t)</span></span><br><span class="line"><span class="comment"> *            orElse(T t)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptionalTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Optional.of(T t) : 创建一个 Optional 实例，t必须非空；</span></span><br><span class="line"><span class="comment">Optional.empty() : 创建一个空的 Optional 实例</span></span><br><span class="line"><span class="comment">Optional.ofNullable(T t)：t可以为null</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Girl girl = <span class="keyword">new</span> Girl();</span><br><span class="line"><span class="comment">//        girl = null;</span></span><br><span class="line">        <span class="comment">//of(T t):保证t是非空的</span></span><br><span class="line">        Optional&lt;Girl&gt; optionalGirl = Optional.of(girl);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Girl girl = <span class="keyword">new</span> Girl();</span><br><span class="line"><span class="comment">//        girl = null;</span></span><br><span class="line">        <span class="comment">//ofNullable(T t)：t可以为null</span></span><br><span class="line">        Optional&lt;Girl&gt; optionalGirl = Optional.ofNullable(girl);</span><br><span class="line">        System.out.println(optionalGirl);</span><br><span class="line">        <span class="comment">//orElse(T t1):如果单前的Optional内部封装的t是非空的，则返回内部的t.</span></span><br><span class="line">        <span class="comment">//如果内部的t是空的，则返回orElse()方法中的参数t1.</span></span><br><span class="line">        Girl girl1 = optionalGirl.orElse(<span class="keyword">new</span> Girl(<span class="string">&quot;赵丽颖&quot;</span>));</span><br><span class="line">        System.out.println(girl1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGirlName</span><span class="params">(Boy boy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boy.getGirl().getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Boy boy = <span class="keyword">new</span> Boy();</span><br><span class="line">        boy = <span class="keyword">null</span>;</span><br><span class="line">        String girlName = getGirlName(boy);</span><br><span class="line">        System.out.println(girlName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//优化以后的getGirlName():</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGirlName1</span><span class="params">(Boy boy)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(boy != <span class="keyword">null</span>)&#123;</span><br><span class="line">          Girl girl = boy.getGirl();</span><br><span class="line">            <span class="keyword">if</span>(girl != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> girl.getName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Boy boy = <span class="keyword">new</span> Boy();</span><br><span class="line">        boy = <span class="keyword">null</span>;</span><br><span class="line">        String girlName = getGirlName1(boy);</span><br><span class="line">        System.out.println(girlName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用Optional类的getGirlName():</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGirlName2</span><span class="params">(Boy boy)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class="line">        <span class="comment">//此时的boy1一定非空</span></span><br><span class="line">        Boy boy1 = boyOptional.orElse(<span class="keyword">new</span> Boy(<span class="keyword">new</span> Girl(<span class="string">&quot;迪丽热巴&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        Girl girl = boy1.getGirl();</span><br><span class="line"></span><br><span class="line">        Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class="line">        <span class="comment">//girl1一定非空</span></span><br><span class="line">        Girl girl1 = girlOptional.orElse(<span class="keyword">new</span> Girl(<span class="string">&quot;古力娜扎&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> girl1.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Boy boy = <span class="keyword">null</span>;</span><br><span class="line">        boy = <span class="keyword">new</span> Boy();</span><br><span class="line">        boy = <span class="keyword">new</span> Boy(<span class="keyword">new</span> Girl(<span class="string">&quot;苍老师&quot;</span>));</span><br><span class="line">        String girlName = getGirlName2(boy);</span><br><span class="line">        System.out.println(girlName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git原理(02)</title>
    <url>/2021/09/17/Git%E5%8E%9F%E7%90%86%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D2/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="11-pack文件"><a href="#11-pack文件" class="headerlink" title="11. pack文件"></a>11. pack文件</h3><h4 id="11-1-背景"><a href="#11-1-背景" class="headerlink" title="11.1 背景"></a>11.1 背景</h4><p>新建一个代码仓库作为演示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2</span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in C:/Files/git-demo2/.git/</span><br></pre></td></tr></table></figure>

<p>将一个大小为7.32M的文件放到工作区</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108221714162.png" alt="image-20210822171427745" style="zoom:50%;" /> 

<ol>
<li><p>将该文件进行添加和提交，使用<code>du -h</code>来查看文件夹的占用情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add word_note.docx</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;1st commit&quot;</span></span></span><br><span class="line">[master (root-commit) 534c54e] 1st commit</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 word_note.docx</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> du -h .git/objects</span></span><br><span class="line">1.0K    .git/objects/17</span><br><span class="line">1.0K    .git/objects/53</span><br><span class="line">7.0M    .git/objects/b8</span><br><span class="line">0       .git/objects/info</span><br><span class="line">0       .git/objects/pack</span><br><span class="line">7.0M    .git/objects</span><br></pre></td></tr></table></figure>
</li>
<li><p>将文件进行小的改动，随之再进行添加和提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add word_note.docx</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;2nd commit&quot;</span></span></span><br><span class="line">[master 67a095b] 2nd commit</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add word_note.docx</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;3rd commit&quot;</span></span></span><br><span class="line">[master 5153efa] 3rd commit</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看此时文件夹占用情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> du -h .git/objects</span></span><br><span class="line">1.0K    .git/objects/17</span><br><span class="line">7.0M    .git/objects/4b</span><br><span class="line">1.0K    .git/objects/51</span><br><span class="line">1.0K    .git/objects/53</span><br><span class="line">1.0K    .git/objects/67</span><br><span class="line">1.0K    .git/objects/ae</span><br><span class="line">7.0M    .git/objects/b8</span><br><span class="line">7.0M    .git/objects/e4</span><br><span class="line">1.0K    .git/objects/fc</span><br><span class="line">0       .git/objects/info</span><br><span class="line">0       .git/objects/pack</span><br><span class="line">21M     .git/objects</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lh</span></span><br><span class="line">total 7.4M</span><br><span class="line">-rw-r--r-- 1 xiong 197609 7.4M Aug 22 17:21 word_note.docx</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files -s</span></span><br><span class="line">100644 e4d8fff037528cc82c6f923a5200f3dfa1876d6b 0       word_note.docx</span><br></pre></td></tr></table></figure>

<p>进行三次提交后objects文件夹已经达到了21M，虽然此时工作区内容只有7.4M</p>
</li>
</ol>
<p>​         在git里，文件会先压缩成blob对象进行存储。这虽在一定程度上减小了内存开销，但是由于每次对文件在工作区修改后，对文件进行添加和提交时，都会存储整个对象的压缩文件。根据开发实际场景，每次文件的改动都不会有较大的改动，而每次再新生成一份blob文件，就会增大内存开销。在此背景下提出了使用<code>git gc</code>进行压缩的方案</p>
<h4 id="11-2-git-gc-进行文件压缩"><a href="#11-2-git-gc-进行文件压缩" class="headerlink" title="11.2 git gc 进行文件压缩"></a>11.2 git gc 进行文件压缩</h4><p>①使用<code>git gc</code>进行文件压缩</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git gc</span></span><br><span class="line">Enumerating objects: 9, done.</span><br><span class="line">Counting objects: 100% (9/9), done.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (6/6), done.</span><br><span class="line">Writing objects: 100% (9/9), done.</span><br><span class="line">Total 9 (delta 2), reused 0 (delta 0), pack-reused 0</span><br></pre></td></tr></table></figure>

<p>②查看现在.git文件夹中的内存占用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> du -h .git</span></span><br><span class="line">35K     .git/hooks</span><br><span class="line">2.0K    .git/info</span><br><span class="line">1.0K    .git/logs/refs/heads</span><br><span class="line">1.0K    .git/logs/refs</span><br><span class="line">2.0K    .git/logs</span><br><span class="line">3.0K    .git/objects/info</span><br><span class="line">7.3M    .git/objects/pack</span><br><span class="line">7.3M    .git/objects</span><br><span class="line">0       .git/refs/heads</span><br><span class="line">0       .git/refs/tags</span><br><span class="line">0       .git/refs</span><br><span class="line">7.3M    .git</span><br></pre></td></tr></table></figure>

<p>21M内容压缩成7.3M</p>
<p>③查看objects中的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo2</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO2\.GIT\OBJECTS</span><br><span class="line">├─info</span><br><span class="line">│      commit-graph</span><br><span class="line">│      packs</span><br><span class="line">│</span><br><span class="line">└─pack</span><br><span class="line">        pack-3181db0c2b5d97f6d38c69d9a43358790246aa10.idx</span><br><span class="line">        pack-3181db0c2b5d97f6d38c69d9a43358790246aa10.pack</span><br></pre></td></tr></table></figure>

<p>blob文件全部被压缩，生成了pack</p>
<ol>
<li><p>查看pack文件夹中文件的大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lh .git/objects/pack</span></span><br><span class="line">total 7.3M</span><br><span class="line">-r--r--r-- 1 xiong 197609 1.3K Aug 22 20:18 pack-3181db0c2b5d97f6d38c69d9a43358790246aa10.idx</span><br><span class="line">-r--r--r-- 1 xiong 197609 7.3M Aug 22 20:18 pack-3181db0c2b5d97f6d38c69d9a43358790246aa10.pack</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看.dex文件里存储的内容：<code>git verify-pack -v 文件路径</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git verify-pack -v .git/objects/pack/pack-3181db0c2b5d97f6d38c69d9a43358790246aa10.idx</span></span><br><span class="line">5153efa4cf47077622e7771888cae3deb87db41e commit 225 149 12</span><br><span class="line">67a095b95ff121fb3e1bc648b98814e1c8f6c148 commit 225 148 161</span><br><span class="line">534c54ea578f0d6517cb5d38ddced88d4c4158b4 commit 177 119 309</span><br><span class="line">b80edea2a581ed6917723b45871f0af11beb714d blob   7683972 7330028 428</span><br><span class="line">4b574b366e9bb3ad454462ba510db98a01837b66 blob   167961 166370 7330456 1 b80edea2a581ed6917723b45871f0af11beb714d</span><br><span class="line">e4d8fff037528cc82c6f923a5200f3dfa1876d6b blob   98578 97543 7496826 2 4b574b366e9bb3ad454462ba510db98a01837b66</span><br><span class="line">fcd21cca77d88e7c8bda0ac43e72c8b5a6c7a4be tree   42 53 7594369</span><br><span class="line">aef20abb0786e52ac2234180cf18ad488023f7f2 tree   42 52 7594422</span><br><span class="line">172344478aef4544529c644e29130d7d8f1b041f tree   42 53 7594474</span><br><span class="line">non delta: 7 objects</span><br><span class="line">chain length = 1: 1 object</span><br><span class="line">chain length = 2: 1 object</span><br><span class="line">.git/objects/pack/pack-3181db0c2b5d97f6d38c69d9a43358790246aa10.pack: ok</span><br></pre></td></tr></table></figure>

<p>里面存储有之前三次添加和提交所产生对象的完整记录</p>
<p>只有b80ede所对应的blob文件所存储的是第一次提交时对象的完整内容，另外两个blob文件（后面跟有一串SHA1值），所记录的是与原始文件存在的差异</p>
</li>
</ol>
<p><strong>应用场景</strong></p>
<p>当从远程克隆仓库到本地时，使用pack文件进行传输就可以节省传输时间，不过在传输到本地后，如果要检索到特定的某一次commit，则需要花费一点时间和内存去解压缩pack文件</p>
<h4 id="11-3-解压缩"><a href="#11-3-解压缩" class="headerlink" title="11.3 解压缩"></a>11.3 解压缩</h4><p>使用<code>git unpack-objects &lt; 输入流</code></p>
<p>使用<code>git help unpack-objects</code>查看命令描述</p>
<ul>
<li><p>名字</p>
<p>git 拆包对象 - 从包装的存档中拆开对象</p>
</li>
<li><p>概要</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git unpack-objects [-n] [-q] [-r] [--strict]</span><br></pre></td></tr></table></figure>
</li>
<li><p>描述</p>
<p>从标准输入中读取包装的存档 （.pack），扩展其中包含的对象，并以”松散”（每个文件一个对象）格式将其写入存储库。</p>
<p>存储库中已经存在的对象<strong>不会</strong>从包装文件中拆开。因此，如果您在目标存储库内的包装文件上使用此命令，则不会拆开任何内容</p>
</li>
<li><p>选项</p>
<p>-n</p>
<p>干运行。检查包文件，而不实际拆开对象。</p>
<p>-q</p>
<p>命令通常显示百分比进度。此标志将抑制它。</p>
<p>-r</p>
<p>解包损坏的打包文件时，该命令在第一次损坏时终止。这个标志告诉它继续前进，尽最大努力恢复尽可能多的对象。</p>
<p>-严格</p>
<p>不要编写内容或链接中断的对象。</p>
<p>-最大输入大小=&lt;尺寸&gt;</p>
<p>如果包大于&lt;大小&gt;， 则死亡</p>
</li>
</ul>
<p><strong>注意点</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo2</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO2\.GIT\OBJECTS</span><br><span class="line">├─info</span><br><span class="line">│      commit-graph</span><br><span class="line">│      packs</span><br><span class="line">│</span><br><span class="line">└─pack</span><br><span class="line">        pack-3181db0c2b5d97f6d38c69d9a43358790246aa10.idx</span><br><span class="line">        pack-3181db0c2b5d97f6d38c69d9a43358790246aa10.pack</span><br></pre></td></tr></table></figure>

<p>当我们要使用unpack时，我们需要将.pack文件移到外面。虽然此时的objects文件夹里没有objects文件，但是所有的文件都被存储在pack里，所以系统任然会认为存储库中已经存在这些文件，验证如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git unpack-objects &lt; .git/objects/pack/pack-3181db0c2b5d97f6d38c69d9a43358790246aa10.pack</span></span><br><span class="line">Unpacking objects: 100% (9/9), 7.24 MiB | 32.96 MiB/s, done.</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo2</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO2\.GIT\OBJECTS</span><br><span class="line">├─info</span><br><span class="line">│      commit-graph</span><br><span class="line">│      packs</span><br><span class="line">│</span><br><span class="line">└─pack</span><br><span class="line">        pack-3181db0c2b5d97f6d38c69d9a43358790246aa10.idx</span><br><span class="line">        pack-3181db0c2b5d97f6d38c69d9a43358790246aa10.pack</span><br></pre></td></tr></table></figure>

<p>虽然使用了unpack文件，但是系统仍然认为仓库里有对象</p>
<p>如果要解压当前pack文件，做法如下</p>
<ol>
<li><p>将pack文件移出object文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> mv .git/objects/pack/pack-3181db0c2b5d97f6d38c69d9a43358790246aa10.pack .git/</span></span><br></pre></td></tr></table></figure>

<p>此时git会认为代码仓库是空的</p>
</li>
<li><p>使用unpack进行解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo2 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git unpack-objects &lt; .git/pack-3181db0c2b5d97f6d38c69d9a43358790246aa10.pack</span></span><br><span class="line">Unpacking objects: 100% (9/9), 7.24 MiB | 6.10 MiB/s, done.</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看objects文件目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo2</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO2\.GIT\OBJECTS</span><br><span class="line">├─17</span><br><span class="line">│      2344478aef4544529c644e29130d7d8f1b041f</span><br><span class="line">│</span><br><span class="line">├─4b</span><br><span class="line">│      574b366e9bb3ad454462ba510db98a01837b66</span><br><span class="line">│</span><br><span class="line">├─51</span><br><span class="line">│      53efa4cf47077622e7771888cae3deb87db41e</span><br><span class="line">│</span><br><span class="line">├─53</span><br><span class="line">│      4c54ea578f0d6517cb5d38ddced88d4c4158b4</span><br><span class="line">│</span><br><span class="line">├─67</span><br><span class="line">│      a095b95ff121fb3e1bc648b98814e1c8f6c148</span><br><span class="line">│</span><br><span class="line">├─ae</span><br><span class="line">│      f20abb0786e52ac2234180cf18ad488023f7f2</span><br><span class="line">│</span><br><span class="line">├─b8</span><br><span class="line">│      0edea2a581ed6917723b45871f0af11beb714d</span><br><span class="line">│</span><br><span class="line">├─e4</span><br><span class="line">│      d8fff037528cc82c6f923a5200f3dfa1876d6b</span><br><span class="line">│</span><br><span class="line">├─fc</span><br><span class="line">│      d21cca77d88e7c8bda0ac43e72c8b5a6c7a4be</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">│      commit-graph</span><br><span class="line">│      packs</span><br><span class="line">│</span><br><span class="line">└─pack</span><br><span class="line">        pack-3181db0c2b5d97f6d38c69d9a43358790246aa10.idx</span><br></pre></td></tr></table></figure>

<p>解压成功，将对象写入到objects文件夹里</p>
</li>
</ol>
<h3 id="12-git垃圾对象的清理"><a href="#12-git垃圾对象的清理" class="headerlink" title="12. git垃圾对象的清理"></a>12. git垃圾对象的清理</h3><h4 id="12-1-多次添加产生垃圾对象"><a href="#12-1-多次添加产生垃圾对象" class="headerlink" title="12.1 多次添加产生垃圾对象"></a>12.1 多次添加产生垃圾对象</h4><p>在使用git进行版本控制的时候，通常会对一个文件在本地进行多次的修改和添加，最后才提交代码仓库。只有最后提交到代码仓库的那次才是有效的，之前所添加到索引区的文件就成为了垃圾对象。对于此类垃圾对象，使用<code>git prune</code>进行垃圾对象清理</p>
<p>初始新的代码仓库git-demo3进行测试，新建文件test.txt，每次做一点修改就进行添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3</span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in C:/Files/git-demo3/.git/</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;abc&#x27;</span> &gt; test.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add test.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in test.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim test.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add test.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in test.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim test.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add test.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in test.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看此时objects中的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo3                  </span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span>                                 </span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表                              </span><br><span class="line">卷序列号为 C0000100 F296:2801                               </span><br><span class="line">C:\FILES\GIT-DEMO3\.GIT\OBJECTS                        </span><br><span class="line">├─5d                                                   </span><br><span class="line">│      8a5566f0e8b2794b60559ecaa3cf8986e23d47          </span><br><span class="line">│                                                      </span><br><span class="line">├─74                                                   </span><br><span class="line">│      ec2e70bd5e4936b3d076b469751e584f434a9a          </span><br><span class="line">│                                                      </span><br><span class="line">├─8b                                                   </span><br><span class="line">│      aef1b4abc478178b004d62031cf7fe6db6f903          </span><br><span class="line">│                                                      </span><br><span class="line">├─info                                                 </span><br><span class="line">└─pack                                                 </span><br></pre></td></tr></table></figure>

<p>经过3次add，产生了三个blob对象</p>
<p>进行一次commit，并使用<code>git gc</code>进行文件压缩，查看结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;1st commit&#x27;</span></span></span><br><span class="line">[master (root-commit) 63a6480] 1st commit</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br><span class="line"> create mode 100644 test.txt</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git gc</span></span><br><span class="line">Enumerating objects: 3, done.</span><br><span class="line">Counting objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo3</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO3\.GIT\OBJECTS</span><br><span class="line">├─5d</span><br><span class="line">│      8a5566f0e8b2794b60559ecaa3cf8986e23d47</span><br><span class="line">│</span><br><span class="line">├─8b</span><br><span class="line">│      aef1b4abc478178b004d62031cf7fe6db6f903</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">│      commit-graph</span><br><span class="line">│      packs</span><br><span class="line">│</span><br><span class="line">└─pack</span><br><span class="line">        pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.idx</span><br><span class="line">        pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.pack</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git verify-pack -v .git/objects/pack/pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.idx</span></span><br><span class="line">63a64804613dbfaa16cfc5c7fb320b501f539d75 commit 177 120 12</span><br><span class="line">74ec2e70bd5e4936b3d076b469751e584f434a9a blob   12 15 132</span><br><span class="line">85d321b0acc1f7618da3b8a24a51c743a0133932 tree   36 46 147</span><br><span class="line">non delta: 3 objects</span><br><span class="line">.git/objects/pack/pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.pack: ok</span><br></pre></td></tr></table></figure>

<p>被压缩的对象是最后一次的blob、tree和commit对象</p>
<p>此时可以看到有两个对象并未被压缩到pack文件里，这两个文件就是垃圾对象</p>
<h5 id="12-1-2-使用git-prune清理垃圾对象"><a href="#12-1-2-使用git-prune清理垃圾对象" class="headerlink" title="12.1.2 使用git prune清理垃圾对象"></a>12.1.2 使用git prune清理垃圾对象</h5><p><code>git prune</code></p>
<ul>
<li><p>名字</p>
<p>git prune从对象数据库中修剪所有无法到达的对象</p>
</li>
<li><p>概要</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git prune [-n] [-v] [--progress] [--expire &lt;time&gt;] [--] [&lt;head&gt;…]</span><br></pre></td></tr></table></figure>
</li>
<li><p>描述</p>
<p>注意：在大多数情况下，用户应该运行git gc，它会调用git prune。请参阅下面的”注意”部分。</p>
<p>运行<code>git fsck --unreachable</code>使用refs/下所有可用的refs，可以选择在命令行上指定其他对象集，并从对象数据库中删除无法从这些head对象中访问的所有未打包对象。此外，它还通过运行git prune-packed来修剪包中的未打包对象。它还从.git/shallow中删除任何ref.ref都无法访问的条目/</p>
</li>
<li><p>选项</p>
<ul>
<li><p>-n</p>
<p>–dry-run </p>
<p>不移除任何事物，只是显示哪些事物将会被移除</p>
</li>
<li><p>-v</p>
<p>–verbose</p>
<p>显示所有背移除的对象</p>
</li>
<li><p>–progress</p>
<p>显示所有进程</p>
</li>
<li><p>expire<time></p>
<p>仅使早于<time>之前的松散对象过期</p>
</li>
<li><p>–</p>
<p>不要将任何其他参数解释为选项</p>
</li>
<li><head>...

<p>除了从我们的任何引用中都可以访问的对象之外，还要保持从列出的<head>s中可以访问的对象。</p>
</li>
</ul>
</li>
<li><p>例子</p>
<p>要修剪存储库未使用的对象或通过其从存储库借用的其他对象，请执行以下操作：<code>.git/objects/info/alternates</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git prune $(<span class="built_in">cd</span> ../another &amp;&amp; git rev-parse --all)</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><code>git fsck</code></p>
<ul>
<li><p>名字</p>
<p>git-fsck - 验证数据库中对象的连接和有效性</p>
</li>
<li><p>概要</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fsck [--tags] [--root] [--unreachable] [--cache] [--no-reflogs]</span><br><span class="line">         [--[no-]full] [--strict] [--verbose] [--lost-found]</span><br><span class="line">         [--[no-]dangling] [--[no-]progress] [--connectivity-only]</span><br><span class="line">         [--[no-]name-objects] [&lt;object&gt;*]</span><br></pre></td></tr></table></figure>
</li>
<li><p>描述</p>
<p>验证数据库中对象的连接和有效性。</p>
</li>
<li><p>选项</p>
<ul>
<li><p>&lt;object&gt;</p>
<p>要作为不可访问性跟踪的头部处理的对象。<br>如果未提供任何对象，git fsck默认使用索引文件、refs命名空间中的所有SHA-1引用以及所有reflogs（除非提供了–no reflogs）作为头。</p>
</li>
<li><p>–unreachable</p>
<p>打印存在但无法从任何引用节点访问的对象。</p>
</li>
<li><p>–[no-]dangling</p>
<p>打印存在但从未直接使用的对象（默认）–不能使用任何悬空来从输出中忽略此信息。</p>
</li>
<li><p>–root</p>
<p>显示根节点</p>
</li>
<li><p>–tags</p>
<p>显示标签</p>
</li>
<li><p>–cache</p>
<p>将索引中记录的任何对象也作为不可达跟踪的头节点。</p>
</li>
<li><p>–no-reflogs</p>
<p>不要考虑仅由reflog中的条目引用的可到达的提交。此选项仅用于搜索以前在ref中但现在不在ref中但仍在相应reflog中的提交。</p>
</li>
<li><p>–full</p>
<p>不仅要检查GIT_OBJECT_目录（$GIT_DIR/objects）中的对象，还要检查GIT_alternate_OBJECT_目录或$GIT_DIR/objects/info/alternates中列出的备用对象池中的对象，以及备用对象池中的$GIT_DIR/objects/pack和相应的pack子目录中的打包GIT归档中的对象。现在这是默认值；你可以关闭它，不需要完全关闭。</p>
<p>……</p>
</li>
</ul>
</li>
</ul>
<p><strong>使用prune -n显示会被删除的对象</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git prune -n</span></span><br><span class="line">5d8a5566f0e8b2794b60559ecaa3cf8986e23d47 blob</span><br><span class="line">8baef1b4abc478178b004d62031cf7fe6db6f903 blob</span><br></pre></td></tr></table></figure>

<p><strong>使用git fsck查看悬空的对象</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git fsck</span></span><br><span class="line">Checking object directories: 100% (256/256), done.</span><br><span class="line">Checking objects: 100% (3/3), done.</span><br><span class="line">dangling blob 8baef1b4abc478178b004d62031cf7fe6db6f903</span><br><span class="line">dangling blob 5d8a5566f0e8b2794b60559ecaa3cf8986e23d47</span><br></pre></td></tr></table></figure>

<ol>
<li><p>使用<code>git prune</code>删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git prune</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看objects</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo3</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO3\.GIT\OBJECTS</span><br><span class="line">├─info</span><br><span class="line">│      commit-graph</span><br><span class="line">│      packs</span><br><span class="line">│</span><br><span class="line">└─pack</span><br><span class="line">        pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.idx</span><br><span class="line">        pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.pack</span><br></pre></td></tr></table></figure>

<p>悬空的两个对象被删除了</p>
</li>
</ol>
<h4 id="12-2-删除未合并分支产生的对象"><a href="#12-2-删除未合并分支产生的对象" class="headerlink" title="12.2 删除未合并分支产生的对象"></a>12.2 删除未合并分支产生的对象</h4><p>对于新建的分支，如果想完整的删除分支，先使用<code>git -D 分支名</code>强制删除，但是这样操作，分支上所做的操作还是可以被还原，分支上的文件也仍然存在，而且使用<code>git prune</code>不会认为是</p>
<ol>
<li><p>创建分支，在分支上添加内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b tmp</span></span><br><span class="line">Switched to a new branch &#x27;tmp&#x27;</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;tmp&#x27;</span>&gt;tmp.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">test.txt  tmp.txt</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add tmp.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in tmp.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br></pre></td></tr></table></figure>
</li>
<li><p>分析一次add的情况</p>
<ol>
<li><p>切换到master分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">A       tmp.txt</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git prune -n</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git fsck</span></span><br><span class="line">Checking object directories: 100% (256/256), done.</span><br><span class="line">Checking objects: 100% (3/3), done.</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换到tmp分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout tmp</span></span><br><span class="line">Switched to branch &#x27;tmp&#x27;</span><br><span class="line">A       tmp.txt</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git prune -n</span></span><br></pre></td></tr></table></figure>

<p>对于只add过一次但还没提交的文件，系统不认为是悬空文件</p>
</li>
</ol>
</li>
<li><p>分析add两次，提交一次的情况</p>
<ol>
<li><p>修改tmp.txt文件，进行一次提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim tmp.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add tmp.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in tmp.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br></pre></td></tr></table></figure>
</li>
<li><p>在tmp分支上查看悬空对象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;1st commit from tmp&#x27;</span></span></span><br><span class="line">[tmp 1915cf6] 1st commit from tmp</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 tmp.txt</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git fsck</span></span><br><span class="line">Checking object directories: 100% (256/256), done.</span><br><span class="line">Checking objects: 100% (3/3), done.</span><br><span class="line">dangling blob a9a5aecf429fd8a0d81fbd5fd37006bfa498d5c1</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换到master分支上查看悬空对象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git fsck</span></span><br><span class="line">Checking object directories: 100% (256/256), done.</span><br><span class="line">Checking objects: 100% (3/3), done.</span><br><span class="line">dangling blob a9a5aecf429fd8a0d81fbd5fd37006bfa498d5c1</span><br></pre></td></tr></table></figure>

<p>分支上的悬空对象，其他分支也能检测到</p>
</li>
</ol>
</li>
<li><p>切换到master分支强制删除tmp</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D tmp</span></span><br><span class="line">Deleted branch tmp (was 1915cf6).</span><br></pre></td></tr></table></figure>

<p>objects目录没有任何变化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo3</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO3\.GIT\OBJECTS</span><br><span class="line">├─0c</span><br><span class="line">│      190188dbbf78236873f4d98402eb35440cf292</span><br><span class="line">│</span><br><span class="line">├─19</span><br><span class="line">│      15cf671b63040967ff38cf434df3a6860da113</span><br><span class="line">│</span><br><span class="line">├─62</span><br><span class="line">│      189d1a10cc2a544c4e5b9c4aba9493cf5782dc</span><br><span class="line">│</span><br><span class="line">├─a9</span><br><span class="line">│      a5aecf429fd8a0d81fbd5fd37006bfa498d5c1</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">│      commit-graph</span><br><span class="line">│      packs</span><br><span class="line">│</span><br><span class="line">└─pack</span><br><span class="line">        pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.idx</span><br><span class="line">        pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.pack</span><br></pre></td></tr></table></figure>

<p>在此种情况下，tmp分支上的对象可以认为是垃圾对象</p>
</li>
<li><p>执行<code>git prune</code>删除对象：不会认为tmp分支上的add(最后一次的)和commit是垃圾对象</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git prune</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo3</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO3\.GIT\OBJECTS</span><br><span class="line">├─0c</span><br><span class="line">│      190188dbbf78236873f4d98402eb35440cf292</span><br><span class="line">│</span><br><span class="line">├─19</span><br><span class="line">│      15cf671b63040967ff38cf434df3a6860da113</span><br><span class="line">│</span><br><span class="line">├─62</span><br><span class="line">│      189d1a10cc2a544c4e5b9c4aba9493cf5782dc</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">│      commit-graph</span><br><span class="line">│      packs</span><br><span class="line">│</span><br><span class="line">└─pack</span><br><span class="line">        pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.idx</span><br><span class="line">        pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.pack</span><br></pre></td></tr></table></figure>

<p>只有一个之前被检测到的悬空对象被删除了</p>
</li>
<li><p>执行<code>git gc</code>：不会认为tmp分支上的add(最后一次的)和commit是垃圾对象，并将其压缩到pack里</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git gc</span></span><br><span class="line">Enumerating objects: 6, done.</span><br><span class="line">Counting objects: 100% (6/6), done.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (6/6), done.</span><br><span class="line">Total 6 (delta 0), reused 3 (delta 0), pack-reused 0</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git verify-pack -v .git/objects/pack/pack-17c963e06e14119b3281aa3a1fa16ebbc8817341.idx</span></span><br><span class="line">1915cf671b63040967ff38cf434df3a6860da113 commit 234 154 12</span><br><span class="line">63a64804613dbfaa16cfc5c7fb320b501f539d75 commit 177 120 166</span><br><span class="line">74ec2e70bd5e4936b3d076b469751e584f434a9a blob   12 15 286</span><br><span class="line">85d321b0acc1f7618da3b8a24a51c743a0133932 tree   36 46 301</span><br><span class="line">0c190188dbbf78236873f4d98402eb35440cf292 tree   71 74 347</span><br><span class="line">62189d1a10cc2a544c4e5b9c4aba9493cf5782dc blob   8 15 421</span><br><span class="line">non delta: 6 objects</span><br><span class="line">.git/objects/pack/pack-17c963e06e14119b3281aa3a1fa16ebbc8817341.pack: ok</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>对于这种情况，使用下面的命令可以进行解决<a href="https://stackoverflow.com/questions/3797907/how-to-remove-unused-objects-from-a-git-repository">file - How to remove unused objects from a git repository? - Stack Overflow</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git -c gc.reflogExpire=0 -c gc.reflogExpireUnreachable=0 \</span><br><span class="line">  -c gc.rerereresolved=0 -c gc.rerereunresolved=0 \</span><br><span class="line">  -c gc.pruneExpire=now gc &quot;$@&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git -c gc.reflogExpire=0 -c gc.reflogExpireUnreachable=0 \</span></span><br><span class="line"><span class="bash">&gt;   -c gc.rerereresolved=0 -c gc.rerereunresolved=0 \</span></span><br><span class="line"><span class="bash">&gt;   -c gc.pruneExpire=now gc <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span></span><br><span class="line">Enumerating objects: 3, done.</span><br><span class="line">Counting objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), done.</span><br><span class="line">Total 3 (delta 0), reused 3 (delta 0), pack-reused 0</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git verify-pack -v .git/objects/pack/pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.idx</span></span><br><span class="line">63a64804613dbfaa16cfc5c7fb320b501f539d75 commit 177 120 12</span><br><span class="line">74ec2e70bd5e4936b3d076b469751e584f434a9a blob   12 15 132</span><br><span class="line">85d321b0acc1f7618da3b8a24a51c743a0133932 tree   36 46 147</span><br><span class="line">non delta: 3 objects</span><br><span class="line">.git/objects/pack/pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.pack: ok</span><br></pre></td></tr></table></figure>

<p>不仅经过压缩了的可以这样进行处理，未压缩的也可以</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b tmp2</span></span><br><span class="line">Switched to a new branch &#x27;tmp2&#x27;</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (tmp2)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;tmp2&#x27;</span> &gt; tmp2.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (tmp2)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add tmp2.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in tmp2.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (tmp2)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;1st commit from tmp2&#x27;</span></span></span><br><span class="line">[tmp2 92cb3a6] 1st commit from tmp2</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 tmp2.txt</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (tmp2)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D tmp2</span></span><br><span class="line">Deleted branch tmp2 (was 92cb3a6).</span><br></pre></td></tr></table></figure>

<p>清理前查看objects文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO3\.GIT\OBJECTS</span><br><span class="line">├─92</span><br><span class="line">│      cb3a62ebb6ad8c15b5f85e9349f6342d0b2ed8</span><br><span class="line">│</span><br><span class="line">├─d0</span><br><span class="line">│      c22e2dc4474240f8082a39ff275622b1221e82</span><br><span class="line">│</span><br><span class="line">├─f0</span><br><span class="line">│      206044e90fd5c77500ec550df0a0be6f0d0c46</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">│      commit-graph</span><br><span class="line">│      packs</span><br><span class="line">│</span><br><span class="line">└─pack</span><br><span class="line">        pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.idx</span><br><span class="line">        pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.pack</span><br></pre></td></tr></table></figure>

<p>清理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git -c gc.reflogExpire=0 -c gc.reflogExpireUnreachable=0 \</span></span><br><span class="line"><span class="bash">&gt; -c gc.rerereresolved=0 -c gc.rerereunresolved=0 \</span></span><br><span class="line"><span class="bash">&gt; -c gc.pruneExpire=now gc <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span></span><br><span class="line">Enumerating objects: 3, done.</span><br><span class="line">Counting objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), done.</span><br><span class="line">Total 3 (delta 0), reused 3 (delta 0), pack-reused 0</span><br></pre></td></tr></table></figure>

<p>清理后查看objects文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo3</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO3\.GIT\OBJECTS</span><br><span class="line">├─info</span><br><span class="line">│      commit-graph</span><br><span class="line">│      packs</span><br><span class="line">│</span><br><span class="line">└─pack</span><br><span class="line">        pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.idx</span><br><span class="line">        pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.pack</span><br></pre></td></tr></table></figure>

<h3 id="13-fast-forward合并"><a href="#13-fast-forward合并" class="headerlink" title="13. fast forward合并"></a>13. fast forward合并</h3><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108231329780.png" alt="image-20210823132936534"></p>
<p>如果当前分支是在master上新建的，而且master分支并未再次进行commit，则满足fast forward的要求</p>
<p>将当前分支切换到master分支，再执行<code>git merge 分支名</code>进行分支合并，实际上只是做了一个指针的移动</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108231333871.png" alt="image-20210823133312415"></p>
<p><strong>测试</strong></p>
<p>当前仓库只有一次提交，且指针指向master分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 63a64804613dbfaa16cfc5c7fb320b501f539d75 (HEAD -&gt; master)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 08:34:07 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br></pre></td></tr></table></figure>

<p>基于当前分支，创建一个新的分支进行演示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev</span></span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 63a64804613dbfaa16cfc5c7fb320b501f539d75 (HEAD -&gt; dev, master)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 08:34:07 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br></pre></td></tr></table></figure>

<p>在新分支上产生一次commit：执行完毕后新分支超前master分支一次提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;test2&#x27;</span> &gt; test2.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add test2.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in test2.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;2nd commit&#x27;</span></span></span><br><span class="line">[dev 596b3cd] 2nd commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test2.txt</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 596b3cd55b27dc3cb5f85c291f73ac8e367aa930 (HEAD -&gt; dev)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 13:38:02 2021 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 63a64804613dbfaa16cfc5c7fb320b501f539d75 (master)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 08:34:07 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br></pre></td></tr></table></figure>

<p>切换到master分支，先查看.git文件，进行分支合并</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo3</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO3\.GIT</span><br><span class="line">│  COMMIT_EDITMSG</span><br><span class="line">│  config</span><br><span class="line">│  description</span><br><span class="line">│  HEAD</span><br><span class="line">│  index</span><br><span class="line">│  packed-refs</span><br><span class="line">│</span><br><span class="line">├─hooks</span><br><span class="line">│      applypatch-msg.sample</span><br><span class="line">│      commit-msg.sample</span><br><span class="line">│      fsmonitor-watchman.sample</span><br><span class="line">│      post-update.sample</span><br><span class="line">│      pre-applypatch.sample</span><br><span class="line">│      pre-commit.sample</span><br><span class="line">│      pre-merge-commit.sample</span><br><span class="line">│      pre-push.sample</span><br><span class="line">│      pre-rebase.sample</span><br><span class="line">│      pre-receive.sample</span><br><span class="line">│      prepare-commit-msg.sample</span><br><span class="line">│      push-to-checkout.sample</span><br><span class="line">│      update.sample</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">│      exclude</span><br><span class="line">│      refs</span><br><span class="line">│</span><br><span class="line">├─logs</span><br><span class="line">│  │  HEAD</span><br><span class="line">│  │</span><br><span class="line">│  └─refs</span><br><span class="line">│      └─heads</span><br><span class="line">│              dev</span><br><span class="line">│              master</span><br><span class="line">│</span><br><span class="line">├─objects</span><br><span class="line">│  ├─18</span><br><span class="line">│  │      0cf8328022becee9aaa2577a8f84ea2b9f3827</span><br><span class="line">│  │</span><br><span class="line">│  ├─59</span><br><span class="line">│  │      6b3cd55b27dc3cb5f85c291f73ac8e367aa930</span><br><span class="line">│  │</span><br><span class="line">│  ├─ae</span><br><span class="line">│  │      3b0c9016b70ff7a211370616236c14571b7f0c</span><br><span class="line">│  │</span><br><span class="line">│  ├─info</span><br><span class="line">│  │      commit-graph</span><br><span class="line">│  │      packs</span><br><span class="line">│  │</span><br><span class="line">│  └─pack</span><br><span class="line">│          pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.idx</span><br><span class="line">│          pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.pack</span><br><span class="line">│</span><br><span class="line">└─refs</span><br><span class="line">    ├─heads</span><br><span class="line">    │      dev</span><br><span class="line">    │</span><br><span class="line">    └─tags</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span></span><br><span class="line">Updating 63a6480..596b3cd</span><br><span class="line">Fast-forward</span><br><span class="line"> test2.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test2.txt</span><br></pre></td></tr></table></figure>

<p><code>Updating 63a6480..596b3cd</code>：把指针从63a6480，指向596b3cd</p>
<p>合并后查看.git文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo3</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO3\.GIT</span><br><span class="line">│  COMMIT_EDITMSG</span><br><span class="line">│  config</span><br><span class="line">│  description</span><br><span class="line">│  HEAD</span><br><span class="line">│  index</span><br><span class="line">│  ORIG_HEAD   #新增</span><br><span class="line">│  packed-refs</span><br><span class="line">│</span><br><span class="line">├─hooks</span><br><span class="line">│      applypatch-msg.sample</span><br><span class="line">│      commit-msg.sample</span><br><span class="line">│      fsmonitor-watchman.sample</span><br><span class="line">│      post-update.sample</span><br><span class="line">│      pre-applypatch.sample</span><br><span class="line">│      pre-commit.sample</span><br><span class="line">│      pre-merge-commit.sample</span><br><span class="line">│      pre-push.sample</span><br><span class="line">│      pre-rebase.sample</span><br><span class="line">│      pre-receive.sample</span><br><span class="line">│      prepare-commit-msg.sample</span><br><span class="line">│      push-to-checkout.sample</span><br><span class="line">│      update.sample</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">│      exclude</span><br><span class="line">│      refs</span><br><span class="line">│</span><br><span class="line">├─logs</span><br><span class="line">│  │  HEAD</span><br><span class="line">│  │</span><br><span class="line">│  └─refs</span><br><span class="line">│      └─heads</span><br><span class="line">│              dev</span><br><span class="line">│              master</span><br><span class="line">│</span><br><span class="line">├─objects</span><br><span class="line">│  ├─18</span><br><span class="line">│  │      0cf8328022becee9aaa2577a8f84ea2b9f3827</span><br><span class="line">│  │</span><br><span class="line">│  ├─59</span><br><span class="line">│  │      6b3cd55b27dc3cb5f85c291f73ac8e367aa930</span><br><span class="line">│  │</span><br><span class="line">│  ├─ae</span><br><span class="line">│  │      3b0c9016b70ff7a211370616236c14571b7f0c</span><br><span class="line">│  │</span><br><span class="line">│  ├─info</span><br><span class="line">│  │      commit-graph</span><br><span class="line">│  │      packs</span><br><span class="line">│  │</span><br><span class="line">│  └─pack</span><br><span class="line">│          pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.idx</span><br><span class="line">│          pack-b9d4bdcbfa833a54a35bc737eaba5f5088f6d956.pack</span><br><span class="line">│</span><br><span class="line">└─refs</span><br><span class="line">    ├─heads</span><br><span class="line">    │      dev</span><br><span class="line">    │      master</span><br><span class="line">    │</span><br><span class="line">    └─tags</span><br></pre></td></tr></table></figure>

<p>分别查看HEAD与ORIG_HEAD</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/HEAD</span></span><br><span class="line">ref: refs/heads/master</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/refs/heads/master</span></span><br><span class="line">596b3cd55b27dc3cb5f85c291f73ac8e367aa930</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/ORIG_HEAD</span></span><br><span class="line">63a64804613dbfaa16cfc5c7fb320b501f539d75</span><br></pre></td></tr></table></figure>

<p>ORIG_HEAD指向前一次commit，git在进行版本控制时，认为merge是比较危险的操作，所以提供了上一次的HEAD指向，以便于进行回滚操作</p>
<p>回滚演示：将master回滚到未merge前的状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset ORIG_HEAD</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        test2.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>

<p>在此种状态下不能立即切换到dev分支,需要先对当前回滚产生的test2.txt进行操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev</span></span><br><span class="line">error: The following untracked working tree files would be overwritten by checkout:</span><br><span class="line">        test2.txt</span><br><span class="line">Please move or remove them before you switch branches.</span><br><span class="line">Aborting</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf test2.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev</span></span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="14-3-way-merge"><a href="#14-3-way-merge" class="headerlink" title="14. 3 way merge"></a>14. 3 way merge</h3><h4 id="14-1-无冲突的merge"><a href="#14-1-无冲突的merge" class="headerlink" title="14.1 无冲突的merge"></a>14.1 无冲突的merge</h4><p>在开发时，如果master分支上有人进行了一次commit</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108231513724.png" alt="image-20210823151348518"></p>
<ol>
<li><p>在dev分支查看当前提交情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 596b3cd55b27dc3cb5f85c291f73ac8e367aa930 (HEAD -&gt; dev)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 13:38:02 2021 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 63a64804613dbfaa16cfc5c7fb320b501f539d75 (master)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 08:34:07 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br></pre></td></tr></table></figure>

<p>dev超前于master分支一次提交</p>
</li>
<li><p>切换到master分支进行一次提交，模拟描述的情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;test3&#x27;</span> &gt; test3.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add test3.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in test3.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;3rd commit&#x27;</span></span></span><br><span class="line">[master ee44067] 3rd commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test3.txt</span><br><span class="line"> </span><br><span class="line"> xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit ee44067f519231c20405f26c9a9fbef7c45e296a (HEAD -&gt; master)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 14:23:08 2021 +0800</span><br><span class="line"></span><br><span class="line">    3rd commit</span><br><span class="line"></span><br><span class="line">commit 63a64804613dbfaa16cfc5c7fb320b501f539d75</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 08:34:07 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行<code>git merge</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span></span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> test2.txt | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test2.txt</span><br></pre></td></tr></table></figure>

<p>此时会进入一个编辑器，要求输入commit信息</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108231432493.png" alt="image-20210823143245060"></p>
<p>查看当前提交记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 2040a9926e6c3f6647fbae96b067fa9ac4d1caac (HEAD -&gt; master)</span><br><span class="line">Merge: ee44067 596b3cd</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 14:31:42 2021 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">commit ee44067f519231c20405f26c9a9fbef7c45e296a</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 14:23:08 2021 +0800</span><br><span class="line"></span><br><span class="line">    3rd commit</span><br><span class="line"></span><br><span class="line">commit 596b3cd55b27dc3cb5f85c291f73ac8e367aa930 (dev)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 13:38:02 2021 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 63a64804613dbfaa16cfc5c7fb320b501f539d75</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 08:34:07 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br></pre></td></tr></table></figure>

<p>此时commit状态如下：新的merge commit比较特殊，指向两个parent</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108231450145.png" alt="image-20210823145013674"></p>
<p>验证如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 2040a9</span></span><br><span class="line">tree 1838144278c4bdebda77473c8b269f173d7c5122</span><br><span class="line">parent ee44067f519231c20405f26c9a9fbef7c45e296a</span><br><span class="line">parent 596b3cd55b27dc3cb5f85c291f73ac8e367aa930</span><br><span class="line">author xiongzhuo &lt;xiongzhuo@outlook.com&gt; 1629700302 +0800</span><br><span class="line">committer xiongzhuo &lt;xiongzhuo@outlook.com&gt; 1629700302 +0800</span><br><span class="line"></span><br><span class="line">Merge branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/refs/heads/dev</span></span><br><span class="line">596b3cd55b27dc3cb5f85c291f73ac8e367aa930</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/ORIG_HEAD</span></span><br><span class="line">ee44067f519231c20405f26c9a9fbef7c45e296a</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo3 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/refs/heads/master</span></span><br><span class="line">2040a9926e6c3f6647fbae96b067fa9ac4d1caac</span><br></pre></td></tr></table></figure>

<p>此时状态</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108231512858.png" alt="image-20210823151244631"></p>
</li>
</ol>
<h4 id="14-2-带冲突的3-way-merge"><a href="#14-2-带冲突的3-way-merge" class="headerlink" title="14.2  带冲突的3 way merge"></a>14.2  带冲突的3 way merge</h4><p>上述merge时所修改的文件不是同一个，如果修改的是同一个文件，则需要解决冲突</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108231524818.png" alt="image-20210823152448688"></p>
<p><strong>初始化一个新的代码仓库进行测试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4</span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in C:/Files/git-demo4/.git/</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;test&#x27;</span>&gt;test.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add test.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in test.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;1st commit&#x27;</span></span></span><br><span class="line">[master (root-commit) 300e689] 1st commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev</span></span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim test.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add test.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in test.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;2nd commit&#x27;</span></span></span><br><span class="line">[dev fd44315] 2nd commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim test.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add test.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;3rd commit&#x27;</span></span></span><br><span class="line">[master e5cdf78] 3rd commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p><strong>查看master分支上的提交记录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit e5cdf7844b4ec84a213a743ae50ce7e75f050da5 (HEAD -&gt; master)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 15:57:24 2021 +0800</span><br><span class="line"></span><br><span class="line">    3rd commit</span><br><span class="line"></span><br><span class="line">commit 300e689767c0e77cd950bc7f7562da1211d8a837</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 15:28:01 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br></pre></td></tr></table></figure>

<p><strong>切换到dev分支查看提交记录</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev</span></span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit fd443159acf34ca861ef84adcd8f4da5703e859b (HEAD -&gt; dev)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 15:29:25 2021 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 300e689767c0e77cd950bc7f7562da1211d8a837</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Mon Aug 23 15:28:01 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br></pre></td></tr></table></figure>

<p><strong>执行<code>git merge dev</code></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span></span><br><span class="line">Auto-merging test.txt</span><br><span class="line">CONFLICT (content): Merge conflict in test.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p><code>Automatic merge failed; fix conflicts and then commit the result.</code>：自动merge失败，解决冲突之后提交结果</p>
<p><strong>查看当前git状态</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line">        both modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>指出test.txt被共同修改了</p>
<p><strong>查看文件内容</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat test.txt</span></span><br><span class="line">test</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">add from master</span><br><span class="line">=======</span><br><span class="line">add from dev</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;&gt;&gt;&gt;&gt; dev</span></span><br></pre></td></tr></table></figure>

<p>列举出来了二者冲突的地方</p>
<p><strong>查看当前索引区文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files -s</span></span><br><span class="line">100644 9daeafb9864cf43055ae93beb0afd6c7d144bfa4 1       test.txt</span><br><span class="line">100644 25059ba70062bc9ca5e6bc169a02b9e03928d383 2       test.txt</span><br><span class="line">100644 94032e5599cd953e1245bedddf18cc3ad6d5b297 3       test.txt</span><br></pre></td></tr></table></figure>

<p>列出了test.txt的三个版本，查看这三个文件内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 9daeaf</span></span><br><span class="line">test</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 25059b</span></span><br><span class="line">test</span><br><span class="line">add from master</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 94032e</span></span><br><span class="line">test</span><br><span class="line">add from dev</span><br></pre></td></tr></table></figure>

<p><strong>通过编辑器打开文件，解决冲突</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim test.txt</span></span><br></pre></td></tr></table></figure>

<p>将修改添加到索引区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line">        both modified:   test.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add test.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files -s</span></span><br><span class="line">100644 c638404ba9aedab9251326c3418b8948ad9344f4 0       test.txt</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p c63840</span></span><br><span class="line">test</span><br><span class="line">add from master</span><br><span class="line">add from dev</span><br></pre></td></tr></table></figure>

<p>修改完后此时git仍然显示test.txt文件是共同修改状态，我们需要进行add和commit就可以解决，而且此时索引区的文件又变回了一个，查看内容，正是我们修改过后的。表示此时冲突已经解决</p>
<p>进行commit</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master|MERGING)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;fix conflicts&#x27;</span></span></span><br><span class="line">[master e486395] fix conflicts</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo4 (master)</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>

<p>提交完之后，(master|MERGING)变成了(master)，完成了所有操作，结果也和普通的3way merge一样</p>
<h3 id="16-git-rebase"><a href="#16-git-rebase" class="headerlink" title="16. git rebase"></a>16. git rebase</h3><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108232108159.gif" alt="git rebase"></p>
<p>当我们遇到需要分支合并的时候，而且此时想让合并的分支呈线性，可以再分支上使用<code>git reabse master</code>，将master分支上的最近一次提交同步到当前分支上，然后系统会改写分支上的commit，使分支上的commit在master之后，最后在使用<code>git merge</code>的时候就使得提交呈现出线性。不过要注意这种操作不适合团队开发使用，因为容易涉及到带冲突合并的问题。</p>
<h3 id="17-标签tag"><a href="#17-标签tag" class="headerlink" title="17. 标签tag"></a>17. 标签tag</h3><p>标签在创建时，指向的是当前所在分支的最新一次commit</p>
<ul>
<li><p>创建tag</p>
<ul>
<li>git tag &lt;tag name&gt;：创建一个轻量级的tag(i.e. git tag v1.0)</li>
<li>git tag -a  &lt;tag name&gt; -m &lt;tag message&gt;：创建一个拥有关联元数据的注解tag( email,date,etc…)(i.e. git tag -a v1.0 -m “version” )</li>
<li>git tag -a &lt;tag name&gt; &lt;commit SHA1 value&gt; ：为以前的commit生成一个注解tag(i.e. git tag -a v1.0 c638404ba9aedab9251326c3418b8948ad9344f4)</li>
</ul>
</li>
<li><p>tag列表</p>
<p>git tag</p>
</li>
<li><p>删除tag</p>
<p>git tag -d &lt;tag name&gt; (i.e. git tag -d v1.0)</p>
</li>
</ul>
<p>①初始化代码仓库，为master分支的最近一次commit使用<code>git tag &lt;tag name&gt;</code>创建tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5</span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in C:/Files/git-demo5/.git/</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;test1&#x27;</span> &gt; test1.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add test1.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in test1.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&#x27;1st commit&#x27;</span></span></span><br><span class="line">[master (root-commit) 8a7e377] 1st commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test1.txt</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag v1.0.0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo5</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/refs /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO5\.GIT\REFS</span><br><span class="line">├─heads</span><br><span class="line">│      master</span><br><span class="line">│</span><br><span class="line">└─tags</span><br><span class="line">        v1.0.0</span><br></pre></td></tr></table></figure>

<p>查看tag内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/refs/tags/v1.0.0</span></span><br><span class="line">8a7e3772b496dcaa2c11ede0d3397371529fe0f1</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -t 8a7e</span></span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 8a7e</span></span><br><span class="line">tree c0da834e42dcbf7b2b1c4a97925bef105d3863a3</span><br><span class="line">author xiongzhuo &lt;xiongzhuo@outlook.com&gt; 1629726589 +0800</span><br><span class="line">committer xiongzhuo &lt;xiongzhuo@outlook.com&gt; 1629726589 +0800</span><br><span class="line"></span><br><span class="line">1st commit</span><br></pre></td></tr></table></figure>

<p>删除tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v1.0.0</span></span><br><span class="line">Deleted tag &#x27;v1.0.0&#x27; (was 8a7e377)</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo5</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/refs /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO5\.GIT\REFS</span><br><span class="line">├─heads</span><br><span class="line">│      master</span><br><span class="line">│</span><br><span class="line">└─tags</span><br></pre></td></tr></table></figure>

<hr>
<p>②使用<code>git tag -a &lt;tag name&gt; -m &lt;tag message&gt;</code>创建tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.0.0 -m <span class="string">&quot;version v1.0.0&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>查看objects</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo5</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO5\.GIT\OBJECTS</span><br><span class="line">├─88</span><br><span class="line">│      1062f4ca137827d78a6f5e4e48996f3ed7722e #新增</span><br><span class="line">│</span><br><span class="line">├─8a</span><br><span class="line">│      7e3772b496dcaa2c11ede0d3397371529fe0f1</span><br><span class="line">│</span><br><span class="line">├─a5</span><br><span class="line">│      bce3fd2565d8f458555a0c6f42d0504a848bd5</span><br><span class="line">│</span><br><span class="line">├─c0</span><br><span class="line">│      da834e42dcbf7b2b1c4a97925bef105d3863a3</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">└─pack</span><br></pre></td></tr></table></figure>

<p>查看新增objects文件类型和文件内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -t 881062</span></span><br><span class="line">tag</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 881062</span></span><br><span class="line">object 8a7e3772b496dcaa2c11ede0d3397371529fe0f1</span><br><span class="line">type commit</span><br><span class="line">tag v1.0.0</span><br><span class="line">tagger xiongzhuo &lt;xiongzhuo@outlook.com&gt; 1629727707 +0800</span><br><span class="line"></span><br><span class="line">version v1.0.0</span><br></pre></td></tr></table></figure>

<p>查看refs</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo5</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/refs /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO5\.GIT\REFS</span><br><span class="line">├─heads</span><br><span class="line">│      master</span><br><span class="line">│</span><br><span class="line">└─tags</span><br><span class="line">        v1.0.0  #新增</span><br></pre></td></tr></table></figure>

<p>删除tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d v1.0.0</span></span><br><span class="line">Deleted tag &#x27;v1.0.0&#x27; (was 881062f)</span><br></pre></td></tr></table></figure>

<p>查看refs，标签被删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo5</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/refs /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO5\.GIT\REFS</span><br><span class="line">├─heads</span><br><span class="line">│      master</span><br><span class="line">│</span><br><span class="line">└─tags</span><br></pre></td></tr></table></figure>

<p>查看objects，tag对象未被删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo5</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO5\.GIT\OBJECTS</span><br><span class="line">├─88</span><br><span class="line">│      1062f4ca137827d78a6f5e4e48996f3ed7722e #tag对象未被删除，产生垃圾对象</span><br><span class="line">│</span><br><span class="line">├─8a</span><br><span class="line">│      7e3772b496dcaa2c11ede0d3397371529fe0f1</span><br><span class="line">│</span><br><span class="line">├─a5</span><br><span class="line">│      bce3fd2565d8f458555a0c6f42d0504a848bd5</span><br><span class="line">│</span><br><span class="line">├─c0</span><br><span class="line">│      da834e42dcbf7b2b1c4a97925bef105d3863a3</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">└─pack</span><br></pre></td></tr></table></figure>

<p>③使用<code>git tag -a &lt;tag name&gt; &lt;commit SHA1 value&gt;</code>创建tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a v1.0.0 8a7e37 -m <span class="string">&quot;version 1&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>查看objects</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo5</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO5\.GIT\OBJECTS</span><br><span class="line">├─88</span><br><span class="line">│      1062f4ca137827d78a6f5e4e48996f3ed7722e</span><br><span class="line">│</span><br><span class="line">├─8a</span><br><span class="line">│      7e3772b496dcaa2c11ede0d3397371529fe0f1</span><br><span class="line">│</span><br><span class="line">├─a5</span><br><span class="line">│      bce3fd2565d8f458555a0c6f42d0504a848bd5</span><br><span class="line">│</span><br><span class="line">├─c0</span><br><span class="line">│      da834e42dcbf7b2b1c4a97925bef105d3863a3</span><br><span class="line">│</span><br><span class="line">├─ec</span><br><span class="line">│      1fd8c3998b32051be0c19affdd49c20e4938fe  #新增tag</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">└─pack</span><br></pre></td></tr></table></figure>

<p>虽然名字一样，但是并未使用之前的tag对象，因为在生成tag对象时里面有时间戳</p>
<p>使用<code>git fsck</code>可以检测出垃圾tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git fsck</span></span><br><span class="line">Checking object directories: 100% (256/256), done.</span><br><span class="line">dangling tag 881062f4ca137827d78a6f5e4e48996f3ed7722e</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git prune</span></span><br></pre></td></tr></table></figure>

<p>使用<code>git prune </code>可以进行垃圾清理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo5 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git prune</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo5</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO5\.GIT\OBJECTS</span><br><span class="line">├─8a</span><br><span class="line">│      7e3772b496dcaa2c11ede0d3397371529fe0f1</span><br><span class="line">│</span><br><span class="line">├─a5</span><br><span class="line">│      bce3fd2565d8f458555a0c6f42d0504a848bd5</span><br><span class="line">│</span><br><span class="line">├─c0</span><br><span class="line">│      da834e42dcbf7b2b1c4a97925bef105d3863a3</span><br><span class="line">│</span><br><span class="line">├─ec</span><br><span class="line">│      1fd8c3998b32051be0c19affdd49c20e4938fe</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">└─pack</span><br></pre></td></tr></table></figure>

<h3 id="18-本地分支和远程分支"><a href="#18-本地分支和远程分支" class="headerlink" title="18. 本地分支和远程分支"></a>18. 本地分支和远程分支</h3><p>新建文件夹，将远程仓库克隆到本地</p>
<h3 id="19-git-fetch-amp-git-pull"><a href="#19-git-fetch-amp-git-pull" class="headerlink" title="19. git fetch &amp; git pull"></a>19. git fetch &amp; git pull</h3><h3 id="20-fetch-head"><a href="#20-fetch-head" class="headerlink" title="20. fetch_head"></a>20. fetch_head</h3><h3 id="21-git-pull"><a href="#21-git-pull" class="headerlink" title="21. git pull"></a>21. git pull</h3><h3 id="22-本地git-hook"><a href="#22-本地git-hook" class="headerlink" title="22. 本地git hook"></a>22. 本地git hook</h3><h3 id="23-pre-commit钩子"><a href="#23-pre-commit钩子" class="headerlink" title="23. pre-commit钩子"></a>23. pre-commit钩子</h3><h3 id="24-git-hook和python"><a href="#24-git-hook和python" class="headerlink" title="24. git hook和python"></a>24. git hook和python</h3>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>个人分享平台构建（博客搭建篇）——Hexo + Next + Github</title>
    <url>/2021/09/17/%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB%E5%B9%B3%E5%8F%B0%E6%9E%84%E5%BB%BA%EF%BC%88%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AF%87%EF%BC%89%E2%80%94%E2%80%94Hexo%20+%20Next%20+%20Github/</url>
    <content><![CDATA[<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><h4 id="1-1-1-安装前提"><a href="#1-1-1-安装前提" class="headerlink" title="1.1.1 安装前提"></a>1.1.1 安装前提</h4><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p>
<ul>
<li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li>
<li><a href="http://git-scm.com/">Git</a></li>
</ul>
<h4 id="1-1-2-安装-Node-js"><a href="#1-1-2-安装-Node-js" class="headerlink" title="1.1.2 安装 Node.js"></a>1.1.2 安装 Node.js</h4><p>简单的说 <strong>Node.js</strong> 就是运行在服务端的 JavaScript。**Node.js **是一个基于Chrome JavaScript 运行时建立的一个平台。</p>
<p><strong>Node.js</strong>是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p>
<p><strong>Node.js</strong> 为大多数平台提供了官方的 <a href="https://nodejs.org/en/download/">安装程序</a>。也可以前往 <a href="https://npm.taobao.org/mirrors/node">淘宝 Node.js 镜像</a> 下载。</p>
<p>其它的安装方法：</p>
<ul>
<li>Windows：通过 <a href="https://github.com/jasongin/nvs/">nvs</a>（推荐）或者<a href="https://github.com/nvm-sh/nvm">nvm</a> 安装。</li>
<li>Mac：使用 <a href="https://brew.sh/">Homebrew</a> 或 <a href="http://www.macports.org/">MacPorts</a> 安装。</li>
<li>Linux（DEB/RPM-based）：从 <a href="https://github.com/nodesource/distributions">NodeSource</a> 安装。</li>
<li>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 <a href="https://nodejs.org/en/download/package-manager/">指导</a></li>
</ul>
<p>对于 Mac 和 Linux 同样建议使用 nvs 或者 nvm，以避免可能会出现的权限问题。</p>
<blockquote>
<p><strong>Windows 用户</strong></p>
<p>使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）</p>
</blockquote>
<blockquote>
<p><strong>For Mac / Linux 用户</strong></p>
<p>如果在尝试安装 Hexo 的过程中出现 <code>EACCES</code> 权限错误，请遵循 <a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally">由 npmjs 发布的指导</a> 修复该问题。建议 <strong>不要</strong> 使用 root、sudo 等方法覆盖权限</p>
</blockquote>
<blockquote>
<p><strong>Linux</strong></p>
<p>‎如果您使用Snap安装了<strong>Node.js</strong>，在‎<a href="https://hexo.io/docs/commands#init">‎初始化‎</a>‎博客时，您可能需要手动运行在目标文件夹中。‎<code>npm install</code></p>
</blockquote>
<h4 id="1-1-3-安装-Git"><a href="#1-1-3-安装-Git" class="headerlink" title="1.1.3 安装 Git"></a>1.1.3 安装 Git</h4><ul>
<li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>.</li>
<li>Mac：使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li>
<li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li>
<li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li>
</ul>
<blockquote>
<p><strong>Mac 用户</strong></p>
<p>如果在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> 安装命令行工具。</p>
</blockquote>
<blockquote>
<p><strong>Windows 用户</strong></p>
<p>前往 <a href="https://npm.taobao.org/mirrors/git-for-windows/">淘宝 Git for Windows 镜像</a> 下载 git 安装包。</p>
</blockquote>
<h4 id="1-1-4-安装-Hexo"><a href="#1-1-4-安装-Hexo" class="headerlink" title="1.1.4 安装 Hexo"></a>1.1.4 安装 Hexo</h4><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h4 id="1-1-5-进阶安装和使用"><a href="#1-1-5-进阶安装和使用" class="headerlink" title="1.1.5 进阶安装和使用"></a>1.1.5 进阶安装和使用</h4><p>对于熟悉 npm 的进阶用户，可以仅局部安装 <code>hexo</code> 包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo</span><br></pre></td></tr></table></figure>

<p>安装以后，可以使用以下两种方式执行 Hexo：</p>
<ol>
<li><p><code>npx hexo &lt;command&gt;</code></p>
</li>
<li><p>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;PATH&#x3D;&quot;$PATH:.&#x2F;node_modules&#x2F;.bin&quot;&#39; &gt;&gt; ~&#x2F;.profile</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="1-1-6-Node-js-版本限制"><a href="#1-1-6-Node-js-版本限制" class="headerlink" title="1.1.6 Node.js 版本限制"></a>1.1.6 Node.js 版本限制</h4><p>我们强烈建议永远安装最新版本的 Hexo，以及 <a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90">推荐的 Node.js 版本</a>。</p>
<table>
<thead>
<tr>
<th align="left">Hexo 版本</th>
<th align="center">最低兼容 Node.js 版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">5.0+</td>
<td align="center">10.13.0</td>
</tr>
<tr>
<td align="left">4.1 - 4.2</td>
<td align="center">8.10</td>
</tr>
<tr>
<td align="left">4.0</td>
<td align="center">8.6</td>
</tr>
<tr>
<td align="left">3.3 - 3.9</td>
<td align="center">6.9</td>
</tr>
<tr>
<td align="left">3.2 - 3.3</td>
<td align="center">0.12</td>
</tr>
<tr>
<td align="left">3.0 - 3.1</td>
<td align="center">0.10 or iojs</td>
</tr>
<tr>
<td align="left">0.0.1 - 2.8</td>
<td align="center">0.10</td>
</tr>
</tbody></table>
<h3 id="2-建站"><a href="#2-建站" class="headerlink" title="2 建站"></a>2 建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<h4 id="2-1-config-yml"><a href="#2-1-config-yml" class="headerlink" title="2.1 _config.yml"></a>2.1 _config.yml</h4><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p>
<h4 id="2-2-package-json"><a href="#2-2-package-json" class="headerlink" title="2.2 package.json"></a>2.2 package.json</h4><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package.json&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;hexo&quot;: &quot;^3.8.0&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class="line">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^0.3.3&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-scaffolds"><a href="#2-3-scaffolds" class="headerlink" title="2.3 scaffolds"></a>2.3 scaffolds</h4><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>
<p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>
<h4 id="2-4-source"><a href="#2-4-source" class="headerlink" title="2.4 source"></a>2.4 source</h4><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p>
<h4 id="2-5-themes"><a href="#2-5-themes" class="headerlink" title="2.5 themes"></a>2.5 themes</h4><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p>
<h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3 配置"></a>3 配置</h3><p>您可以在 <code>_config.yml</code> 中修改大部分的配置。</p>
<h4 id="3-1-网站"><a href="#3-1-网站" class="headerlink" title="3.1 网站"></a>3.1 网站</h4><hr>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>title</code></td>
<td align="left">网站标题</td>
</tr>
<tr>
<td align="left"><code>subtitle</code></td>
<td align="left">网站副标题</td>
</tr>
<tr>
<td align="left"><code>description</code></td>
<td align="left">网站描述</td>
</tr>
<tr>
<td align="left"><code>keywords</code></td>
<td align="left">网站的关键词。支持多个关键词。</td>
</tr>
<tr>
<td align="left"><code>author</code></td>
<td align="left">您的名字</td>
</tr>
<tr>
<td align="left"><code>language</code></td>
<td align="left">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td>
</tr>
<tr>
<td align="left"><code>timezone</code></td>
<td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td>
</tr>
</tbody></table>
<p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p>
<h4 id="3-2-网址"><a href="#3-2-网址" class="headerlink" title="3.2 网址"></a>3.2 网址</h4><hr>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>url</code></td>
<td align="left">网址, must starts with <code>http://</code> or <code>https://</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>root</code></td>
<td align="left">网站根目录</td>
<td align="left"><code>url&#39;s pathname</code></td>
</tr>
<tr>
<td align="left"><code>permalink</code></td>
<td align="left">文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式</td>
<td align="left"><code>:year/:month/:day/:title/</code></td>
</tr>
<tr>
<td align="left"><code>permalink_defaults</code></td>
<td align="left">永久链接中各部分的默认值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>pretty_urls</code></td>
<td align="left">改写 <a href="https://hexo.io/zh-cn/docs/variables"><code>permalink</code></a> 的值来美化 URL</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>pretty_urls.trailing_index</code></td>
<td align="left">是否在永久链接中保留尾部的 <code>index.html</code>，设置为 <code>false</code> 时去除</td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left"><code>pretty_urls.trailing_html</code></td>
<td align="left">是否在永久链接中保留尾部的 <code>.html</code>, 设置为 <code>false</code> 时去除 (<em>对尾部的 <code>index.html</code>无效</em>)</td>
<td align="left"><code>true</code></td>
</tr>
</tbody></table>
<blockquote>
<p>网站存放在子目录</p>
<p>如果您的网站存放在子目录中，例如 <code>http://example.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://example.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 比如，一个页面的永久链接是 http:&#x2F;&#x2F;example.com&#x2F;foo&#x2F;bar&#x2F;index.html</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: false</span><br><span class="line"># 此时页面的永久链接会变为 http:&#x2F;&#x2F;example.com&#x2F;foo&#x2F;bar&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-目录"><a href="#3-3-目录" class="headerlink" title="3.3 目录"></a>3.3 目录</h4><hr>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>source_dir</code></td>
<td align="left">资源文件夹，这个文件夹用来存放内容。</td>
<td align="left"><code>source</code></td>
</tr>
<tr>
<td align="left"><code>public_dir</code></td>
<td align="left">公共文件夹，这个文件夹用于存放生成的站点文件。</td>
<td align="left"><code>public</code></td>
</tr>
<tr>
<td align="left"><code>tag_dir</code></td>
<td align="left">标签文件夹</td>
<td align="left"><code>tags</code></td>
</tr>
<tr>
<td align="left"><code>archive_dir</code></td>
<td align="left">归档文件夹</td>
<td align="left"><code>archives</code></td>
</tr>
<tr>
<td align="left"><code>category_dir</code></td>
<td align="left">分类文件夹</td>
<td align="left"><code>categories</code></td>
</tr>
<tr>
<td align="left"><code>code_dir</code></td>
<td align="left">Include code 文件夹，<code>source_dir</code> 下的子目录</td>
<td align="left"><code>downloads/code</code></td>
</tr>
<tr>
<td align="left"><code>i18n_dir</code></td>
<td align="left">国际化（i18n）文件夹</td>
<td align="left"><code>:lang</code></td>
</tr>
<tr>
<td align="left"><code>skip_render</code></td>
<td align="left">跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 <code>public</code> 目录中。您可使用 <a href="https://github.com/micromatch/micromatch#extended-globbing">glob 表达式</a>来匹配路径。</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skip_render: &quot;mypage&#x2F;**&#x2F;*&quot;</span><br><span class="line"># 将会直接将 &#96;source&#x2F;mypage&#x2F;index.html&#96; 和 &#96;source&#x2F;mypage&#x2F;code.js&#96; 不做改动地输出到 &#39;public&#39; 目录</span><br><span class="line"># 你也可以用这种方法来跳过对指定文章文件的渲染</span><br><span class="line">skip_render: &quot;_posts&#x2F;test-post.md&quot;</span><br><span class="line"># 这将会忽略对 &#39;test-post.md&#39; 的渲染</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示</p>
<p>如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p>
</blockquote>
<h4 id="3-4-文章"><a href="#3-4-文章" class="headerlink" title="3.4 文章"></a>3.4 文章</h4><hr>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>new_post_name</code></td>
<td align="left">新文章的文件名称</td>
<td align="left">:title.md</td>
</tr>
<tr>
<td align="left"><code>default_layout</code></td>
<td align="left">预设布局</td>
<td align="left">post</td>
</tr>
<tr>
<td align="left"><code>auto_spacing</code></td>
<td align="left">在中文和英文之间加入空格</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><code>titlecase</code></td>
<td align="left">把标题转换为 title case</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><code>external_link</code></td>
<td align="left">在新标签中打开链接</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><code>external_link.enable</code></td>
<td align="left">在新标签中打开链接</td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left"><code>external_link.field</code></td>
<td align="left">对整个网站（<code>site</code>）生效或仅对文章（<code>post</code>）生效</td>
<td align="left"><code>site</code></td>
</tr>
<tr>
<td align="left"><code>external_link.exclude</code></td>
<td align="left">需要排除的域名。主域名和子域名如 <code>www</code> 需分别配置</td>
<td align="left"><code>[]</code></td>
</tr>
<tr>
<td align="left"><code>filename_case</code></td>
<td align="left">把文件名称转换为 (1) 小写或 (2) 大写</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left"><code>render_drafts</code></td>
<td align="left">显示草稿</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><code>post_asset_folder</code></td>
<td align="left">启动 <a href="https://hexo.io/zh-cn/docs/asset-folders">Asset 文件夹</a></td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><code>relative_link</code></td>
<td align="left">把链接改为与根目录的相对位址</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><code>future</code></td>
<td align="left">显示未来的文章</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><code>highlight</code></td>
<td align="left">代码块的设置, see <a href="https://hexo.io/docs/syntax-highlight#Highlight-js">Highlight.js</a> section for usage guide</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>prismjs</code></td>
<td align="left">代码块的设置, see <a href="https://hexo.io/docs/syntax-highlight#PrismJS">PrismJS</a> section for usage guide</td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p>相对地址</p>
<p>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 <code>example.com</code>,您有一篇文章名为 <code>hello</code>，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是<strong>绝对</strong>于域名的。相对链接像这样：<code>/hello.html</code>，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p>
</blockquote>
<h4 id="3-5-分类-amp-标签"><a href="#3-5-分类-amp-标签" class="headerlink" title="3.5 分类 &amp; 标签"></a>3.5 分类 &amp; 标签</h4><hr>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>default_category</code></td>
<td align="left">默认分类</td>
<td align="left"><code>uncategorized</code></td>
</tr>
<tr>
<td align="left"><code>category_map</code></td>
<td align="left">分类别名</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>tag_map</code></td>
<td align="left">标签别名</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="3-6-日期-时间格式"><a href="#3-6-日期-时间格式" class="headerlink" title="3.6 日期 / 时间格式"></a>3.6 日期 / 时间格式</h4><hr>
<p>Hexo 使用 <a href="http://momentjs.com/">Moment.js</a> 来解析和显示时间。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>date_format</code></td>
<td align="left">日期格式</td>
<td align="left"><code>YYYY-MM-DD</code></td>
</tr>
<tr>
<td align="left"><code>time_format</code></td>
<td align="left">时间格式</td>
<td align="left"><code>HH:mm:ss</code></td>
</tr>
<tr>
<td align="left"><code>updated_option</code></td>
<td align="left">当 Front Matter 中没有指定 <a href="https://hexo.io/zh-cn/docs/variables#%E9%A1%B5%E9%9D%A2%E5%8F%98%E9%87%8F"><code>updated</code></a> 时 <code>updated</code> 的取值</td>
<td align="left"><code>mtime</code></td>
</tr>
</tbody></table>
<blockquote>
<p>updated_option</p>
<p><code>updated_option</code> 控制了当 Front Matter 中没有指定 <code>updated</code> 时，<code>updated</code> 如何取值：</p>
<ul>
<li><code>mtime</code>: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。</li>
<li><code>date</code>: 使用 <code>date</code> 作为 <code>updated</code> 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变</li>
<li><code>empty</code>: 直接删除 <code>updated</code>。使用这一选项可能会导致大部分主题和插件无法正常工作。</li>
</ul>
<p><code>use_date_for_updated</code> 选项已经被废弃，将会在下个重大版本发布时去除。请改为使用 <code>updated_option: &#39;date&#39;</code>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use_date_for_updated&#96; | 启用以后，如果 Front Matter 中没有指定 &#96;updated&#96;， [&#96;post.updated&#96;](https:&#x2F;&#x2F;hexo.io&#x2F;zh-cn&#x2F;docs&#x2F;configuration) 将会使用 &#96;date&#96; 的值而不是文件的创建时间。在 Git 工作流中这个选项会很有用 | &#96;true</span><br></pre></td></tr></table></figure>

<h4 id="3-7-分页"><a href="#3-7-分页" class="headerlink" title="3.7 分页"></a>3.7 分页</h4><hr>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>per_page</code></td>
<td align="left">每页显示的文章量 (0 = 关闭分页功能)</td>
<td align="left"><code>10</code></td>
</tr>
<tr>
<td align="left"><code>pagination_dir</code></td>
<td align="left">分页目录</td>
<td align="left"><code>page</code></td>
</tr>
</tbody></table>
<h4 id="3-8-扩展"><a href="#3-8-扩展" class="headerlink" title="3.8 扩展"></a>3.8 扩展</h4><hr>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>theme</code></td>
<td align="left">当前主题名称。值为<code>false</code>时禁用主题</td>
</tr>
<tr>
<td align="left"><code>theme_config</code></td>
<td align="left">主题的配置文件。在这里放置的配置会覆盖主题目录下的 <code>_config.yml</code> 中的配置</td>
</tr>
<tr>
<td align="left"><code>deploy</code></td>
<td align="left">部署部分的设置</td>
</tr>
<tr>
<td align="left"><code>meta_generator</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#%E5%B1%9E%E6%80%A7">Meta generator</a> 标签。 值为 <code>false</code> 时 Hexo 不会在头部插入该标签</td>
</tr>
</tbody></table>
<h4 id="3-9-包括或不包括目录和文件"><a href="#3-9-包括或不包括目录和文件" class="headerlink" title="3.9 包括或不包括目录和文件"></a>3.9 包括或不包括目录和文件</h4><hr>
<p>在 Hexo 配置文件中，通过设置 include/exclude 可以让 Hexo 进行处理或忽略某些目录和文件夹。你可以使用 <a href="https://github.com/isaacs/minimatch">glob 表达式</a> 对目录和文件进行匹配。</p>
<p><code>include</code> and <code>exclude</code> options only apply to the <code>source/</code> folder, whereas <code>ignore</code> option applies to all folders.</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>include</code></td>
<td align="left">Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 <code>.</code> 开头的文件和文件夹，Hexo 的 <code>_posts</code> 和 <code>_data</code> 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 <code>source</code> 目录下。</td>
</tr>
<tr>
<td align="left"><code>exclude</code></td>
<td align="left">Hexo 会忽略这些文件和目录</td>
</tr>
<tr>
<td align="left"><code>ignore</code></td>
<td align="left">Ignore files/folders</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Include&#x2F;Exclude Files&#x2F;Folders</span><br><span class="line">include:</span><br><span class="line">  - &quot;.nojekyll&quot;</span><br><span class="line">  # 包括 &#39;source&#x2F;css&#x2F;_typing.css&#39;</span><br><span class="line">  - &quot;css&#x2F;_typing.css&quot;</span><br><span class="line">  # 包括 &#39;source&#x2F;_css&#x2F;&#39; 中的任何文件，但不包括子目录及其其中的文件。</span><br><span class="line">  - &quot;_css&#x2F;*&quot;</span><br><span class="line">  # 包含 &#39;source&#x2F;_css&#x2F;&#39; 中的任何文件和子目录下的任何文件</span><br><span class="line">  - &quot;_css&#x2F;**&#x2F;*&quot;</span><br><span class="line"></span><br><span class="line">exclude:</span><br><span class="line">  # 不包括 &#39;source&#x2F;js&#x2F;test.js&#39;</span><br><span class="line">  - &quot;js&#x2F;test.js&quot;</span><br><span class="line">  # 不包括 &#39;source&#x2F;js&#x2F;&#39; 中的文件、但包括子目录下的所有目录和文件</span><br><span class="line">  - &quot;js&#x2F;*&quot;</span><br><span class="line">  # 不包括 &#39;source&#x2F;js&#x2F;&#39; 中的文件和子目录下的任何文件</span><br><span class="line">  - &quot;js&#x2F;**&#x2F;*&quot;</span><br><span class="line">  # 不包括 &#39;source&#x2F;js&#x2F;&#39; 目录下的所有文件名以 &#39;test&#39; 开头的文件，但包括其它文件和子目录下的单文件</span><br><span class="line">  - &quot;js&#x2F;test*&quot;</span><br><span class="line">  # 不包括 &#39;source&#x2F;js&#x2F;&#39; 及其子目录中任何以 &#39;test&#39; 开头的文件</span><br><span class="line">  - &quot;js&#x2F;**&#x2F;test*&quot;</span><br><span class="line">  # 不要用 exclude 来忽略 &#39;source&#x2F;_posts&#x2F;&#39; 中的文件。你应该使用 &#39;skip_render&#39;，或者在要忽略的文件的文件名之前加一个下划线 &#39;_&#39;</span><br><span class="line">  # 在这里配置一个 - &quot;_posts&#x2F;hello-world.md&quot; 是没有用的。</span><br><span class="line"></span><br><span class="line">ignore:</span><br><span class="line">  # Ignore any folder named &#39;foo&#39;.</span><br><span class="line">  - &quot;**&#x2F;foo&quot;</span><br><span class="line">  # Ignore &#39;foo&#39; folder in &#39;themes&#x2F;&#39; only.</span><br><span class="line">  - &quot;**&#x2F;themes&#x2F;*&#x2F;foo&quot;</span><br><span class="line">  # Same as above, but applies to every subfolders of &#39;themes&#x2F;&#39;.</span><br><span class="line">  - &quot;**&#x2F;themes&#x2F;**&#x2F;foo&quot;</span><br></pre></td></tr></table></figure>

<p>列表中的每一项都必须用单引号或双引号包裹起来。</p>
<p><code>include</code> 和 <code>exclude</code> 并不适用于 <code>themes/</code> 目录下的文件。如果需要忽略 <code>themes/</code> 目录下的部分文件或文件夹，可以使用 <code>ignore</code> 或在文件名之前添加下划线 <code>_</code>。</p>
<h4 id="3-10-使用代替配置文件"><a href="#3-10-使用代替配置文件" class="headerlink" title="3.10 使用代替配置文件"></a>3.10 使用代替配置文件</h4><hr>
<p>可以在 hexo-cli 中使用 <code>--config</code> 参数来指定自定义配置文件的路径。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># use &#39;custom.yml&#39; in place of &#39;_config.yml&#39;</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># use &#39;custom.yml&#39; &amp; &#39;custom2.json&#39;, prioritizing &#39;custom3.yml&#39;, then &#39;custom2.json&#39;</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>

<p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p>
<p>例如，使用 <code>--options</code> 指定了两个自定义配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate --config custom.yml,custom2.json</span><br></pre></td></tr></table></figure>

<p>如果 <code>custom.yml</code> 中指定了 <code>foo: bar</code>，在 custom2.json 中指定了 <code>&quot;foo&quot;: &quot;dinosaur&quot;</code>，那么在 <code>_multiconfig.yml</code> 中你会得到 <code>foo: dinosaur</code>。</p>
<h4 id="3-11-使用代替主题配置文件"><a href="#3-11-使用代替主题配置文件" class="headerlink" title="3.11 使用代替主题配置文件"></a>3.11 使用代替主题配置文件</h4><hr>
<p>通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 <code>_config.yml</code> 配置文件。</p>
<p>除了自行维护独立的主题配置文件，你也可以在其它地方对主题进行配置。</p>
<p><strong>配置文件中的 <code>theme_config</code></strong></p>
<blockquote>
<p>该特性自 Hexo 2.8.2 起提供</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># _config.yml</span><br><span class="line">theme: &quot;my-theme&quot;</span><br><span class="line">theme_config:</span><br><span class="line">  bio: &quot;My awesome bio&quot;</span><br><span class="line">  foo:</span><br><span class="line">    bar: &#39;a&#39;</span><br><span class="line"># themes&#x2F;my-theme&#x2F;_config.yml</span><br><span class="line">bio: &quot;Some generic bio&quot;</span><br><span class="line">logo: &quot;a-cool-image.png&quot;</span><br><span class="line">  foo:</span><br><span class="line">    baz: &#39;b&#39;</span><br></pre></td></tr></table></figure>

<p>最终主题配置的输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  bio: &quot;My awesome bio&quot;,</span><br><span class="line">  logo: &quot;a-cool-image.png&quot;,</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: &quot;a&quot;,</span><br><span class="line">    baz: &quot;b&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>独立的 <code>_config.[theme].yml</code> 文件</strong></p>
<blockquote>
<p>该特性自 Hexo 5.0.0 起提供</p>
</blockquote>
<p>独立的主题配置文件应放置于站点根目录下，支持 <code>yml</code> 或 <code>json</code> 格式。需要配置站点 <code>_config.yml</code> 文件中的 <code>theme</code> 以供 Hexo 寻找 <code>_config.[theme].yml</code> 文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># _config.yml</span><br><span class="line">theme: &quot;my-theme&quot;</span><br><span class="line"># _config.my-theme.yml</span><br><span class="line">bio: &quot;My awesome bio&quot;</span><br><span class="line">foo:</span><br><span class="line">  bar: &#39;a&#39;</span><br><span class="line"># themes&#x2F;my-theme&#x2F;_config.yml</span><br><span class="line">bio: &quot;Some generic bio&quot;</span><br><span class="line">logo: &quot;a-cool-image.png&quot;</span><br><span class="line">  foo:</span><br><span class="line">    baz: &#39;b&#39;</span><br></pre></td></tr></table></figure>

<p>最终主题配置的输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  bio: &quot;My awesome bio&quot;,</span><br><span class="line">  logo: &quot;a-cool-image.png&quot;,</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: &quot;a&quot;,</span><br><span class="line">    baz: &quot;b&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议将所有的主题配置集中在一处。如果不得不在多处配置你的主题，注意以下信息：Hexo 在合并主题配置时，Hexo 配置文件中的 <code>theme_config</code> 的优先级最高，其次是 <code>_config.[theme].yml</code> 文件，最后是位于主题目录下的 <code>_config.yml</code> 文件。</p>
</blockquote>
<h3 id="4-指令"><a href="#4-指令" class="headerlink" title="4 指令"></a>4 指令</h3><h4 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure>

<p>新建一个网站。 如果没有设置 ，Hexo 默认在目前的文件夹建立网站。<code>folder</code></p>
<p>此命令是运行以下步骤的快捷方式：</p>
<ol>
<li>Git 克隆<a href="https://github.com/hexojs/hexo-starter">hexo 启动器</a>，包括<a href="https://github.com/hexojs/hexo-theme-landscape">hexo 主题</a>到当前目录或目标文件夹（如果指定）。</li>
<li>使用包管理器安装依赖项：<a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、pnpm 或<a href="https://docs.npmjs.com/cli/install">npm，</a>以安装者为准： 如果安装了多个，则优先级将列出。默认情况下npm与Node.js捆绑。</li>
</ol>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure>

<p>列出网站资料。</p>
<h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure>

<p>显示 Hexo 版本。</p>
<h4 id="4-1-新增功能"><a href="#4-1-新增功能" class="headerlink" title="4.1 新增功能"></a>4.1 新增功能</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>新建一篇文章。 如果没有设置 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 参数代替。 如果标题包含空格的话，请使用引号括起来。<code>layout``default_layout</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>,<code>--path</code></td>
<td align="left">自定义新文章的路径</td>
</tr>
<tr>
<td align="left"><code>-r</code>,<code>--replace</code></td>
<td align="left">如果存在同名文章，将其替换</td>
</tr>
<tr>
<td align="left"><code>-s</code>,<code>--slug</code></td>
<td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td>
</tr>
</tbody></table>
<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。 对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 文件。 你可以使用 参数来覆盖上述行为、自行决定文件的目录：<code>index.md``--path</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me &quot;About me&quot;</span><br></pre></td></tr></table></figure>

<p>以上命令会创建一个 文件，同时 Front Matter 中的 title 为 <code>source/about/me.md``&quot;About me&quot;</code></p>
<p>注意！ title 是必须指定的！ 如果你这么做并不能达到你的目的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me</span><br></pre></td></tr></table></figure>

<p>此时 Hexo 会创建 ，同时 的 Front Matter 中的 title 为 。 这是因为在上述命令中，hexo-cli 将 视为指定文章的标题、并采用默认的 。<code>source/_posts/about/me.md``me.md``&quot;page&quot;``page``layout</code></p>
<h4 id="4-2-生成"><a href="#4-2-生成" class="headerlink" title="4.2 生成"></a>4.2 生成</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>生成静态文件。</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-d</code>,<code>--deploy</code></td>
<td align="left">文件生成后立即部署网站</td>
</tr>
<tr>
<td align="left"><code>-w</code>,<code>--watch</code></td>
<td align="left">监视文件变动</td>
</tr>
<tr>
<td align="left"><code>-b</code>,<code>--bail</code></td>
<td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td>
</tr>
<tr>
<td align="left"><code>-f</code>,<code>--force</code></td>
<td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 目录存在，那么 只会重新生成改动的文件。 使用该参数的效果接近 <code>public``hexo g``hexo clean &amp;&amp; hexo generate</code></td>
</tr>
<tr>
<td align="left"><code>-c</code>,<code>--concurrency</code></td>
<td align="left">最大同时生成文件的数量，默认无限制</td>
</tr>
</tbody></table>
<p>该命令可以简写为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<h4 id="4-3-发布"><a href="#4-3-发布" class="headerlink" title="4.3 发布"></a>4.3 发布</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>发表草稿。</p>
<h4 id="4-4-服务器"><a href="#4-4-服务器" class="headerlink" title="4.4 服务器"></a>4.4 服务器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>启动服务器。 默认情况下，访问网址为： 。<code>http://localhost:4000/</code></p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>,<code>--port</code></td>
<td align="left">重设端口</td>
</tr>
<tr>
<td align="left"><code>-s</code>,<code>--static</code></td>
<td align="left">只使用静态文件</td>
</tr>
<tr>
<td align="left"><code>-l</code>,<code>--log</code></td>
<td align="left">启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody></table>
<h4 id="4-5-部署"><a href="#4-5-部署" class="headerlink" title="4.5 部署"></a>4.5 部署</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>部署网站。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-g</code>,<code>--generate</code></td>
<td align="left">部署之前预先生成静态文件</td>
</tr>
</tbody></table>
<p>该命令可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<h4 id="4-6-呈现"><a href="#4-6-呈现" class="headerlink" title="4.6 呈现"></a>4.6 呈现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>

<p>渲染文件。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-o</code>,<code>--output</code></td>
<td align="left">设置输出路径</td>
</tr>
</tbody></table>
<h4 id="4-7-迁移"><a href="#4-7-迁移" class="headerlink" title="4.7 迁移"></a>4.7 迁移</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure>

<p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p>
<h4 id="4-8-清理"><a href="#4-8-清理" class="headerlink" title="4.8 清理"></a>4.8 清理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>

<p>清除缓存文件 () 和已生成的静态文件 ()。<code>db.json``public</code></p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<h4 id="4-9-选项"><a href="#4-9-选项" class="headerlink" title="4.9 选项"></a>4.9 选项</h4><h5 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure>

<p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>
<h5 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure>

<p>在终端中显示调试信息并记录到 。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new">提交调试信息到 GitHub</a>。<code>debug.log</code></p>
<h5 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure>

<p>隐藏终端信息。</p>
<h5 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>

<p>自定义配置文件的路径，指定这个参数后将不再使用默认的 。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。 例如：<code>_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>

<p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 。 如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。 这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。<code>_multiconfig.yml</code></p>
<h5 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure>

<p>显示 文件夹中的草稿文章。<code>source/_drafts</code></p>
<h5 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --cwd &#x2F;path&#x2F;to&#x2F;cwd</span><br></pre></td></tr></table></figure>

<p>自定义当前工作目录（Current working directory）的路径。</p>
<h3 id="5-迁移"><a href="#5-迁移" class="headerlink" title="5 迁移"></a>5 迁移</h3><h4 id="5-1-RSS"><a href="#5-1-RSS" class="headerlink" title="5.1 RSS"></a>5.1 RSS</h4><p>首先，安装 <code>hexo-migrator-rss</code> 插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-migrator-rss --save</span><br></pre></td></tr></table></figure>

<p>插件安装完成后，执行下列命令，从 RSS 迁移所有文章。<code>source</code> 可以是文件路径或网址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo migrate rss &lt;source&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-Jekyll"><a href="#5-2-Jekyll" class="headerlink" title="5.2 Jekyll"></a>5.2 Jekyll</h4><p>把 <code>_posts</code> 文件夹内的所有文件复制到 <code>source/_posts</code> 文件夹，并在 <code>_config.yml</code> 中修改 <code>new_post_name</code> 参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure>

<h4 id="5-3-Octopress"><a href="#5-3-Octopress" class="headerlink" title="5.3 Octopress"></a>5.3 Octopress</h4><p>把 Octopress <code>source/_posts</code> 文件夹内的所有文件转移到 Hexo 的 <code>source/_posts</code> 文件夹，并修改 <code>_config.yml</code> 中的 <code>new_post_name</code> 参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure>

<h4 id="5-4-WordPress"><a href="#5-4-WordPress" class="headerlink" title="5.4 WordPress"></a>5.4 WordPress</h4><p>首先，安装 <code>hexo-migrator-wordpress</code> 插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-migrator-wordpress --save</span><br></pre></td></tr></table></figure>

<p>在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)（详情参考<a href="http://en.support.wordpress.com/export/">WP支持页面</a>）。</p>
<p>插件安装完成后，执行下列命令来迁移所有文章。<code>source</code> 可以是 WordPress 导出的文件路径或网址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo migrate wordpress &lt;source&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>这个插件并不能完美地实现WordPress-&gt;Hexo的数据转换，尤其是在处理WordPress的分类方面存在问题（见<a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter中的分类与标签</a>）。因此，建议您在迁移完成后，手工审阅所有生成的markdown文件，检查其中是否有错误。对于文章数量较大的WordPress站点，这项工作可能要花很长的时间。</p>
</blockquote>
<h4 id="5-5-Joomla"><a href="#5-5-Joomla" class="headerlink" title="5.5 Joomla"></a>5.5 Joomla</h4><p>首先，安装 <code>hexo-migrator-joomla</code> 插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-migrator-joomla --save</span><br></pre></td></tr></table></figure>

<p>使用 <a href="http://extensions.joomla.org/extensions/migration-a-conversion/data-import-a-export/12816?qh=YToxOntpOjA7czo1OiJqMnhtbCI7fQ==">J2XML</a> 组件导出 Joomla 文章。<br>插件安装完成后，执行下列命令来迁移所有文章。<code>source</code> 可以是 Joomla 导出的文件路径或网址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo migrate joomla &lt;source&gt;</span><br></pre></td></tr></table></figure>

<h3 id="6-写作"><a href="#6-写作" class="headerlink" title="6 写作"></a>6 写作</h3><p>你可以执行下列命令来创建一篇新文章或者新的页面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p>
<h4 id="6-1-布局（Layout）"><a href="#6-1-布局（Layout）" class="headerlink" title="6.1 布局（Layout）"></a>6.1 布局（Layout）</h4><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p>
<table>
<thead>
<tr>
<th align="left">布局</th>
<th align="left">路径</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>post</code></td>
<td align="left"><code>source/_posts</code></td>
</tr>
<tr>
<td align="left"><code>page</code></td>
<td align="left"><code>source</code></td>
</tr>
<tr>
<td align="left"><code>draft</code></td>
<td align="left"><code>source/_drafts</code></td>
</tr>
</tbody></table>
<blockquote>
<p>Disabling layout</p>
<p>If you don’t want an article (post/page) to be processed with a theme, set <code>layout: false</code> in its front-matter. Refer to <a href="https://hexo.io/zh-cn/docs/front-matter#%E5%B8%83%E5%B1%80">this section</a> for more details.</p>
</blockquote>
<h4 id="6-2-文件名称"><a href="#6-2-文件名称" class="headerlink" title="6.2 文件名称"></a>6.2 文件名称</h4><p>Hexo 默认以标题做为文件名称，但您可编辑 <code>new_post_name</code> 参数来改变默认的文件名称，举例来说，设为 <code>:year-:month-:day-:title.md</code> 可让您更方便的通过日期来管理文章。</p>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>:title</code></td>
<td align="left">标题（小写，空格将会被替换为短杠）</td>
</tr>
<tr>
<td align="left"><code>:year</code></td>
<td align="left">建立的年份，比如， <code>2015</code></td>
</tr>
<tr>
<td align="left"><code>:month</code></td>
<td align="left">建立的月份（有前导零），比如， <code>04</code></td>
</tr>
<tr>
<td align="left"><code>:i_month</code></td>
<td align="left">建立的月份（无前导零），比如， <code>4</code></td>
</tr>
<tr>
<td align="left"><code>:day</code></td>
<td align="left">建立的日期（有前导零），比如， <code>07</code></td>
</tr>
<tr>
<td align="left"><code>:i_day</code></td>
<td align="left">建立的日期（无前导零），比如， <code>7</code></td>
</tr>
</tbody></table>
<h4 id="6-3-草稿"><a href="#6-3-草稿" class="headerlink" title="6.3 草稿"></a>6.3 草稿</h4><p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p>
<h4 id="6-4-模版（Scaffold）"><a href="#6-4-模版（Scaffold）" class="headerlink" title="6.4 模版（Scaffold）"></a>6.4 模版（Scaffold）</h4><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure>

<p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>layout</code></td>
<td align="left">布局</td>
</tr>
<tr>
<td align="left"><code>title</code></td>
<td align="left">标题</td>
</tr>
<tr>
<td align="left"><code>date</code></td>
<td align="left">文件建立日期</td>
</tr>
</tbody></table>
<h4 id="6-5-支持的格式"><a href="#6-5-支持的格式" class="headerlink" title="6.5 支持的格式"></a>6.5 支持的格式</h4><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p>
<p>例如，Hexo 默认安装了 <code>hexo-renderer-marked</code> 和 <code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 <code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p>
<p>只需要将文章的扩展名从 <code>md</code> 改成 <code>ejs</code>，Hexo 就会使用 <code>hexo-renderer-ejs</code> 渲染这个文件，其他格式同理。</p>
<h3 id="7-Front-matter"><a href="#7-Front-matter" class="headerlink" title="7 Front-matter"></a>7 Front-matter</h3><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2013&#x2F;7&#x2F;13 20:46:25</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>layout</code></td>
<td align="left">布局</td>
<td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td>
</tr>
<tr>
<td align="left"><code>title</code></td>
<td align="left">标题</td>
<td align="left">文章的文件名</td>
</tr>
<tr>
<td align="left"><code>date</code></td>
<td align="left">建立日期</td>
<td align="left">文件建立日期</td>
</tr>
<tr>
<td align="left"><code>updated</code></td>
<td align="left">更新日期</td>
<td align="left">文件更新日期</td>
</tr>
<tr>
<td align="left"><code>comments</code></td>
<td align="left">开启文章的评论功能</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><code>tags</code></td>
<td align="left">标签（不适用于分页）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>categories</code></td>
<td align="left">分类（不适用于分页）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>permalink</code></td>
<td align="left">覆盖文章网址</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>excerpt</code></td>
<td align="left">Page excerpt in plain text. Use <a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">this plugin</a> to format the text</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>disableNunjucks</code></td>
<td align="left">Disable rendering of Nunjucks tag <code>&#123;&#123; &#125;&#125;</code>/<code>&#123;% %&#125;</code> and <a href="https://hexo.io/docs/tag-plugins">tag plugins</a> when enabled</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="7-1-布局"><a href="#7-1-布局" class="headerlink" title="7.1 布局"></a>7.1 布局</h4><p>‎默认布局是 <code>post</code>, 根据设置在<code>_config.yml</code>里的 <a href="https://hexo.io/zh-cn/docs/(/docs/configuration#Writing)"><code>default_layout</code></a> 的值。当文章中的布局被禁用时 (<code>layout: false</code>),它将不会以主题进行处理。但是，它仍将由任何可用的渲染器呈现：如果一篇文章写在标记和标记渲染器（如默认‎<a href="https://github.com/hexojs/hexo-renderer-marked">‎的 hexo 渲染器标记‎</a>‎）中，它将呈现给 HTML。‎<code>post``_config.yml``layout: false</code></p>
<p>‎无论布局如何，‎<a href="https://hexo.io/docs/tag-plugins">‎标记插件‎</a>‎始终被处理，除非设置或‎<a href="https://hexo.io/api/renderer#Disable-Nunjucks-tags">‎渲染器‎</a>‎禁用。‎<code>disableNunjucks</code></p>
<h4 id="7-2-分类和标签"><a href="#7-2-分类和标签" class="headerlink" title="7.2 分类和标签"></a>7.2 分类和标签</h4><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分类方法的分歧</p>
<p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Diary</span><br><span class="line">  - Life</span><br></pre></td></tr></table></figure>

<p>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p>
<p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure>

<p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p>
</blockquote>
<h4 id="7-3-JSON-Front-matter"><a href="#7-3-JSON-Front-matter" class="headerlink" title="7.3 JSON Front-matter"></a>7.3 JSON Front-matter</h4><p>除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 <code>---</code> 代换成 <code>;;;</code> 即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;title&quot;: &quot;Hello World&quot;,</span><br><span class="line">&quot;date&quot;: &quot;2013&#x2F;7&#x2F;13 20:46:25&quot;</span><br><span class="line">;;;</span><br></pre></td></tr></table></figure>

<h3 id="8-标签插件（Tag-Plugins）"><a href="#8-标签插件（Tag-Plugins）" class="headerlink" title="8 标签插件（Tag Plugins）"></a>8 标签插件（Tag Plugins）</h3><p>标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。</p>
<p>虽然你可以使用任何格式书写你的文章，但是标签插件永远可用，且语法也都是一致的。</p>
<p><em>‎标记插件不应包裹在标记语法中，‎</em>, e.g. <code>[](&#123;% post_path lorem-ipsum %&#125;)</code> 是不被支持的</p>
<h4 id="8-1-引用块"><a href="#8-1-引用块" class="headerlink" title="8.1 引用块"></a>8.1 引用块</h4><p>在文章中插入引言，可包含作者、来源和标题。</p>
<p><strong>别号：</strong> quote</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-样例"><a href="#8-2-样例" class="headerlink" title="8.2 样例"></a>8.2 样例</h4><p><strong>没有提供参数，则只输出普通的 blockquote</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote %&#125;</span><br><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p>
</blockquote>
<p><strong>引用书上的句子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote David Levithan, Wide Awake %&#125;</span><br><span class="line">Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p>
<p><strong>David Levithan</strong>Wide Awake</p>
</blockquote>
<p><strong>引用 Twitter</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote @DevDocs https:&#x2F;&#x2F;twitter.com&#x2F;devdocs&#x2F;status&#x2F;356095192085962752 %&#125;</span><br><span class="line">NEW: DevDocs now comes with syntax highlighting. http:&#x2F;&#x2F;devdocs.io</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io/">http://devdocs.io</a></p>
<p><strong>@DevDocs</strong><a href="https://twitter.com/devdocs/status/356095192085962752">twitter.com/devdocs/status/356095192085962752</a></p>
</blockquote>
<p><strong>引用网络上的文章</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote Seth Godin http:&#x2F;&#x2F;sethgodin.typepad.com&#x2F;seths_blog&#x2F;2009&#x2F;07&#x2F;welcome-to-island-marketing.html Welcome to Island Marketing %&#125;</span><br><span class="line">Every interaction is both precious and an opportunity to delight.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Every interaction is both precious and an opportunity to delight.</p>
<p><strong>Seth Godin</strong><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></p>
</blockquote>
<h4 id="8-3-代码块"><a href="#8-3-代码块" class="headerlink" title="8.3 代码块"></a>8.3 代码块</h4><p>在文章中插入代码。</p>
<p><strong>别名：</strong> code</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock [title] [lang:language] [url] [link text] [additional options] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>

<p>Specify additional options in <code>option:value</code> format, e.g. <code>line_number:false first_line:5</code>.</p>
<table>
<thead>
<tr>
<th align="left">Extra Options</th>
<th align="left">Description</th>
<th align="left">Default</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>line_number</code></td>
<td align="left">Show line number</td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left"><code>highlight</code></td>
<td align="left">Enable code highlighting</td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left"><code>first_line</code></td>
<td align="left">Specify the first line number</td>
<td align="left"><code>1</code></td>
</tr>
<tr>
<td align="left"><code>mark</code></td>
<td align="left">Line highlight specific line(s), each value separated by a comma. Specify number range using a dash Example: <code>mark:1,4-7,10</code> will mark line 1, 4 to 7 and 10.</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>wrap</code></td>
<td align="left">Wrap the code block in <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table">``</a></td>
<td align="left"><code>true</code></td>
</tr>
</tbody></table>
<h4 id="8-5-样例"><a href="#8-5-样例" class="headerlink" title="8.5 样例"></a>8.5 样例</h4><p><strong>普通的代码块</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock %&#125;</span><br><span class="line">alert(&#39;Hello World!&#39;);</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br><span class="line">alert(&#39;Hello World!&#39;);</span><br></pre></td></tr></table></figure>

<p><strong>指定语言</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock lang:objc %&#125;</span><br><span class="line">[rectangle setX: 10 y: 10 width: 20 height: 20];</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br><span class="line">[rectangle setX: 10 y: 10 width: 20 height: 20];</span><br></pre></td></tr></table></figure>

<p><strong>附加说明</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock Array.map %&#125;</span><br><span class="line">array.map(callback[, thisArg])</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br><span class="line">Array.maparray.map(callback[, thisArg])</span><br></pre></td></tr></table></figure>

<p><strong>附加说明和网址</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock _.compact http:&#x2F;&#x2F;underscorejs.org&#x2F;#compact Underscore.js %&#125;</span><br><span class="line">_.compact([0, 1, false, 2, &#39;&#39;, 3]);</span><br><span class="line">&#x3D;&gt; [1, 2, 3]</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br><span class="line">_.compactUnderscore.js_.compact([0, 1, false, 2, &#39;&#39;, 3]);</span><br><span class="line">&#x3D;&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<h4 id="8-6-反引号代码块"><a href="#8-6-反引号代码块" class="headerlink" title="8.6 反引号代码块"></a>8.6 反引号代码块</h4><p>另一种形式的代码块，不同的是它使用三个反引号来包裹。</p>
<p>``` [language] [title] [url] [link text] code snippet ```</p>
<h4 id="Pull-Quote"><a href="#Pull-Quote" class="headerlink" title="Pull Quote"></a>Pull Quote</h4><p>在文章中插入 Pull quote。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% pullquote [class] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endpullquote %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="jsFiddle"><a href="#jsFiddle" class="headerlink" title="jsFiddle"></a>jsFiddle</h4><p>在文章中嵌入 jsFiddle。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h4><p>在文章中嵌入 Gist。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% gist gist_id [filename] %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h4><p>在文章中插入 iframe。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% iframe url [width] [height] %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><p>在文章中插入指定大小的图片。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% img [class names] &#x2F;path&#x2F;to&#x2F;image [width] [height] &#39;&quot;title text&quot; &quot;alt text&quot;&#39; %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h4><p>在文章中插入链接，并自动给外部链接添加 <code>target=&quot;_blank&quot;</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% link text url [external] [title] %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Include-Code"><a href="#Include-Code" class="headerlink" title="Include Code"></a>Include Code</h4><p>插入 <code>source/downloads/code</code> 文件夹内的代码文件。<code>source/downloads/code</code> 不是固定的，取决于你在配置文件中 <code>code_dir</code> 的配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include_code [title] [lang:language] [from:line] [to:line] path&#x2F;to&#x2F;file %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-7-样例"><a href="#8-7-样例" class="headerlink" title="8.7 样例"></a>8.7 样例</h4><p><strong>嵌入 test.js 文件全文</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include_code lang:javascript test.js %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>只嵌入第 3 行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include_code lang:javascript from:3 to:3 test.js %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>嵌入第 5 行至第 8 行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include_code lang:javascript from:5 to:8 test.js %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>嵌入第 5 行至文件结束</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include_code lang:javascript from:5 test.js %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>嵌入第 1 行至第 8 行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include_code lang:javascript to:8 test.js %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-8-引用文章"><a href="#8-8-引用文章" class="headerlink" title="8.8 引用文章"></a>8.8 引用文章</h4><p>引用其他文章的链接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_path filename %&#125;</span><br><span class="line">&#123;% post_link filename [title] [escape] %&#125;</span><br></pre></td></tr></table></figure>

<p>在使用此标签时可以忽略文章文件所在的路径或者文章的永久链接信息、如语言、日期。</p>
<p>例如，在文章中使用 <code>&#123;% post_link how-to-bake-a-cake %&#125;</code> 时，只需有一个名为 <code>how-to-bake-a-cake.md</code> 的文章文件即可。即使这个文件位于站点文件夹的 <code>source/posts/2015-02-my-family-holiday</code> 目录下、或者文章的永久链接是 <code>2018/en/how-to-bake-a-cake</code>，都没有影响。</p>
<p>默认链接文字是文章的标题，你也可以自定义要显示的文本。</p>
<p>默认对文章的标题和自定义标题里的特殊字符进行转义。可以使用<code>escape</code>选项，禁止对特殊字符进行转义。</p>
<p><strong>链接使用文章的标题</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_link hexo-3-8-released %&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/news/2018/10/19/hexo-3-8-released/">Hexo 3.8.0 Released</a></p>
<p><strong>链接使用自定义文字</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_link hexo-3-8-released &#39;通往文章的链接&#39; %&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/news/2018/10/19/hexo-3-8-released/">通往文章的链接</a></p>
<p><strong>对标题的特殊字符进行转义</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_link hexo-4-released &#39;How to use &lt;b&gt; tag in title&#39; %&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/news/2019/10/14/hexo-4-released/">How to use  tag in title</a></p>
<p><strong>禁止对标题的特殊字符进行转义</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_link hexo-4-released &#39;&lt;b&gt;bold&lt;&#x2F;b&gt; custom title&#39; false %&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/news/2019/10/14/hexo-4-released/"><strong>bold</strong> custom title</a></p>
<h4 id="8-9-引用资源"><a href="#8-9-引用资源" class="headerlink" title="8.9 引用资源"></a>8.9 引用资源</h4><p>引用文章的资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_path filename %&#125;</span><br><span class="line">&#123;% asset_img [class names] slug [width] [height] [title text [alt text]] %&#125;</span><br><span class="line">&#123;% asset_link filename [title] [escape] %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Embed-image"><a href="#Embed-image" class="headerlink" title="Embed image"></a>Embed image</h3><p><em>‎hexo-渲染器标记的 3.1.0+ 可以（可选地）自动解析帖子的图像路径，请参阅‎<a href="https://hexo.io/docs/asset-folders#Embedding-an-image-using-markdown">‎此部分‎</a>‎，了解如何启用该图像。‎</em></p>
<p>“foo.jpg” is located at <code>http://example.com/2020/01/02/hello/foo.jpg</code>.</p>
<p><strong>Default (no option)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img foo.jpg %&#125;</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;2020&#x2F;01&#x2F;02&#x2F;hello&#x2F;foo.jpg&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Custom class</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img post-image foo.jpg %&#125;</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;2020&#x2F;01&#x2F;02&#x2F;hello&#x2F;foo.jpg&quot; class&#x3D;&quot;post-image&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Display size</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img foo.jpg 500 400 %&#125;</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;2020&#x2F;01&#x2F;02&#x2F;hello&#x2F;foo.jpg&quot; width&#x3D;&quot;500&quot; height&#x3D;&quot;400&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Title &amp; Alt</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img logo.svg &quot;lorem ipsum&#39;dolor&#39;&quot; %&#125;</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;2020&#x2F;01&#x2F;02&#x2F;hello&#x2F;foo.jpg&quot; title&#x3D;&quot;lorem ipsum&quot; alt&#x3D;&quot;dolor&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Raw"><a href="#Raw" class="headerlink" title="Raw"></a>Raw</h4><p>如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-10-文章摘要和截断"><a href="#8-10-文章摘要和截断" class="headerlink" title="8.10 文章摘要和截断"></a>8.10 文章摘要和截断</h4><p>在文章中使用 <code>&lt;!-- more --&gt;</code>，那么 <code>&lt;!-- more --&gt;</code> 之前的文字将会被视为摘要。首页中将只出现这部分文字，同时这部分文字也会出现在正文之中。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</span><br></pre></td></tr></table></figure>

<p>首页中将只会出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</span><br></pre></td></tr></table></figure>

<p>正文中则会出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</span><br><span class="line"></span><br><span class="line">Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</span><br></pre></td></tr></table></figure>

<p>注意，摘要可能会被 Front Matter 中的 <code>excerpt</code> 覆盖。</p>
<h3 id="9-资源文件夹"><a href="#9-资源文件夹" class="headerlink" title="9 资源文件夹"></a>9 资源文件夹</h3><p>资源（Asset）代表 <code>source</code> 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 <code>source/images</code> 文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code> 的方法访问它们。</p>
<h4 id="9-1-文章资源文件夹"><a href="#9-1-文章资源文件夹" class="headerlink" title="9.1 文章资源文件夹"></a>9.1 文章资源文件夹</h4><p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_config.ymlpost_asset_folder: true</span><br></pre></td></tr></table></figure>

<p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p>
<h4 id="9-2-相对路径引用的标签插件"><a href="#9-2-相对路径引用的标签插件" class="headerlink" title="9.2 相对路径引用的标签插件"></a>9.2 相对路径引用的标签插件</h4><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的<a href="https://hexo.io/docs/tag-plugins#Include-Assets">标签插件</a>被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure>

<p>比如说：当你打开文章资源文件夹功能后，你把一个 <code>example.jpg</code> 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](example.jpg)</code> ，它将 <em>不会</em> 出现在首页上。（但是它会在文章中按你期待的方式工作）</p>
<p>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p>
<h4 id="9-3-‎使用‎-markdown嵌入图像"><a href="#9-3-‎使用‎-markdown嵌入图像" class="headerlink" title="9.3 ‎使用‎ markdown嵌入图像"></a>9.3 ‎使用‎ markdown嵌入图像</h4><p><a href="https://github.com/hexojs/hexo-renderer-marked">‎hexo-渲染器标记的‎</a>‎3.1.0引入了一个新的选项，允许您在不使用标签插件的情况下在标记中嵌入图像。‎</p>
<p>To enable:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_config.ymlpost_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure>

<p>‎一旦启用，资产图像将自动解决到其相应的帖子路径。例如，”图像.jpg”位于”/2020/01/02/foo/图像.jpg”，这意味着它是”/2020/01/02/foo/“帖子的资产图像，将呈现为。‎ <code>![](image.jpg)</code> will be rendered as <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code>.</p>
<h3 id="10-数据文件"><a href="#10-数据文件" class="headerlink" title="10 数据文件"></a>10 数据文件</h3><p>有时您可能需要在主题中使用某些资料，而这些资料并不在文章内，并且是需要重复使用的，那么您可以考虑使用 Hexo 3.0 新增的「数据文件」功能。此功能会载入 <code>source/_data</code> 内的 YAML 或 JSON 文件，如此一来您便能在网站中复用这些文件了。</p>
<p>举例来说，在 <code>source/_data</code> 文件夹中新建 <code>menu.yml</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Home: &#x2F;</span><br><span class="line">Gallery: &#x2F;gallery&#x2F;</span><br><span class="line">Archives: &#x2F;archives&#x2F;</span><br></pre></td></tr></table></figure>

<p>您就能在模板中使用这些资料：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% for (var link in site.data.menu) &#123; %&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;&lt;%&#x3D; site.data.menu[link] %&gt;&quot;&gt; &lt;%&#x3D; link %&gt; &lt;&#x2F;a&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p>渲染结果如下 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&#x2F;&quot;&gt; Home &lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;&#x2F;gallery&#x2F;&quot;&gt; Gallery &lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;&#x2F;archives&#x2F;&quot;&gt; Archives &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="11-服务器"><a href="#11-服务器" class="headerlink" title="11 服务器"></a>11 服务器</h3><h4 id="hexo-server"><a href="#hexo-server" class="headerlink" title="hexo-server"></a><a href="https://github.com/hexojs/hexo-server">hexo-server</a></h4><p>Hexo 3.0 把服务器独立成了个别模块，您必须先安装 <a href="https://github.com/hexojs/hexo-server">hexo-server</a> 才能使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure>

<p>安装完成后，输入以下命令以启动服务器，您的网站会在 <code>http://localhost:4000</code> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>如果您想要更改端口，或是在执行时遇到了 <code>EADDRINUSE</code> 错误，可以在执行时使用 <code>-p</code> 选项指定其他端口，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server -p 5000</span><br></pre></td></tr></table></figure>

<h4 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h4><p>在静态模式下，服务器只处理 <code>public</code> 文件夹内的文件，而不会处理文件变动，在执行时，您应该先自行执行 <code>hexo generate</code>，此模式通常用于生产环境（production mode）下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server -s</span><br></pre></td></tr></table></figure>

<h4 id="自定义-IP"><a href="#自定义-IP" class="headerlink" title="自定义 IP"></a>自定义 IP</h4><p>服务器默认运行在 <code>0.0.0.0</code>，您可以覆盖默认的 IP 设置，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server -i 192.168.1.1</span><br></pre></td></tr></table></figure>

<p>指定这个参数后，您就只能通过该IP才能访问站点。例如，对于一台使用无线网络的笔记本电脑，除了指向本机的<code>127.0.0.1</code>外，通常还有一个<code>192.168.*.*</code>的局域网IP，如果像上面那样使用<code>-i</code>参数，就不能用<code>127.0.0.1</code>来访问站点了。对于有公网IP的主机，如果您指定一个局域网IP作为<code>-i</code>参数的值，那么就无法通过公网来访问站点。</p>
<h4 id="Pow"><a href="#Pow" class="headerlink" title="Pow"></a>Pow</h4><p><a href="http://pow.cx/">Pow</a> 是一个 Mac 系统上的零配置 Rack 服务器，它也可以作为一个简单易用的静态文件服务器来使用。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl get.pow.cx | sh</span><br></pre></td></tr></table></figure>

<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>在 <code>~/.pow</code> 文件夹建立链接（symlink）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~&#x2F;.pow</span><br><span class="line">$ ln -s &#x2F;path&#x2F;to&#x2F;myapp</span><br></pre></td></tr></table></figure>

<p>您的网站将会在 <code>http://myapp.dev</code> 下运行，网址根据链接名称而定。</p>
<h3 id="11-生成文件"><a href="#11-生成文件" class="headerlink" title="11 生成文件"></a>11 生成文件</h3><p>使用 Hexo 生成静态文件快速而且简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<h4 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h4><p>Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate --watch</span><br></pre></td></tr></table></figure>

<h4 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h4><p>您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate --deploy</span><br><span class="line">$ hexo deploy --generate</span><br></pre></td></tr></table></figure>

<blockquote>
<p>简写</p>
<p>上面两个命令可以简写为<br>$ hexo g -d<br>$ hexo d -g</p>
</blockquote>
<h2 id="NexT"><a href="#NexT" class="headerlink" title="NexT"></a>NexT</h2><p>访问Hexo官网，下载喜欢的主题，此处下载主题为NexT，Next主题有非常多的自定义选项，网络上的美化教程也十分丰富，建议下载。</p>
<h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h4><p>如果您使用的是 Hexo 5.0 或更晚，安装最简单的方法是通过 npm：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd hexo-site</span><br><span class="line">$ npm install hexo-theme-next</span><br></pre></td></tr></table></figure>

<p>或者您可以克隆整个存储库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd hexo-site</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;next-theme&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>如果您需要任何其他变体，请参阅<a href="https://theme-next.js.org/docs/getting-started/installation.html">详细的安装说明</a>。</p>
<p>安装后，打开 Hexo 配置文件并设置变量。<code>theme``next</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2 配置"></a>2 配置</h4><p>目前，NexT 鼓励用户使用<a href="https://theme-next.js.org/docs/getting-started/configuration.html">备用主题配置</a>来配置 NexT。使用<a href="https://theme-next.js.org/docs/advanced-settings/custom-files.html">自定义文件</a>可以轻松地自定义 NexT 的布局或样式。</p>
<p>不建议直接修改 NexT 主题中的任何文件。因为这可能导致错误（例如合并冲突），修改后的文件在升级主题时可能会被丢弃。</p>
<p>但是，您可以绕过合并冲突（错误消息（如**”提交更改或在合并之前将其存放”），**使用本地更改的命令。请参阅<a href="https://stackoverflow.com/a/15745424/5861495">此处</a>如何做到这一点。<code>Commit``Stash``Reset</code></p>
<h4 id="3-插件"><a href="#3-插件" class="headerlink" title="3 插件"></a>3 插件</h4><p>插件扩展和扩展了 NexT 的功能。插件有两种类型：核心插件和第三方插件。核心插件由 NexT 的基本功能要求。第三方插件提供大量可选功能。</p>
<p>配置这些插件非常容易。例如，如果您想在您的网站上启用，只需设置为在NexT配置文件中：<code>pjax``pjax``true</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Easily enable fast Ajax navigation on your website.</span><br><span class="line"># For more information: https:&#x2F;&#x2F;github.com&#x2F;next-theme&#x2F;pjax</span><br><span class="line">pjax: true</span><br></pre></td></tr></table></figure>

<h4 id="4-配置-CDN"><a href="#4-配置-CDN" class="headerlink" title="4 配置 CDN"></a>4 配置 CDN</h4><p>默认情况下，第三方插件将从<a href="https://www.jsdelivr.com/">jsDelivr</a> CDN 加载。我们还提供其他可选的清洁发展机制，包括著名的<a href="https://unpkg.com/">联合国驻科特派团</a>和<a href="https://cdnjs.com/">CDNJS。</a></p>
<p>例如，如果您想使用而不是作为默认的 CDN 提供商，则需要编辑 NexT 配置文件中的以下设置：<code>unpkg``jsdelivr</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vendors:</span><br><span class="line">  # ...</span><br><span class="line">  # Some contents...</span><br><span class="line">  # ...</span><br><span class="line">  plugins: unpkg</span><br></pre></td></tr></table></figure>

<h4 id="5-更新"><a href="#5-更新" class="headerlink" title="5 更新"></a>5 更新</h4><p>NexT 的新版本将每月发布一次。请在更新主题之前阅读<a href="https://github.com/next-theme/hexo-theme-next/releases">发布说明</a>。您可以通过以下命令更新NexT。</p>
<p>安装最新版本的npm：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd hexo-site</span><br><span class="line">$ npm install hexo-theme-next@latest</span><br></pre></td></tr></table></figure>

<p>或更新到最新的主分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd themes&#x2F;next</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>

<p><strong>如果您想从v5.x/v7.x更新到最新版本，请阅读<a href="https://theme-next.js.org/docs/getting-started/upgrade.html">本文</a>。</strong></p>
<p>创建 Hexo 主题非常容易，您只要在 <code>themes</code> 文件夹内，新增一个任意名称的文件夹，并修改 <code>_config.yml</code> 内的 <code>theme</code> 设定，即可切换主题。一个主题可能会有以下的结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── languages</span><br><span class="line">├── layout</span><br><span class="line">├── scripts</span><br><span class="line">└── source</span><br></pre></td></tr></table></figure>

<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>在本教程中，我们将会使用 <a href="https://travis-ci.com/">Travis CI</a> 将 Hexo 博客部署到 GitHub Pages 上。Travis CI 对于开源 repository 是免费的，但是这意味着你的站点文件将会是公开的。如果你希望你的站点文件不被公开，请直接前往本文 [私有 Repository](#私有 Repository) 部分。</p>
<ol>
<li>新建一个 repository。如果你希望你的站点能通过 <code>&lt;你的 GitHub 用户名&gt;.github.io</code> 域名访问，你的 repository 应该直接命名为 <code>&lt;你的 GitHub 用户名&gt;.github.io</code>。</li>
<li>将你的 Hexo 站点文件夹推送到 repository 中。默认情况下不应该 <code>public</code> 目录将不会被推送到 repository 中，你应该检查 <code>.gitignore</code> 文件中是否包含 <code>public</code> 一行，如果没有请加上。</li>
<li>将 <a href="https://github.com/marketplace/travis-ci">Travis CI</a> 添加到你的 GitHub 账户中。</li>
<li>前往 GitHub 的 <a href="https://github.com/settings/installations">Applications settings</a>，配置 Travis CI 权限，使其能够访问你的 repository。</li>
<li>你应该会被重定向到 Travis CI 的页面。如果没有，请 <a href="https://travis-ci.com/">手动前往</a>。</li>
<li>在浏览器新建一个标签页，前往 GitHub <a href="https://github.com/settings/tokens">新建 Personal Access Token</a>，只勾选 <code>repo</code> 的权限并生成一个新的 Token。Token 生成后请复制并保存好。</li>
<li>回到 Travis CI，前往你的 repository 的设置页面，在 <strong>Environment Variables</strong> 下新建一个环境变量，<strong>Name</strong> 为 <code>GH_TOKEN</code>，<strong>Value</strong> 为刚才你在 GitHub 生成的 Token。确保 <strong>DISPLAY VALUE IN BUILD LOG</strong> 保持 <strong>不被勾选</strong> 避免你的 Token 泄漏。点击 <strong>Add</strong> 保存。</li>
<li>在你的 Hexo 站点文件夹中新建一个 <code>.travis.yml</code> 文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo: false</span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 # use nodejs v10 LTS</span><br><span class="line">cache: npm</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - master # build master branch only</span><br><span class="line">script:</span><br><span class="line">  - hexo generate # generate static files</span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: true</span><br><span class="line">  github-token: $GH_TOKEN</span><br><span class="line">  keep-history: true</span><br><span class="line">  on:</span><br><span class="line">    branch: master</span><br><span class="line">  local-dir: public</span><br></pre></td></tr></table></figure>

<ol>
<li>将 <code>.travis.yml</code> 推送到 repository 中。Travis CI 应该会自动开始运行，并将生成的文件推送到同一 repository 下的 <code>gh-pages</code> 分支下</li>
<li>在 GitHub 中前往你的 repository 的设置页面，修改 <code>GitHub Pages</code> 的部署分支为 <code>gh-pages</code>。</li>
<li>前往 <code>https://&lt;你的 GitHub 用户名&gt;.github.io</code> 查看你的站点是否可以访问。这可能需要一些时间。</li>
</ol>
<h4 id="Project-page"><a href="#Project-page" class="headerlink" title="Project page"></a>Project page</h4><p>如果你更希望你的站点部署在 <code>&lt;你的 GitHub 用户名&gt;.github.io</code> 的子目录中，你的 repository 需要直接命名为子目录的名字，这样你的站点可以通过 <code>https://&lt;你的 GitHub 用户名&gt;.github.io/&lt;repository 的名字&gt;</code> 访问。你需要检查你的 Hexo 配置文件，将 <code>url</code> 修改为 <code>https://&lt;你的 GitHub 用户名&gt;.github.io/&lt;repository 的名字&gt;</code>、将 <code>root</code> 的值修改为 <code>/&lt;repository 的名字&gt;/</code></p>
<h4 id="私有-Repository"><a href="#私有-Repository" class="headerlink" title="私有 Repository"></a>私有 Repository</h4><p>下面的指示基于 <a href="https://hexo.io/docs/one-command-deployment">一键部署</a> 编写。</p>
<ol>
<li><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>.</p>
</li>
<li><p>在 <strong>_config.yml</strong>（如果有已存在的请删除）添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;&lt;username&gt;&#x2F;&lt;project&gt;</span><br><span class="line">  # example, https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexojs.github.io</span><br><span class="line">  branch: gh-pages</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 <code>hexo clean &amp;&amp; hexo deploy</code> 。</p>
</li>
<li><p>查看 <em>username</em>.github.io 上的网页是否部署成功。</p>
</li>
</ol>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul>
<li><a href="https://help.github.com/categories/github-pages-basics/">GitHub Pages 使用文档</a></li>
<li><a href="https://docs.travis-ci.com/user/tutorial/">Travis CI 使用文档</a></li>
<li><a href="https://github.com/hexojs/awesome-hexo">Awesome Hexo</a></li>
<li>[在百度上搜索 “Hexo GitHub”](<a href="https://www.baidu.com/s?wd=Hexo">https://www.baidu.com/s?wd=Hexo</a> GitHub)</li>
</ul>
]]></content>
      <categories>
        <category>办公技能</category>
      </categories>
      <tags>
        <tag>Hexo + Next + Github</tag>
      </tags>
  </entry>
  <entry>
    <title>09-Java常用类</title>
    <url>/2021/09/17/09%E2%80%94Java%E5%B8%B8%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="09—Java常用类"><a href="#09—Java常用类" class="headerlink" title="09—Java常用类"></a>09—Java常用类</h3><h4 id="1-字符串相关类"><a href="#1-字符串相关类" class="headerlink" title="1.字符串相关类"></a>1.字符串相关类</h4><h5 id="1-1-String特性"><a href="#1-1-String特性" class="headerlink" title="1.1 String特性"></a>1.1 String特性</h5><ul>
<li><p>String类：代表字符串。Java程序中所有的字符串字面值（如“abc”）都作为此类的实例实现</p>
</li>
<li><p>String是一个final类，代表不可变的字符序列</p>
</li>
<li><p>字符串是常量，用双引号引起来表示。他们的值在创建之后不能更改</p>
</li>
<li><p>String对象的字符内容是存储在一个字符数组value[]中的</p>
</li>
<li><pre><code class="java">public final class String implements java.io.Serializable,Comparable&lt;String&gt;,CharSequence&#123;
    //The vlue is used for character storage
    private final char value[];
    //Cache the hash code for the string
    private int hash;//Default to 0
&#125;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">###### 1.1.1 String对象的创建</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java </span><br><span class="line">String str &#x3D; &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;本质上this.value &#x3D; new char[0];</span><br><span class="line">String s1 &#x3D; new String();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;本质上this.value &#x3D; original.value;</span><br><span class="line">String s2 &#x3D; new String(String original);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;本质上this.value &#x3D; Array.copyOf(value, value.length);</span><br><span class="line">String s3 &#x3D; new String(char[] a);</span><br><span class="line">String s4 &#x3D; new String(char[] a, int startIndex, int count);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h5 id="1-2-String-内存解析"><a href="#1-2-String-内存解析" class="headerlink" title="1.2 String 内存解析"></a>1.2 String 内存解析</h5><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210716201342.png" alt="image-20210716201332311" style="zoom:50%;" />

<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210716201419.png" alt="image-20210716201418152" style="zoom: 50%;" />

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108161644004.png" alt="image-20210816164410800"></p>
<p>​                                                     <img src="../../../../Users/xiong/AppData/Roaming/Typora/typora-user-images/image-20210816164540235.png" alt="image-20210816164540235" style="zoom:67%;" /></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108161646576.png" alt="image-20210816164635997"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    String:字符串，使用一对&quot;&quot;引起来表示。</span></span><br><span class="line"><span class="comment">    1.String声明为final的，不可被继承</span></span><br><span class="line"><span class="comment">    2.String实现了Serializable接口：表示字符串是支持序列化的。</span></span><br><span class="line"><span class="comment">            实现了Comparable接口：表示String可以比较大小</span></span><br><span class="line"><span class="comment">    3.String内部定义了final char[] value用于存储字符串数据</span></span><br><span class="line"><span class="comment">    4.String:代表不可变的字符序列。简称：不可变性。</span></span><br><span class="line"><span class="comment">        体现：1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</span></span><br><span class="line"><span class="comment">             2. 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span></span><br><span class="line"><span class="comment">             3. 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span></span><br><span class="line"><span class="comment">    5.通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</span></span><br><span class="line"><span class="comment">    6.字符串常量池中是不会存储相同内容的字符串的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量的定义方式</span></span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//比较s1和s2的地址值</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s1);<span class="comment">//hello</span></span><br><span class="line">        System.out.println(s2);<span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String s3 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        s3 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        System.out.println(s3);<span class="comment">//abcdef</span></span><br><span class="line">        System.out.println(s2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String s4 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s5 = s4.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">        System.out.println(s4);<span class="comment">//abc</span></span><br><span class="line">        System.out.println(s5);<span class="comment">//mbc</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">    String的实例化方式：</span></span><br><span class="line"><span class="comment">    方式一：通过字面量定义的方式</span></span><br><span class="line"><span class="comment">    方式二：通过new + 构造器的方式</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     面试题：String s = new String(&quot;abc&quot;);方式创建对象，在内存中创建了几个对象？</span></span><br><span class="line"><span class="comment">            两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：&quot;abc&quot;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。</span></span><br><span class="line">        String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        <span class="comment">//通过new + 构造器的方式:此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。</span></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line">        String s4 = <span class="keyword">new</span> String(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s1 == s4);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;***********************&quot;</span>);</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1.name.equals(p2.name));<span class="comment">//true</span></span><br><span class="line">        System.out.println(p1.name == p2.name);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        p1.name = <span class="string">&quot;Jerry&quot;</span>;</span><br><span class="line">        System.out.println(p2.name);<span class="comment">//Tom</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">    结论：</span></span><br><span class="line"><span class="comment">    1.常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。</span></span><br><span class="line"><span class="comment">    2.只要其中有一个是变量，结果就在堆中。</span></span><br><span class="line"><span class="comment">    3.如果拼接的结果调用intern()方法，返回值就在常量池中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        String s3 = s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String s4 = <span class="string">&quot;javaEE&quot;</span>;<span class="comment">//s4:常量</span></span><br><span class="line">        String s5 = s4 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s5);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String s3 = <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line">        String s4 = <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        String s5 = s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">        String s6 = <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line">        String s7 = s1 + s2;</span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        String s8 = s6.intern();<span class="comment">//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop”</span></span><br><span class="line">        System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h6 id="1-2-1-String使用陷阱"><a href="#1-2-1-String使用陷阱" class="headerlink" title="1.2.1 String使用陷阱"></a>1.2.1 String使用陷阱</h6><ul>
<li><p>String s1 = “a”;  </p>
<p>说明：在字符串常量池中创建了一个字面量为”a”的字符串。</p>
</li>
<li><p>s1 = s1 + “b”;  </p>
<p>说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+”b”（也就是”ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响 程序的性能。</p>
</li>
<li><p>String s2 = “ab”; </p>
<p>说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。</p>
</li>
<li><p>String s3 = “a” + “b”; </p>
<p>说明：s3指向字符串常量池中已经创建的”ab”的字符串。 </p>
</li>
<li><p>String s4 = s1.intern(); </p>
<p>说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的”ab”字符串 赋值给s4。</p>
</li>
</ul>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210716202413.png" alt="image-20210716202411258"></p>
<p>面试题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String str = <span class="keyword">new</span> String(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="keyword">char</span>[] ch = &#123; <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">char</span> ch[])</span> </span>&#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StringTest ex = <span class="keyword">new</span> StringTest();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);<span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);<span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-3-字符串相关的类：String常用方法"><a href="#1-3-字符串相关的类：String常用方法" class="headerlink" title="1.3 字符串相关的类：String常用方法"></a>1.3 字符串相关的类：String常用方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>：返回字符串的长度： return value.length</span></span><br><span class="line"><span class="function"> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>： 返回某索引处的字符return value[index] </span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>：判断是否是空字符串：return value.length </span>== <span class="number">0</span> </span><br><span class="line"> <span class="function">String <span class="title">toLowerCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为小写</span></span><br><span class="line"><span class="function"> String <span class="title">toUpperCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为大写</span></span><br><span class="line"><span class="function"> String <span class="title">trim</span><span class="params">()</span>：返回字符串的副本，忽略前导空白和尾部空白</span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>：比较字符串的内容是否相同</span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span>：与equals方法类似，忽略大小写</span></span><br><span class="line"><span class="function"> String <span class="title">concat</span><span class="params">(String str)</span>：将指定字符串连接到此字符串的结尾。 等价于用“+” </span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span>：比较两个字符串的大小</span></span><br><span class="line"><span class="function"> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span>：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。 </span></span><br><span class="line"><span class="function"> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> ：返回一个新字符串，它是此字符串从beginIndex开始截取到<span class="title">endIndex</span><span class="params">(不包含)</span>的一个子字符串。</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span>：测试此字符串是否以指定的后缀结束</span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span>：测试此字符串是否以指定的前缀开始</span></span><br><span class="line"><span class="function"> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span>：当且仅当此字符串包含指定的 <span class="keyword">char</span> 值序列时，返回 <span class="keyword">true</span></span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中第一次出现处的索引</span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中最右边出现处的索引</span></span><br><span class="line"><span class="function"> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</span></span><br><span class="line"><span class="function">注：indexOf和lastIndexOf方法如果未找到都是返回-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。 </span></span><br><span class="line"><span class="function"> String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。 </span></span><br><span class="line"><span class="function"> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> ：使用给定的replacement 替换此字符串所有匹配给定的正则表达式的子字符串。 </span></span><br><span class="line"><span class="function"> String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> ：使用给定的replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span>：告知此字符串是否匹配给定的正则表达式。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。 </span><br><span class="line"> String[] split(String regex, <span class="keyword">int</span> limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> String类;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    boolean matches(String regx)：返回此字符串是否匹配给定的正则表达式</span></span><br><span class="line"><span class="comment">    String[] split(String regx)：根据正则表达式的匹配来拆分此字符串</span></span><br><span class="line"><span class="comment">    String[] split(String regx, int limit)：根据匹配的给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部放到最后一个元素中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;#X#I#O#N#G&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> boo = str.matches(<span class="string">&quot;(#[A-Z])+&quot;</span>);</span><br><span class="line">        System.out.println(boo);</span><br><span class="line">        String[] sp = str.split(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        String[] sp2 = str.split(<span class="string">&quot;#&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(String s : sp)</span><br><span class="line">        System.out.print(s);</span><br><span class="line">        <span class="keyword">for</span> (String a : sp2) &#123;</span><br><span class="line">            System.out.print(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int length()：返回字符串的长度：return value.length</span></span><br><span class="line"><span class="comment">    char charAt(int index)：返回某索引处的字符return value[index]</span></span><br><span class="line"><span class="comment">    boolean isEmpty()：判断是否为空字符串：return value.length == 0</span></span><br><span class="line"><span class="comment">    String toLowerCase()：使用默认语言环境，将String中的所有字符转为小写</span></span><br><span class="line"><span class="comment">    String toUpperCase()：使用默认语言环境，将String中的所有字符转为大写</span></span><br><span class="line"><span class="comment">    String trim()：返回字符串副本，忽略前导空白和尾部空白</span></span><br><span class="line"><span class="comment">    boolean equals(Object obj)：比较字符串的内容是否相同</span></span><br><span class="line"><span class="comment">    boolean equalsIgnoreCase(String anthorString)：与equals方法类似，忽略大小写</span></span><br><span class="line"><span class="comment">    String concat(String str)：将指定字符串连接到此字符串的结尾。等价用+</span></span><br><span class="line"><span class="comment">    int comapreTo(String anotherString)：比较两字符串的大小</span></span><br><span class="line"><span class="comment">    String substring(int beginIndex)：返回一个新的字符串，他是此字符串从beginIndex开始截取到最后的一个子字符串</span></span><br><span class="line"><span class="comment">    String substring(int beginIndex, int endIndex)：返回一个新的字符串，他是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str = <span class="string">&quot; xiongZhuO &quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;原始字符串为：&quot;</span> + str);</span><br><span class="line">        System.out.println(<span class="string">&quot;返回字符串长度：str.length() = &quot;</span>+str.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;寻找字符串中索引为1的字符：str.charAt(1) = &quot;</span> + str.charAt(str.indexOf(<span class="string">&#x27;x&#x27;</span>)));</span><br><span class="line">        System.out.println(<span class="string">&quot;判断字符串是否为空：str.isEmpty() = &quot;</span>+str.isEmpty());</span><br><span class="line">        System.out.println(<span class="string">&quot;将字符串全部转为大写：str.toUppercase() = &quot;</span> + str.toUpperCase());</span><br><span class="line">        System.out.println(<span class="string">&quot;将字符串全部转为小写：str.toLowerCase() = &quot;</span> + str.toLowerCase());</span><br><span class="line">        System.out.println(<span class="string">&quot;去除字符串中的前后空白符：str.trim() = &quot;</span> + str.trim());</span><br><span class="line">        System.out.println(<span class="string">&quot;比较\&quot; xiongzhuo \&quot;是否与原字符串相等：\&quot; xiongzhuo \&quot;.equals(str) = &quot;</span>+<span class="string">&quot; xiongzhuo &quot;</span>.equals(str));</span><br><span class="line">        System.out.println(<span class="string">&quot;忽略大小写比较\&quot; xiongzhuo \&quot;是否与原字符串相等：\&quot; xiongzhuo \&quot;.equalsIngoreCase(str) = &quot;</span> + <span class="string">&quot; xiongzhuo &quot;</span>.equalsIgnoreCase(str));</span><br><span class="line">        System.out.println(<span class="string">&quot;将\&quot;GUET\&quot;连接到字符串的起始位置：\&quot;GUET\&quot;.concat(str) = &quot;</span> + <span class="string">&quot;GUET&quot;</span>.concat(str));</span><br><span class="line">        System.out.println(<span class="string">&quot;比较\&quot;GUET\&quot;与字符串的大小：\&quot;GUET\&quot;.compareTo(str) = &quot;</span> + <span class="string">&quot;GUET&quot;</span>.compareTo(str));</span><br><span class="line">        System.out.println(<span class="string">&quot;从索引6开始截取一个新的子串：str.substring(6) = &quot;</span> + str.substring(<span class="number">6</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;从索引1到索引6截取一个新的串：str.substring(1,6) = &quot;</span> + str.substring(<span class="number">1</span>, <span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束</span></span><br><span class="line"><span class="comment">    boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始</span></span><br><span class="line"><span class="comment">    boolean startsWitd(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    boolean contains(CharSequence s)：当且仅当此字符串包含指定的char值序列时，返回true</span></span><br><span class="line"><span class="comment">    int indexOf(String str)：返回指定字符串在此字符串中第一次出现处的索引</span></span><br><span class="line"><span class="comment">    int indexOf(String str, int fromIndex)：返回指定字符串在此字符串中第一次出现的索引，从指定索引开始</span></span><br><span class="line"><span class="comment">    int lastIndexOf(String str)：返回指定字符串在此字符串中最右边出现的索引</span></span><br><span class="line"><span class="comment">    int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</span></span><br><span class="line"><span class="comment">    注：indexOf和lastIndexOf如果未找到返回都是-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;GGGGUET XXXIONGZHUO&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b1 = str.endsWith(<span class="string">&quot;ZHUO&quot;</span>);</span><br><span class="line">        System.out.println(b1);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b2 = str.startsWith(<span class="string">&quot;G&quot;</span>);</span><br><span class="line">        System.out.println(b2);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b3 = str.startsWith(<span class="string">&quot;XX&quot;</span>,<span class="number">8</span>);</span><br><span class="line">        System.out.println(b3);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> b4 = str.contains(<span class="string">&quot;XIONG&quot;</span>);</span><br><span class="line">        System.out.println(b4);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i1 = str.indexOf(<span class="string">&quot;X&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;X在字符串中的索引位置为：&quot;</span> + i1);<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i2 = str.indexOf(<span class="string">&quot;XX&quot;</span>,<span class="number">7</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;XX在字符串中以索引7为开始的搜索位置：&quot;</span> + i2);<span class="comment">//8</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i3 = str.lastIndexOf(<span class="string">&quot;O&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;O在字符串中的索引位置为：&quot;</span> + i3);<span class="comment">//18</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i4 = str.lastIndexOf(<span class="string">&quot;O&quot;</span>,<span class="number">15</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;O在字符串中以索引15为开始反向搜索的位置：&quot;</span> + i4);<span class="comment">//-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    替换：</span></span><br><span class="line"><span class="comment">    String replace(char oldChar, char newChar)：返回一个新的字符串，他是通过用newChar替换oldChar得到的。</span></span><br><span class="line"><span class="comment">    String replace(CharSequence targe, ChaeSequence replacement)：使用指定字面值替换序列替换此字符串中所有匹配字面值目标序列的子字符串</span></span><br><span class="line"><span class="comment">    String replaceAll(String regex, String replacement)：使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串</span></span><br><span class="line"><span class="comment">    String replaceFirst(String regx, String replacement)：使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串</span></span><br><span class="line"><span class="comment">    匹配：</span></span><br><span class="line"><span class="comment">    boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式</span></span><br><span class="line"><span class="comment">    切片：</span></span><br><span class="line"><span class="comment">    String[] split(String regx)：根据给定的正则表达式拆分此字符串</span></span><br><span class="line"><span class="comment">    String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串。最多不超过Limit个，如果超过了，剩下的全部放到最后一个元素中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;路漫漫其修远兮，吾将上下而求索&quot;</span>;</span><br><span class="line">        String str2 = str1.replace(<span class="string">&quot;吾&quot;</span>,<span class="string">&quot;wo&quot;</span>);</span><br><span class="line">        String str3 = str1.replace(<span class="string">&quot;吾将上下而求索&quot;</span>,<span class="string">&quot;屈原&quot;</span>);</span><br><span class="line">        String str4 = str1.replaceAll(<span class="string">&quot;(.)\\1+&quot;</span>,<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">        String str5 = str1.replaceFirst(<span class="string">&quot;漫&quot;</span>,<span class="string">&quot;man&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Str1: &quot;</span> + str1);<span class="comment">//Str1: 路漫漫其修远兮，吾将上下而求索</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Str2: &quot;</span> + str2);<span class="comment">//Str2: 路漫漫其修远兮，wo将上下而求索</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Str3: &quot;</span> + str3);<span class="comment">//Str3: 路漫漫其修远兮，屈原</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Str4: &quot;</span> + str4);<span class="comment">//Str4: 路漫其修远兮，吾将上下而求索</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Str5: &quot;</span> + str5);<span class="comment">//Str5: 路man漫其修远兮，吾将上下而求索</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h6 id="1-3-1-String与基本数据类型的转换"><a href="#1-3-1-String与基本数据类型的转换" class="headerlink" title="1.3.1 String与基本数据类型的转换"></a>1.3.1 String与基本数据类型的转换</h6><ul>
<li>字符串 -&gt; 基本数据类型、包装类<ul>
<li>Integer包装类的public static int parseInt(String s)：可以由“数字”字符组成的字符串转为整型</li>
<li>类似的，使用java.lang包中的Byte、Short、Long、Float、Double类调相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型</li>
</ul>
</li>
<li>基本数据类型、包装类 -&gt; 字符串<ul>
<li>调用String类中的public String valueOf(int n)可将innt转为字符串</li>
<li>相应的valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b)可以由参数的相应类型到字符串的转换</li>
</ul>
</li>
</ul>
<h6 id="1-3-2-String与字符数组转化"><a href="#1-3-2-String与字符数组转化" class="headerlink" title="1.3.2 String与字符数组转化"></a>1.3.2 String与字符数组转化</h6><ul>
<li>字符数组 -&gt; 字符串<ul>
<li>String类的构造器：String(char[])字符数组中的全部字符创建字符串对象</li>
<li>String(char[],int offset, int length)用字符数组中的部分字符创建字符串对象</li>
</ul>
</li>
<li>字符串 -&gt; 字符数组<ul>
<li>public char[]  toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法</li>
<li>public void getChars(int srcBegin, int srcEnd, char[] dst, int detBegin)：提供了将指定索引范围内的字符串存放到数组中的方法</li>
</ul>
</li>
</ul>
<h6 id="1-3-3-String与字节数组的转化"><a href="#1-3-3-String与字节数组的转化" class="headerlink" title="1.3.3 String与字节数组的转化"></a>1.3.3 String与字节数组的转化</h6><ul>
<li><p>字节数组 -&gt; 字符串</p>
<ul>
<li>String(byte[])：通过使用平台默认的字符集解码指定的byte数组，构造一个新的String</li>
<li>String(byte[], int offset, int length)：用指定的字节数组的一部分，即总数组的起始位置offset开始取length个字节构造一个字符串对象。</li>
</ul>
</li>
<li><p>字符串 -&gt; 字节数组</p>
<ul>
<li>public byte[] getBytes()：使用平台的默认字符集将此String编码为byte序列，并将结果存储到一个新的byte数组中</li>
<li>public byte[] getBytes(String charsetName)：使用指定的字符集将此String编码到byte序列，并将结果存储到新的byte数组</li>
</ul>
</li>
<li><pre><code class="java">package String类;

import org.junit.Test;

import java.io.UnsupportedEncodingException;
import java.util.Arrays;

public class StringTest1 &#123;

     /*
    String 与 byte[]之间的转换
    编码：String --&gt; byte[]:调用String的getBytes()
    解码：byte[] --&gt; String:调用String的构造器

    编码：字符串 --&gt;字节  (看得懂 ---&gt;看不懂的二进制数据)
    解码：编码的逆过程，字节 --&gt; 字符串 （看不懂的二进制数据 ---&gt; 看得懂）

    说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。
     */
    @Test
    public void test3() throws UnsupportedEncodingException &#123;
        String str1 = &quot;abc123中国&quot;;
        byte[] bytes = str1.getBytes();//使用默认的字符集，进行编码。
        System.out.println(Arrays.toString(bytes));
        //[97, 98, 99, 49, 50, 51, -28, -72, -83, -27, -101, -67]utf-8中文使用三个来编码

        byte[] gbks = str1.getBytes(&quot;gbk&quot;);//使用gbk字符集进行编码。
        System.out.println(Arrays.toString(gbks));
        //[97, 98, 99, 49, 50, 51, -42, -48, -71, -6]gbk中文使用两个来编码

        System.out.println(&quot;******************&quot;);

        String str2 = new String(bytes);//使用默认的字符集，进行解码。
        System.out.println(str2);//abc123中国

        String str3 = new String(gbks);
        System.out.println(str3);//出现乱码。原因：编码集和解码集不一致！


        String str4 = new String(gbks, &quot;gbk&quot;);
        System.out.println(str4);//没有出现乱码。原因：编码集和解码集一致！


    &#125;

    /*
    String 与 char[]之间的转换

    String --&gt; char[]:调用String的toCharArray()
    char[] --&gt; String:调用String的构造器
     */
    @Test
    public void test2()&#123;
        String str1 = &quot;abc123&quot;;  //题目： a21cb3

        char[] charArray = str1.toCharArray();
        for (int i = 0; i &lt; charArray.length; i++) &#123;
            System.out.println(charArray[i]);
        &#125;

        char[] arr = new char[]&#123;&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;&#125;;
        String str2 = new String(arr);
        System.out.println(str2);
    &#125;

    /*
    复习：
    String 与基本数据类型、包装类之间的转换。

    String --&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)
    基本数据类型、包装类 --&gt; String:调用String重载的valueOf(xxx)

     */
    @Test
    public void test1()&#123;
        String str1 = &quot;123&quot;;
//        int num = (int)str1;//错误的
        int num = Integer.parseInt(str1);

        String str2 = String.valueOf(num);//&quot;123&quot;
        String str3 = num + &quot;&quot;;

        System.out.println(str1 == str3);
    &#125;

&#125;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 1.4 字符串相关类--StringBuffer</span><br><span class="line"></span><br><span class="line">* java.lang.StringBuffer代表可变的字符序列，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象</span><br><span class="line">* 很多方法与String相同</span><br><span class="line">* 作为参数传递时，方法内部可以改变值</span><br><span class="line">* &lt;img src&#x3D;&quot;https:&#x2F;&#x2F;gitee.com&#x2F;xiongzero&#x2F;alienware_-pic-go&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210716212117.png&quot; alt&#x3D;&quot;image-20210716212116312&quot; style&#x3D;&quot;zoom:50%;&quot; &#x2F;&gt; </span><br><span class="line">* StringBuffer类不同于String，其对象必须使用构造器生成，有三个构造器：</span><br><span class="line">  * StringBuffer()：初始容量为16的字符串缓冲区</span><br><span class="line">  * StringBuffer(int size)：构造指定容量的字符串缓冲区</span><br><span class="line">  * StringBuffer(String str)：将内容初始化为指定字符串内容</span><br><span class="line">* ![image-20210716212823159](https:&#x2F;&#x2F;gitee.com&#x2F;xiongzero&#x2F;alienware_-pic-go&#x2F;raw&#x2F;master&#x2F;img&#x2F;20210716212826.png)</span><br><span class="line"></span><br><span class="line">###### 1.4.1 StringBuffer类的常用方法</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接</span><br><span class="line">StringBuffer delete(int start,int end)：删除指定位置的内容</span><br><span class="line">StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str</span><br><span class="line">StringBuffer insert(int offset, xxx)：在指定位置插入xxx</span><br><span class="line">StringBuffer reverse() ：把当前字符序列逆转</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>当append和insert时，如果原来value数组长度不够，可扩容</p>
</li>
<li><p>如上这些方法支持方法链操作</p>
</li>
<li><p>方法链原理</p>
</li>
<li><pre><code class="java">@Override
public StringBuilder append(String str)&#123;
    super.append(str);
    return this;
&#125;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**append()方法浅解**</span><br><span class="line"></span><br><span class="line">1.String与StringBuffer</span><br><span class="line"></span><br><span class="line">两个类均由public final修饰，意味着是最终类，不能被继承，但是为啥StringBuffer长度和内容可变，而String不可变呢？</span><br><span class="line"></span><br><span class="line">​    我们看String的源码中的成员变量：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;java</span><br><span class="line">&#x2F;** String本质是个char数组.*&#x2F;</span><br><span class="line"> private final char value[];</span><br></pre></td></tr></table></figure>

使用了final修饰，一旦创建，该值就不可改变，但是注意final修饰引用类型的变量时，指的是引用类型地址值不能发生改变。但是Array数组是可变的，如果我们不改变指向value[]的地址，而改变value[]的值呢？此时需要注意value[]是采用private修饰的，后面String所有的方法没有动value[]里的元素，而且String类不可被继承，不能重写方法，所以String不可变。
   那为啥StringBuffer长度和内容可变？发现StringBuffer没有value[]成员变量，看父类AbstractStringBuilder中value[]成员变量
</code></pre>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure>

<p>豁然开朗，那就看看StringBuffer的append()方法，了解一下是如何改变添加的</p>
<p>2.查看StringBuffer的append()方法</p>
<p>为了好说明，举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">stringBuffer.append(<span class="string">&quot;world&quot;</span>);<span class="comment">/*打印出helloworld*/</span></span><br><span class="line">System.out.println(stringBuffer);</span><br></pre></td></tr></table></figure>

<ol>
<li><p>进入append方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;        </span><br><span class="line"> <span class="keyword">super</span>.append(str);        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 其中toStringCache是啥呢？看描述是Cleared whenever the StringBuffer is modified.当改变就清空，接下来看调用了父类的append的方法【注意用synchronized修饰了，线程安全】</p>
</li>
<li><p>进入AbstractStringBuilder的append()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)            </span><br><span class="line">        <span class="keyword">return</span> appendNull();        </span><br><span class="line">    <span class="keyword">int</span> len = str.length();        </span><br><span class="line">    ensureCapacityInternal(count + len);        </span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);        </span><br><span class="line">    count += len;        </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如果参数str为空返回appendNull(); 该方法最终返回return this;接下来看ensureCapacityInternal()方法，传入的count+len是hello与world的总长度</p>
</li>
<li><p>进入ensureCapacityInternal()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code        </span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;            </span><br><span class="line">        value = Arrays.copyOf(value,newCapacity(minimumCapacity));        </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一目了然。 copyOf(char[] original, int newLength)的方法查JDK帮助文档可知： 复制指定的数组，复制具有指定的长度。也就是说 ensureCapacityInternal()方法其实是重新复制了一个新数组，将长度扩大成传入的参数长度，并重新赋值给value</p>
</li>
<li><p>进入String的getChars()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getChars</span><span class="params">(<span class="keyword">int</span> srcBegin, <span class="keyword">int</span> srcEnd, <span class="keyword">char</span> dst[], <span class="keyword">int</span> dstBegin)</span> </span>&#123;<span class="comment">//0,len=5,value=[hello],count=5</span></span><br><span class="line">        <span class="keyword">if</span> (srcBegin &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (srcEnd &gt; value.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (srcBegin &gt; srcEnd) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(srcEnd - srcBegin);</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(value, srcBegin, dst, dstBegin, srcEnd - srcBegin);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最终调用的是System.arraycopy的方法:将指定源数组中的数组从指定位置复制到目标数组的指定位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> srcPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Object dest,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> destPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*src - 源数组。</span></span></span><br><span class="line"><span class="function"><span class="comment"> srcPos - 源数组中的起始位置。</span></span></span><br><span class="line"><span class="function"><span class="comment"> dest - 目标数组。</span></span></span><br><span class="line"><span class="function"><span class="comment"> destPos - 目的地数据中的起始位置。</span></span></span><br><span class="line"><span class="function"><span class="comment"> length - 要复制的数组元素的数量。 </span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">System.<span class="title">arraycopy</span><span class="params">([world], <span class="number">0</span>, [hello], <span class="number">5</span>, <span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>以上可知，append方法其实是创建了一个新的数组，扩大了长度，将需要添加的字符串给复制到这个新的数组中去。</p>
</li>
</ol>
<p>其他方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">char</span> ch)</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 关于StringBuffer和StringBuilder的使用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shkstart</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2019 下午 3:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferBuilderTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对比String、StringBuffer、StringBuilder三者的效率：</span></span><br><span class="line"><span class="comment">    从高到低排列：StringBuilder &gt; StringBuffer &gt; String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始设置</span></span><br><span class="line">        <span class="keyword">long</span> startTime = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">long</span> endTime = <span class="number">0L</span>;</span><br><span class="line">        String text = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        StringBuilder builder = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//开始对比</span></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            buffer.append(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            builder.append(String.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">            text = text + i;</span><br><span class="line">        &#125;</span><br><span class="line">        endTime = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;String的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    StringBuffer的常用方法：</span></span><br><span class="line"><span class="comment">StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接</span></span><br><span class="line"><span class="comment">StringBuffer delete(int start,int end)：删除指定位置的内容</span></span><br><span class="line"><span class="comment">StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str</span></span><br><span class="line"><span class="comment">StringBuffer insert(int offset, xxx)：在指定位置插入xxx</span></span><br><span class="line"><span class="comment">StringBuffer reverse() ：把当前字符序列逆转</span></span><br><span class="line"><span class="comment">public int indexOf(String str)</span></span><br><span class="line"><span class="comment">public String substring(int start,int end):返回一个从start开始到end索引结束的左闭右开区间的子字符串</span></span><br><span class="line"><span class="comment">public int length()</span></span><br><span class="line"><span class="comment">public char charAt(int n )</span></span><br><span class="line"><span class="comment">public void setCharAt(int n ,char ch)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        总结：</span></span><br><span class="line"><span class="comment">        增：append(xxx)</span></span><br><span class="line"><span class="comment">        删：delete(int start,int end)</span></span><br><span class="line"><span class="comment">        改：setCharAt(int n ,char ch) / replace(int start, int end, String str)</span></span><br><span class="line"><span class="comment">        查：charAt(int n )</span></span><br><span class="line"><span class="comment">        插：insert(int offset, xxx)</span></span><br><span class="line"><span class="comment">        长度：length();</span></span><br><span class="line"><span class="comment">        *遍历：for() + charAt() / toString()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer s1 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        s1.append(<span class="number">1</span>);</span><br><span class="line">        s1.append(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line"><span class="comment">//        s1.delete(2,4);</span></span><br><span class="line"><span class="comment">//        s1.replace(2,4,&quot;hello&quot;);</span></span><br><span class="line"><span class="comment">//        s1.insert(2,false);</span></span><br><span class="line"><span class="comment">//        s1.reverse();</span></span><br><span class="line">        String s2 = s1.substring(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s1.length());</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    String、StringBuffer、StringBuilder三者的异同？</span></span><br><span class="line"><span class="comment">    String:不可变的字符序列；底层使用char[]存储</span></span><br><span class="line"><span class="comment">    StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储</span></span><br><span class="line"><span class="comment">    StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    源码分析：</span></span><br><span class="line"><span class="comment">    String str = new String();//char[] value = new char[0];</span></span><br><span class="line"><span class="comment">    String str1 = new String(&quot;abc&quot;);//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。</span></span><br><span class="line"><span class="comment">    System.out.println(sb1.length());//</span></span><br><span class="line"><span class="comment">    sb1.append(&#x27;a&#x27;);//value[0] = &#x27;a&#x27;;</span></span><br><span class="line"><span class="comment">    sb1.append(&#x27;b&#x27;);//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    //问题1. System.out.println(sb2.length());//3</span></span><br><span class="line"><span class="comment">    //问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。</span></span><br><span class="line"><span class="comment">             默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        StringBuffer sb1 = <span class="keyword">new</span> StringBuffer(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        sb1.setCharAt(<span class="number">0</span>,<span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">        System.out.println(sb1);</span><br><span class="line"></span><br><span class="line">        StringBuffer sb2 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        System.out.println(sb2.length());<span class="comment">//0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="1-5-字符串相关类：StringBuilder"><a href="#1-5-字符串相关类：StringBuilder" class="headerlink" title="1.5 字符串相关类：StringBuilder"></a>1.5 字符串相关类：StringBuilder</h5><ul>
<li>StringBuilder和StringBuffer非常相似，均代表可变的字符序列，而且提供相关功能的方法也一样</li>
<li>面试题：对比String、StringBuffer、StringBuilder<ul>
<li>String(JDK1.0)：不可变字符序列</li>
<li>StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全</li>
<li>StringBuilder(JDK 5.0)：可变字符序列、效率高、线程不安全</li>
<li>注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值</li>
</ul>
</li>
</ul>
<p><strong>相关代码测试</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> String类;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matcher;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringExer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    将一个字符串进行反转。将字符串中指定部分进行反转，比如“abcdefg”反转为&quot;abfedcg&quot;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">        System.out.println(reverse1(<span class="number">2</span>, <span class="number">5</span>, str));</span><br><span class="line">        System.out.println(reverse2(<span class="number">2</span>, <span class="number">5</span>, str));</span><br><span class="line">        System.out.println(reverse3(<span class="number">2</span>, <span class="number">5</span>, str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式一：转为char[] 反转区间为[startIndex, endIndex]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverse1</span><span class="params">(<span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex, String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] arr = str.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = startIndex, y = endIndex; x &lt; y; x++, y--) &#123;</span><br><span class="line">                <span class="keyword">char</span> temp = arr[x];</span><br><span class="line">                arr[x] = arr[y];</span><br><span class="line">                arr[y] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(arr);<span class="comment">//返回的字符串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：使用String的拼接 反转区间为[startIndex, endIndex]</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverse2</span><span class="params">(<span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex, String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//第一部分</span></span><br><span class="line">            String newStr = str.substring(<span class="number">0</span>, startIndex);</span><br><span class="line">            <span class="comment">//第二部分</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = endIndex; i &gt;= startIndex; i--) &#123;</span><br><span class="line">                newStr += str.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第三部分</span></span><br><span class="line">            newStr += str.substring(endIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> newStr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式三；使用StringBuffer/StringBuilder替换String</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverse3</span><span class="params">(<span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex, String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span>) &#123;</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder(str.length());<span class="comment">//创建一个原字符串长度的StringBuilder变量</span></span><br><span class="line">            <span class="comment">//第一部分</span></span><br><span class="line">            stringBuilder.append(str.substring(<span class="number">0</span>, startIndex));</span><br><span class="line">            <span class="comment">//第二部分</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = endIndex; i &gt;= startIndex; i--) &#123;</span><br><span class="line">                stringBuilder.append(str.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//第三部分</span></span><br><span class="line">            stringBuilder.append(str.substring(endIndex + <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取一个字符串在另一个字符串中出现的次数。比如：获取“ab”在 “abkkcadkabkebfkaabkskab” 中出现的次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String mainStr = <span class="string">&quot;abkkcadkabkebfkaabkskab&quot;</span>;</span><br><span class="line">        String subStr = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.println(getCount1(mainStr, subStr));</span><br><span class="line">        System.out.println(getCount2(mainStr, subStr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式一：使用正则表达式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount1</span><span class="params">(String mainStr, String subStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        Pattern pat = Pattern.compile(subStr);</span><br><span class="line">        Matcher matcher = pat.matcher(mainStr);</span><br><span class="line">        <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二；使用字符串的indexOf方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount2</span><span class="params">(String mainStr, String subStr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> subLength = subStr.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mainStr.length() &gt;= subStr.length()) &#123;</span><br><span class="line">            <span class="comment">//方式一</span></span><br><span class="line">            <span class="keyword">while</span> ((index = mainStr.indexOf(subStr, index)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                index += subLength;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//           // 方式二</span></span><br><span class="line"><span class="comment">//            while((index = mainStr.indexOf(subStr))!= -1)&#123;</span></span><br><span class="line"><span class="comment">//                count++;</span></span><br><span class="line"><span class="comment">//                mainStr = mainStr.substring(index+subLength);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取两个字符串最大的相同子串</span></span><br><span class="line"><span class="comment">     str1 = &quot;abcwerthelloyuiodefabcdef&quot;;str2 = &quot;cvhellobnm&quot;</span></span><br><span class="line"><span class="comment">   提示：将短的那个串进行长度依次递减的子串与较长的串比较。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;abcwerthelloyuiodefabcdefxiong&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;cvhellodfsaxiong&quot;</span>;</span><br><span class="line">        System.out.println(getMaxSameString(str1, str2));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMaxSameString</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str1 != <span class="keyword">null</span> &amp;&amp; str2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            StringBuffer sb1 = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            String maxString = (str1.length() &gt; str2.length())?str1:str2;</span><br><span class="line">            String minString = (str1.length() &lt;= str2.length())?str1:str2;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> len = minString.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>,y = len -i; y &lt;= len; x++,y++)&#123;</span><br><span class="line">                    String subString = minString.substring(x, y);</span><br><span class="line">                    <span class="keyword">if</span>(maxString.contains(subString))&#123;</span><br><span class="line">                        sb1.append(subString + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sb1.length() != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">                String dest = <span class="keyword">null</span>;</span><br><span class="line">                String[] spilt = sb1.toString().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; spilt.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(spilt[i].length() &gt; max)&#123;</span><br><span class="line">                        max = spilt[i].length();</span><br><span class="line">                        dest = spilt[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> dest;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="2-JDK8之前的日期时间API"><a href="#2-JDK8之前的日期时间API" class="headerlink" title="2.JDK8之前的日期时间API"></a>2.JDK8之前的日期时间API</h4><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210717125819.png" alt="image-20210717125817612" style="zoom:67%;" />

<h5 id="2-1-java-lang-System类"><a href="#2-1-java-lang-System类" class="headerlink" title="2.1 java.lang.System类"></a>2.1 java.lang.System类</h5><p>System类提供的public static long currentTimeMillis()用来返回当时时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。此方法适用于计算时间差</p>
<ul>
<li>计算世界时间的主要标准有<ul>
<li>UTC(Coordinated Universal Time)</li>
<li>GMT(Greewich MEan Time)</li>
<li>CST(Central Standard Time)</li>
</ul>
</li>
</ul>
<h5 id="2-2-java-util-Date类"><a href="#2-2-java-util-Date类" class="headerlink" title="2.2 java.util.Date类"></a>2.2 java.util.Date类</h5><p>表示特定的瞬间，精确到毫秒</p>
<ul>
<li>构造器<ul>
<li>Date()：使用无参构造器创建的时间可以获取本地当前时间</li>
<li>Date(long date)：创建指定毫秒数的Date对象</li>
</ul>
</li>
<li>常用方法<ul>
<li>getTime()：返回自1970年1月1日00：00：00 GMT以来此Date对象表示的毫秒数</li>
<li>toString()：把此Date对象转化为以下的形式String：dow mon dd hh:mm:ss zzz yyy 其中：dow是一周中的某一天(Sun,Mon,Tue,Wed,Thu,Fri,Sat)，zzz是标准时间</li>
<li>其他很多方法都过时了</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 日期和时间的API;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.System类中的cuurentTimeMillis</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> time = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差</span></span><br><span class="line">        <span class="comment">//称为时间戳</span></span><br><span class="line">        System.out.println(time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    java.util.Data类</span></span><br><span class="line"><span class="comment">            |----java.sql.Data类</span></span><br><span class="line"><span class="comment">    1.两个构造器的使用</span></span><br><span class="line"><span class="comment">        &gt;构造器一：Data()：创建一个对应当前时间的Date对象</span></span><br><span class="line"><span class="comment">        &gt;构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line"><span class="comment">    2.两个方法的使用</span></span><br><span class="line"><span class="comment">        &gt;toString()；显示当前的年、月、日、时、分、秒</span></span><br><span class="line"><span class="comment">        &gt;getTime()：获取当前Date对象对应的毫秒数。（时间戳）</span></span><br><span class="line"><span class="comment">    3.java.sql.Data对应着数据库中的日期类型变量</span></span><br><span class="line"><span class="comment">        &gt;如何实例化</span></span><br><span class="line"><span class="comment">        &gt;如何将java.util.Date对象转化为java.sql.Date对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date1);</span><br><span class="line">        System.out.println(date1.getTime());<span class="comment">//Tue Jul 20 17:16:29 CST 2021</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造器二：Date(long date)创建指定毫秒数的Date对象</span></span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date(<span class="number">1626772568900L</span>);</span><br><span class="line">        System.out.println(date2.toString());<span class="comment">//Tue Jul 20 17:16:08 CST 2021</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建java.sql.Date对象</span></span><br><span class="line">        java.sql.Date date3 = <span class="keyword">new</span> java.sql.Date(<span class="number">1626772568900L</span>);</span><br><span class="line">        System.out.println(date3);<span class="comment">//2021-07-20</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何将java.util.Date对象转化为java.sql.Date对象</span></span><br><span class="line">        <span class="comment">//情况一：多态</span></span><br><span class="line">        Date date4 = <span class="keyword">new</span> java.sql.Date(<span class="number">1626772568900L</span>);</span><br><span class="line">        java.sql.Date date5 = (java.sql.Date)date4;</span><br><span class="line">        System.out.println(date5);<span class="comment">//2021-07-20</span></span><br><span class="line">        <span class="comment">//情况二：间接传递</span></span><br><span class="line">        Date date6 = <span class="keyword">new</span> Date();</span><br><span class="line">        java.sql.Date date7 = <span class="keyword">new</span> java.sql.Date(date6.getTime());</span><br><span class="line">        System.out.println(date7);<span class="comment">//2021-07-20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="2-3-java-text-SimpleDateFormat类"><a href="#2-3-java-text-SimpleDateFormat类" class="headerlink" title="2.3 java.text.SimpleDateFormat类"></a>2.3 java.text.SimpleDateFormat类</h5><ul>
<li>Date类的API不易国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类</li>
<li>它允许进行格式化：日期-&gt;文本、解析：文本-&gt;日期</li>
<li>格式化<ul>
<li>SimpleDateFormat()：默认的模式和语言环境创建对象</li>
<li>public SimpleDateFormat(String pattern)：该构造方法可以用参数pattern指定的格式创建一个对象，该对象调用：</li>
<li>public String format(Date date)：方法格式化时间对象date</li>
</ul>
</li>
<li>解析<ul>
<li>public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210717150200.png" alt="image-20210717150157636"></p>
<h5 id="2-4-java-util-Calendar-日历类"><a href="#2-4-java-util-Calendar-日历类" class="headerlink" title="2.4 java.util.Calendar(日历类)"></a>2.4 java.util.Calendar(日历类)</h5><ul>
<li><p>Calendar是一个抽象基类，主要完成日期字段之间相互操作的功能。</p>
</li>
<li><p>获取Calendar的实例方法</p>
<ul>
<li>使用Calendar.getInstance()方法</li>
<li>调用它的子类GregorianCalendar的构造器</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210717171046.png" alt="image-20210717171045329"></li>
<li>一个Calendar的实例是系统时间的抽象表示，通过get(int filed)方法来取得想要的时间信息。比如YEAR、MONTＨ、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND<ul>
<li>public void set(int filed, int value)</li>
<li>public void add(int filed, int amount)</li>
<li>public final Date getTime()</li>
<li>public final void setTime(Date date)</li>
</ul>
</li>
<li>注意：<ul>
<li>获取月份时：一月是0，二月是1，以此类推</li>
<li>获取星期时：周一时是1，周二是2，以此类推</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="comment">// 从一个 Calendar 对象中获取 Date 对象</span></span><br><span class="line">Date date = calendar.getTime();</span><br><span class="line"><span class="comment">// 使用给定的 Date 设置此 Calendar 的时间</span></span><br><span class="line">date = <span class="keyword">new</span> Date(<span class="number">234234235235L</span>);</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH, <span class="number">8</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间日设置为8后,时间是:&quot;</span> + calendar.getTime());</span><br><span class="line">calendar.add(Calendar.HOUR, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;当前时间加2小时后,时间是:&quot;</span> + calendar.getTime());</span><br><span class="line">calendar.add(Calendar.MONTH, -<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;当前日期减2个月后,时间是:&quot;</span> + calendar.getTime());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 日期和时间的API;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateTimeTest2</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    SimpleDateFormat的使用：simpleDateFormat对日期Date类的格式化和解析</span></span><br><span class="line"><span class="comment">    1.两个操作：</span></span><br><span class="line"><span class="comment">    1.1 格式化：日期-&gt;字符串</span></span><br><span class="line"><span class="comment">    1.2 解析：格式化的逆过程，字符串-&gt;日期</span></span><br><span class="line"><span class="comment">    2.SimpleDateFormat的实例化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="comment">//实例化SimpleDateFormat：使用默认构造器</span></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line">        <span class="comment">//格式化：日期——&gt;字符串</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date);<span class="comment">//Wed Jul 21 14:07:38 CST 2021</span></span><br><span class="line">        String format = sdf.format(date);</span><br><span class="line">        System.out.println(format);<span class="comment">//21-7-21 下午2:07</span></span><br><span class="line">        <span class="comment">//解析：格式化的逆过程，字符串---&gt;日期</span></span><br><span class="line">        String str = <span class="string">&quot;21-7-21 下午1:57&quot;</span>;</span><br><span class="line">        Date date1 = sdf.parse(str);</span><br><span class="line">        System.out.println(date1);<span class="comment">//Wed Jul 21 13:57:00 CST 2021</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//**********按照指定的方式格式化和解析：调用带参的构造器</span></span><br><span class="line">        SimpleDateFormat sdf1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">//格式化</span></span><br><span class="line">        String format1 = sdf1.format(date);</span><br><span class="line">        System.out.println(format1);<span class="comment">//2021-07-21 02:07:38</span></span><br><span class="line">        <span class="comment">//解析：要求字符串必须是符合SimpleDateFormat识别的格式（通过构造器参数体现）</span></span><br><span class="line">        Date date2 = sdf1.parse(<span class="string">&quot;2021-07-21 14:07:27&quot;</span>);</span><br><span class="line">        System.out.println(date2);<span class="comment">//Wed Jul 21 14:07:27 CST 2021</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    将字符串&quot;2021-07-21&quot;转换为java.sql.Date</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        String birth = <span class="string">&quot;2021-07-21&quot;</span>;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        Date date = sdf.parse(birth);</span><br><span class="line">        java.sql.Date date1 = <span class="keyword">new</span> java.sql.Date(date.getTime());</span><br><span class="line">        System.out.println(date1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Calendar日历（抽象类）的使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.实例化</span></span><br><span class="line">        <span class="comment">//方式一：创建其子类(GregorianCalendar)的对象</span></span><br><span class="line">        <span class="comment">//方式二：调用其静态方法getInstance()</span></span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        System.out.println(calendar.getClass());<span class="comment">//class java.util.GregorianCalendar</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.常用方法</span></span><br><span class="line">        <span class="comment">//get()</span></span><br><span class="line">        <span class="keyword">int</span> days = calendar.get(Calendar.DAY_OF_MONTH);<span class="comment">//一个月中的第几天</span></span><br><span class="line">        System.out.println(days);</span><br><span class="line">        System.out.println(calendar.get(Calendar.DAY_OF_YEAR));<span class="comment">//一年中的第几天</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//set() calendar可变性</span></span><br><span class="line">        calendar.set(Calendar.DAY_OF_MONTH,<span class="number">22</span>);<span class="comment">//改变当前时间为本月中的第22天</span></span><br><span class="line">        days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//add()</span></span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</span><br><span class="line">        days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//getTime()：日历类--&gt;Date</span></span><br><span class="line">        Date date = calendar.getTime();</span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//setTime()：Date---&gt;日历类</span></span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">        calendar.setTime(date1);</span><br><span class="line">        days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="3-JDK8中新增的日期时间API"><a href="#3-JDK8中新增的日期时间API" class="headerlink" title="3.JDK8中新增的日期时间API"></a>3.JDK8中新增的日期时间API</h4><h5 id="3-1-产生背景"><a href="#3-1-产生背景" class="headerlink" title="3.1 产生背景"></a>3.1 产生背景</h5><p>​        如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不 过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0中包含了 一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用 了。而Calendar并不比Date好多少。它们面临的问题是：<br>​        可变性：像日期和时间这样的类应该是不可变的。<br>​        偏移性：Date中的年份是从1900开始的，而月份都从0开始。<br>​        格式化：格式化只对Date有用，Calendar则不行。<br>​         此外，它们也不是线程安全的；不能处理闰秒等。<br>​        总结：对日期和时间的操作一直是Java程序员最痛苦的地方之一。</p>
<h5 id="3-2-新时间日期API"><a href="#3-2-新时间日期API" class="headerlink" title="3.2 新时间日期API"></a>3.2 新时间日期API</h5><ul>
<li><p>第三次引入的API是成功的，并且Java 8中引入的java.time API 已经纠正了 过去的缺陷，将来很长一段时间内它都会为我们服务。</p>
</li>
<li><p>Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。 新的 java.time 中包含了所有关于本地日期（LocalDate）、本地时间 （LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime） 和持续时间（Duration）的类。历史悠久的 Date 类新增了 toInstant() 方法， 用于把 Date 转换成新的表示形式。这些新增的本地化时间日期 API 大大简 化了日期时间和本地化的管理。</p>
</li>
<li><p>java.time – 包含值对象的基础包<br>java.time.chrono – 提供对不同的日历系统的访问<br>java.time.format – 格式化和解析时间和日期<br>java.time.temporal – 包括底层框架和扩展特性<br>java.time.zone – 包含时区支持的类 说明：大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽 管有68个新的公开类型，大多数开发者，大概将只会用到其中的三分之一。</p>
</li>
<li><p>LocalDate、LocalTime、LocalDateTime类是其中比较重要的类，他们的实例是不可变的对象，分别表示使用ISO-8601日历系统的日期、时间、日期和时间，他们提供了人简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息</p>
<ul>
<li>LocalDate代表ISO格式（yyyy-MM-dd)的日期，可以存储生日、纪念日等日期</li>
<li>LocalTime表示一个时间，而不是日期</li>
<li>LocalDateTime是用来表示日期和时间的，这是最常用的类之一</li>
</ul>
</li>
<li><p>注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。</p>
</li>
</ul>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210721153324.png" alt="image-20210721153315244" style="zoom: 67%;" />

<h5 id="3-3-瞬时：instance"><a href="#3-3-瞬时：instance" class="headerlink" title="3.3 瞬时：instance"></a>3.3 瞬时：instance</h5><ul>
<li>Instant：时间线上的一个瞬时点。 这可能被用来记录应用程序中的事件时间 戳。</li>
<li>在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是 时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连 续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机 处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中， 也是从1970年开始，但以毫秒为单位。</li>
<li>java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间 单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。 概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒 数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。</li>
<li>(1 ns = 10-9 s) 1秒 = 1000毫秒 =10^6微秒=10^9纳秒</li>
</ul>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210721195759.png" alt="image-20210721195756710"></p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210721195827.png" alt="image-20210721195824428"></p>
<h5 id="3-4-格式化与解析日期或时间"><a href="#3-4-格式化与解析日期或时间" class="headerlink" title="3.4 格式化与解析日期或时间"></a>3.4 格式化与解析日期或时间</h5><ul>
<li>预定义的标准格式。如： ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</li>
<li>本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)</li>
<li>自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</li>
</ul>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210721195959.png" alt="image-20210721195958023"></p>
<h5 id="3-5-其他API"><a href="#3-5-其他API" class="headerlink" title="3.5 其他API"></a>3.5 其他API</h5><ul>
<li><p>ZoneId：该类中包含了所有的时区信息，一个时区的ID，如 Europe/Paris</p>
</li>
<li><p>ZonedDateTime：一个在ISO-8601日历系统时区的日期时间，如 2007-12- 03T10:15:30+01:00 Europe/Paris。</p>
<ul>
<li>其中每个时区都对应着ID，地区ID都为“{区域}/{城市}”的格式，例如： Asia/Shanghai等</li>
</ul>
</li>
<li><p>Clock：使用时区提供对当前即时、日期和时间的访问的时钟。</p>
</li>
<li><p>持续时间：Duration，用于计算两个“时间”间隔</p>
</li>
<li><p>日期间隔：Period，用于计算两个“日期”间隔</p>
</li>
<li><p>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整 到“下一个工作日”等操作。</p>
</li>
<li><p>TemporalAdjusters : 该类通过静态方法 (firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用 TemporalAdjuster 的实现。</p>
</li>
<li><pre><code class="java">//ZoneId:类中包含了所有的时区信息
// ZoneId的getAvailableZoneIds():获取所有的ZoneId
Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();
for (String s : zoneIds) &#123;
System.out.println(s);
&#125;
// ZoneId的of():获取指定时区的时间
LocalDateTime localDateTime = LocalDateTime.now(ZoneId.of(&quot;Asia/Tokyo&quot;));
System.out.println(localDateTime);
//ZonedDateTime:带时区的日期时间
// ZonedDateTime的now():获取本时区的ZonedDateTime对象
ZonedDateTime zonedDateTime = ZonedDateTime.now();
System.out.println(zonedDateTime);
// ZonedDateTime的now(ZoneId id):获取指定时区的ZonedDateTime对象
ZonedDateTime zonedDateTime1 = ZonedDateTime.now(ZoneId.of(&quot;Asia/Tokyo&quot;));
System.out.println(zonedDateTime1);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* &#96;&#96;&#96;java</span><br><span class="line">  &#x2F;&#x2F;Duration:用于计算两个“时间”间隔，以秒和纳秒为基准</span><br><span class="line">  LocalTime localTime &#x3D; LocalTime.now();</span><br><span class="line">  LocalTime localTime1 &#x3D; LocalTime.of(15, 23, 32);</span><br><span class="line">  &#x2F;&#x2F;between():静态方法，返回Duration对象，表示两个时间的间隔</span><br><span class="line">  Duration duration &#x3D; Duration.between(localTime1, localTime);</span><br><span class="line">  System.out.println(duration);</span><br><span class="line">  System.out.println(duration.getSeconds());</span><br><span class="line">  System.out.println(duration.getNano());</span><br><span class="line">  LocalDateTime localDateTime &#x3D; LocalDateTime.of(2016, 6, 12, 15, 23, 32);</span><br><span class="line">  LocalDateTime localDateTime1 &#x3D; LocalDateTime.of(2017, 6, 12, 15, 23, 32);</span><br><span class="line">  Duration duration1 &#x3D; Duration.between(localDateTime1, localDateTime);</span><br><span class="line">  System.out.println(duration1.toDays());</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="java">//Period:用于计算两个“日期”间隔，以年、月、日衡量LocalDate localDate = LocalDate.now();LocalDate localDate1 = LocalDate.of(2028, 3, 18);Period period = Period.between(localDate, localDate1);System.out.println(period);System.out.println(period.getYears());System.out.println(period.getMonths());System.out.println(period.getDays());Period period1 = period.withYears(2);System.out.println(period1);
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* &#96;&#96;&#96;java</span><br><span class="line">  &#x2F;&#x2F; TemporalAdjuster:时间校正器</span><br><span class="line">  &#x2F;&#x2F; 获取当前日期的下一个周日是哪天？</span><br><span class="line">  TemporalAdjuster temporalAdjuster &#x3D; TemporalAdjusters.next(DayOfWeek.SUNDAY);</span><br><span class="line">  LocalDateTime localDateTime &#x3D; LocalDateTime.now().with(temporalAdjuster);</span><br><span class="line">  System.out.println(localDateTime);</span><br><span class="line">  &#x2F;&#x2F; 获取下一个工作日是哪天？</span><br><span class="line">  LocalDate localDate &#x3D; LocalDate.now().with(new TemporalAdjuster() &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public Temporal adjustInto(Temporal temporal) &#123;</span><br><span class="line">  LocalDate date &#x3D; (LocalDate) temporal;</span><br><span class="line">  if (date.getDayOfWeek().equals(DayOfWeek.FRIDAY)) &#123;</span><br><span class="line">  return date.plusDays(3);</span><br><span class="line">  &#125; else if (date.getDayOfWeek().equals(DayOfWeek.SATURDAY)) &#123;</span><br><span class="line">  return date.plusDays(2);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  return date.plusDays(1);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  System.out.println(&quot;下一个工作日是：&quot; + localDate);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>传统日期的处理与转换</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210721200405.png" alt="image-20210721200404286"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 日期和时间的API;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.time.format.FormatStyle;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.TemporalAccessor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKDateTimeTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    LocalDate、LocalTime、LocalDateTime的使用</span></span><br><span class="line"><span class="comment">    说明：</span></span><br><span class="line"><span class="comment">        1.LocalDateTime相较于LocalDate、LocalTime，使用频率要高</span></span><br><span class="line"><span class="comment">        2.类似于Calendar</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//now()获取当前时间</span></span><br><span class="line">        LocalDate localDate = LocalDate.now();</span><br><span class="line">        LocalTime localTime = LocalTime.now();</span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;LocalDate: &quot;</span> + localDate);<span class="comment">//LocalDate: 2021-07-21</span></span><br><span class="line">        System.out.println(<span class="string">&quot;LocalTime: &quot;</span> + localTime);<span class="comment">//LocalTime: 20:35:54.300</span></span><br><span class="line">        System.out.println(<span class="string">&quot;LocalDateTime: &quot;</span> + localDateTime);<span class="comment">//LocalDateTime: 2021-07-21T20:35:54.300</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//of()设置指定的年、月、日、时、分、秒，没有偏移量 此处以LocalDateTime为例</span></span><br><span class="line">        LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">2021</span>,<span class="number">7</span>,<span class="number">21</span>,<span class="number">20</span>,<span class="number">38</span>,<span class="number">16</span>);</span><br><span class="line">        System.out.println(localDateTime1);<span class="comment">//2021-07-21T20:38:16</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//getXxx()获取当前相关的属性</span></span><br><span class="line">        System.out.println(localDateTime.getDayOfYear());<span class="comment">//返回当前是一年中的第几天</span></span><br><span class="line">        System.out.println(localDateTime.getDayOfMonth());<span class="comment">//返回当前是一个月中的第几天</span></span><br><span class="line">        System.out.println(localDateTime.getDayOfWeek());<span class="comment">//返回房前是周几</span></span><br><span class="line">        System.out.println(localDateTime.getMonthValue());<span class="comment">//返回当前月份 7</span></span><br><span class="line">        System.out.println(localDateTime.getYear());<span class="comment">//返回当前年份</span></span><br><span class="line">        System.out.println(localDateTime.getMonth());<span class="comment">//返回当前月份 JULY</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//withXxx()设置相关属性，体现不可变性</span></span><br><span class="line">        LocalDateTime localDateTime2 = localDateTime.withDayOfMonth(<span class="number">23</span>);</span><br><span class="line">        System.out.println(localDateTime);<span class="comment">//2021-07-21T20:48:26.324</span></span><br><span class="line">        System.out.println(localDateTime2);<span class="comment">//2021-07-23T20:48:26.324</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Instant的使用</span></span><br><span class="line"><span class="comment">    类似于java.util.Date类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//now()获取本初子午线对应的标准时间</span></span><br><span class="line">        Instant instant = Instant.now();</span><br><span class="line">        System.out.println(instant);<span class="comment">//2021-07-21T12:50:33.857Z</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加时间偏移量 我们在东八区</span></span><br><span class="line">        OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">        System.out.println(offsetDateTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//toEpochMill()获取自1970年1月1日0时0分0秒（UTC)开始的毫秒数 ----&gt;Date类的getTime()</span></span><br><span class="line">        <span class="keyword">long</span> milli = instant.toEpochMilli();</span><br><span class="line">        System.out.println(milli);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//ofEpochMill()通过给定毫秒数，获取Instant实例---&gt;Date(long millis)</span></span><br><span class="line">        Instant instant1 = Instant.ofEpochMilli(<span class="number">1626872518532L</span>);</span><br><span class="line">        System.out.println(instant1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    DateTimeFormatter：格式化或解析日期、时间</span></span><br><span class="line"><span class="comment">    类似于SimpleDateFormat</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//方式一：预定义的标准格式。如ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</span></span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">        <span class="comment">//格式化：日期--&gt;字符串</span></span><br><span class="line">        LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">        String str1 = formatter.format(localDateTime);</span><br><span class="line">        System.out.println(localDateTime);<span class="comment">//2021-07-21T21:09:21.825</span></span><br><span class="line">        System.out.println(str1);<span class="comment">//2021-07-21T21:09:21.825</span></span><br><span class="line">        <span class="comment">//解析：字符串---&gt;日期</span></span><br><span class="line">        TemporalAccessor parse = formatter.parse(<span class="string">&quot;2021-07-21T21:09:21.825&quot;</span>);</span><br><span class="line">        System.out.println(parse);<span class="comment">//&#123;&#125;,ISO resolved to 2021-07-21T21:09:21.825</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：本地化相关的格式。如：ofLocalizedDateTime()</span></span><br><span class="line">        <span class="comment">//FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT：适用于LocalDateTime</span></span><br><span class="line">        DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line">        <span class="comment">//格式化</span></span><br><span class="line">        String str2 = formatter1.format(localDateTime);</span><br><span class="line">        System.out.println(str2);<span class="comment">//2021年7月21日 下午09时18分57秒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式三：自定义格式。如ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;)</span></span><br><span class="line">        DateTimeFormatter formatter2 = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">//格式化</span></span><br><span class="line">        String str4 = formatter2.format(localDateTime);</span><br><span class="line">        System.out.println(str4);<span class="comment">//2021-07-21 09:23:38</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="4-Java比较器"><a href="#4-Java比较器" class="headerlink" title="4.Java比较器"></a>4.Java比较器</h4><p>​        在Java中经常会涉及到对象数组的排序问题，那么就涉及到对象之间 的比较问题。</p>
<p>​        Java实现对象排序的方式有两种： </p>
<p>​        ①自然排序：java.lang.Comparable ；②定制排序：java.util.Comparator</p>
<h5 id="4-1-方式一：自然排序：java-lang-Comparable"><a href="#4-1-方式一：自然排序：java-lang-Comparable" class="headerlink" title="4.1 方式一：自然排序：java.lang.Comparable"></a>4.1 方式一：自然排序：java.lang.Comparable</h5><ul>
<li>Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序。 </li>
<li>实现 Comparable 的类必须实现 compareTo(Object obj) 方法，两个对象即 通过 compareTo(Object obj) 方法的返回值来比较大小。如果当前对象this大 于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回 负整数，如果当前对象this等于形参对象obj，则返回零。 </li>
<li>实现Comparable接口的对象列表（和数组）可以通过 Collections.sort 或 Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有 序集合中的元素，无需指定比较器。 </li>
<li>对于类 C 的每一个 e1 和 e2 来说，当且仅当 e1.compareTo(e2) == 0 与 e1.equals(e2) 具有相同的 boolean 值时，类 C 的自然排序才叫做与 equals  一致。建议（虽然不是必需的）最好使自然排序与 equals 一致。</li>
<li>Comparable 的典型实现：(默认都是从小到大排列的) <ul>
<li>String：按照字符串中字符的Unicode值进行比较 </li>
<li>Character：按照字符的Unicode值来进行比较 </li>
<li>数值类型对应的包装类以及BigInteger、BigDecimal：按照它们对应的数值 大小进行比较 </li>
<li>Boolean：true 对应的包装类实例大于 false 对应的包装类实例 </li>
<li>Date、Time等：后面的日期时间比前面的日期时间大</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Java比较器;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Goods&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, peice=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指明商品比较大小的方式：按照价格从低到高排序，再按照产品名称从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            Goods goods = (Goods) o;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> - <span class="keyword">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;传入的数据类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="4-2-方式二：定制排序：java-util-Comparator"><a href="#4-2-方式二：定制排序：java-util-Comparator" class="headerlink" title="4.2 方式二：定制排序：java.util.Comparator"></a>4.2 方式二：定制排序：java.util.Comparator</h5><ul>
<li>当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码， 或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那 么可以考虑使用 Comparator 的对象来排序，强行对多个对象进行整体排 序的比较。</li>
<li>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返 回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示 o1小于o2。</li>
<li>可以将 Comparator 传递给 sort 方法（如 Collections.sort 或 Arrays.sort）， 从而允许在排序顺序上实现精确控制。</li>
<li>还可以使用 Comparator 来控制某些数据结构（如有序 set或有序映射）的 顺序，或者为那些没有自然顺序的对象 collection 提供排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Java比较器;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompareTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    一、说明：Java中的对象，正常情况下，只能进行比较：== 或！= 、不能使用 &gt; 或 &lt; 的</span></span><br><span class="line"><span class="comment">            但是在开发场景中，我们需要对多个对象进行排序</span></span><br><span class="line"><span class="comment">            实现方法：使用两个接口中的任何一个：Comparable 或 Comparator</span></span><br><span class="line"><span class="comment">    二、Comparable接口与Comparator的使用的对比：</span></span><br><span class="line"><span class="comment">            Comparable接口的方式一旦指定，保证Comparable接口实现类的对象在任何位置都可以比较大小</span></span><br><span class="line"><span class="comment">            Comparator接口属于临时性的比较</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Comparable接口的使用：自然排序</span></span><br><span class="line"><span class="comment">    1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式</span></span><br><span class="line"><span class="comment">    2.像String、包装类重写compareTo()方法以后，进行了从小到大的排列</span></span><br><span class="line"><span class="comment">    3.重写compareTo(obj)的规则</span></span><br><span class="line"><span class="comment">        如果当前对象this大于形参obj，则返回正整数</span></span><br><span class="line"><span class="comment">        如果当前对象this小于形参obj，则返回负数</span></span><br><span class="line"><span class="comment">        如果当前对象this等于形参obj，则返回零</span></span><br><span class="line"><span class="comment">    4.对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法，在compareTo(obj)方法中指明如何排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));<span class="comment">//[AA, CC, DD, GG, JJ, KK, MM]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Goods[] goods = <span class="keyword">new</span> Goods[<span class="number">5</span>];</span><br><span class="line">        goods[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovoMouse&quot;</span>,<span class="number">34</span>);</span><br><span class="line">        goods[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dellMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        goods[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;xiaomiMouse&quot;</span>,<span class="number">23</span>);</span><br><span class="line">        goods[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">65</span>);</span><br><span class="line">        goods[<span class="number">4</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;microsoftMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(goods);</span><br><span class="line">        System.out.println(Arrays.toString(goods));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Comparator接口的使用：定制排序</span></span><br><span class="line"><span class="comment">    1.背景：</span></span><br><span class="line"><span class="comment">    当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator的对象来排序</span></span><br><span class="line"><span class="comment">    2.重写compare(Object o1, Object o2)方法，比较o1和o2的大小</span></span><br><span class="line"><span class="comment">      如果重写方法返回正整数，则表示o1大于o2，如果返回负数则o1小于o2，如果返回0，表示相等</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Goods[] arr = <span class="keyword">new</span> Goods[<span class="number">6</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovoMouse&quot;</span>,<span class="number">34</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;dellMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;xiaomiMouse&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">65</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">224</span>);</span><br><span class="line">        arr[<span class="number">5</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;microsoftMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> Comparator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">                    Goods goods1 = (Goods) o1;</span><br><span class="line">                    Goods goods2 = (Goods) o2;</span><br><span class="line">                    <span class="keyword">if</span>(goods1.getName().equals(goods2.getName()))&#123;</span><br><span class="line">                        <span class="keyword">return</span> -Double.compare(goods1.getPrice(),goods2.getPrice());</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> goods1.getName().compareTo(goods2.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="5-System类"><a href="#5-System类" class="headerlink" title="5. System类"></a>5. System类</h4><ul>
<li><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。 该类位于java.lang包。 </p>
</li>
<li><p>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便 的进行调用。 </p>
</li>
<li><p>成员变量 </p>
<ul>
<li>System类内部包含in、out和err三个成员变量，分别代表标准输入流 (键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。 </li>
</ul>
</li>
<li><p>成员方法 </p>
<ul>
<li><p>native long currentTimeMillis()： </p>
<p>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时 间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。 </p>
</li>
<li><p>void exit(int status)： </p>
<p>该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表 异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>
</li>
<li><p>void gc()： </p>
<p>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。 </p>
</li>
<li><p>String getProperty(String key)： </p>
<p>该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108161714847.png" alt="image-20210816171447150"></p>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String javaVersion = System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;java的version:&quot;</span> + javaVersion);</span><br><span class="line">String javaHome = System.getProperty(<span class="string">&quot;java.home&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;java的home:&quot;</span> + javaHome);</span><br><span class="line">String osName = System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;os的name:&quot;</span> + osName);</span><br><span class="line">String osVersion = System.getProperty(<span class="string">&quot;os.version&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;os的version:&quot;</span> + osVersion);</span><br><span class="line">String userName = System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user的name:&quot;</span> + userName);</span><br><span class="line">String userHome = System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user的home:&quot;</span> + userHome);</span><br><span class="line">String userDir = System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;user的dir:&quot;</span> + userDir);</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h4 id="6-Math类"><a href="#6-Math类" class="headerlink" title="6. Math类"></a>6. Math类</h4><p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回 值类型一般为double型。 </p>
<p>abs     绝对值<br>acos,asin,atan,cos,sin,tan 三角函数<br>sqrt 平方根<br>pow(double a,doble b) a的b次幂<br>log 自然对数<br>exp e为底指数<br>max(double a,double b)<br>min(double a,double b)<br>random() 返回0.0到1.0的随机数<br>long round(double a)<br>double型数据a转换为long型（四舍五入）<br>toDegrees(double angrad) 弧度—&gt;角度<br>toRadians(double angdeg) 角度—&gt;弧度</p>
<h4 id="7-BigInteger与BigDecimal"><a href="#7-BigInteger与BigDecimal" class="headerlink" title="7. BigInteger与BigDecimal"></a>7. BigInteger与BigDecimal</h4><ul>
<li><p>Integer类作为int的包装类，能存储的最大整型值为2^31^-1，Long类也有限, 最大为2^63^-1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类 都无能为力，更不用说进行运算了。 </p>
</li>
<li><p>java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有 Java 的基本整数操作符的对应物，并提供 java.lang.Math 的所有相关方法。 另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、 位操作以及一些其他操作。 </p>
</li>
<li><p>构造器 </p>
<ul>
<li>BigInteger(String val)：根据字符串构建BigInteger对象</li>
</ul>
</li>
<li><p>常用方法</p>
<ul>
<li>public BigInteger abs()：返回此 BigInteger 的绝对值的 BigInteger。 </li>
<li>BigInteger add(BigInteger val) ：返回其值为 (this + val) 的 BigInteger </li>
<li>BigInteger subtract(BigInteger val) ：返回其值为 (this - val) 的 BigInteger </li>
<li>BigInteger multiply(BigInteger val) ：返回其值为 (this * val) 的 BigInteger </li>
<li>BigInteger divide(BigInteger val) ：返回其值为 (this / val) 的 BigInteger。整数 相除只保留整数部分。 </li>
<li>BigInteger remainder(BigInteger val) ：返回其值为 (this % val) 的 BigInteger。 </li>
<li>BigInteger[] divideAndRemainder(BigInteger val)：返回包含 (this / val) 后跟 (this % val) 的两个 BigInteger 的数组。 </li>
<li>BigInteger pow(int exponent) ：返回其值为 (this^exponent^) 的 BigInteger。</li>
</ul>
</li>
<li><p>一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中， 要求数字精度比较高，故用到java.math.BigDecimal类。 </p>
</li>
<li><p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。 </p>
</li>
<li><p>构造器 </p>
<ul>
<li>public BigDecimal(double val) </li>
<li>public BigDecimal(String val) </li>
</ul>
</li>
<li><p>常用方法 </p>
<ul>
<li>public BigDecimal add(BigDecimal augend) </li>
<li>public BigDecimal subtract(BigDecimal subtrahend) </li>
<li>public BigDecimal multiply(BigDecimal multiplicand) </li>
<li>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</li>
</ul>
</li>
<li><p>示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBigInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">&quot;12433241123&quot;</span>);</span><br><span class="line">	BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">	BigDecimal bd2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">	System.out.println(bi);</span><br><span class="line">	<span class="comment">// System.out.println(bd.divide(bd2));</span></span><br><span class="line">	System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">	System.out.println(bd.divide(bd2, <span class="number">15</span>, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>







</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Git原理(01)</title>
    <url>/2021/09/17/Git%E5%8E%9F%E7%90%86%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<span id="more"></span>

<h2 id="Git原理基本介绍"><a href="#Git原理基本介绍" class="headerlink" title="Git原理基本介绍"></a>Git原理基本介绍</h2><h3 id="1-代码仓库的初始化"><a href="#1-代码仓库的初始化" class="headerlink" title="1.  代码仓库的初始化"></a>1.  代码仓库的初始化</h3><ol>
<li><p>新建文件夹作为本地仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy</span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir git-demo</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化本地代码仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy</span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in C:/Files/gitStudy/.git/</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br></pre></td></tr></table></figure>

<p>初始化后会多出 .git的隐藏文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -la</span></span><br><span class="line">total 16</span><br><span class="line">drwxr-xr-x 1 xiong 197609 0 Aug 21 10:10 ./</span><br><span class="line">drwxr-xr-x 1 xiong 197609 0 Aug 21 08:52 ../</span><br><span class="line">drwxr-xr-x 1 xiong 197609 0 Aug 21 10:10 .git/</span><br><span class="line">drwxr-xr-x 1 xiong 197609 0 Aug 21 08:55 git-demo/</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看.git文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> find .git</span></span><br><span class="line">.git</span><br><span class="line">.git/config</span><br><span class="line">.git/description</span><br><span class="line">.git/HEAD</span><br><span class="line">.git/hooks</span><br><span class="line">.git/hooks/applypatch-msg.sample</span><br><span class="line">.git/hooks/commit-msg.sample</span><br><span class="line">.git/hooks/fsmonitor-watchman.sample</span><br><span class="line">.git/hooks/post-update.sample</span><br><span class="line">.git/hooks/pre-applypatch.sample</span><br><span class="line">.git/hooks/pre-commit.sample</span><br><span class="line">.git/hooks/pre-merge-commit.sample</span><br><span class="line">.git/hooks/pre-push.sample</span><br><span class="line">.git/hooks/pre-rebase.sample</span><br><span class="line">.git/hooks/pre-receive.sample</span><br><span class="line">.git/hooks/prepare-commit-msg.sample</span><br><span class="line">.git/hooks/push-to-checkout.sample</span><br><span class="line">.git/hooks/update.sample</span><br><span class="line">.git/info</span><br><span class="line">.git/info/exclude</span><br><span class="line">.git/objects</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/pack</span><br><span class="line">.git/refs</span><br><span class="line">.git/refs/heads</span><br><span class="line">.git/refs/tags</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除掉hooks目录下的.sample文件，便于查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf .git/hooks/*.sample</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> find .git</span></span><br><span class="line">.git</span><br><span class="line">.git/config</span><br><span class="line">.git/description</span><br><span class="line">.git/HEAD</span><br><span class="line">.git/hooks</span><br><span class="line">.git/info</span><br><span class="line">.git/info/exclude</span><br><span class="line">.git/objects</span><br><span class="line">.git/objects/info</span><br><span class="line">.git/objects/pack</span><br><span class="line">.git/refs</span><br><span class="line">.git/refs/heads</span><br><span class="line">.git/refs/tags</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="1-1-查看config文件"><a href="#1-1-查看config文件" class="headerlink" title="1.1 查看config文件"></a>1.1 查看config文件</h4><p>config是配置的意思，那么git config命令就是对git进行一些配置。而配置一般都是写在配置文件里面,git里面一共有3个配置文件</p>
<h5 id="1-1-1-仓库级配置文件"><a href="#1-1-1-仓库级配置文件" class="headerlink" title="1.1.1 仓库级配置文件"></a>1.1.1 仓库级配置文件</h5><p><strong>方法1：</strong></p>
<p>找到该文件，直接打开：该文件位于当前仓库下，路径.git/，文件名为config</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108211044226.png" alt="image-20210821104413522"></p>
<p>这个配置中的设置只对当前所在仓库(C:/Files/gitStudy)有效，仓库级配置文件内容如下：</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108211037689.png" alt="image-20210821103756493"></p>
<p><strong>方法2：</strong></p>
<p>通过命令查看项目配置（仓库级配置）：<code>git config --local -l</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --<span class="built_in">local</span> -l</span></span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=false</span><br><span class="line">core.bare=false</span><br><span class="line">core.logallrefupdates=true</span><br><span class="line">core.symlinks=false</span><br><span class="line">core.ignorecase=true</span><br></pre></td></tr></table></figure>

<h5 id="1-1-2-全局级配置文件"><a href="#1-1-2-全局级配置文件" class="headerlink" title="1.1.2 全局级配置文件"></a>1.1.2 全局级配置文件</h5><p><strong>方法1：</strong></p>
<p>以win10个人的PC机为例，在用户目录下，其路径为：C:\Users\Administrator，文件名为 .gitconfig</p>
<p>全局级配置文件内容如下：</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108211043817.png" alt="image-20210821104308404"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108211045927.png" alt="image-20210821104523114"></p>
<p><strong>方法2：</strong></p>
<p>通过命令查看全局级配置：<code>git config --global -l</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global -l</span></span><br><span class="line">user.name=xiongzhuo</span><br><span class="line">user.email=xiongzhuo@outlook.com</span><br><span class="line">core.autocrlf=true</span><br><span class="line">filter.lfs.clean=git-lfs clean -- %f</span><br><span class="line">filter.lfs.smudge=git-lfs smudge -- %f</span><br><span class="line">filter.lfs.process=git-lfs filter-process</span><br><span class="line">filter.lfs.required=true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="1-1-3-系统级配置文件"><a href="#1-1-3-系统级配置文件" class="headerlink" title="1.1.3 系统级配置文件"></a>1.1.3 系统级配置文件</h5><p><strong>方法1：</strong></p>
<p>本地git的安装目录下，以我的git安装路径为例：C:\SoftWares\Git\etc，文件名为：gitconfig，内容如下：</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108211052280.png" alt="image-20210821105251795"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108211053039.png" alt="image-20210821105332653"></p>
<p><strong>方法2：</strong></p>
<p>通过命令查看系统配置：git config –system -l</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --system -l</span></span><br><span class="line">diff.astextplain.textconv=astextplain</span><br><span class="line">filter.lfs.clean=git-lfs clean -- %f</span><br><span class="line">filter.lfs.smudge=git-lfs smudge -- %f</span><br><span class="line">filter.lfs.process=git-lfs filter-process</span><br><span class="line">filter.lfs.required=true</span><br><span class="line">http.sslbackend=openssl</span><br><span class="line">http.sslcainfo=C:/SoftWares/Git/mingw64/ssl/certs/ca-bundle.crt</span><br><span class="line">core.autocrlf=true</span><br><span class="line">core.fscache=true</span><br><span class="line">core.symlinks=false</span><br><span class="line">pull.rebase=false</span><br><span class="line">credential.helper=manager-core</span><br><span class="line">credential.https://dev.azure.com.usehttppath=true</span><br><span class="line">init.defaultbranch=master</span><br><span class="line">user.name=system</span><br><span class="line">user.email=system@email.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>对于git来说，配置文件的权重是仓库&gt;全局&gt;系统</strong></p>
<p><strong>查看当前生效的配置</strong></p>
<p>命令：<code>git config -l</code>，这个时候会显示最终三个配置文件计算后的配置信息，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config -l</span></span><br><span class="line">diff.astextplain.textconv=astextplain</span><br><span class="line">filter.lfs.clean=git-lfs clean -- %f</span><br><span class="line">filter.lfs.smudge=git-lfs smudge -- %f</span><br><span class="line">filter.lfs.process=git-lfs filter-process</span><br><span class="line">filter.lfs.required=true</span><br><span class="line">http.sslbackend=openssl</span><br><span class="line">http.sslcainfo=C:/SoftWares/Git/mingw64/ssl/certs/ca-bundle.crt</span><br><span class="line">core.autocrlf=true</span><br><span class="line">core.fscache=true</span><br><span class="line">core.symlinks=false</span><br><span class="line">pull.rebase=false</span><br><span class="line">credential.helper=manager-core</span><br><span class="line">credential.https://dev.azure.com.usehttppath=true</span><br><span class="line">init.defaultbranch=master</span><br><span class="line">user.name=system</span><br><span class="line">user.email=system@email.com</span><br><span class="line">user.name=xiongzhuo</span><br><span class="line">user.email=xiongzhuo@outlook.com</span><br><span class="line">core.autocrlf=true</span><br><span class="line">filter.lfs.clean=git-lfs clean -- %f</span><br><span class="line">filter.lfs.smudge=git-lfs smudge -- %f</span><br><span class="line">filter.lfs.process=git-lfs filter-process</span><br><span class="line">filter.lfs.required=true</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=false</span><br><span class="line">core.bare=false</span><br><span class="line">core.logallrefupdates=true</span><br><span class="line">core.symlinks=false</span><br><span class="line">core.ignorecase=true</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="1-2-使用git-config命令编辑配置文件"><a href="#1-2-使用git-config命令编辑配置文件" class="headerlink" title="1.2 使用git config命令编辑配置文件"></a>1.2 使用git config命令编辑配置文件</h4><p>编辑的英文单词是什么，没错，edit</p>
<p>命令参数 –edit, 简写 -e</p>
<p>格式：<code>git config [–local|–global|–system] -e</code></p>
<p>编辑仓库级的config，命令：git config –local -e，与–list参数不同的是，git config -e默认是编辑仓库级的配置文件。</p>
<p>编辑全局级的config，命令：git config –global -e</p>
<p>编辑系统级的config，命令：git config –system -e</p>
<p><strong>注：执行这个命令的时候，git会用配置文件中设定的编辑器打开配置文件。</strong></p>
<h4 id="1-3-使用git-config命令增加一个配置项"><a href="#1-3-使用git-config命令增加一个配置项" class="headerlink" title="1.3 使用git config命令增加一个配置项"></a>1.3 使用git config命令增加一个配置项</h4><p>参数 –add</p>
<p>格式: git config [-local|-global|-system] –add section.key value(默认是添加在local配置中)</p>
<p>注意add后面的section,key,value一项都不能少，否则添加失败。比如我们执行：</p>
<p><code>git config --add cat.name tom</code></p>
<p>注意增加一项配置而不赋值 git config -add cat.age，或者单单增加一个section,git config -add cat1，不会成功。然后查看local中的配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --add cat.name tom</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --<span class="built_in">local</span> -l</span></span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=false</span><br><span class="line">core.bare=false</span><br><span class="line">core.logallrefupdates=true</span><br><span class="line">core.symlinks=false</span><br><span class="line">core.ignorecase=true</span><br><span class="line">cat.name=tom</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>添加本地用户信息，用于提交时指向提交者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --add user-name <span class="string">&quot;demo&quot;</span></span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --add user-email <span class="string">&quot;demo@demo.com&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="1-4-使用git-config命令获取一个配置项"><a href="#1-4-使用git-config命令获取一个配置项" class="headerlink" title="1.4 使用git config命令获取一个配置项"></a>1.4 使用git config命令获取一个配置项</h4><p>有时候，我们并不需要查看所有配置的值，而是查看某个配置项的值，怎么做呢？</p>
<p>命令参数 -get</p>
<p>格式：<code>git config [-local|-global|-system] -get section.key</code>(默认是获取local配置中内容)</p>
<p>我们先往git配置中写入一个cat.name=tom的配置项，再使用git config -get cat.name看看得到的是什么</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --get cat.name</span></span><br><span class="line">tom</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --<span class="built_in">local</span> --get cat.name</span></span><br><span class="line">tom</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果就是local中的cat.name=tom，因此<strong>git config –get section.key</strong> 等价于</p>
<p><strong>git config –local –get section.key</strong></p>
<p><strong>如果获取一个section不存在的key值，不会返回任何值</strong></p>
<p><strong>如果获取一个不存在的section的key值，则会报错</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --<span class="built_in">local</span> --get cat.age</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --<span class="built_in">local</span> --get cattle</span></span><br><span class="line">error: key does not contain a section: cattle</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-5-使用git-config命令删除一个配置项"><a href="#1-5-使用git-config命令删除一个配置项" class="headerlink" title="1.5 使用git config命令删除一个配置项"></a>1.5 使用git config命令删除一个配置项</h4><p>命令参数 -unset</p>
<p>格式：<code>git config [-local|-global|-system] -unset section.key</code></p>
<p>相信有了前两个命令的使用基础，大家举一反三就知道改怎么用了，来，我们试试删除local配置中的cat.name</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --<span class="built_in">local</span> --<span class="built_in">unset</span> cat.name</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --<span class="built_in">local</span> -l</span></span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=false</span><br><span class="line">core.bare=false</span><br><span class="line">core.logallrefupdates=true</span><br><span class="line">core.symlinks=false</span><br><span class="line">core.ignorecase=true</span><br><span class="line">user.name=demo</span><br><span class="line">user.email=demo@demo.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-git-add背后发什么了什么"><a href="#2-git-add背后发什么了什么" class="headerlink" title="2. git add背后发什么了什么"></a>2. git add背后发什么了什么</h3><p>在当前工作区(C:/Files/GitStudy)新建文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;hello git&quot;</span>&gt;hello.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat hello.txt</span></span><br><span class="line">hello git</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看此时git状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        hello.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>

<p>如果需要git帮我们管理hello.txt文件，则需将当前文件从工作区添加到缓冲区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add hello.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in hello.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br></pre></td></tr></table></figure>

<p>为了方便观察，我们在window的cmd里使用tree命令(因为git bash不支持此命令，后续的文件树结构均是在windows里的cmd显示)查看.git当前的文件结构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\gitStudy</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GITSTUDY\.GIT</span><br><span class="line">│  config</span><br><span class="line">│  description</span><br><span class="line">│  HEAD</span><br><span class="line">│  index         #新增文件</span><br><span class="line">│</span><br><span class="line">├─hooks</span><br><span class="line">├─info</span><br><span class="line">│      exclude</span><br><span class="line">│</span><br><span class="line">├─objects</span><br><span class="line">│  ├─8d       #新增目录</span><br><span class="line">│  │      0e41234f24b6da002d962a26c2495ea16a425f  #新增文件</span><br><span class="line">│  │</span><br><span class="line">│  ├─info</span><br><span class="line">│  └─pack</span><br><span class="line">└─refs</span><br><span class="line">    ├─heads</span><br><span class="line">    └─tags</span><br></pre></td></tr></table></figure>

<p>新增了 index文件，object文件夹下新增了8d文件夹，8d文件夹下新增了一串名为hash的objects文件，此处objects下新增的文件加以及文件，名字组合起来为一个SHA1值，这个值是由从工作区add到缓冲区的<u>文件内容和文件类型</u>进行哈希散列得到的（”blob %u\0” % len(date)）</p>
<h4 id="2-1-分析新增的objects对象"><a href="#2-1-分析新增的objects对象" class="headerlink" title="2.1 分析新增的objects对象"></a>2.1 分析新增的objects对象</h4><p>使用<code>git cat-file</code> 查看objects文件：<br>① -t SHA1值：查看该objects的类型(SHA1值一般去前6位就已足够。记得别忘了文件夹的那两位)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -t 8d0e41</span></span><br><span class="line">blob</span><br></pre></td></tr></table></figure>

<p>blob文件：只存储文件内容，不存储文件名</p>
<p>验证：新建一个tmp.txt文件，内容与hello.txt一致，执行git add进行添加后，查看.git文件目录结构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\gitStudy</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GITSTUDY\.GIT</span><br><span class="line">│  config</span><br><span class="line">│  description</span><br><span class="line">│  HEAD</span><br><span class="line">│  index</span><br><span class="line">│</span><br><span class="line">├─hooks</span><br><span class="line">├─info</span><br><span class="line">│      exclude</span><br><span class="line">│</span><br><span class="line">├─objects</span><br><span class="line">│  ├─8d</span><br><span class="line">│  │      0e41234f24b6da002d962a26c2495ea16a425f</span><br><span class="line">│  │</span><br><span class="line">│  ├─info</span><br><span class="line">│  └─pack</span><br><span class="line">└─refs</span><br><span class="line">    ├─heads</span><br><span class="line">    └─tags</span><br></pre></td></tr></table></figure>

<p>发现文件目录没有任何改变</p>
<p>② -p SHA1值：查看该objects的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 8d0e41</span></span><br><span class="line">hello git</span><br></pre></td></tr></table></figure>

<p>③ -s SHA1值：查看该objects对象的长度</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -s 8d0e</span></span><br><span class="line">10</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="3-blob对象和SHA1哈希"><a href="#3-blob对象和SHA1哈希" class="headerlink" title="3. blob对象和SHA1哈希"></a>3. blob对象和SHA1哈希</h3><h4 id="3-1-Hash算法"><a href="#3-1-Hash算法" class="headerlink" title="3.1 Hash算法"></a>3.1 Hash算法</h4><p>把任意长度的输入通过散列算法变换成固定长度的输出</p>
<ul>
<li>MD5           128bit</li>
<li>SHA1        160bit</li>
<li>SHA256    256bit</li>
<li>SHA512    512bit</li>
<li><a href="https://1024tools.com/hash">Hash在线计算、md5计算、sha1计算、sha256计算、sha512计算 - 1024Tools</a></li>
</ul>
<h4 id="3-2-还原git生成SHA1的过程"><a href="#3-2-还原git生成SHA1的过程" class="headerlink" title="3.2 还原git生成SHA1的过程"></a>3.2 还原git生成SHA1的过程</h4><ol>
<li><p>查看要生成文件的大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lh</span></span><br><span class="line">total 2.0K</span><br><span class="line">drwxr-xr-x 1 xiong 197609  0 Aug 21 08:55 git-demo/</span><br><span class="line">-rw-r--r-- 1 xiong 197609 10 Aug 21 11:43 hello.txt</span><br><span class="line">-rw-r--r-- 1 xiong 197609 10 Aug 21 12:15 tmp.txt</span><br></pre></td></tr></table></figure>

<p>此处选择计算 hello.txt 大小为10B</p>
</li>
<li><p>计算</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">&quot;blob 10\0hello git&quot;</span>|shasum</span></span><br><span class="line">8d0e41234f24b6da002d962a26c2495ea16a425f *-</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于echo<br>-e        enable interpretation of the following backslash escapes<br>启用以下反斜杠转义的解释</p>
</blockquote>
</li>
</ol>
<h4 id="3-3-了解git通过压缩对文件进行管理"><a href="#3-3-了解git通过压缩对文件进行管理" class="headerlink" title="3.3 了解git通过压缩对文件进行管理"></a>3.3 了解git通过压缩对文件进行管理</h4><p><strong>查看blob文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/objects/8d/0e41234f24b6da002d962a26c2495ea16a425f</span></span><br><span class="line">xK▒▒OR04`▒H▒▒▒WH▒,▒6A▒</span><br></pre></td></tr></table></figure>

<p>出现乱码的原因是：git在存储文件时对文件内容进行了压缩</p>
<p><strong>对比blob文件与原始文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lh</span></span><br><span class="line">total 2.0K</span><br><span class="line">drwxr-xr-x 1 xiong 197609  0 Aug 21 08:55 git-demo/</span><br><span class="line">-rw-r--r-- 1 xiong 197609 10 Aug 21 11:43 hello.txt</span><br><span class="line">-rw-r--r-- 1 xiong 197609 10 Aug 21 12:15 tmp.txt</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/gitStudy (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls .git/objects/8d -lh</span></span><br><span class="line">total 1.0K</span><br><span class="line">-r--r--r-- 1 xiong 197609 26 Aug 21 12:15 0e41234f24b6da002d962a26c2495ea16a425f</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>blob文件大小为26B，原始文件大小为10B（因为源文件过小，导致压缩后的文件在包含压缩信息后反而增大，如果换为大文件，则能够看出明显效果）</p>
<h3 id="4-工作区和索引区"><a href="#4-工作区和索引区" class="headerlink" title="4. 工作区和索引区"></a>4. 工作区和索引区</h3><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108211529488.png" alt="image-20210821152947074"></p>
<p>Working directory：工作区</p>
<p>Staging Area(index)：索引区 —&gt;  文件内容存在blob里，文件名存储在index里</p>
<p><strong>初始化一个新的代码仓库进行实验</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line">Initialized empty Git repository in C:/Files/git-demo/.git/</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;file1&quot;</span> &gt; file1.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        file1.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add file1.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in file1.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>文件树</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO\.GIT</span><br><span class="line">│  config</span><br><span class="line">│  description</span><br><span class="line">│  HEAD</span><br><span class="line">│  index</span><br><span class="line">│</span><br><span class="line">├─hooks</span><br><span class="line">│      applypatch-msg.sample</span><br><span class="line">│      commit-msg.sample</span><br><span class="line">│      fsmonitor-watchman.sample</span><br><span class="line">│      post-update.sample</span><br><span class="line">│      pre-applypatch.sample</span><br><span class="line">│      pre-commit.sample</span><br><span class="line">│      pre-merge-commit.sample</span><br><span class="line">│      pre-push.sample</span><br><span class="line">│      pre-rebase.sample</span><br><span class="line">│      pre-receive.sample</span><br><span class="line">│      prepare-commit-msg.sample</span><br><span class="line">│      push-to-checkout.sample</span><br><span class="line">│      update.sample</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">│      exclude</span><br><span class="line">│</span><br><span class="line">├─objects</span><br><span class="line">│  ├─e2</span><br><span class="line">│  │      129701f1a4d54dc44f03c93bca0a2aec7c5449</span><br><span class="line">│  │</span><br><span class="line">│  ├─info</span><br><span class="line">│  └─pack</span><br><span class="line">└─refs</span><br><span class="line">    ├─heads</span><br><span class="line">    └─tags</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>列出当前在索引区里的内容</strong></p>
<p><code>git ls-files</code>：列出索引区里的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files</span></span><br><span class="line">file1.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>git ls-files -s</code>：列出索引区里文件的具体内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files -s</span></span><br><span class="line">100644 e2129701f1a4d54dc44f03c93bca0a2aec7c5449 0       file1.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>10064：标识权限<br>e2129701f1a4d54dc44f03c93bca0a2aec7c5449：blob对象</p>
<h4 id="4-1-新建file2-txt，不进行提交，查看当前状态"><a href="#4-1-新建file2-txt，不进行提交，查看当前状态" class="headerlink" title="4.1 新建file2.txt，不进行提交，查看当前状态"></a>4.1 新建file2.txt，不进行提交，查看当前状态</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;file2&quot;</span>&gt;file2.txt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>查看工作区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">file1.txt  file2.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看索引区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files</span></span><br><span class="line">file1.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看git状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   file1.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        file2.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**<u>Untracked files：</u>**文件的一种状态，在工作区新建的文件，但是没有添加到索引区</p>
</li>
</ol>
<h4 id="4-2-将file2-xtx添加到索引区后再进行查看"><a href="#4-2-将file2-xtx添加到索引区后再进行查看" class="headerlink" title="4.2 将file2.xtx添加到索引区后再进行查看"></a>4.2 将file2.xtx添加到索引区后再进行查看</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add file2.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in file2.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   file1.txt</span><br><span class="line">        new file:   file2.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看当前objects目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO\.GIT\OBJECTS</span><br><span class="line">├─6c</span><br><span class="line">│      493ff740f9380390d5c9ddef4af18697ac9375</span><br><span class="line">│</span><br><span class="line">├─e2</span><br><span class="line">│      129701f1a4d54dc44f03c93bca0a2aec7c5449</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">└─pack</span><br></pre></td></tr></table></figure>

<p>查看索引区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files -s</span></span><br><span class="line">100644 e2129701f1a4d54dc44f03c93bca0a2aec7c5449 0       file1.txt</span><br><span class="line">100644 6c493ff740f9380390d5c9ddef4af18697ac9375 0       file2.txt</span><br></pre></td></tr></table></figure>

<h4 id="4-3-修改file1-txt后再进行查看"><a href="#4-3-修改file1-txt后再进行查看" class="headerlink" title="4.3 修改file1.txt后再进行查看"></a>4.3 修改file1.txt后再进行查看</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim file1.txt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

 <img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108211345564.png" alt="image-20210821134530436" style="zoom:50%;" />

<p>在末尾添加一个”.”</p>
<ol>
<li><p>查看工作区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">file1.txt  file2.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看索引区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files</span></span><br><span class="line">file1.txt</span><br><span class="line">file2.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看git状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   file1.txt</span><br><span class="line">        new file:   file2.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   file1.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong><u>modified</u>：</strong>文件的另一种状态。索引区存在file1.txt，但是通过对比发现，此文件在工作区里的内容和在索引区里的内容不一致，判定此文件被修改了</p>
</li>
</ol>
<h4 id="4-4-将修改后的file1-txt进行提交"><a href="#4-4-将修改后的file1-txt进行提交" class="headerlink" title="4.4 将修改后的file1.txt进行提交"></a>4.4 将修改后的file1.txt进行提交</h4><ol>
<li><p>提交前索引区里的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files -s</span></span><br><span class="line">100644 e2129701f1a4d54dc44f03c93bca0a2aec7c5449 0       file1.txt</span><br><span class="line">100644 6c493ff740f9380390d5c9ddef4af18697ac9375 0       file2.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交后索引区里的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add file1.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in file1.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files -s</span></span><br><span class="line">100644 ca5a43e53e012b6fd3b2a8a06ebb6c2ee24a24e5 0       file1.txt</span><br><span class="line">100644 6c493ff740f9380390d5c9ddef4af18697ac9375 0       file2.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>​          对比前后发现此时的file1.txt文件的blob发生了变化</p>
<ol start="3">
<li><p>查看objects目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO\.GIT\OBJECTS</span><br><span class="line">├─6c</span><br><span class="line">│      493ff740f9380390d5c9ddef4af18697ac9375</span><br><span class="line">│</span><br><span class="line">├─ca </span><br><span class="line">│      5a43e53e012b6fd3b2a8a06ebb6c2ee24a24e5 #file1.txt新</span><br><span class="line">│</span><br><span class="line">├─e2</span><br><span class="line">│      129701f1a4d54dc44f03c93bca0a2aec7c5449 #file1.txt旧</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">└─pack</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="5-git-commit背后发什么了什么"><a href="#5-git-commit背后发什么了什么" class="headerlink" title="5. git commit背后发什么了什么"></a>5. git commit背后发什么了什么</h3><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108211530108.png" alt="image-20210821153025981"></p>
<h4 id="5-1-未进行commit文件的内容和状态"><a href="#5-1-未进行commit文件的内容和状态" class="headerlink" title="5.1 未进行commit文件的内容和状态"></a>5.1 未进行commit文件的内容和状态</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file1.txt</span></span><br><span class="line">file1.</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat file2.txt</span></span><br><span class="line">file2</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p ca5a</span></span><br><span class="line">file1.</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 6c49</span></span><br><span class="line">file2</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files -s</span></span><br><span class="line">100644 ca5a43e53e012b6fd3b2a8a06ebb6c2ee24a24e5 0       file1.txt</span><br><span class="line">100644 6c493ff740f9380390d5c9ddef4af18697ac9375 0       file2.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>此时工作区和索引区状态一致</p>
<h4 id="5-2-commit一次后各文件的状态"><a href="#5-2-commit一次后各文件的状态" class="headerlink" title="5.2 commit一次后各文件的状态"></a>5.2 commit一次后各文件的状态</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;1st commit&quot;</span></span></span><br><span class="line">[master (root-commit) 8a44e8c] 1st commit</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 file1.txt</span><br><span class="line"> create mode 100644 file2.txt</span><br></pre></td></tr></table></figure>

<h5 id="5-2-1-objects中新增文件"><a href="#5-2-1-objects中新增文件" class="headerlink" title="5.2.1 objects中新增文件"></a>5.2.1 objects中新增文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO\.GIT\OBJECTS</span><br><span class="line">├─29</span><br><span class="line">│      d3f358addb2b6e16ebfb981716fa75cc562ee7 #新增tree</span><br><span class="line">│</span><br><span class="line">├─6c</span><br><span class="line">│      493ff740f9380390d5c9ddef4af18697ac9375</span><br><span class="line">│</span><br><span class="line">├─8a</span><br><span class="line">│      44e8c0e81d4766b22777a61f3233d8b14497cc #新增commit</span><br><span class="line">│</span><br><span class="line">├─ca</span><br><span class="line">│      5a43e53e012b6fd3b2a8a06ebb6c2ee24a24e5</span><br><span class="line">│</span><br><span class="line">├─e2</span><br><span class="line">│      129701f1a4d54dc44f03c93bca0a2aec7c5449</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">└─pack</span><br></pre></td></tr></table></figure>

<p>根据commit生成的SHA1，查看新增文件</p>
<ol>
<li><p>查看文件类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -t 8a44</span></span><br><span class="line">commit</span><br></pre></td></tr></table></figure>

<p>文件为commit类型</p>
</li>
<li><p>查看文件内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 8a44</span></span><br><span class="line">tree 29d3f358addb2b6e16ebfb981716fa75cc562ee7</span><br><span class="line">author xiongzhuo &lt;xiongzhuo@outlook.com&gt; 1629531426 +0800</span><br><span class="line">committer xiongzhuo &lt;xiongzhuo@outlook.com&gt; 1629531426 +0800</span><br><span class="line"></span><br><span class="line">1st commit</span><br></pre></td></tr></table></figure>

<p>包含了一个tree对象和提交者的信息，以及提交时的备注</p>
<ol>
<li><p>查看commit文件里tree的类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -t 29d3f</span></span><br><span class="line">tree</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看commit文件里tree的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 29d3f</span></span><br><span class="line">100644 blob ca5a43e53e012b6fd3b2a8a06ebb6c2ee24a24e5    file1.txt</span><br><span class="line">100644 blob 6c493ff740f9380390d5c9ddef4af18697ac9375    file2.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tree里记录了当前提交的内容</p>
</li>
</ol>
</li>
</ol>
<h5 id="5-2-2-refs中新增文件"><a href="#5-2-2-refs中新增文件" class="headerlink" title="5.2.2 refs中新增文件"></a>5.2.2 refs中新增文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/refs /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO\.GIT\REFS</span><br><span class="line">├─heads</span><br><span class="line">│      master  #新增</span><br><span class="line">│</span><br><span class="line">└─tags</span><br></pre></td></tr></table></figure>

<p>查看新增文件内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/refs/heads/master</span></span><br><span class="line">8a44e8c0e81d4766b22777a61f3233d8b14497cc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>master里存着最近一次commit的SHA1值</p>
<p>关联：查看.git里的HEAD文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/HEAD</span></span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure>

<p>HEAD指向当前工作的分支</p>
<h5 id="5-2-3-commit一次后代码仓库的状态"><a href="#5-2-3-commit一次后代码仓库的状态" class="headerlink" title="5.2.3 commit一次后代码仓库的状态"></a>5.2.3 commit一次后代码仓库的状态</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108211601796.png" alt="image-20210821160109435"></p>
<h4 id="5-3-commit二次后各文件的状态"><a href="#5-3-commit二次后各文件的状态" class="headerlink" title="5.3 commit二次后各文件的状态"></a>5.3 commit二次后各文件的状态</h4><p>修改file2.txt里的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> vim file2.txt</span></span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108211720671.png" alt="image-20210821160520509" style="zoom:50%;" /> 

<p>在末尾添加”.”</p>
<p><strong>查看当前git status状态</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   file2.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>跟踪到了被修改的file2.txt</p>
<ol>
<li><p>将修改后的文件添加到索引区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add file2.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in file2.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看objects中的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO\.GIT\OBJECTS</span><br><span class="line">├─29</span><br><span class="line">│      d3f358addb2b6e16ebfb981716fa75cc562ee7</span><br><span class="line">│</span><br><span class="line">├─6c</span><br><span class="line">│      493ff740f9380390d5c9ddef4af18697ac9375 </span><br><span class="line">│</span><br><span class="line">├─8a</span><br><span class="line">│      44e8c0e81d4766b22777a61f3233d8b14497cc</span><br><span class="line">│</span><br><span class="line">├─98</span><br><span class="line">│      87c1a1fdc70e53d47d73b5764a65c889704ef3 #新增blob</span><br><span class="line">│</span><br><span class="line">├─ca</span><br><span class="line">│      5a43e53e012b6fd3b2a8a06ebb6c2ee24a24e5</span><br><span class="line">│</span><br><span class="line">├─e2</span><br><span class="line">│      129701f1a4d54dc44f03c93bca0a2aec7c5449</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">└─pack</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看当前索引区中文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files -s</span></span><br><span class="line">100644 ca5a43e53e012b6fd3b2a8a06ebb6c2ee24a24e5 0       file1.txt</span><br><span class="line">100644 9887c1a1fdc70e53d47d73b5764a65c889704ef3 0       file2.txt</span><br></pre></td></tr></table></figure>

<p>file2.txt的blob对象更新</p>
</li>
</ol>
<p><strong>将更新进行提交</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;2nd commit&quot;</span></span></span><br><span class="line">[master 1928061] 2nd commit</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看当前objects中的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO\.GIT\OBJECTS</span><br><span class="line">├─19</span><br><span class="line">│      28061d327bfa64a0a6ce3f4faa029b8c1ce776 #新增commit</span><br><span class="line">│</span><br><span class="line">├─29</span><br><span class="line">│      d3f358addb2b6e16ebfb981716fa75cc562ee7</span><br><span class="line">│</span><br><span class="line">├─6c</span><br><span class="line">│      493ff740f9380390d5c9ddef4af18697ac9375</span><br><span class="line">│</span><br><span class="line">├─87</span><br><span class="line">│      6af0020e37f45ec09c802d96d7120b2302075f #新增tree</span><br><span class="line">│</span><br><span class="line">├─8a</span><br><span class="line">│      44e8c0e81d4766b22777a61f3233d8b14497cc</span><br><span class="line">│</span><br><span class="line">├─98</span><br><span class="line">│      87c1a1fdc70e53d47d73b5764a65c889704ef3</span><br><span class="line">│</span><br><span class="line">├─ca</span><br><span class="line">│      5a43e53e012b6fd3b2a8a06ebb6c2ee24a24e5</span><br><span class="line">│</span><br><span class="line">├─e2</span><br><span class="line">│      129701f1a4d54dc44f03c93bca0a2aec7c5449</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">└─pack</span><br></pre></td></tr></table></figure>

<ol>
<li><p>查看当前commit对象中的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 192806</span></span><br><span class="line">tree 876af0020e37f45ec09c802d96d7120b2302075f</span><br><span class="line">parent 8a44e8c0e81d4766b22777a61f3233d8b14497cc</span><br><span class="line">author xiongzhuo &lt;xiongzhuo@outlook.com&gt; 1629533646 +0800</span><br><span class="line">committer xiongzhuo &lt;xiongzhuo@outlook.com&gt; 1629533646 +0800</span><br><span class="line"></span><br><span class="line">2nd commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>parent指向的是上一个commit</p>
<ol>
<li><p>查看当前commit中tree的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 876af0</span></span><br><span class="line">100644 blob ca5a43e53e012b6fd3b2a8a06ebb6c2ee24a24e5    file1.txt</span><br><span class="line">100644 blob 9887c1a1fdc70e53d47d73b5764a65c889704ef3    file2.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>file2.txt的blob进行了更新</p>
</li>
</ol>
</li>
</ol>
<h5 id="5-3-3-commit二次后代码仓库的状态"><a href="#5-3-3-commit二次后代码仓库的状态" class="headerlink" title="5.3.3 commit二次后代码仓库的状态"></a>5.3.3 commit二次后代码仓库的状态</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108211649503.png" alt="image-20210821164921086"></p>
<h4 id="5-4-commit文件夹"><a href="#5-4-commit文件夹" class="headerlink" title="5.4 commit文件夹"></a>5.4 commit文件夹</h4><p>新建文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir folder1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>对于空文件夹，git不算任何改变</p>
<p>进入到新文件夹里，新建文件后git能够将其识别</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> folder1/</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo/folder1 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;file3.&quot;</span>&gt;file3.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo/folder1 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        ./</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo/folder1 (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ..</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        folder1/</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure>

<p>将未跟踪的文件添加到索引区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add folder1/</span></span><br><span class="line">warning: LF will be replaced by CRLF in folder1/file3.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看索引区内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git ls-files -s</span></span><br><span class="line">100644 ca5a43e53e012b6fd3b2a8a06ebb6c2ee24a24e5 0       file1.txt</span><br><span class="line">100644 9887c1a1fdc70e53d47d73b5764a65c889704ef3 0       file2.txt</span><br><span class="line">100644 89a53edddc5f8fbc09bc500a2a807750e9673c08 0       folder1/file3.txt</span><br></pre></td></tr></table></figure>

<p>查看objects文件夹里的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO\.GIT\OBJECTS</span><br><span class="line">├─19</span><br><span class="line">│      28061d327bfa64a0a6ce3f4faa029b8c1ce776</span><br><span class="line">│</span><br><span class="line">├─29</span><br><span class="line">│      d3f358addb2b6e16ebfb981716fa75cc562ee7</span><br><span class="line">│</span><br><span class="line">├─6c</span><br><span class="line">│      493ff740f9380390d5c9ddef4af18697ac9375</span><br><span class="line">│</span><br><span class="line">├─87</span><br><span class="line">│      6af0020e37f45ec09c802d96d7120b2302075f</span><br><span class="line">│</span><br><span class="line">├─89</span><br><span class="line">│      a53edddc5f8fbc09bc500a2a807750e9673c08 #新增</span><br><span class="line">│</span><br><span class="line">├─8a</span><br><span class="line">│      44e8c0e81d4766b22777a61f3233d8b14497cc</span><br><span class="line">│</span><br><span class="line">├─98</span><br><span class="line">│      87c1a1fdc70e53d47d73b5764a65c889704ef3</span><br><span class="line">│</span><br><span class="line">├─ca</span><br><span class="line">│      5a43e53e012b6fd3b2a8a06ebb6c2ee24a24e5</span><br><span class="line">│</span><br><span class="line">├─e2</span><br><span class="line">│      129701f1a4d54dc44f03c93bca0a2aec7c5449</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">└─pack</span><br></pre></td></tr></table></figure>

<p><strong>commit更新的内容</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;3rd commit&quot;</span></span></span><br><span class="line">[master a1431ae] 3rd commit</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 folder1/file3.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看objects文件的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/objects /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO\.GIT\OBJECTS</span><br><span class="line">├─19</span><br><span class="line">│      28061d327bfa64a0a6ce3f4faa029b8c1ce776</span><br><span class="line">│</span><br><span class="line">├─29</span><br><span class="line">│      d3f358addb2b6e16ebfb981716fa75cc562ee7</span><br><span class="line">│</span><br><span class="line">├─46</span><br><span class="line">│      fcafbbc3e0ba215d6b9924a20a0cb3b107423f #新增tree</span><br><span class="line">│</span><br><span class="line">├─6c</span><br><span class="line">│      493ff740f9380390d5c9ddef4af18697ac9375</span><br><span class="line">│</span><br><span class="line">├─87</span><br><span class="line">│      6af0020e37f45ec09c802d96d7120b2302075f</span><br><span class="line">│</span><br><span class="line">├─89</span><br><span class="line">│      a53edddc5f8fbc09bc500a2a807750e9673c08</span><br><span class="line">│</span><br><span class="line">├─8a</span><br><span class="line">│      44e8c0e81d4766b22777a61f3233d8b14497cc</span><br><span class="line">│</span><br><span class="line">├─98</span><br><span class="line">│      87c1a1fdc70e53d47d73b5764a65c889704ef3</span><br><span class="line">│</span><br><span class="line">├─a1</span><br><span class="line">│      431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b #新增commit</span><br><span class="line">│</span><br><span class="line">├─ca</span><br><span class="line">│      5a43e53e012b6fd3b2a8a06ebb6c2ee24a24e5</span><br><span class="line">│</span><br><span class="line">├─e2</span><br><span class="line">│      129701f1a4d54dc44f03c93bca0a2aec7c5449</span><br><span class="line">│</span><br><span class="line">├─e3</span><br><span class="line">│      cfebfb440e2af91732e71deda277030d7182e9</span><br><span class="line">│</span><br><span class="line">├─info</span><br><span class="line">└─pack</span><br></pre></td></tr></table></figure>

<ol>
<li><p>查看commit内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p a1431a</span></span><br><span class="line">tree 46fcafbbc3e0ba215d6b9924a20a0cb3b107423f</span><br><span class="line">parent 1928061d327bfa64a0a6ce3f4faa029b8c1ce776</span><br><span class="line">author xiongzhuo &lt;xiongzhuo@outlook.com&gt; 1629537005 +0800</span><br><span class="line">committer xiongzhuo &lt;xiongzhuo@outlook.com&gt; 1629537005 +0800</span><br><span class="line"></span><br><span class="line">3rd commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>查看commit里tree对象内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 46fcaf</span></span><br><span class="line">100644 blob ca5a43e53e012b6fd3b2a8a06ebb6c2ee24a24e5    file1.txt</span><br><span class="line">100644 blob 9887c1a1fdc70e53d47d73b5764a65c889704ef3    file2.txt</span><br><span class="line">040000 tree e3cfebfb440e2af91732e71deda277030d7182e9    folder1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当前tree包含另一个与文件夹同名的tree</p>
<p>查看commit里tree对象里tree对象的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p e3cfeb</span></span><br><span class="line">100644 blob 89a53edddc5f8fbc09bc500a2a807750e9673c08    file3.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当前tree里包含了file3.txt的blob对象</p>
</li>
</ol>
</li>
</ol>
<h5 id="5-4-1-commit文件夹后代码仓库的状态"><a href="#5-4-1-commit文件夹后代码仓库的状态" class="headerlink" title="5.4.1 commit文件夹后代码仓库的状态"></a>5.4.1 commit文件夹后代码仓库的状态</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108211720314.png" alt="image-20210821172012808"></p>
<h3 id="6-文件的状态"><a href="#6-文件的状态" class="headerlink" title="6. 文件的状态"></a>6. 文件的状态</h3><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108211725016.png" alt="image-20210821172521600"></p>
<h3 id="7-Branch和HEAD"><a href="#7-Branch和HEAD" class="headerlink" title="7. Branch和HEAD"></a>7. Branch和HEAD</h3><p>Branch：分支，被命名为指针去指向commits</p>
<p>HEAD：是一个特殊的指针，指向当前工作的分支，且总是指向最近一次提交</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108211733729.png" alt="image-20210821173328944"></p>
<p>  <strong>验证</strong></p>
<ol>
<li><p>查看HEAD文件的内容：指向refs/heads/master</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/HEAD</span></span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看master内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/refs/heads/master</span></span><br><span class="line">a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看master内容所指文件的类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -t a1431a</span></span><br><span class="line">commit</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看提交历史：HEAD指向master分支，且指向最新一次提交</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b (HEAD -&gt; master)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 17:10:05 2021 +0800</span><br><span class="line"></span><br><span class="line">    3rd commit</span><br><span class="line"></span><br><span class="line">commit 1928061d327bfa64a0a6ce3f4faa029b8c1ce776</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 16:14:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 8a44e8c0e81d4766b22777a61f3233d8b14497cc</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 15:37:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="7-1-Branch的创建和使用"><a href="#7-1-Branch的创建和使用" class="headerlink" title="7.1 Branch的创建和使用"></a>7.1 Branch的创建和使用</h4><ul>
<li>git branch：列举出拥有的分支</li>
<li>git branch <branch_name>：以branch_name为名创建分支，如果已有同名分支，则返回失败</li>
<li>git branch -D <branch_name>：删除分支，不能删除当前工作的分支或不存在的分支</li>
<li>git checkout：更改当前的工作分支</li>
</ul>
<h5 id="7-1-1-查看分支"><a href="#7-1-1-查看分支" class="headerlink" title="7.1.1 查看分支"></a>7.1.1 查看分支</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>*master：表示当前所在分支是master</p>
<h5 id="7-1-2-创建分支"><a href="#7-1-2-创建分支" class="headerlink" title="7.1.2 创建分支"></a>7.1.2 创建分支</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch dev</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">  dev</span><br><span class="line">* master</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看提交历史</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b (HEAD -&gt; master, dev)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 17:10:05 2021 +0800</span><br><span class="line"></span><br><span class="line">    3rd commit</span><br><span class="line"></span><br><span class="line">commit 1928061d327bfa64a0a6ce3f4faa029b8c1ce776</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 16:14:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 8a44e8c0e81d4766b22777a61f3233d8b14497cc</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 15:37:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>HEAD -&gt; master, dev：HEAD当前指向的是master，而此时新建的分支dev恰好指向的也是a1431a这次提交，所以显示成这样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/refs/heads/dev</span></span><br><span class="line">a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/refs/heads/master</span></span><br><span class="line">a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/HEAD</span></span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure>



<p>分支存在.git/refs/heads/目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls .git/refs/heads</span></span><br><span class="line">dev  master</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="7-1-3-切换分支"><a href="#7-1-3-切换分支" class="headerlink" title="7.1.3 切换分支"></a>7.1.3 切换分支</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev</span></span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  </span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/HEAD</span></span><br><span class="line">ref: refs/heads/dev</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b (HEAD -&gt; dev, master)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 17:10:05 2021 +0800</span><br><span class="line"></span><br><span class="line">    3rd commit</span><br><span class="line"></span><br><span class="line">commit 1928061d327bfa64a0a6ce3f4faa029b8c1ce776</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 16:14:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 8a44e8c0e81d4766b22777a61f3233d8b14497cc</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 15:37:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>切换分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev</span></span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>当前所处分支</strong></p>
<ol>
<li><p>查看当前所处分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看HEAD指向</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/HEAD</span></span><br><span class="line">ref: refs/heads/dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看提交记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b (HEAD -&gt; dev, master)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 17:10:05 2021 +0800</span><br><span class="line"></span><br><span class="line">    3rd commit</span><br><span class="line"></span><br><span class="line">commit 1928061d327bfa64a0a6ce3f4faa029b8c1ce776</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 16:14:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 8a44e8c0e81d4766b22777a61f3233d8b14497cc</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 15:37:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>在dev分支上进行操作</p>
<ol>
<li><p>新建文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;dev&quot;</span> &gt; dev.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">dev.txt  file1.txt  file2.txt  folder1/</span><br></pre></td></tr></table></figure>
</li>
<li><p>将工作区的文件添加到索引区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add dev.txt</span></span><br><span class="line">warning: LF will be replaced by CRLF in dev.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br></pre></td></tr></table></figure>
</li>
<li><p>提交文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;1st commit from dev branch&quot;</span></span></span><br><span class="line">[dev 939dc9f] 1st commit from dev branch</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 dev.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看提交记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 939dc9f4fbb92d5bdcff9952f6de1f432fed1b3a (HEAD -&gt; dev)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 20:34:48 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit from dev branch</span><br><span class="line"></span><br><span class="line">commit a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b (master)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 17:10:05 2021 +0800</span><br><span class="line"></span><br><span class="line">    3rd commit</span><br><span class="line"></span><br><span class="line">commit 1928061d327bfa64a0a6ce3f4faa029b8c1ce776</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 16:14:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 8a44e8c0e81d4766b22777a61f3233d8b14497cc</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 15:37:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h5 id="7-1-4-删除分支"><a href="#7-1-4-删除分支" class="headerlink" title="7.1.4 删除分支"></a>7.1.4 删除分支</h5><p>删除失败情况：不能删除当前分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --delete dev</span></span><br><span class="line">error: Cannot delete branch &#x27;dev&#x27; checked out at &#x27;C:/Files/git-demo&#x27;</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D dev</span></span><br><span class="line">error: Cannot delete branch &#x27;dev&#x27; checked out at &#x27;C:/Files/git-demo&#x27;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>git branch –delete dev</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --delete dev</span></span><br><span class="line">error: The branch &#x27;dev&#x27; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#x27;git branch -D dev&#x27;.</span><br></pre></td></tr></table></figure>

<p>在使用–delete (-d)删除时，系统会有提示消息，删除分支时建议使用-d</p>
</li>
<li><p>git brnach -D dev</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D dev</span></span><br><span class="line">Deleted branch dev (was 939dc9f).</span><br></pre></td></tr></table></figure>

<p>删除分支后，该分支上的文件还存在</p>
<ol>
<li><p>查看939dc9f</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -t 939dc9f</span></span><br><span class="line">commit</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看该文件内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 939dc9f</span></span><br><span class="line">tree b48a27332ca027db625a0601ab1c6957fe4f5cc8</span><br><span class="line">parent a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b</span><br><span class="line">author xiongzhuo &lt;xiongzhuo@outlook.com&gt; 1629549288 +0800</span><br><span class="line">committer xiongzhuo &lt;xiongzhuo@outlook.com&gt; 1629549288 +0800</span><br><span class="line"></span><br><span class="line">1st commit from dev branch</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看文件中tree的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p b48a27</span></span><br><span class="line">100644 blob 38f8e886e1a6d733aa9bfa7282568f83c133ecd6    dev.txt</span><br><span class="line">100644 blob ca5a43e53e012b6fd3b2a8a06ebb6c2ee24a24e5    file1.txt</span><br><span class="line">100644 blob 9887c1a1fdc70e53d47d73b5764a65c889704ef3    file2.txt</span><br><span class="line">040000 tree e3cfebfb440e2af91732e71deda277030d7182e9    folder1</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看dev.txt的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -p 38f8e8</span></span><br><span class="line">dev</span><br></pre></td></tr></table></figure>

<p>通过此四步操作，任然能查看到被删除分支上的内容。这样遗留下来的对象为<u>垃圾对象</u></p>
</li>
</ol>
</li>
</ol>
<p>在git 进行的删除，它实际上只是删除了指向某个commit的指针，这个commit没有被删除</p>
<h3 id="8-checkout特定的commit"><a href="#8-checkout特定的commit" class="headerlink" title="8. checkout特定的commit"></a>8. checkout特定的commit</h3><p>可以通过chekout切换到特定的commit上</p>
<ol>
<li><p>查看commit历史，切换到指定分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b (HEAD -&gt; master)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 17:10:05 2021 +0800</span><br><span class="line"></span><br><span class="line">    3rd commit</span><br><span class="line"></span><br><span class="line">commit 1928061d327bfa64a0a6ce3f4faa029b8c1ce776</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 16:14:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 8a44e8c0e81d4766b22777a61f3233d8b14497cc</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 15:37:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout 192806</span></span><br><span class="line">Note: switching to &#x27;192806&#x27;.</span><br><span class="line"></span><br><span class="line">You are in &#x27;detached HEAD&#x27; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by switching back to a branch.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -c with the switch command. Example:</span><br><span class="line"></span><br><span class="line">  git switch -c &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">Or undo this operation with:</span><br><span class="line"></span><br><span class="line">  git switch -</span><br><span class="line"></span><br><span class="line">Turn off this advice by setting config variable advice.detachedHead to false</span><br><span class="line"></span><br><span class="line">HEAD is now at 1928061 2nd commit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo ((1928061...))</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 1928061d327bfa64a0a6ce3f4faa029b8c1ce776 (HEAD)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 16:14:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 8a44e8c0e81d4766b22777a61f3233d8b14497cc</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 15:37:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108212109934.png" alt="image-20210821210922721"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo ((1928061...))</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout 8a44e8</span></span><br><span class="line">Previous HEAD position was 1928061 2nd commit</span><br><span class="line">HEAD is now at 8a44e8c 1st commit</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo ((8a44e8c...))</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108212110666.png" alt="image-20210821211021284"></p>
<ol>
<li><p>可以通过 <code>git checkout -b 分支名</code>在当前commit创建分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo ((8a44e8c...))</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b tmp</span></span><br><span class="line">Switched to a new branch &#x27;tmp&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 8a44e8c0e81d4766b22777a61f3233d8b14497cc (HEAD -&gt; tmp)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 15:37:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br><span class="line">    </span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/HEAD</span></span><br><span class="line">ref: refs/heads/tmp</span><br></pre></td></tr></table></figure>

<p>通过git log发现当前指向并未变，只是分支名发生了变化</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108212118104.png" alt="image-20210821211857803"></p>
</li>
</ol>
</li>
</ol>
<h5 id="8-1-使用场景"><a href="#8-1-使用场景" class="headerlink" title="8.1 使用场景"></a>8.1 使用场景</h5><p>分支在未合并时就被删除，可以通过checkout + git reflog进行恢复</p>
<blockquote>
<p><code>git log</code>是显示当前的<code>HEAD</code>和它的祖先的，递归是沿着当前指针的父亲，父亲的父亲，……，这样的原则。<br><code>git reflog</code>根本不遍历<code>HEAD</code>的祖先。它是<code>HEAD</code>所指向的一个顺序的提交列表：它的<code>undo</code>历史。<code>reflog</code>并不是<code>repo</code>（仓库）的一部分，它单独存储，而且不包含在<code>pushes</code>，<code>fetches</code>或者<code>clones</code>里面，它纯属是本地的。<br><code>reflog</code>可以很好地帮助你恢复你误操作的数据，例如你错误地<code>reset</code>了一个旧的提交，或者<code>rebase</code>，……，这个时候你可以使用<code>reflog</code>去查看在误操作之前的信息，并且使用<code>git reset --hard</code> 去恢复之前的状态。</p>
</blockquote>
<p>以之前删除的dev分支为例</p>
<ol>
<li><p>切换到master分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (tmp)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>git reflog</code>查看HEAD所指向的顺序提交的列表</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br><span class="line">a1431ae (HEAD -&gt; master) HEAD@&#123;0&#125;: checkout: moving from tmp to master</span><br><span class="line">8a44e8c (tmp) HEAD@&#123;1&#125;: checkout: moving from 8a44e8c0e81d4766b22777a61f3233d8b14497cc to tmp</span><br><span class="line">8a44e8c (tmp) HEAD@&#123;2&#125;: checkout: moving from 1928061d327bfa64a0a6ce3f4faa029b8c1ce776 to 8a44e8</span><br><span class="line">1928061 HEAD@&#123;3&#125;: checkout: moving from master to 192806</span><br><span class="line">a1431ae (HEAD -&gt; master) HEAD@&#123;4&#125;: checkout: moving from dev to master</span><br><span class="line">939dc9f HEAD@&#123;5&#125;: commit: 1st commit from dev branch</span><br><span class="line">a1431ae (HEAD -&gt; master) HEAD@&#123;6&#125;: checkout: moving from master to dev</span><br><span class="line">a1431ae (HEAD -&gt; master) HEAD@&#123;7&#125;: commit: 3rd commit</span><br><span class="line">1928061 HEAD@&#123;8&#125;: commit: 2nd commit</span><br><span class="line">8a44e8c (tmp) HEAD@&#123;9&#125;: commit (initial): 1st commit</span><br></pre></td></tr></table></figure>

<p>找到<code>939dc9f HEAD@&#123;5&#125;: commit: 1st commit from dev branch</code></p>
</li>
<li><p>使用checkout 切换到所找到的commit，进入到<code>&#39;detached HEAD&#39;</code>模式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout 939dc9f</span></span><br><span class="line">Note: switching to &#x27;939dc9f&#x27;.</span><br><span class="line"></span><br><span class="line">You are in &#x27;detached HEAD&#x27; state. You can look around, make experimental</span><br><span class="line">changes and commit them, and you can discard any commits you make in this</span><br><span class="line">state without impacting any branches by switching back to a branch.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may</span><br><span class="line">do so (now or later) by using -c with the switch command. Example:</span><br><span class="line"></span><br><span class="line">  git switch -c &lt;new-branch-name&gt;</span><br><span class="line"></span><br><span class="line">Or undo this operation with:</span><br><span class="line"></span><br><span class="line">  git switch -</span><br><span class="line"></span><br><span class="line">Turn off this advice by setting config variable advice.detachedHead to false</span><br><span class="line"></span><br><span class="line">HEAD is now at 939dc9f 1st commit from dev branch</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo ((939dc9f...))</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">dev.txt  file1.txt  file2.txt  folder1/</span><br></pre></td></tr></table></figure>

<p>切换到该commit以后，dev.txt文件再次出现</p>
</li>
<li><p>在此处建立新的分支进行切换, <code>git switch -c &lt;new-branch-name&gt;</code>是新版提供的命令，在此处用<code>git checkout -b dev</code>与之等效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo ((939dc9f...))</span><br><span class="line"><span class="meta">$</span><span class="bash"> git switch -c dev</span></span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit 939dc9f4fbb92d5bdcff9952f6de1f432fed1b3a (HEAD -&gt; dev)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 20:34:48 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit from dev branch</span><br><span class="line"></span><br><span class="line">commit a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b (master)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 17:10:05 2021 +0800</span><br><span class="line"></span><br><span class="line">    3rd commit</span><br><span class="line"></span><br><span class="line">commit 1928061d327bfa64a0a6ce3f4faa029b8c1ce776</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 16:14:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 8a44e8c0e81d4766b22777a61f3233d8b14497cc (tmp)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 15:37:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="9-git-diff命令"><a href="#9-git-diff命令" class="headerlink" title="9. git diff命令"></a>9. git diff命令</h3><p>用来比较文件间的区别</p>
<p>新建测试文件README.txt，将其从工作区添加到索引区</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch dev</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        README.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add README.txt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li><p>修改工作区中的README.txt，比较工作区与索引区README.txt的区别</p>
<p>①使用Sublime Merge工具可以检测到文件被修改了，绿色为修改部分</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108221101784.png" alt="image-20210822110107633"></p>
<p>②使用<code>git diff</code>命令进行查询</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line">diff --git a/README.txt b/README.txt</span><br><span class="line">index eac2114..ff06760 100644</span><br><span class="line">--- a/README.txt</span><br><span class="line">+++ b/README.txt</span><br><span class="line">@@ -92,4 +92,6 @@ git add .                             # 添加本地代码</span><br><span class="line"> git commit -m &quot;add local source&quot;      # 提交本地代码</span><br><span class="line"> git pull origin master                # 下载远程代码</span><br><span class="line"> git merge master                      # 合并master分支</span><br><span class="line">-git push -u origin master             # 上传代码</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+git push -u origin master             # 上传代码</span><br><span class="line">+</span><br><span class="line">+#添加信息</span><br><span class="line">\ No newline at end of file</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>diff --git a/README.txt b/README.txt</code>：显示只有README.txt文件有区别；<br><code>index eac2114..ff06760 100644</code>：对比的是index(索引区里)eac2114(当前索引区文件的blob对象)，ff06760是工作区文件的SHA1值</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108221123971.gif" alt="动画"></p>
<p><code>--- a/README.txt</code>：代表索引区文件<br><code>+++ b/README.txt</code>：代表工作区文件<br><code>@@ -92,4 +92,6 @@ git add .</code>：不同之处位于，索引区从92行开始往后数4行和工作区从92行开始往后数6行</p>
</li>
<li><p>通过<code>git diff --cached</code>对比索引区与代码仓库的不同</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br><span class="line">diff --git a/README.txt b/README.txt</span><br><span class="line">new file mode 100644</span><br><span class="line">index 0000000..eac2114</span><br><span class="line">--- /dev/null</span><br><span class="line">+++ b/README.txt</span><br><span class="line">@@ -0,0 +1,95 @@</span><br><span class="line">+#常用命令</span><br><span class="line">+git remote add origin git@github.com:yeszao/dofiler.git         # 配置远程git版本</span><br><span class="line">库</span><br><span class="line">+git pull origin master                                          # 下载代码及快速合并</span><br><span class="line">+git push origin master                                          # 上传代码及快速合并</span><br><span class="line">+git fetch origin                                                # 从远程库获取代码</span><br><span class="line">+git branch                                                      # 显示所有分支</span><br><span class="line">+git checkout master                                             # 切换到master分支</span><br><span class="line">+git checkout -b dev                                             # 创建并切换到dev</span><br><span class="line">分支</span><br><span class="line">+git commit -m &quot;first version&quot;                                   # 提交</span><br><span class="line">+git status                                                      # 查看状态</span><br><span class="line">+git log                                                         # 查看提交历史</span><br><span class="line">+git config --global core.editor vim                             # 设置默认编辑器为vim（git默认用nano）</span><br><span class="line">+git config core.ignorecase false                                # 设置大小写敏感</span><br><span class="line">+git config --global user.name &quot;YOUR NAME&quot;                       # 设置用户名</span><br><span class="line">+git config --global user.email &quot;YOUR EMAIL ADDRESS&quot;             # 设置邮箱</span><br><span class="line">+</span><br><span class="line">+#别名</span><br><span class="line">+git config --global alias.br=&quot;branch&quot;                 # 创建/查看本地分支</span><br><span class="line">+git config --global alias.co=&quot;checkout&quot;               # 切换分支</span><br><span class="line">+git config --global alias.cb=&quot;checkout -b&quot;            # 创建并切换到新分支</span><br><span class="line">+git config --global alias.cm=&quot;commit -m&quot;              # 提交</span><br><span class="line">+git config --global alias.st=&quot;status&quot;                 # 查看状态</span><br><span class="line">+git config --global alias.pullm=&quot;pull origin master&quot;  # 拉取分支</span><br><span class="line">+git config --global alias.pushm=&quot;push origin master&quot;  # 提交分支</span><br><span class="line">+git config --global alias.log=&quot;git log --oneline --graph --decorate --color=always&quot; # 单行、分颜色显示记录</span><br><span class="line">+git config --global alias.logg=&quot;git log --graph --all --format=format:&#x27;%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(bold white)— %an%C(reset)%C(bold yellow)%d%C(reset)&#x27; --abbrev-commit --date=relative&quot; # 复杂显示</span><br><span class="line">+</span><br><span class="line">+#创建版本库</span><br><span class="line">+git clone &lt;url&gt;                 # 克隆远程版本库</span><br><span class="line">+git init                        # 初始化本地版本库</span><br><span class="line">+</span><br><span class="line">+#修改和提交</span><br><span class="line">+git status                      # 查看状态</span><br><span class="line">+git diff                        # 查看变更内容</span><br><span class="line">+git add .                       # 跟踪所有改动过的文件</span><br><span class="line">+git add &lt;file&gt;                  # 跟踪指定的文件</span><br><span class="line">+git mv &lt;old&gt; &lt;new&gt;              # 文件改名</span><br><span class="line">+git rm &lt;file&gt;                   # 删除文件</span><br><span class="line">+git rm --cached &lt;file&gt;          # 停止跟踪文件但不删除</span><br><span class="line">+git commit -m “commit message”  # 提交所有更新过的文件</span><br><span class="line">+git commit --amend              # 修改最后一次提交</span><br><span class="line">+</span><br><span class="line">+#查看历史</span><br><span class="line">+git log                         # 查看提交历史</span><br><span class="line">+git log -p &lt;file&gt;               # 查看指定文件的提交历史</span><br><span class="line">+git blame &lt;file&gt;                # 以列表方式查看指定文件的提交历史</span><br><span class="line">+</span><br><span class="line">+#撤销</span><br><span class="line">+git reset --hard HEAD           # 撤消工作目录中所有未提交文件的修改内容</span><br><span class="line">+git reset --hard &lt;version&gt;      # 撤销到某个特定版本</span><br><span class="line">+git checkout HEAD &lt;file&gt;        # 撤消指定的未提交文件的修改内容</span><br><span class="line">+git checkout --&lt;file&gt;           # 同上一个命令</span><br><span class="line">+git revert &lt;commit&gt;             # 撤消指定的提交分支与标签</span><br><span class="line">+</span><br><span class="line">+#分支与标签</span><br><span class="line">+git branch                      # 显示所有本地分支</span><br><span class="line">+git checkout &lt;branch/tag&gt;       # 切换到指定分支或标签</span><br><span class="line">+git branch &lt;new-branch&gt;         # 创建新分支</span><br><span class="line">+git branch -d &lt;branch&gt;          # 删除本地分支</span><br><span class="line">+git tag                         # 列出所有本地标签</span><br><span class="line">+git tag &lt;tag-name&gt;              # 基于最新提交创建标签</span><br><span class="line">+git tag -a &quot;v1.0&quot; -m &quot;一些说明&quot;  # -a指定标签名称，-m指定标签说明</span><br><span class="line">+git tag -d &lt;tag-name&gt;           # 删除标签</span><br><span class="line">+git checkout dev                # 合并特定的commit到dev分支上</span><br><span class="line">+git cherry-pick 62ecb3</span><br><span class="line">+</span><br><span class="line">+#合并与衍合</span><br><span class="line">+git merge &lt;branch&gt;              # 合并指定分支到当前分支</span><br><span class="line">+git merge --abort               # 取消当前合并，重建合并前状态</span><br><span class="line">+git merge dev -Xtheirs          # 以合并dev分支到当前分支，有冲突则以dev分支为准</span><br><span class="line">+git rebase &lt;branch&gt;             # 衍合指定分支到当前分支</span><br><span class="line">+</span><br><span class="line">+#远程操作</span><br><span class="line">+git remote -v                                           # 查看远程版本库信息</span><br><span class="line">+git remote show &lt;remote&gt;                                # 查看指定远程版本库信息</span><br><span class="line">+git remote add &lt;remote&gt; &lt;url&gt;                           # 添加远程版本库</span><br><span class="line">+git remote remove &lt;remote&gt;                              # 删除指定的远程版本库</span><br><span class="line">+git fetch &lt;remote&gt;                                      # 从远程库获取代码</span><br><span class="line">+git pull &lt;remote&gt; &lt;branch&gt;                              # 下载代码及快速合并</span><br><span class="line">+git push &lt;remote&gt; &lt;branch&gt;                              # 上传代码及快速合并</span><br><span class="line">+git push &lt;remote&gt; :&lt;branch/tag-name&gt;                    # 删除远程分支或标签</span><br><span class="line">+git push --tags                                         # 上传所有标签</span><br><span class="line">+</span><br><span class="line">+#打包</span><br><span class="line">+git archive --format=zip --output ../file.zip master    # 将master分支打包成file.zip文件，保存在上一级目录</span><br><span class="line">+git archive --format=zip --output ../v1.2.zip v1.2      # 打包v1.2标签的文件，保存在上一级目录v1.2.zip文件中</span><br><span class="line">+git archive --format=zip v1.2 &gt; ../v1.2.zip             # 作用同上一条命令</span><br><span class="line">+</span><br><span class="line">+#远程与本地合并</span><br><span class="line">+git init                              # 初始化本地代码仓</span><br><span class="line">+git add .                             # 添加本地代码</span><br><span class="line">+git commit -m &quot;add local source&quot;      # 提交本地代码</span><br><span class="line">+git pull origin master                # 下载远程代码</span><br><span class="line">+git merge master                      # 合并master分支</span><br><span class="line">+git push -u origin master             # 上传代码</span><br><span class="line">\ No newline at end of file</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于未将文件提交到仓库，所以仓库将文件里的内容全部作为新增内容</p>
</li>
<li><p>将修改后的文件先添加到索引区，再从索引区添加到代码仓库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git add README.txt</span></span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (dev)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;2nd commit from dev&quot;</span></span></span><br><span class="line">[dev 116e5dd] 2nd commit from dev</span><br><span class="line"> 1 file changed, 97 insertions(+)</span><br><span class="line"> create mode 100644 README.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="10-远程仓库的添加"><a href="#10-远程仓库的添加" class="headerlink" title="10. 远程仓库的添加"></a>10. 远程仓库的添加</h3><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108221156794.jpeg" alt="网页捕获_22-8-2021_11566_github.com"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108221158144.jpeg" alt="网页捕获_22-8-2021_115820_github.com"></p>
<p>在此演示将本地仓库以httpsh的方式push到远程仓库</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108221202754.png" alt="image-20210822120200581"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>

<ol>
<li><p>添加远程地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin https://github.com/xiongzhuozhuo/2021-git-demo.git</span></span><br></pre></td></tr></table></figure>

<p>添加远程仓库地址后，文件目录不会发生改变，但是.git/config文件发生了变化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/config</span></span><br><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = false</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br><span class="line">        symlinks = false</span><br><span class="line">        ignorecase = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">        url = https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure>
</li>
<li><p>将本地内容推送到远程master分支上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br><span class="line">Enumerating objects: 11, done.</span><br><span class="line">Counting objects: 100% (11/11), done.</span><br><span class="line">Delta compression using up to 8 threads</span><br><span class="line">Compressing objects: 100% (6/6), done.</span><br><span class="line">Writing objects: 100% (11/11), 760 bytes | 190.00 KiB/s, done.</span><br><span class="line">Total 11 (delta 1), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (1/1), done.</span><br><span class="line">To https://github.com/xiongzhuozhuo/2021-git-demo.git</span><br><span class="line"> * [new branch]      master -&gt; master</span><br><span class="line">Branch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108221228160.png" alt="image-20210822122806491"></p>
</li>
<li><p>查看新增文件</p>
<p>①logs里有新增文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/logs /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO\.GIT\LOGS</span><br><span class="line">│  HEAD</span><br><span class="line">│</span><br><span class="line">└─refs</span><br><span class="line">    ├─heads</span><br><span class="line">    │      dev</span><br><span class="line">    │      master</span><br><span class="line">    │      tmp</span><br><span class="line">    │</span><br><span class="line">    └─remotes            #新增</span><br><span class="line">        └─origin         #新增</span><br><span class="line">                master    #新增</span><br></pre></td></tr></table></figure>

<p>②refs里有新增文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@SURFACE-PRO6 C:\Files\git-demo</span><br><span class="line"><span class="meta">$</span><span class="bash"> tree .git/refs /f</span></span><br><span class="line">卷 Local Disk 的文件夹 PATH 列表</span><br><span class="line">卷序列号为 C0000100 F296:2801</span><br><span class="line">C:\FILES\GIT-DEMO\.GIT\REFS</span><br><span class="line">├─heads</span><br><span class="line">│      dev</span><br><span class="line">│      master</span><br><span class="line">│      tmp</span><br><span class="line">│</span><br><span class="line">├─remotes                 #新增</span><br><span class="line">│  └─origin              #新增</span><br><span class="line">│          master         #新增</span><br><span class="line">│</span><br><span class="line">└─tags</span><br></pre></td></tr></table></figure>

<p>因为此时是在master分支上将文件推送到远程服务器的，所以二者的指向应该相同，验证如下：</p>
<ol>
<li><p>查看remotes里的master分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/refs/remotes/origin/master</span></span><br><span class="line">a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b</span><br><span class="line"></span><br><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git cat-file -t a1431a</span></span><br><span class="line">commit</span><br></pre></td></tr></table></figure>

<p>指向的为一次提交</p>
</li>
<li><p>查看heads里的master分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat .git/refs/heads/master</span></span><br><span class="line">a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b</span><br></pre></td></tr></table></figure>

<p>二者指向同一次提交</p>
</li>
<li><p>查看提交历史</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xiong@Surface-pro6 MINGW64 /c/Files/git-demo (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line">commit a1431ae9fc3ef4f2ddd35c6a44349b69a5bd2f8b (HEAD -&gt; master, origin/master)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 17:10:05 2021 +0800</span><br><span class="line"></span><br><span class="line">    3rd commit</span><br><span class="line"></span><br><span class="line">commit 1928061d327bfa64a0a6ce3f4faa029b8c1ce776</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 16:14:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    2nd commit</span><br><span class="line"></span><br><span class="line">commit 8a44e8c0e81d4766b22777a61f3233d8b14497cc (tmp)</span><br><span class="line">Author: xiongzhuo &lt;xiongzhuo@outlook.com&gt;</span><br><span class="line">Date:   Sat Aug 21 15:37:06 2021 +0800</span><br><span class="line"></span><br><span class="line">    1st commit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<p>此时在本地做一次提交后，本地的master分支和远程仓库的master分支就不同步了</p>
<h3 id="11-git-对象的压缩"><a href="#11-git-对象的压缩" class="headerlink" title="11. git 对象的压缩"></a>11. git 对象的压缩</h3><h3 id="12-SHA1插曲"><a href="#12-SHA1插曲" class="headerlink" title="12. SHA1插曲"></a>12. SHA1插曲</h3><h3 id="13-git-pack压缩"><a href="#13-git-pack压缩" class="headerlink" title="13. git pack压缩"></a>13. git pack压缩</h3><p><strong>背景</strong></p>
<p>在git里，文件会先压缩成blob对象进行存储，虽在在一定程度上减小了内存开销，但是由于每次对文件在工作区修改后，都需要将</p>
<h3 id="14-git-pack解压缩"><a href="#14-git-pack解压缩" class="headerlink" title="14. git pack解压缩"></a>14. git pack解压缩</h3><h3 id="15-git垃圾对象的清理"><a href="#15-git垃圾对象的清理" class="headerlink" title="15. git垃圾对象的清理"></a>15. git垃圾对象的清理</h3><h3 id="16-fast-forward合并"><a href="#16-fast-forward合并" class="headerlink" title="16. fast forward合并"></a>16. fast forward合并</h3><h3 id="17-3-way-merge"><a href="#17-3-way-merge" class="headerlink" title="17. 3 way merge"></a>17. 3 way merge</h3><h3 id="18-带冲突的3-way-merge"><a href="#18-带冲突的3-way-merge" class="headerlink" title="18. 带冲突的3 way merge"></a>18. 带冲突的3 way merge</h3><h3 id="19-git-rebase"><a href="#19-git-rebase" class="headerlink" title="19. git rebase"></a>19. git rebase</h3><h3 id="20-标签tag"><a href="#20-标签tag" class="headerlink" title="20. 标签tag"></a>20. 标签tag</h3><h3 id="21-本地分支和远程分支"><a href="#21-本地分支和远程分支" class="headerlink" title="21. 本地分支和远程分支"></a>21. 本地分支和远程分支</h3><h3 id="22-git-fetch-amp-git-pull"><a href="#22-git-fetch-amp-git-pull" class="headerlink" title="22. git fetch &amp; git pull"></a>22. git fetch &amp; git pull</h3><h3 id="23-fetch-head"><a href="#23-fetch-head" class="headerlink" title="23. fetch_head"></a>23. fetch_head</h3><h3 id="24-git-pull"><a href="#24-git-pull" class="headerlink" title="24. git pull"></a>24. git pull</h3><h3 id="25-本地git-hook"><a href="#25-本地git-hook" class="headerlink" title="25. 本地git hook"></a>25. 本地git hook</h3><h3 id="26-pre-commit钩子"><a href="#26-pre-commit钩子" class="headerlink" title="26. pre-commit钩子"></a>26. pre-commit钩子</h3><h3 id="27-git-hook和python"><a href="#27-git-hook和python" class="headerlink" title="27. git hook和python"></a>27. git hook和python</h3>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
