<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>个人分享平台构建（前导篇）——Markdown基础语法</title>
    <url>/2021/02/25/%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB%E5%B9%B3%E5%8F%B0%E6%9E%84%E5%BB%BA(%E5%89%8D%E5%AF%BC%E7%AF%87)%E2%80%94%E2%80%94Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305161628.png" alt="个人分享平台构建"></p>
<h1 id="MarkDown常用语法"><a href="#MarkDown常用语法" class="headerlink" title="MarkDown常用语法"></a>MarkDown常用语法</h1><p><a href="https://www.bilibili.com/video/av87982836#reply2366896129">基础视频讲解链接</a><br><a href="https://www.bilibili.com/video/av88551739/">画图视频讲解链接</a></p>
<span id="more"></span>
<p>本篇为前导教程，帮助大家了解Markdown的基础语法 ，Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。<br>由于Markdown的轻量化、易读易写特性，并且对于图片，图表、数学式都有支持，许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。如GitHub、Reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge、简书等，甚至还能被使用来撰写电子书。了解Markdown语法规则有利于大家后期个人博客的撰写。</p>
<h2 id="语块及标识"><a href="#语块及标识" class="headerlink" title="语块及标识"></a>语块及标识</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">```语言名称</span></span><br><span class="line"><span class="code">```(英文输入法下输入)</span></span><br></pre></td></tr></table></figure>
<h3 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">`行内代码`</span><br></pre></td></tr></table></figure>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;一级引用</span><br><span class="line">&gt;&gt;二级引用</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">***  或  ---  或  ___</span><br></pre></td></tr></table></figure>
<h2 id="文字效果"><a href="#文字效果" class="headerlink" title="文字效果"></a>文字效果</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 标题名字 （#个数代表标题级数）</span><br></pre></td></tr></table></figure>
<h3 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**文本**  或  __文本__</span><br><span class="line">__(英文输入法下 Shift + -)</span><br></pre></td></tr></table></figure>
<h3 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">*文本*  或  _文本_</span><br></pre></td></tr></table></figure>
<h3 id="加粗斜体"><a href="#加粗斜体" class="headerlink" title="加粗斜体"></a>加粗斜体</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">***文本***  或  ___文本___</span><br></pre></td></tr></table></figure>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;文本&lt;/u&gt;</span><br></pre></td></tr></table></figure>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">~~文字~~</span><br></pre></td></tr></table></figure>
<h3 id="在Typora下需勾选扩展语法的效果"><a href="#在Typora下需勾选扩展语法的效果" class="headerlink" title="在Typora下需勾选扩展语法的效果"></a>在Typora下需勾选扩展语法的效果</h3><h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">==文本== （Typora下需勾选扩展语法)</span><br></pre></td></tr></table></figure>
<h4 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">水 H~<span class="number">2</span>~O</span><br><span class="line">双氧水 H~<span class="number">2</span>~O~<span class="number">2</span>~</span><br></pre></td></tr></table></figure>
<h4 id="上标"><a href="#上标" class="headerlink" title="上标"></a>上标</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">面积 m^<span class="number">2</span>^</span><br><span class="line">体积 m^<span class="number">3</span>^</span><br></pre></td></tr></table></figure>
<h3 id="表情符号"><a href="#表情符号" class="headerlink" title="表情符号"></a>表情符号</h3><p>😁😀 （win标 + ;)</p>
<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><h3 id="外部跳转"><a href="#外部跳转" class="headerlink" title="外部跳转"></a>外部跳转</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[描述](网址)</span><br></pre></td></tr></table></figure>
<h3 id="内部跳转"><a href="#内部跳转" class="headerlink" title="内部跳转"></a>内部跳转</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">[描述]（#标题）</span><br></pre></td></tr></table></figure>
<h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;网址&gt;</span><br></pre></td></tr></table></figure>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h3 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">![图片描述](图片本地地址)</span><br></pre></td></tr></table></figure>
<h3 id="网络图片"><a href="#网络图片" class="headerlink" title="网络图片"></a>网络图片</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">![图片描述](图片网络地址)</span><br></pre></td></tr></table></figure>
<h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序表"><a href="#无序表" class="headerlink" title="无序表"></a>无序表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">* 可以使用“*”作为标记</span><br><span class="line">+ 也可以使用“+”</span><br><span class="line">- 或者“-”</span><br></pre></td></tr></table></figure>
<h4 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">数字.空格</span><br><span class="line"><span class="number">1.</span> 有序表以数字和<span class="string">&#x27;.&#x27;</span>开始</span><br><span class="line"><span class="number">4.</span> 数字序列不会影响生成序列</span><br><span class="line"><span class="number">5</span>\. 数字\. 取消显示为列表</span><br></pre></td></tr></table></figure>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">使用|来分隔不同单元格，使用-来分隔表头和其他行,使用:来设置对齐</span><br><span class="line">姓名 | 年龄</span><br><span class="line">-- | --</span><br><span class="line">张三 | <span class="number">12</span></span><br><span class="line">李四 | <span class="number">23</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>办公技能</category>
      </categories>
      <tags>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>个人分享平台构建(工具篇)——Typora + PicGo + Gitee</title>
    <url>/2021/03/05/%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB%E5%B9%B3%E5%8F%B0%E6%9E%84%E5%BB%BA(%E5%B7%A5%E5%85%B7%E7%AF%87)%E2%80%94%E2%80%94Typora+PicGo+Gitee/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305161628.png" alt="个人分享平台构建"></p>
<span id="more"></span>
<h3 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h3><h4 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a><a href="https://www.typora.io/">Typora</a></h4><p>​    <strong>Typora</strong>是一个所见即所得的Markdown格式文本编辑器，支持Windows、macOS和GNU/Linux操作系统，包括对GitHub Flavored Markdown扩展格式的支持、拼写检查、自定义CSS样式、数学公式渲染（通过MathJax）等特性，<a href="https://www.typora.io/">点击跳转下载</a>，软件截图如下：</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305140341.png" alt="image-20210305140336396" style="zoom: 50%;" />

<h4 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a><a href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.0-beta.4">PicGo</a></h4><p>​    我们在写作、写 Markdown、博客时，经常都要插入图片。然而要贴图 (上传图片) 时还得登录图床网站/服务器去手工上传和复制链接，操作比较繁琐。</p>
<p>​    <strong>PicGo</strong> 是一款开源跨平台的免费图片上传工具以及图床相册管理软件，它能帮你快速地将图片上传到微博、又拍云、阿里云 OSS、腾讯云 COS、七牛、GitHub、sm.ms、Imgur 等常见的免费图床网站或云存储服务上，并自动复制图片的链接到剪贴板里，使用上非常高效便捷。<a href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.0-beta.4">点击跳转下载</a>，软件截图如下：</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305140622.png" alt="image-20210305140621282" style="zoom: 50%;" />

<h4 id="Gitee"><a href="#Gitee" class="headerlink" title="Gitee"></a><a href="https://gitee.com/">Gitee</a></h4><p>​    <strong>Gitee</strong>是深圳市奥思网络科技有限公司推出的代码托管平台，支持Git和SVN，提供免费的私有仓库托管。目前开发者超过500万，托管项目超过1000万，汇聚几乎所有本土原创开源项目，并于2016年推出企业版，提供企业级代码托管服务。<a href="https://gitee.com/">点击跳转官网</a>进行Gitee账户注册。</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305141040.png" alt="image-20210305141038648" style="zoom: 25%;" />

<h3 id="工具配置"><a href="#工具配置" class="headerlink" title="工具配置"></a>工具配置</h3><p>​    Typora作为一款Markdown编辑器，搭配图床工具PicGo以及托管平台Gitee，能够简洁高效的编写图文并茂的博客。按照链接==<strong>下载好Typora、PicGo并注册Gitee账号后</strong>==，下面进入配置环节。</p>
<h4 id="1-配置Gitee"><a href="#1-配置Gitee" class="headerlink" title="1.配置Gitee"></a>1.配置Gitee</h4><p>【创建仓库】</p>
<p>​    点击头像右侧“+”，【新建仓库】——填写【仓库名称】——是否开源选择【公开】（如果不公开，PicGo上传之后的图片无法在Typora中通过网络地址进行显示）——【创建】</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305144104.png" alt="image-20210305144102602" style="zoom: 67%;" />

<p>【生成私人令牌】</p>
<p>​    点击头像，【设置】——【私人令牌】——【生成新令牌】——填写令牌描述【提交】，复制令牌</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305145414.png" alt="image-20210305145412307"></p>
<h4 id="2-配置PicGo"><a href="#2-配置PicGo" class="headerlink" title="2.配置PicGo"></a>2.配置PicGo</h4><p><a href="https://nodejs.org/zh-cn/">点击下载node.js</a>，为安装插件做准备</p>
<p>【插件设置】——下载gitee插件</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305145931.png" alt="image-20210305145929348" style="zoom: 50%;" />

<p>【PicGo设置】——开启Gitee图床——开启【时间戳重命名】</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305150117.png" alt="image-20210305150114651" style="zoom:50%;" />

<p>【图床设置】——Gitee图床设置</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305150333.png" alt="image-20210305150331034" style="zoom:50%;" />

<h4 id="3-配置Typora"><a href="#3-配置Typora" class="headerlink" title="3.配置Typora"></a>3.配置Typora</h4><p>【文件】——【偏好设置】——【图像】，PicGo路径为当前电脑安装路径</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305151539.png" alt="image-20210305151537874" style="zoom:50%;" />

<p>【验证图片上传选项】</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305151955.png" alt="image-20210305151953065" style="zoom: 67%;" />

<h3 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h3><p>​    运行PicGo，运行Typora，插入图片进行测试。右键插入的图片，点击【上传图片】，上传成功，并能正确显示，完成测试</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/20210305152932.png" style="zoom:25%;" />



]]></content>
      <categories>
        <category>办公技能</category>
      </categories>
      <tags>
        <tag>Typora + PicGo + Gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>01-Java语言概述</title>
    <url>/2021/08/14/01-Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><span id="more"></span>
<h3 id="01-Java语言概述"><a href="#01-Java语言概述" class="headerlink" title="01-Java语言概述"></a>01-Java语言概述</h3><p><strong>Java基础知识图解</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108140854557.png" alt="Java基础知识图解"></p>
<h4 id="1-软件开发介绍"><a href="#1-软件开发介绍" class="headerlink" title="1. 软件开发介绍"></a>1. 软件开发介绍</h4><ul>
<li><p>软件开发</p>
<p>软件，即一系列按照特定顺序组织的计算机数据和指令的集合。有系统软件和应用软件之分。</p>
</li>
<li><p>人机交互方式</p>
<ul>
<li>图形化界面(Graphical User Interface GUI)这种方式简单直观，使用者易于接受，容易上手操作。</li>
<li>命令行方式(Command Line Interface CLI)：需要有一个控制台，输 入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些 命令。</li>
</ul>
</li>
<li><p>常用Dos命令</p>
<ul>
<li>dir：列出当前目录下的文件以及文件夹</li>
<li>md：创建目录</li>
<li>rd：删除目录</li>
<li>cd：进入指定目录</li>
<li>cd..：退回到上一级目录</li>
<li>cd\：回到根目录</li>
<li>del：删除文件</li>
<li>exit：退出dos命令行<ul>
<li>补充：echo javase&gt;1.doc</li>
</ul>
</li>
</ul>
</li>
<li><p>常用快捷键</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108140954873.png" alt="image-20210814095451964" style="zoom: 67%;" /> 

</li>
</ul>
<h4 id="2-计算机编程语言介绍"><a href="#2-计算机编程语言介绍" class="headerlink" title="2. 计算机编程语言介绍"></a>2. 计算机编程语言介绍</h4><ul>
<li><p>什么是计算机语言</p>
<ul>
<li><p>语言：是人与人之间用于沟通的一种方式。例如：中国人与中国人用普通话沟通。而中国人要和英国人交流，就要学习英语。</p>
</li>
<li><p>计算机语言：人与计算机交流的方式</p>
<p>如果人要与计算机交流，那么就要学习计算机语言。</p>
<p>计算机语言有很多种。如：C ,C++ ,Java ,PHP , Kotlin，Python，Scala等。</p>
</li>
</ul>
</li>
<li><p>第一代语言</p>
<ul>
<li>机器语言。指令以二进制代码形式存在</li>
</ul>
</li>
<li><p>第二代语言</p>
<ul>
<li><p>汇编语言。使用助记符表示一条机器指令</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108140958142.png" alt="image-20210814095801122"></p>
</li>
</ul>
</li>
<li><p>第三代语言：高级语言</p>
<ul>
<li>C、Pascal、Fortran面向过程的语言</li>
<li>C++面向过程/面向对象</li>
<li>Java跨平台的纯面向对象的语言</li>
<li>.NET跨语言的平台</li>
<li>Pyton、Scala…</li>
</ul>
</li>
<li><p>从市场需求来看<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141003345.png" alt="image-20210814100355030"></p>
<p><a href="https://www.tiobe.com/tiobe-index/">index | TIOBE - The Software Quality Company</a></p>
</li>
</ul>
<h4 id="3-Java语言概述"><a href="#3-Java语言概述" class="headerlink" title="3. Java语言概述"></a>3. Java语言概述</h4><ul>
<li><p>是SUN(Stanford University Network，斯坦福大学网络公司 ) 1995年推出的一 门高级编程语言。</p>
</li>
<li><p>是一种面向Internet的编程语言。Java一开始富有吸引力是因为Java程序可以 在Web浏览器中运行。这些Java程序被称为Java小程序（applet）。applet使 用现代的图形用户界面与Web用户进行交互。 applet内嵌在HTML代码中。</p>
</li>
<li><p>随着Java技术在web方面的不断成熟，已经成为Web应用程序的首选开发语言。</p>
<p>后台开发：Java、PHP、Python、Go、Node.js</p>
</li>
<li><p>Java简史</p>
<ul>
<li>1991年 Green项目，开发语言最初命名为Oak (橡树)</li>
<li>1994年，开发组意识到Oak 非常适合于互联网</li>
<li>1996年，发布JDK 1.0，约8.3万个网页应用Java技术来制作</li>
<li>1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最</li>
<li>1998年，发布JDK 1.2，同年发布企业平台J2EE</li>
<li>1999年，Java分成J2SE、J2EE和J2ME，JSP/Servlet技术诞生</li>
<li>==2004年，发布里程碑式版本：JDK 1.5，为突出此版本的重要性，更名为JDK 5.0==</li>
<li>2005年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE，J2ME -&gt; JavaME</li>
<li>2009年，Oracle公司收购SUN，交易价格74亿美元</li>
<li>2011年，发布JDK 7.0</li>
<li>==2014年，发布JDK 8.0，是继JDK 5.0以来变化最大的版本==</li>
<li>2017年，发布JDK 9.0，最大限度实现模块化</li>
<li>2018年3月，发布JDK 10.0，版本号也称为18.3</li>
<li>2018年9月，发布JDK 11.0，版本号也称为18.9</li>
</ul>
</li>
<li><p>Java技术体系平台</p>
<img src="../../../AppData/Roaming/Typora/typora-user-images/image-20210814100954968.png" alt="image-20210814100954968" style="zoom:80%;" /> 
</li>
<li><p>Java再各领域的应用</p>
<ul>
<li>从Java的应用领域来分，Java语言的应用方向主要表现在以下几个方面：<ul>
<li>企业级应用：主要指复杂的大企业的软件系统、各种类型的网站。Java的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。</li>
<li>Android平台应用：Android应用程序使用Java语言编写。Android开发水平的高低 很大程度上取决于Java语言核心能力是否扎实。</li>
<li>大数据平台开发：各类框架有Hadoop，spark，storm，flink等，就这类技术生态圈来讲，还有各种中间件如flume，kafka，sqoop等等 ，这些框架以及工具大多数是用Java编写而成，但提供诸如Java，scala，Python，R等各种语言API供编程。</li>
<li>移动领域应用：主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括手 机、PDA、机顶盒、汽车通信设备等。</li>
</ul>
</li>
</ul>
</li>
<li><p>Java语言的诞生</p>
<p>​         java之父James Gosling团队在开发”Green”项目时，发现C缺少垃圾回收系统，还有可移植的安 全性、分布程序设计和多线程功能。最后，他们想要一种易于移植到各种设备上的平台。<br>​         Java确实是从C语言和C++语言继承了许多成份，甚至可以将Java看 成是类C语言发展和衍生的产物。比如Java语言的变量声明，操作符 形式，参数传递，流程控制等方面和C语言、C++语言完全相同。但同 时，Java是一个纯粹的面向对象的程序设计语言，它继承了C++语言 面向对象技术的核心。Java舍弃了C语言中容易引起错误的指针（以 引用取代）、运算符重载（operator overloading）、多重继承 （以接口取代）等特性，增加了垃圾回收器功能用于回收不再被引用 的对象所占据的内存空间。JDK1.5又引入了泛型编程（Generic  Programming）、类型安全的枚举、不定长参数和自动装/拆箱</p>
</li>
<li><p>主要特性</p>
<ul>
<li>Java语言是易学的。Java语言的语法与C语言和C++语言很接近，使得大多数程序员 很容易学习和使用Java。</li>
<li>Java语言是强制面向对象的。Java语言提供类、接口和继承等原语，为了简单起见， 只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制 （关键字为implements）。</li>
<li>Java语言是分布式的。Java语言支持Internet应用的开发，在基本的Java应用编 程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类 库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程 方法激活）机制也是开发分布式应用的重要手段。</li>
<li>Java语言是健壮的。Java的强类型机制、异常处理、垃圾的自动收集等是Java程序 健壮性的重要保证。对指针的丢弃是Java的明智选择。</li>
<li>Java语言是安全的。Java通常被用在网络环境中，为此，Java提供了一个安全机 制以防恶意代码的攻击。如：安全防范机制（类ClassLoader），如分配不同的 名字空间以防替代本地的同名类、字节代码检查。</li>
<li>Java语言是体系结构中立的。Java程序（后缀为java的文件）在Java平台上被 编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个 Java平台的任何系统中运行。</li>
<li>Java语言是解释型的。如前所述，Java程序在Java平台上被编译为字节码格式， 然后可以在实现这个Java平台的任何系统的解释器中运行。</li>
<li>Java是性能略高的。与那些解释型的高级脚本语言相比，Java的性能还是较优的。</li>
<li>Java语言是原生支持多线程的。在Java语言中，线程是一种特殊的对象，它必须 由Thread类或其子（孙）类来创建。</li>
</ul>
</li>
</ul>
<h4 id="4-运行机制及运行过程"><a href="#4-运行机制及运行过程" class="headerlink" title="4. 运行机制及运行过程"></a>4. 运行机制及运行过程</h4><ul>
<li>Java语言的特点<ul>
<li>特点一：面向对象<ul>
<li>两个基本概念：类、对象</li>
<li>三大特性：封装、继承、多态</li>
</ul>
</li>
<li>特点二：健壮性<ul>
<li>吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与 释放等），提供了一个相对安全的内存管理和访问机制</li>
</ul>
</li>
<li>特点三：跨平台性<ul>
<li>跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。“Write  once , Run Anywhere”<ul>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141017944.png" alt="image-20210814101734807"></li>
</ul>
</li>
<li>原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java  Virtual Machine) 即可。由JVM来负责Java程序在该系统中的运行。</li>
</ul>
</li>
</ul>
</li>
<li>Java的两种核心机制<ul>
<li>Java虚拟机 (Java Virtal Machine)</li>
<li>垃圾收集机制 (Garbage Collection)</li>
</ul>
</li>
<li>核心机制—Java虚拟机<ul>
<li>JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。</li>
<li>对于不同的平台，有不同的虚拟机。</li>
<li>只有某平台提供了对应的java虚拟机，java程序才可在此平台运行</li>
<li>Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行”</li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141019425.png" alt="image-20210814101933458"></li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141021496.png" alt="image-20210814102128856" style="zoom:80%;" /> </li>
</ul>
</li>
<li>核心机制—垃圾回收<ul>
<li>不再使用的内存空间应回收—— 垃圾回收。<ul>
<li>在C/C++等语言中，由程序员负责回收无用内存。</li>
<li>Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。</li>
<li>垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。</li>
</ul>
</li>
<li>Java程序还会出现内存泄漏和内存溢出问题吗？Yes!</li>
</ul>
</li>
</ul>
<h4 id="5-Java的环境搭建"><a href="#5-Java的环境搭建" class="headerlink" title="5. Java的环境搭建"></a>5. Java的环境搭建</h4><ul>
<li><p>明确什么是JDK, JRE</p>
</li>
<li><p>下载 JDK</p>
</li>
<li><p>安装 JDK</p>
</li>
<li><p>配置环境变量</p>
<ul>
<li>path：windows系统执行命令时要搜寻的路径。</li>
</ul>
</li>
<li><p>验证是否成功：javac java</p>
</li>
<li><p>选择合适的文本编辑器或 IDE 开发</p>
</li>
<li><p>什么是JDK,JRE</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141026886.png" alt="image-20210814102648748" style="zoom:80%;" />
</li>
<li><p>JDK、JRE、JVM关系</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141030638.png" alt="image-20210814103016502"  /> 

<p><a href="https://docs.oracle.com/javase/8/docs/">Java Platform Standard Edition 8 Documentation (oracle.com)</a></p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141031010.png" alt="image-20210814103148629" style="zoom:80%;" />
</li>
<li><p>官方网址：</p>
<ul>
<li><a href="http://www.oracle.com/">www.oracle.com</a></li>
<li>java.sun.com</li>
</ul>
</li>
<li><p>安装JDK</p>
<ul>
<li>傻瓜式安装，下一步即可。</li>
<li>建议：安装路径不要有中文或者空格等特殊符号。</li>
<li>如果操作系统是64位的，软件尽量选择支持64位的（除非软件本身不区分）。</li>
<li>当提示安装 JRE 时，正常在JDK安装时已经装过了，但是为了后续使用Eclipse等开发 工具不报错，建议也根据提示安装JRE。</li>
</ul>
</li>
<li><p>配置环境变量path</p>
<ul>
<li><p>在dos命令行中敲入javac，出现错误</p>
</li>
<li><p>错误原因：当前执行的程序在当前目录下如果不存在，windows系统会在系 统中已有的一个名为path的环境变量指定的目录中查找。如果仍未找到，会 出现以上的错误提示。所以进入到 jdk安装路径\bin目录下，执行javac，会看到javac参数提示信息。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141036210.png" alt="image-20210814103637239"></p>
<p>每次执行 java 的工具都要进入到bin目录下，是非常麻烦的。可不可以在任何目 录下都可以执行java的工具呢？</p>
</li>
<li><p>根据windows系统在查找可执行程序的原理，可以将java工具所在路径定义到 path 环境变量中，让系统帮我们去找运行执行的程序。</p>
</li>
<li><p>配置方法</p>
<ul>
<li>我的电脑–属性–高级系统设置–环境变量</li>
<li>编辑 path 环境变量，在变量值开始处加上java工具所在目录，后面用 “ ; ”和其他值分隔 开即可。</li>
<li>打开DOS命令行，任意目录下敲入javac。如果出现javac 的参数信息，配置成功。</li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141045807.png" alt="image-20210814104346438"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-开发体验—HelloWord"><a href="#6-开发体验—HelloWord" class="headerlink" title="6. 开发体验—HelloWord"></a>6. 开发体验—HelloWord</h4><ul>
<li><p>步骤</p>
<ol>
<li><p>将 Java 代码编写到扩展名为 .java 的文件中。</p>
</li>
<li><p>通过 javac 命令对该 java 文件进行编译。</p>
</li>
<li><p>通过 java 命令对生成的 class 文件进行运行。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141105182.png" alt="image-20210814110554841"></p>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>个人分享平台构建（博客搭建篇）——Hexo + Next + Github</title>
    <url>/2021/03/06/%E4%B8%AA%E4%BA%BA%E5%88%86%E4%BA%AB%E5%B9%B3%E5%8F%B0%E6%9E%84%E5%BB%BA%EF%BC%88%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AF%87%EF%BC%89%E2%80%94%E2%80%94Hexo%20+%20Next%20+%20Github/</url>
    <content><![CDATA[<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h3 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h3><h4 id="1-1-1-安装前提"><a href="#1-1-1-安装前提" class="headerlink" title="1.1.1 安装前提"></a>1.1.1 安装前提</h4><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p>
<ul>
<li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li>
<li><a href="http://git-scm.com/">Git</a></li>
</ul>
<h4 id="1-1-2-安装-Node-js"><a href="#1-1-2-安装-Node-js" class="headerlink" title="1.1.2 安装 Node.js"></a>1.1.2 安装 Node.js</h4><p>简单的说 <strong>Node.js</strong> 就是运行在服务端的 JavaScript。**Node.js **是一个基于Chrome JavaScript 运行时建立的一个平台。</p>
<p><strong>Node.js</strong>是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p>
<p><strong>Node.js</strong> 为大多数平台提供了官方的 <a href="https://nodejs.org/en/download/">安装程序</a>。也可以前往 <a href="https://npm.taobao.org/mirrors/node">淘宝 Node.js 镜像</a> 下载。</p>
<p>其它的安装方法：</p>
<ul>
<li>Windows：通过 <a href="https://github.com/jasongin/nvs/">nvs</a>（推荐）或者<a href="https://github.com/nvm-sh/nvm">nvm</a> 安装。</li>
<li>Mac：使用 <a href="https://brew.sh/">Homebrew</a> 或 <a href="http://www.macports.org/">MacPorts</a> 安装。</li>
<li>Linux（DEB/RPM-based）：从 <a href="https://github.com/nodesource/distributions">NodeSource</a> 安装。</li>
<li>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 <a href="https://nodejs.org/en/download/package-manager/">指导</a></li>
</ul>
<p>对于 Mac 和 Linux 同样建议使用 nvs 或者 nvm，以避免可能会出现的权限问题。</p>
<blockquote>
<p><strong>Windows 用户</strong></p>
<p>使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）</p>
</blockquote>
<blockquote>
<p><strong>For Mac / Linux 用户</strong></p>
<p>如果在尝试安装 Hexo 的过程中出现 <code>EACCES</code> 权限错误，请遵循 <a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally">由 npmjs 发布的指导</a> 修复该问题。建议 <strong>不要</strong> 使用 root、sudo 等方法覆盖权限</p>
</blockquote>
<blockquote>
<p><strong>Linux</strong></p>
<p>‎如果您使用Snap安装了<strong>Node.js</strong>，在‎<a href="https://hexo.io/docs/commands#init">‎初始化‎</a>‎博客时，您可能需要手动运行在目标文件夹中。‎<code>npm install</code></p>
</blockquote>
<h4 id="1-1-3-安装-Git"><a href="#1-1-3-安装-Git" class="headerlink" title="1.1.3 安装 Git"></a>1.1.3 安装 Git</h4><ul>
<li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>.</li>
<li>Mac：使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li>
<li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li>
<li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li>
</ul>
<blockquote>
<p><strong>Mac 用户</strong></p>
<p>如果在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> 安装命令行工具。</p>
</blockquote>
<blockquote>
<p><strong>Windows 用户</strong></p>
<p>前往 <a href="https://npm.taobao.org/mirrors/git-for-windows/">淘宝 Git for Windows 镜像</a> 下载 git 安装包。</p>
</blockquote>
<h4 id="1-1-4-安装-Hexo"><a href="#1-1-4-安装-Hexo" class="headerlink" title="1.1.4 安装 Hexo"></a>1.1.4 安装 Hexo</h4><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h4 id="1-1-5-进阶安装和使用"><a href="#1-1-5-进阶安装和使用" class="headerlink" title="1.1.5 进阶安装和使用"></a>1.1.5 进阶安装和使用</h4><p>对于熟悉 npm 的进阶用户，可以仅局部安装 <code>hexo</code> 包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo</span><br></pre></td></tr></table></figure>

<p>安装以后，可以使用以下两种方式执行 Hexo：</p>
<ol>
<li><p><code>npx hexo &lt;command&gt;</code></p>
</li>
<li><p>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;PATH&#x3D;&quot;$PATH:.&#x2F;node_modules&#x2F;.bin&quot;&#39; &gt;&gt; ~&#x2F;.profile</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="1-1-6-Node-js-版本限制"><a href="#1-1-6-Node-js-版本限制" class="headerlink" title="1.1.6 Node.js 版本限制"></a>1.1.6 Node.js 版本限制</h4><p>我们强烈建议永远安装最新版本的 Hexo，以及 <a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85%E5%89%8D%E6%8F%90">推荐的 Node.js 版本</a>。</p>
<table>
<thead>
<tr>
<th align="left">Hexo 版本</th>
<th align="center">最低兼容 Node.js 版本</th>
</tr>
</thead>
<tbody><tr>
<td align="left">5.0+</td>
<td align="center">10.13.0</td>
</tr>
<tr>
<td align="left">4.1 - 4.2</td>
<td align="center">8.10</td>
</tr>
<tr>
<td align="left">4.0</td>
<td align="center">8.6</td>
</tr>
<tr>
<td align="left">3.3 - 3.9</td>
<td align="center">6.9</td>
</tr>
<tr>
<td align="left">3.2 - 3.3</td>
<td align="center">0.12</td>
</tr>
<tr>
<td align="left">3.0 - 3.1</td>
<td align="center">0.10 or iojs</td>
</tr>
<tr>
<td align="left">0.0.1 - 2.8</td>
<td align="center">0.10</td>
</tr>
</tbody></table>
<h3 id="2-建站"><a href="#2-建站" class="headerlink" title="2 建站"></a>2 建站</h3><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>

<h4 id="2-1-config-yml"><a href="#2-1-config-yml" class="headerlink" title="2.1 _config.yml"></a>2.1 _config.yml</h4><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p>
<h4 id="2-2-package-json"><a href="#2-2-package-json" class="headerlink" title="2.2 package.json"></a>2.2 package.json</h4><p>应用程序的信息。<a href="https://ejs.co/">EJS</a>, <a href="http://learnboost.github.io/stylus/">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/">Markdown</a> renderer 已默认安装，您可以自由移除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package.json&#123;</span><br><span class="line">  &quot;name&quot;: &quot;hexo-site&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;hexo&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;hexo&quot;: &quot;^3.8.0&quot;,</span><br><span class="line">    &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;,</span><br><span class="line">    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,</span><br><span class="line">    &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;,</span><br><span class="line">    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,</span><br><span class="line">    &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;,</span><br><span class="line">    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;,</span><br><span class="line">    &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;,</span><br><span class="line">    &quot;hexo-server&quot;: &quot;^0.3.3&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-scaffolds"><a href="#2-3-scaffolds" class="headerlink" title="2.3 scaffolds"></a>2.3 scaffolds</h4><p><a href="https://hexo.io/zh-cn/docs/writing">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>
<p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>
<h4 id="2-4-source"><a href="#2-4-source" class="headerlink" title="2.4 source"></a>2.4 source</h4><p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p>
<h4 id="2-5-themes"><a href="#2-5-themes" class="headerlink" title="2.5 themes"></a>2.5 themes</h4><p><a href="https://hexo.io/zh-cn/docs/themes">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p>
<h3 id="3-配置"><a href="#3-配置" class="headerlink" title="3 配置"></a>3 配置</h3><p>您可以在 <code>_config.yml</code> 中修改大部分的配置。</p>
<h4 id="3-1-网站"><a href="#3-1-网站" class="headerlink" title="3.1 网站"></a>3.1 网站</h4><hr>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>title</code></td>
<td align="left">网站标题</td>
</tr>
<tr>
<td align="left"><code>subtitle</code></td>
<td align="left">网站副标题</td>
</tr>
<tr>
<td align="left"><code>description</code></td>
<td align="left">网站描述</td>
</tr>
<tr>
<td align="left"><code>keywords</code></td>
<td align="left">网站的关键词。支持多个关键词。</td>
</tr>
<tr>
<td align="left"><code>author</code></td>
<td align="left">您的名字</td>
</tr>
<tr>
<td align="left"><code>language</code></td>
<td align="left">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td>
</tr>
<tr>
<td align="left"><code>timezone</code></td>
<td align="left">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td>
</tr>
</tbody></table>
<p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p>
<h4 id="3-2-网址"><a href="#3-2-网址" class="headerlink" title="3.2 网址"></a>3.2 网址</h4><hr>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>url</code></td>
<td align="left">网址, must starts with <code>http://</code> or <code>https://</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>root</code></td>
<td align="left">网站根目录</td>
<td align="left"><code>url&#39;s pathname</code></td>
</tr>
<tr>
<td align="left"><code>permalink</code></td>
<td align="left">文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式</td>
<td align="left"><code>:year/:month/:day/:title/</code></td>
</tr>
<tr>
<td align="left"><code>permalink_defaults</code></td>
<td align="left">永久链接中各部分的默认值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>pretty_urls</code></td>
<td align="left">改写 <a href="https://hexo.io/zh-cn/docs/variables"><code>permalink</code></a> 的值来美化 URL</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>pretty_urls.trailing_index</code></td>
<td align="left">是否在永久链接中保留尾部的 <code>index.html</code>，设置为 <code>false</code> 时去除</td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left"><code>pretty_urls.trailing_html</code></td>
<td align="left">是否在永久链接中保留尾部的 <code>.html</code>, 设置为 <code>false</code> 时去除 (<em>对尾部的 <code>index.html</code>无效</em>)</td>
<td align="left"><code>true</code></td>
</tr>
</tbody></table>
<blockquote>
<p>网站存放在子目录</p>
<p>如果您的网站存放在子目录中，例如 <code>http://example.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://example.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 比如，一个页面的永久链接是 http:&#x2F;&#x2F;example.com&#x2F;foo&#x2F;bar&#x2F;index.html</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: false</span><br><span class="line"># 此时页面的永久链接会变为 http:&#x2F;&#x2F;example.com&#x2F;foo&#x2F;bar&#x2F;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-目录"><a href="#3-3-目录" class="headerlink" title="3.3 目录"></a>3.3 目录</h4><hr>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>source_dir</code></td>
<td align="left">资源文件夹，这个文件夹用来存放内容。</td>
<td align="left"><code>source</code></td>
</tr>
<tr>
<td align="left"><code>public_dir</code></td>
<td align="left">公共文件夹，这个文件夹用于存放生成的站点文件。</td>
<td align="left"><code>public</code></td>
</tr>
<tr>
<td align="left"><code>tag_dir</code></td>
<td align="left">标签文件夹</td>
<td align="left"><code>tags</code></td>
</tr>
<tr>
<td align="left"><code>archive_dir</code></td>
<td align="left">归档文件夹</td>
<td align="left"><code>archives</code></td>
</tr>
<tr>
<td align="left"><code>category_dir</code></td>
<td align="left">分类文件夹</td>
<td align="left"><code>categories</code></td>
</tr>
<tr>
<td align="left"><code>code_dir</code></td>
<td align="left">Include code 文件夹，<code>source_dir</code> 下的子目录</td>
<td align="left"><code>downloads/code</code></td>
</tr>
<tr>
<td align="left"><code>i18n_dir</code></td>
<td align="left">国际化（i18n）文件夹</td>
<td align="left"><code>:lang</code></td>
</tr>
<tr>
<td align="left"><code>skip_render</code></td>
<td align="left">跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 <code>public</code> 目录中。您可使用 <a href="https://github.com/micromatch/micromatch#extended-globbing">glob 表达式</a>来匹配路径。</td>
<td align="left"></td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">skip_render: &quot;mypage&#x2F;**&#x2F;*&quot;</span><br><span class="line"># 将会直接将 &#96;source&#x2F;mypage&#x2F;index.html&#96; 和 &#96;source&#x2F;mypage&#x2F;code.js&#96; 不做改动地输出到 &#39;public&#39; 目录</span><br><span class="line"># 你也可以用这种方法来跳过对指定文章文件的渲染</span><br><span class="line">skip_render: &quot;_posts&#x2F;test-post.md&quot;</span><br><span class="line"># 这将会忽略对 &#39;test-post.md&#39; 的渲染</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示</p>
<p>如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p>
</blockquote>
<h4 id="3-4-文章"><a href="#3-4-文章" class="headerlink" title="3.4 文章"></a>3.4 文章</h4><hr>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>new_post_name</code></td>
<td align="left">新文章的文件名称</td>
<td align="left">:title.md</td>
</tr>
<tr>
<td align="left"><code>default_layout</code></td>
<td align="left">预设布局</td>
<td align="left">post</td>
</tr>
<tr>
<td align="left"><code>auto_spacing</code></td>
<td align="left">在中文和英文之间加入空格</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><code>titlecase</code></td>
<td align="left">把标题转换为 title case</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><code>external_link</code></td>
<td align="left">在新标签中打开链接</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><code>external_link.enable</code></td>
<td align="left">在新标签中打开链接</td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left"><code>external_link.field</code></td>
<td align="left">对整个网站（<code>site</code>）生效或仅对文章（<code>post</code>）生效</td>
<td align="left"><code>site</code></td>
</tr>
<tr>
<td align="left"><code>external_link.exclude</code></td>
<td align="left">需要排除的域名。主域名和子域名如 <code>www</code> 需分别配置</td>
<td align="left"><code>[]</code></td>
</tr>
<tr>
<td align="left"><code>filename_case</code></td>
<td align="left">把文件名称转换为 (1) 小写或 (2) 大写</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left"><code>render_drafts</code></td>
<td align="left">显示草稿</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><code>post_asset_folder</code></td>
<td align="left">启动 <a href="https://hexo.io/zh-cn/docs/asset-folders">Asset 文件夹</a></td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><code>relative_link</code></td>
<td align="left">把链接改为与根目录的相对位址</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left"><code>future</code></td>
<td align="left">显示未来的文章</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><code>highlight</code></td>
<td align="left">代码块的设置, see <a href="https://hexo.io/docs/syntax-highlight#Highlight-js">Highlight.js</a> section for usage guide</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>prismjs</code></td>
<td align="left">代码块的设置, see <a href="https://hexo.io/docs/syntax-highlight#PrismJS">PrismJS</a> section for usage guide</td>
<td align="left"></td>
</tr>
</tbody></table>
<blockquote>
<p>相对地址</p>
<p>默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 <code>example.com</code>,您有一篇文章名为 <code>hello</code>，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是<strong>绝对</strong>于域名的。相对链接像这样：<code>/hello.html</code>，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p>
</blockquote>
<h4 id="3-5-分类-amp-标签"><a href="#3-5-分类-amp-标签" class="headerlink" title="3.5 分类 &amp; 标签"></a>3.5 分类 &amp; 标签</h4><hr>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>default_category</code></td>
<td align="left">默认分类</td>
<td align="left"><code>uncategorized</code></td>
</tr>
<tr>
<td align="left"><code>category_map</code></td>
<td align="left">分类别名</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>tag_map</code></td>
<td align="left">标签别名</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="3-6-日期-时间格式"><a href="#3-6-日期-时间格式" class="headerlink" title="3.6 日期 / 时间格式"></a>3.6 日期 / 时间格式</h4><hr>
<p>Hexo 使用 <a href="http://momentjs.com/">Moment.js</a> 来解析和显示时间。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>date_format</code></td>
<td align="left">日期格式</td>
<td align="left"><code>YYYY-MM-DD</code></td>
</tr>
<tr>
<td align="left"><code>time_format</code></td>
<td align="left">时间格式</td>
<td align="left"><code>HH:mm:ss</code></td>
</tr>
<tr>
<td align="left"><code>updated_option</code></td>
<td align="left">当 Front Matter 中没有指定 <a href="https://hexo.io/zh-cn/docs/variables#%E9%A1%B5%E9%9D%A2%E5%8F%98%E9%87%8F"><code>updated</code></a> 时 <code>updated</code> 的取值</td>
<td align="left"><code>mtime</code></td>
</tr>
</tbody></table>
<blockquote>
<p>updated_option</p>
<p><code>updated_option</code> 控制了当 Front Matter 中没有指定 <code>updated</code> 时，<code>updated</code> 如何取值：</p>
<ul>
<li><code>mtime</code>: 使用文件的最后修改时间。这是从 Hexo 3.0.0 开始的默认行为。</li>
<li><code>date</code>: 使用 <code>date</code> 作为 <code>updated</code> 的值。可被用于 Git 工作流之中，因为使用 Git 管理站点时，文件的最后修改日期常常会发生改变</li>
<li><code>empty</code>: 直接删除 <code>updated</code>。使用这一选项可能会导致大部分主题和插件无法正常工作。</li>
</ul>
<p><code>use_date_for_updated</code> 选项已经被废弃，将会在下个重大版本发布时去除。请改为使用 <code>updated_option: &#39;date&#39;</code>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use_date_for_updated&#96; | 启用以后，如果 Front Matter 中没有指定 &#96;updated&#96;， [&#96;post.updated&#96;](https:&#x2F;&#x2F;hexo.io&#x2F;zh-cn&#x2F;docs&#x2F;configuration) 将会使用 &#96;date&#96; 的值而不是文件的创建时间。在 Git 工作流中这个选项会很有用 | &#96;true</span><br></pre></td></tr></table></figure>

<h4 id="3-7-分页"><a href="#3-7-分页" class="headerlink" title="3.7 分页"></a>3.7 分页</h4><hr>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>per_page</code></td>
<td align="left">每页显示的文章量 (0 = 关闭分页功能)</td>
<td align="left"><code>10</code></td>
</tr>
<tr>
<td align="left"><code>pagination_dir</code></td>
<td align="left">分页目录</td>
<td align="left"><code>page</code></td>
</tr>
</tbody></table>
<h4 id="3-8-扩展"><a href="#3-8-扩展" class="headerlink" title="3.8 扩展"></a>3.8 扩展</h4><hr>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>theme</code></td>
<td align="left">当前主题名称。值为<code>false</code>时禁用主题</td>
</tr>
<tr>
<td align="left"><code>theme_config</code></td>
<td align="left">主题的配置文件。在这里放置的配置会覆盖主题目录下的 <code>_config.yml</code> 中的配置</td>
</tr>
<tr>
<td align="left"><code>deploy</code></td>
<td align="left">部署部分的设置</td>
</tr>
<tr>
<td align="left"><code>meta_generator</code></td>
<td align="left"><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#%E5%B1%9E%E6%80%A7">Meta generator</a> 标签。 值为 <code>false</code> 时 Hexo 不会在头部插入该标签</td>
</tr>
</tbody></table>
<h4 id="3-9-包括或不包括目录和文件"><a href="#3-9-包括或不包括目录和文件" class="headerlink" title="3.9 包括或不包括目录和文件"></a>3.9 包括或不包括目录和文件</h4><hr>
<p>在 Hexo 配置文件中，通过设置 include/exclude 可以让 Hexo 进行处理或忽略某些目录和文件夹。你可以使用 <a href="https://github.com/isaacs/minimatch">glob 表达式</a> 对目录和文件进行匹配。</p>
<p><code>include</code> and <code>exclude</code> options only apply to the <code>source/</code> folder, whereas <code>ignore</code> option applies to all folders.</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>include</code></td>
<td align="left">Hexo 默认会忽略隐藏文件和文件夹（包括名称以下划线和 <code>.</code> 开头的文件和文件夹，Hexo 的 <code>_posts</code> 和 <code>_data</code> 等目录除外）。通过设置此字段将使 Hexo 处理他们并将它们复制到 <code>source</code> 目录下。</td>
</tr>
<tr>
<td align="left"><code>exclude</code></td>
<td align="left">Hexo 会忽略这些文件和目录</td>
</tr>
<tr>
<td align="left"><code>ignore</code></td>
<td align="left">Ignore files/folders</td>
</tr>
</tbody></table>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Include&#x2F;Exclude Files&#x2F;Folders</span><br><span class="line">include:</span><br><span class="line">  - &quot;.nojekyll&quot;</span><br><span class="line">  # 包括 &#39;source&#x2F;css&#x2F;_typing.css&#39;</span><br><span class="line">  - &quot;css&#x2F;_typing.css&quot;</span><br><span class="line">  # 包括 &#39;source&#x2F;_css&#x2F;&#39; 中的任何文件，但不包括子目录及其其中的文件。</span><br><span class="line">  - &quot;_css&#x2F;*&quot;</span><br><span class="line">  # 包含 &#39;source&#x2F;_css&#x2F;&#39; 中的任何文件和子目录下的任何文件</span><br><span class="line">  - &quot;_css&#x2F;**&#x2F;*&quot;</span><br><span class="line"></span><br><span class="line">exclude:</span><br><span class="line">  # 不包括 &#39;source&#x2F;js&#x2F;test.js&#39;</span><br><span class="line">  - &quot;js&#x2F;test.js&quot;</span><br><span class="line">  # 不包括 &#39;source&#x2F;js&#x2F;&#39; 中的文件、但包括子目录下的所有目录和文件</span><br><span class="line">  - &quot;js&#x2F;*&quot;</span><br><span class="line">  # 不包括 &#39;source&#x2F;js&#x2F;&#39; 中的文件和子目录下的任何文件</span><br><span class="line">  - &quot;js&#x2F;**&#x2F;*&quot;</span><br><span class="line">  # 不包括 &#39;source&#x2F;js&#x2F;&#39; 目录下的所有文件名以 &#39;test&#39; 开头的文件，但包括其它文件和子目录下的单文件</span><br><span class="line">  - &quot;js&#x2F;test*&quot;</span><br><span class="line">  # 不包括 &#39;source&#x2F;js&#x2F;&#39; 及其子目录中任何以 &#39;test&#39; 开头的文件</span><br><span class="line">  - &quot;js&#x2F;**&#x2F;test*&quot;</span><br><span class="line">  # 不要用 exclude 来忽略 &#39;source&#x2F;_posts&#x2F;&#39; 中的文件。你应该使用 &#39;skip_render&#39;，或者在要忽略的文件的文件名之前加一个下划线 &#39;_&#39;</span><br><span class="line">  # 在这里配置一个 - &quot;_posts&#x2F;hello-world.md&quot; 是没有用的。</span><br><span class="line"></span><br><span class="line">ignore:</span><br><span class="line">  # Ignore any folder named &#39;foo&#39;.</span><br><span class="line">  - &quot;**&#x2F;foo&quot;</span><br><span class="line">  # Ignore &#39;foo&#39; folder in &#39;themes&#x2F;&#39; only.</span><br><span class="line">  - &quot;**&#x2F;themes&#x2F;*&#x2F;foo&quot;</span><br><span class="line">  # Same as above, but applies to every subfolders of &#39;themes&#x2F;&#39;.</span><br><span class="line">  - &quot;**&#x2F;themes&#x2F;**&#x2F;foo&quot;</span><br></pre></td></tr></table></figure>

<p>列表中的每一项都必须用单引号或双引号包裹起来。</p>
<p><code>include</code> 和 <code>exclude</code> 并不适用于 <code>themes/</code> 目录下的文件。如果需要忽略 <code>themes/</code> 目录下的部分文件或文件夹，可以使用 <code>ignore</code> 或在文件名之前添加下划线 <code>_</code>。</p>
<h4 id="3-10-使用代替配置文件"><a href="#3-10-使用代替配置文件" class="headerlink" title="3.10 使用代替配置文件"></a>3.10 使用代替配置文件</h4><hr>
<p>可以在 hexo-cli 中使用 <code>--config</code> 参数来指定自定义配置文件的路径。你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># use &#39;custom.yml&#39; in place of &#39;_config.yml&#39;</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># use &#39;custom.yml&#39; &amp; &#39;custom2.json&#39;, prioritizing &#39;custom3.yml&#39;, then &#39;custom2.json&#39;</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>

<p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p>
<p>例如，使用 <code>--options</code> 指定了两个自定义配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate --config custom.yml,custom2.json</span><br></pre></td></tr></table></figure>

<p>如果 <code>custom.yml</code> 中指定了 <code>foo: bar</code>，在 custom2.json 中指定了 <code>&quot;foo&quot;: &quot;dinosaur&quot;</code>，那么在 <code>_multiconfig.yml</code> 中你会得到 <code>foo: dinosaur</code>。</p>
<h4 id="3-11-使用代替主题配置文件"><a href="#3-11-使用代替主题配置文件" class="headerlink" title="3.11 使用代替主题配置文件"></a>3.11 使用代替主题配置文件</h4><hr>
<p>通常情况下，Hexo 主题是一个独立的项目，并拥有一个独立的 <code>_config.yml</code> 配置文件。</p>
<p>除了自行维护独立的主题配置文件，你也可以在其它地方对主题进行配置。</p>
<p><strong>配置文件中的 <code>theme_config</code></strong></p>
<blockquote>
<p>该特性自 Hexo 2.8.2 起提供</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># _config.yml</span><br><span class="line">theme: &quot;my-theme&quot;</span><br><span class="line">theme_config:</span><br><span class="line">  bio: &quot;My awesome bio&quot;</span><br><span class="line">  foo:</span><br><span class="line">    bar: &#39;a&#39;</span><br><span class="line"># themes&#x2F;my-theme&#x2F;_config.yml</span><br><span class="line">bio: &quot;Some generic bio&quot;</span><br><span class="line">logo: &quot;a-cool-image.png&quot;</span><br><span class="line">  foo:</span><br><span class="line">    baz: &#39;b&#39;</span><br></pre></td></tr></table></figure>

<p>最终主题配置的输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  bio: &quot;My awesome bio&quot;,</span><br><span class="line">  logo: &quot;a-cool-image.png&quot;,</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: &quot;a&quot;,</span><br><span class="line">    baz: &quot;b&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>独立的 <code>_config.[theme].yml</code> 文件</strong></p>
<blockquote>
<p>该特性自 Hexo 5.0.0 起提供</p>
</blockquote>
<p>独立的主题配置文件应放置于站点根目录下，支持 <code>yml</code> 或 <code>json</code> 格式。需要配置站点 <code>_config.yml</code> 文件中的 <code>theme</code> 以供 Hexo 寻找 <code>_config.[theme].yml</code> 文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># _config.yml</span><br><span class="line">theme: &quot;my-theme&quot;</span><br><span class="line"># _config.my-theme.yml</span><br><span class="line">bio: &quot;My awesome bio&quot;</span><br><span class="line">foo:</span><br><span class="line">  bar: &#39;a&#39;</span><br><span class="line"># themes&#x2F;my-theme&#x2F;_config.yml</span><br><span class="line">bio: &quot;Some generic bio&quot;</span><br><span class="line">logo: &quot;a-cool-image.png&quot;</span><br><span class="line">  foo:</span><br><span class="line">    baz: &#39;b&#39;</span><br></pre></td></tr></table></figure>

<p>最终主题配置的输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  bio: &quot;My awesome bio&quot;,</span><br><span class="line">  logo: &quot;a-cool-image.png&quot;,</span><br><span class="line">  foo: &#123;</span><br><span class="line">    bar: &quot;a&quot;,</span><br><span class="line">    baz: &quot;b&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议将所有的主题配置集中在一处。如果不得不在多处配置你的主题，注意以下信息：Hexo 在合并主题配置时，Hexo 配置文件中的 <code>theme_config</code> 的优先级最高，其次是 <code>_config.[theme].yml</code> 文件，最后是位于主题目录下的 <code>_config.yml</code> 文件。</p>
</blockquote>
<h3 id="4-指令"><a href="#4-指令" class="headerlink" title="4 指令"></a>4 指令</h3><h4 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure>

<p>新建一个网站。 如果没有设置 ，Hexo 默认在目前的文件夹建立网站。<code>folder</code></p>
<p>此命令是运行以下步骤的快捷方式：</p>
<ol>
<li>Git 克隆<a href="https://github.com/hexojs/hexo-starter">hexo 启动器</a>，包括<a href="https://github.com/hexojs/hexo-theme-landscape">hexo 主题</a>到当前目录或目标文件夹（如果指定）。</li>
<li>使用包管理器安装依赖项：<a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>、pnpm 或<a href="https://docs.npmjs.com/cli/install">npm，</a>以安装者为准： 如果安装了多个，则优先级将列出。默认情况下npm与Node.js捆绑。</li>
</ol>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo list &lt;type&gt;</span><br></pre></td></tr></table></figure>

<p>列出网站资料。</p>
<h4 id="version"><a href="#version" class="headerlink" title="version"></a>version</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo version</span><br></pre></td></tr></table></figure>

<p>显示 Hexo 版本。</p>
<h4 id="4-1-新增功能"><a href="#4-1-新增功能" class="headerlink" title="4.1 新增功能"></a>4.1 新增功能</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>新建一篇文章。 如果没有设置 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 参数代替。 如果标题包含空格的话，请使用引号括起来。<code>layout``default_layout</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>,<code>--path</code></td>
<td align="left">自定义新文章的路径</td>
</tr>
<tr>
<td align="left"><code>-r</code>,<code>--replace</code></td>
<td align="left">如果存在同名文章，将其替换</td>
</tr>
<tr>
<td align="left"><code>-s</code>,<code>--slug</code></td>
<td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td>
</tr>
</tbody></table>
<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。 对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 文件。 你可以使用 参数来覆盖上述行为、自行决定文件的目录：<code>index.md``--path</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me &quot;About me&quot;</span><br></pre></td></tr></table></figure>

<p>以上命令会创建一个 文件，同时 Front Matter 中的 title 为 <code>source/about/me.md``&quot;About me&quot;</code></p>
<p>注意！ title 是必须指定的！ 如果你这么做并不能达到你的目的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me</span><br></pre></td></tr></table></figure>

<p>此时 Hexo 会创建 ，同时 的 Front Matter 中的 title 为 。 这是因为在上述命令中，hexo-cli 将 视为指定文章的标题、并采用默认的 。<code>source/_posts/about/me.md``me.md``&quot;page&quot;``page``layout</code></p>
<h4 id="4-2-生成"><a href="#4-2-生成" class="headerlink" title="4.2 生成"></a>4.2 生成</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>生成静态文件。</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-d</code>,<code>--deploy</code></td>
<td align="left">文件生成后立即部署网站</td>
</tr>
<tr>
<td align="left"><code>-w</code>,<code>--watch</code></td>
<td align="left">监视文件变动</td>
</tr>
<tr>
<td align="left"><code>-b</code>,<code>--bail</code></td>
<td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td>
</tr>
<tr>
<td align="left"><code>-f</code>,<code>--force</code></td>
<td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 目录存在，那么 只会重新生成改动的文件。 使用该参数的效果接近 <code>public``hexo g``hexo clean &amp;&amp; hexo generate</code></td>
</tr>
<tr>
<td align="left"><code>-c</code>,<code>--concurrency</code></td>
<td align="left">最大同时生成文件的数量，默认无限制</td>
</tr>
</tbody></table>
<p>该命令可以简写为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<h4 id="4-3-发布"><a href="#4-3-发布" class="headerlink" title="4.3 发布"></a>4.3 发布</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>

<p>发表草稿。</p>
<h4 id="4-4-服务器"><a href="#4-4-服务器" class="headerlink" title="4.4 服务器"></a>4.4 服务器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>启动服务器。 默认情况下，访问网址为： 。<code>http://localhost:4000/</code></p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>,<code>--port</code></td>
<td align="left">重设端口</td>
</tr>
<tr>
<td align="left"><code>-s</code>,<code>--static</code></td>
<td align="left">只使用静态文件</td>
</tr>
<tr>
<td align="left"><code>-l</code>,<code>--log</code></td>
<td align="left">启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody></table>
<h4 id="4-5-部署"><a href="#4-5-部署" class="headerlink" title="4.5 部署"></a>4.5 部署</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>部署网站。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-g</code>,<code>--generate</code></td>
<td align="left">部署之前预先生成静态文件</td>
</tr>
</tbody></table>
<p>该命令可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>

<h4 id="4-6-呈现"><a href="#4-6-呈现" class="headerlink" title="4.6 呈现"></a>4.6 呈现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>

<p>渲染文件。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-o</code>,<code>--output</code></td>
<td align="left">设置输出路径</td>
</tr>
</tbody></table>
<h4 id="4-7-迁移"><a href="#4-7-迁移" class="headerlink" title="4.7 迁移"></a>4.7 迁移</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure>

<p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p>
<h4 id="4-8-清理"><a href="#4-8-清理" class="headerlink" title="4.8 清理"></a>4.8 清理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>

<p>清除缓存文件 () 和已生成的静态文件 ()。<code>db.json``public</code></p>
<p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<h4 id="4-9-选项"><a href="#4-9-选项" class="headerlink" title="4.9 选项"></a>4.9 选项</h4><h5 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --safe</span><br></pre></td></tr></table></figure>

<p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>
<h5 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --debug</span><br></pre></td></tr></table></figure>

<p>在终端中显示调试信息并记录到 。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new">提交调试信息到 GitHub</a>。<code>debug.log</code></p>
<h5 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --silent</span><br></pre></td></tr></table></figure>

<p>隐藏终端信息。</p>
<h5 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>

<p>自定义配置文件的路径，指定这个参数后将不再使用默认的 。<br>你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。 例如：<code>_config.yml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用 custom.yml 代替默认的 _config.yml</span><br><span class="line">$ hexo server --config custom.yml</span><br><span class="line"></span><br><span class="line"># 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json</span><br><span class="line">$ hexo generate --config custom.yml,custom2.json,custom3.yml</span><br></pre></td></tr></table></figure>

<p>当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 。 如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。 这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。<code>_multiconfig.yml</code></p>
<h5 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --draft</span><br></pre></td></tr></table></figure>

<p>显示 文件夹中的草稿文章。<code>source/_drafts</code></p>
<h5 id="自定义-CWD"><a href="#自定义-CWD" class="headerlink" title="自定义 CWD"></a>自定义 CWD</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo --cwd &#x2F;path&#x2F;to&#x2F;cwd</span><br></pre></td></tr></table></figure>

<p>自定义当前工作目录（Current working directory）的路径。</p>
<h3 id="5-迁移"><a href="#5-迁移" class="headerlink" title="5 迁移"></a>5 迁移</h3><h4 id="5-1-RSS"><a href="#5-1-RSS" class="headerlink" title="5.1 RSS"></a>5.1 RSS</h4><p>首先，安装 <code>hexo-migrator-rss</code> 插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-migrator-rss --save</span><br></pre></td></tr></table></figure>

<p>插件安装完成后，执行下列命令，从 RSS 迁移所有文章。<code>source</code> 可以是文件路径或网址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo migrate rss &lt;source&gt;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-Jekyll"><a href="#5-2-Jekyll" class="headerlink" title="5.2 Jekyll"></a>5.2 Jekyll</h4><p>把 <code>_posts</code> 文件夹内的所有文件复制到 <code>source/_posts</code> 文件夹，并在 <code>_config.yml</code> 中修改 <code>new_post_name</code> 参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure>

<h4 id="5-3-Octopress"><a href="#5-3-Octopress" class="headerlink" title="5.3 Octopress"></a>5.3 Octopress</h4><p>把 Octopress <code>source/_posts</code> 文件夹内的所有文件转移到 Hexo 的 <code>source/_posts</code> 文件夹，并修改 <code>_config.yml</code> 中的 <code>new_post_name</code> 参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure>

<h4 id="5-4-WordPress"><a href="#5-4-WordPress" class="headerlink" title="5.4 WordPress"></a>5.4 WordPress</h4><p>首先，安装 <code>hexo-migrator-wordpress</code> 插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-migrator-wordpress --save</span><br></pre></td></tr></table></figure>

<p>在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)（详情参考<a href="http://en.support.wordpress.com/export/">WP支持页面</a>）。</p>
<p>插件安装完成后，执行下列命令来迁移所有文章。<code>source</code> 可以是 WordPress 导出的文件路径或网址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo migrate wordpress &lt;source&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意</p>
<p>这个插件并不能完美地实现WordPress-&gt;Hexo的数据转换，尤其是在处理WordPress的分类方面存在问题（见<a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter中的分类与标签</a>）。因此，建议您在迁移完成后，手工审阅所有生成的markdown文件，检查其中是否有错误。对于文章数量较大的WordPress站点，这项工作可能要花很长的时间。</p>
</blockquote>
<h4 id="5-5-Joomla"><a href="#5-5-Joomla" class="headerlink" title="5.5 Joomla"></a>5.5 Joomla</h4><p>首先，安装 <code>hexo-migrator-joomla</code> 插件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-migrator-joomla --save</span><br></pre></td></tr></table></figure>

<p>使用 <a href="http://extensions.joomla.org/extensions/migration-a-conversion/data-import-a-export/12816?qh=YToxOntpOjA7czo1OiJqMnhtbCI7fQ==">J2XML</a> 组件导出 Joomla 文章。<br>插件安装完成后，执行下列命令来迁移所有文章。<code>source</code> 可以是 Joomla 导出的文件路径或网址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo migrate joomla &lt;source&gt;</span><br></pre></td></tr></table></figure>

<h3 id="6-写作"><a href="#6-写作" class="headerlink" title="6 写作"></a>6 写作</h3><p>你可以执行下列命令来创建一篇新文章或者新的页面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p>
<h4 id="6-1-布局（Layout）"><a href="#6-1-布局（Layout）" class="headerlink" title="6.1 布局（Layout）"></a>6.1 布局（Layout）</h4><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p>
<table>
<thead>
<tr>
<th align="left">布局</th>
<th align="left">路径</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>post</code></td>
<td align="left"><code>source/_posts</code></td>
</tr>
<tr>
<td align="left"><code>page</code></td>
<td align="left"><code>source</code></td>
</tr>
<tr>
<td align="left"><code>draft</code></td>
<td align="left"><code>source/_drafts</code></td>
</tr>
</tbody></table>
<blockquote>
<p>Disabling layout</p>
<p>If you don’t want an article (post/page) to be processed with a theme, set <code>layout: false</code> in its front-matter. Refer to <a href="https://hexo.io/zh-cn/docs/front-matter#%E5%B8%83%E5%B1%80">this section</a> for more details.</p>
</blockquote>
<h4 id="6-2-文件名称"><a href="#6-2-文件名称" class="headerlink" title="6.2 文件名称"></a>6.2 文件名称</h4><p>Hexo 默认以标题做为文件名称，但您可编辑 <code>new_post_name</code> 参数来改变默认的文件名称，举例来说，设为 <code>:year-:month-:day-:title.md</code> 可让您更方便的通过日期来管理文章。</p>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>:title</code></td>
<td align="left">标题（小写，空格将会被替换为短杠）</td>
</tr>
<tr>
<td align="left"><code>:year</code></td>
<td align="left">建立的年份，比如， <code>2015</code></td>
</tr>
<tr>
<td align="left"><code>:month</code></td>
<td align="left">建立的月份（有前导零），比如， <code>04</code></td>
</tr>
<tr>
<td align="left"><code>:i_month</code></td>
<td align="left">建立的月份（无前导零），比如， <code>4</code></td>
</tr>
<tr>
<td align="left"><code>:day</code></td>
<td align="left">建立的日期（有前导零），比如， <code>07</code></td>
</tr>
<tr>
<td align="left"><code>:i_day</code></td>
<td align="left">建立的日期（无前导零），比如， <code>7</code></td>
</tr>
</tbody></table>
<h4 id="6-3-草稿"><a href="#6-3-草稿" class="headerlink" title="6.3 草稿"></a>6.3 草稿</h4><p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p>
<h4 id="6-4-模版（Scaffold）"><a href="#6-4-模版（Scaffold）" class="headerlink" title="6.4 模版（Scaffold）"></a>6.4 模版（Scaffold）</h4><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new photo &quot;My Gallery&quot;</span><br></pre></td></tr></table></figure>

<p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>layout</code></td>
<td align="left">布局</td>
</tr>
<tr>
<td align="left"><code>title</code></td>
<td align="left">标题</td>
</tr>
<tr>
<td align="left"><code>date</code></td>
<td align="left">文件建立日期</td>
</tr>
</tbody></table>
<h4 id="6-5-支持的格式"><a href="#6-5-支持的格式" class="headerlink" title="6.5 支持的格式"></a>6.5 支持的格式</h4><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p>
<p>例如，Hexo 默认安装了 <code>hexo-renderer-marked</code> 和 <code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 <code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p>
<p>只需要将文章的扩展名从 <code>md</code> 改成 <code>ejs</code>，Hexo 就会使用 <code>hexo-renderer-ejs</code> 渲染这个文件，其他格式同理。</p>
<h3 id="7-Front-matter"><a href="#7-Front-matter" class="headerlink" title="7 Front-matter"></a>7 Front-matter</h3><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2013&#x2F;7&#x2F;13 20:46:25</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>layout</code></td>
<td align="left">布局</td>
<td align="left"><a href="https://hexo.io/zh-cn/docs/configuration#%E6%96%87%E7%AB%A0"><code>config.default_layout</code></a></td>
</tr>
<tr>
<td align="left"><code>title</code></td>
<td align="left">标题</td>
<td align="left">文章的文件名</td>
</tr>
<tr>
<td align="left"><code>date</code></td>
<td align="left">建立日期</td>
<td align="left">文件建立日期</td>
</tr>
<tr>
<td align="left"><code>updated</code></td>
<td align="left">更新日期</td>
<td align="left">文件更新日期</td>
</tr>
<tr>
<td align="left"><code>comments</code></td>
<td align="left">开启文章的评论功能</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left"><code>tags</code></td>
<td align="left">标签（不适用于分页）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>categories</code></td>
<td align="left">分类（不适用于分页）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>permalink</code></td>
<td align="left">覆盖文章网址</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>excerpt</code></td>
<td align="left">Page excerpt in plain text. Use <a href="https://hexo.io/docs/tag-plugins#Post-Excerpt">this plugin</a> to format the text</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>disableNunjucks</code></td>
<td align="left">Disable rendering of Nunjucks tag <code>&#123;&#123; &#125;&#125;</code>/<code>&#123;% %&#125;</code> and <a href="https://hexo.io/docs/tag-plugins">tag plugins</a> when enabled</td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="7-1-布局"><a href="#7-1-布局" class="headerlink" title="7.1 布局"></a>7.1 布局</h4><p>‎默认布局是 <code>post</code>, 根据设置在<code>_config.yml</code>里的 <a href="https://hexo.io/zh-cn/docs/(/docs/configuration#Writing)"><code>default_layout</code></a> 的值。当文章中的布局被禁用时 (<code>layout: false</code>),它将不会以主题进行处理。但是，它仍将由任何可用的渲染器呈现：如果一篇文章写在标记和标记渲染器（如默认‎<a href="https://github.com/hexojs/hexo-renderer-marked">‎的 hexo 渲染器标记‎</a>‎）中，它将呈现给 HTML。‎<code>post``_config.yml``layout: false</code></p>
<p>‎无论布局如何，‎<a href="https://hexo.io/docs/tag-plugins">‎标记插件‎</a>‎始终被处理，除非设置或‎<a href="https://hexo.io/api/renderer#Disable-Nunjucks-tags">‎渲染器‎</a>‎禁用。‎<code>disableNunjucks</code></p>
<h4 id="7-2-分类和标签"><a href="#7-2-分类和标签" class="headerlink" title="7.2 分类和标签"></a>7.2 分类和标签</h4><p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- Diary</span><br><span class="line">tags:</span><br><span class="line">- PS3</span><br><span class="line">- Games</span><br></pre></td></tr></table></figure>

<blockquote>
<p>分类方法的分歧</p>
<p>如果您有过使用 WordPress 的经验，就很容易误解 Hexo 的分类方式。WordPress 支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是 Hexo 不支持指定多个同级分类。下面的指定方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">  - Diary</span><br><span class="line">  - Life</span><br></pre></td></tr></table></figure>

<p>会使分类<code>Life</code>成为<code>Diary</code>的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。</p>
<p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure>

<p>此时这篇文章同时包括三个分类： <code>PlayStation</code> 和 <code>Games</code> 分别都是父分类 <code>Diary</code> 的子分类，同时 <code>Life</code> 是一个没有子分类的分类。</p>
</blockquote>
<h4 id="7-3-JSON-Front-matter"><a href="#7-3-JSON-Front-matter" class="headerlink" title="7.3 JSON Front-matter"></a>7.3 JSON Front-matter</h4><p>除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 <code>---</code> 代换成 <code>;;;</code> 即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;title&quot;: &quot;Hello World&quot;,</span><br><span class="line">&quot;date&quot;: &quot;2013&#x2F;7&#x2F;13 20:46:25&quot;</span><br><span class="line">;;;</span><br></pre></td></tr></table></figure>

<h3 id="8-标签插件（Tag-Plugins）"><a href="#8-标签插件（Tag-Plugins）" class="headerlink" title="8 标签插件（Tag Plugins）"></a>8 标签插件（Tag Plugins）</h3><p>标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。</p>
<p>虽然你可以使用任何格式书写你的文章，但是标签插件永远可用，且语法也都是一致的。</p>
<p><em>‎标记插件不应包裹在标记语法中，‎</em>, e.g. <code>[](&#123;% post_path lorem-ipsum %&#125;)</code> 是不被支持的</p>
<h4 id="8-1-引用块"><a href="#8-1-引用块" class="headerlink" title="8.1 引用块"></a>8.1 引用块</h4><p>在文章中插入引言，可包含作者、来源和标题。</p>
<p><strong>别号：</strong> quote</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-样例"><a href="#8-2-样例" class="headerlink" title="8.2 样例"></a>8.2 样例</h4><p><strong>没有提供参数，则只输出普通的 blockquote</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote %&#125;</span><br><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p>
</blockquote>
<p><strong>引用书上的句子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote David Levithan, Wide Awake %&#125;</span><br><span class="line">Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p>
<p><strong>David Levithan</strong>Wide Awake</p>
</blockquote>
<p><strong>引用 Twitter</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote @DevDocs https:&#x2F;&#x2F;twitter.com&#x2F;devdocs&#x2F;status&#x2F;356095192085962752 %&#125;</span><br><span class="line">NEW: DevDocs now comes with syntax highlighting. http:&#x2F;&#x2F;devdocs.io</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io/">http://devdocs.io</a></p>
<p><strong>@DevDocs</strong><a href="https://twitter.com/devdocs/status/356095192085962752">twitter.com/devdocs/status/356095192085962752</a></p>
</blockquote>
<p><strong>引用网络上的文章</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote Seth Godin http:&#x2F;&#x2F;sethgodin.typepad.com&#x2F;seths_blog&#x2F;2009&#x2F;07&#x2F;welcome-to-island-marketing.html Welcome to Island Marketing %&#125;</span><br><span class="line">Every interaction is both precious and an opportunity to delight.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Every interaction is both precious and an opportunity to delight.</p>
<p><strong>Seth Godin</strong><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></p>
</blockquote>
<h4 id="8-3-代码块"><a href="#8-3-代码块" class="headerlink" title="8.3 代码块"></a>8.3 代码块</h4><p>在文章中插入代码。</p>
<p><strong>别名：</strong> code</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock [title] [lang:language] [url] [link text] [additional options] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>

<p>Specify additional options in <code>option:value</code> format, e.g. <code>line_number:false first_line:5</code>.</p>
<table>
<thead>
<tr>
<th align="left">Extra Options</th>
<th align="left">Description</th>
<th align="left">Default</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>line_number</code></td>
<td align="left">Show line number</td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left"><code>highlight</code></td>
<td align="left">Enable code highlighting</td>
<td align="left"><code>true</code></td>
</tr>
<tr>
<td align="left"><code>first_line</code></td>
<td align="left">Specify the first line number</td>
<td align="left"><code>1</code></td>
</tr>
<tr>
<td align="left"><code>mark</code></td>
<td align="left">Line highlight specific line(s), each value separated by a comma. Specify number range using a dash Example: <code>mark:1,4-7,10</code> will mark line 1, 4 to 7 and 10.</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>wrap</code></td>
<td align="left">Wrap the code block in <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table">``</a></td>
<td align="left"><code>true</code></td>
</tr>
</tbody></table>
<h4 id="8-5-样例"><a href="#8-5-样例" class="headerlink" title="8.5 样例"></a>8.5 样例</h4><p><strong>普通的代码块</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock %&#125;</span><br><span class="line">alert(&#39;Hello World!&#39;);</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br><span class="line">alert(&#39;Hello World!&#39;);</span><br></pre></td></tr></table></figure>

<p><strong>指定语言</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock lang:objc %&#125;</span><br><span class="line">[rectangle setX: 10 y: 10 width: 20 height: 20];</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br><span class="line">[rectangle setX: 10 y: 10 width: 20 height: 20];</span><br></pre></td></tr></table></figure>

<p><strong>附加说明</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock Array.map %&#125;</span><br><span class="line">array.map(callback[, thisArg])</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br><span class="line">Array.maparray.map(callback[, thisArg])</span><br></pre></td></tr></table></figure>

<p><strong>附加说明和网址</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock _.compact http:&#x2F;&#x2F;underscorejs.org&#x2F;#compact Underscore.js %&#125;</span><br><span class="line">_.compact([0, 1, false, 2, &#39;&#39;, 3]);</span><br><span class="line">&#x3D;&gt; [1, 2, 3]</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br><span class="line">_.compactUnderscore.js_.compact([0, 1, false, 2, &#39;&#39;, 3]);</span><br><span class="line">&#x3D;&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<h4 id="8-6-反引号代码块"><a href="#8-6-反引号代码块" class="headerlink" title="8.6 反引号代码块"></a>8.6 反引号代码块</h4><p>另一种形式的代码块，不同的是它使用三个反引号来包裹。</p>
<p>``` [language] [title] [url] [link text] code snippet ```</p>
<h4 id="Pull-Quote"><a href="#Pull-Quote" class="headerlink" title="Pull Quote"></a>Pull Quote</h4><p>在文章中插入 Pull quote。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% pullquote [class] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endpullquote %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="jsFiddle"><a href="#jsFiddle" class="headerlink" title="jsFiddle"></a>jsFiddle</h4><p>在文章中嵌入 jsFiddle。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Gist"><a href="#Gist" class="headerlink" title="Gist"></a>Gist</h4><p>在文章中嵌入 Gist。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% gist gist_id [filename] %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h4><p>在文章中插入 iframe。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% iframe url [width] [height] %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h4><p>在文章中插入指定大小的图片。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% img [class names] &#x2F;path&#x2F;to&#x2F;image [width] [height] &#39;&quot;title text&quot; &quot;alt text&quot;&#39; %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h4><p>在文章中插入链接，并自动给外部链接添加 <code>target=&quot;_blank&quot;</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% link text url [external] [title] %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Include-Code"><a href="#Include-Code" class="headerlink" title="Include Code"></a>Include Code</h4><p>插入 <code>source/downloads/code</code> 文件夹内的代码文件。<code>source/downloads/code</code> 不是固定的，取决于你在配置文件中 <code>code_dir</code> 的配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include_code [title] [lang:language] [from:line] [to:line] path&#x2F;to&#x2F;file %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-7-样例"><a href="#8-7-样例" class="headerlink" title="8.7 样例"></a>8.7 样例</h4><p><strong>嵌入 test.js 文件全文</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include_code lang:javascript test.js %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>只嵌入第 3 行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include_code lang:javascript from:3 to:3 test.js %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>嵌入第 5 行至第 8 行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include_code lang:javascript from:5 to:8 test.js %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>嵌入第 5 行至文件结束</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include_code lang:javascript from:5 test.js %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>嵌入第 1 行至第 8 行</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include_code lang:javascript to:8 test.js %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-8-引用文章"><a href="#8-8-引用文章" class="headerlink" title="8.8 引用文章"></a>8.8 引用文章</h4><p>引用其他文章的链接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_path filename %&#125;</span><br><span class="line">&#123;% post_link filename [title] [escape] %&#125;</span><br></pre></td></tr></table></figure>

<p>在使用此标签时可以忽略文章文件所在的路径或者文章的永久链接信息、如语言、日期。</p>
<p>例如，在文章中使用 <code>&#123;% post_link how-to-bake-a-cake %&#125;</code> 时，只需有一个名为 <code>how-to-bake-a-cake.md</code> 的文章文件即可。即使这个文件位于站点文件夹的 <code>source/posts/2015-02-my-family-holiday</code> 目录下、或者文章的永久链接是 <code>2018/en/how-to-bake-a-cake</code>，都没有影响。</p>
<p>默认链接文字是文章的标题，你也可以自定义要显示的文本。</p>
<p>默认对文章的标题和自定义标题里的特殊字符进行转义。可以使用<code>escape</code>选项，禁止对特殊字符进行转义。</p>
<p><strong>链接使用文章的标题</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_link hexo-3-8-released %&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/news/2018/10/19/hexo-3-8-released/">Hexo 3.8.0 Released</a></p>
<p><strong>链接使用自定义文字</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_link hexo-3-8-released &#39;通往文章的链接&#39; %&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/news/2018/10/19/hexo-3-8-released/">通往文章的链接</a></p>
<p><strong>对标题的特殊字符进行转义</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_link hexo-4-released &#39;How to use &lt;b&gt; tag in title&#39; %&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/news/2019/10/14/hexo-4-released/">How to use  tag in title</a></p>
<p><strong>禁止对标题的特殊字符进行转义</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% post_link hexo-4-released &#39;&lt;b&gt;bold&lt;&#x2F;b&gt; custom title&#39; false %&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://hexo.io/news/2019/10/14/hexo-4-released/"><strong>bold</strong> custom title</a></p>
<h4 id="8-9-引用资源"><a href="#8-9-引用资源" class="headerlink" title="8.9 引用资源"></a>8.9 引用资源</h4><p>引用文章的资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_path filename %&#125;</span><br><span class="line">&#123;% asset_img [class names] slug [width] [height] [title text [alt text]] %&#125;</span><br><span class="line">&#123;% asset_link filename [title] [escape] %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Embed-image"><a href="#Embed-image" class="headerlink" title="Embed image"></a>Embed image</h3><p><em>‎hexo-渲染器标记的 3.1.0+ 可以（可选地）自动解析帖子的图像路径，请参阅‎<a href="https://hexo.io/docs/asset-folders#Embedding-an-image-using-markdown">‎此部分‎</a>‎，了解如何启用该图像。‎</em></p>
<p>“foo.jpg” is located at <code>http://example.com/2020/01/02/hello/foo.jpg</code>.</p>
<p><strong>Default (no option)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img foo.jpg %&#125;</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;2020&#x2F;01&#x2F;02&#x2F;hello&#x2F;foo.jpg&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Custom class</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img post-image foo.jpg %&#125;</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;2020&#x2F;01&#x2F;02&#x2F;hello&#x2F;foo.jpg&quot; class&#x3D;&quot;post-image&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Display size</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img foo.jpg 500 400 %&#125;</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;2020&#x2F;01&#x2F;02&#x2F;hello&#x2F;foo.jpg&quot; width&#x3D;&quot;500&quot; height&#x3D;&quot;400&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Title &amp; Alt</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img logo.svg &quot;lorem ipsum&#39;dolor&#39;&quot; %&#125;</span><br><span class="line">&lt;img src&#x3D;&quot;&#x2F;2020&#x2F;01&#x2F;02&#x2F;hello&#x2F;foo.jpg&quot; title&#x3D;&quot;lorem ipsum&quot; alt&#x3D;&quot;dolor&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Raw"><a href="#Raw" class="headerlink" title="Raw"></a>Raw</h4><p>如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-10-文章摘要和截断"><a href="#8-10-文章摘要和截断" class="headerlink" title="8.10 文章摘要和截断"></a>8.10 文章摘要和截断</h4><p>在文章中使用 <code>&lt;!-- more --&gt;</code>，那么 <code>&lt;!-- more --&gt;</code> 之前的文字将会被视为摘要。首页中将只出现这部分文字，同时这部分文字也会出现在正文之中。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</span><br></pre></td></tr></table></figure>

<p>首页中将只会出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</span><br></pre></td></tr></table></figure>

<p>正文中则会出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</span><br><span class="line"></span><br><span class="line">Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</span><br></pre></td></tr></table></figure>

<p>注意，摘要可能会被 Front Matter 中的 <code>excerpt</code> 覆盖。</p>
<h3 id="9-资源文件夹"><a href="#9-资源文件夹" class="headerlink" title="9 资源文件夹"></a>9 资源文件夹</h3><p>资源（Asset）代表 <code>source</code> 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 <code>source/images</code> 文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code> 的方法访问它们。</p>
<h4 id="9-1-文章资源文件夹"><a href="#9-1-文章资源文件夹" class="headerlink" title="9.1 文章资源文件夹"></a>9.1 文章资源文件夹</h4><p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_config.ymlpost_asset_folder: true</span><br></pre></td></tr></table></figure>

<p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p>
<h4 id="9-2-相对路径引用的标签插件"><a href="#9-2-相对路径引用的标签插件" class="headerlink" title="9.2 相对路径引用的标签插件"></a>9.2 相对路径引用的标签插件</h4><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的<a href="https://hexo.io/docs/tag-plugins#Include-Assets">标签插件</a>被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure>

<p>比如说：当你打开文章资源文件夹功能后，你把一个 <code>example.jpg</code> 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](example.jpg)</code> ，它将 <em>不会</em> 出现在首页上。（但是它会在文章中按你期待的方式工作）</p>
<p>正确的引用图片方式是使用下列的标签插件而不是 markdown ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure>

<p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p>
<h4 id="9-3-‎使用‎-markdown嵌入图像"><a href="#9-3-‎使用‎-markdown嵌入图像" class="headerlink" title="9.3 ‎使用‎ markdown嵌入图像"></a>9.3 ‎使用‎ markdown嵌入图像</h4><p><a href="https://github.com/hexojs/hexo-renderer-marked">‎hexo-渲染器标记的‎</a>‎3.1.0引入了一个新的选项，允许您在不使用标签插件的情况下在标记中嵌入图像。‎</p>
<p>To enable:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_config.ymlpost_asset_folder: true</span><br><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></table></figure>

<p>‎一旦启用，资产图像将自动解决到其相应的帖子路径。例如，”图像.jpg”位于”/2020/01/02/foo/图像.jpg”，这意味着它是”/2020/01/02/foo/“帖子的资产图像，将呈现为。‎ <code>![](image.jpg)</code> will be rendered as <code>&lt;img src=&quot;/2020/01/02/foo/image.jpg&quot;&gt;</code>.</p>
<h3 id="10-数据文件"><a href="#10-数据文件" class="headerlink" title="10 数据文件"></a>10 数据文件</h3><p>有时您可能需要在主题中使用某些资料，而这些资料并不在文章内，并且是需要重复使用的，那么您可以考虑使用 Hexo 3.0 新增的「数据文件」功能。此功能会载入 <code>source/_data</code> 内的 YAML 或 JSON 文件，如此一来您便能在网站中复用这些文件了。</p>
<p>举例来说，在 <code>source/_data</code> 文件夹中新建 <code>menu.yml</code> 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Home: &#x2F;</span><br><span class="line">Gallery: &#x2F;gallery&#x2F;</span><br><span class="line">Archives: &#x2F;archives&#x2F;</span><br></pre></td></tr></table></figure>

<p>您就能在模板中使用这些资料：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;% for (var link in site.data.menu) &#123; %&gt;</span><br><span class="line">  &lt;a href&#x3D;&quot;&lt;%&#x3D; site.data.menu[link] %&gt;&quot;&gt; &lt;%&#x3D; link %&gt; &lt;&#x2F;a&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p>渲染结果如下 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;&#x2F;&quot;&gt; Home &lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;&#x2F;gallery&#x2F;&quot;&gt; Gallery &lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;&#x2F;archives&#x2F;&quot;&gt; Archives &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<h3 id="11-服务器"><a href="#11-服务器" class="headerlink" title="11 服务器"></a>11 服务器</h3><h4 id="hexo-server"><a href="#hexo-server" class="headerlink" title="hexo-server"></a><a href="https://github.com/hexojs/hexo-server">hexo-server</a></h4><p>Hexo 3.0 把服务器独立成了个别模块，您必须先安装 <a href="https://github.com/hexojs/hexo-server">hexo-server</a> 才能使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-server --save</span><br></pre></td></tr></table></figure>

<p>安装完成后，输入以下命令以启动服务器，您的网站会在 <code>http://localhost:4000</code> 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>如果您想要更改端口，或是在执行时遇到了 <code>EADDRINUSE</code> 错误，可以在执行时使用 <code>-p</code> 选项指定其他端口，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server -p 5000</span><br></pre></td></tr></table></figure>

<h4 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h4><p>在静态模式下，服务器只处理 <code>public</code> 文件夹内的文件，而不会处理文件变动，在执行时，您应该先自行执行 <code>hexo generate</code>，此模式通常用于生产环境（production mode）下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server -s</span><br></pre></td></tr></table></figure>

<h4 id="自定义-IP"><a href="#自定义-IP" class="headerlink" title="自定义 IP"></a>自定义 IP</h4><p>服务器默认运行在 <code>0.0.0.0</code>，您可以覆盖默认的 IP 设置，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server -i 192.168.1.1</span><br></pre></td></tr></table></figure>

<p>指定这个参数后，您就只能通过该IP才能访问站点。例如，对于一台使用无线网络的笔记本电脑，除了指向本机的<code>127.0.0.1</code>外，通常还有一个<code>192.168.*.*</code>的局域网IP，如果像上面那样使用<code>-i</code>参数，就不能用<code>127.0.0.1</code>来访问站点了。对于有公网IP的主机，如果您指定一个局域网IP作为<code>-i</code>参数的值，那么就无法通过公网来访问站点。</p>
<h4 id="Pow"><a href="#Pow" class="headerlink" title="Pow"></a>Pow</h4><p><a href="http://pow.cx/">Pow</a> 是一个 Mac 系统上的零配置 Rack 服务器，它也可以作为一个简单易用的静态文件服务器来使用。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl get.pow.cx | sh</span><br></pre></td></tr></table></figure>

<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>在 <code>~/.pow</code> 文件夹建立链接（symlink）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~&#x2F;.pow</span><br><span class="line">$ ln -s &#x2F;path&#x2F;to&#x2F;myapp</span><br></pre></td></tr></table></figure>

<p>您的网站将会在 <code>http://myapp.dev</code> 下运行，网址根据链接名称而定。</p>
<h3 id="11-生成文件"><a href="#11-生成文件" class="headerlink" title="11 生成文件"></a>11 生成文件</h3><p>使用 Hexo 生成静态文件快速而且简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<h4 id="监视文件变动"><a href="#监视文件变动" class="headerlink" title="监视文件变动"></a>监视文件变动</h4><p>Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate --watch</span><br></pre></td></tr></table></figure>

<h4 id="完成后部署"><a href="#完成后部署" class="headerlink" title="完成后部署"></a>完成后部署</h4><p>您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate --deploy</span><br><span class="line">$ hexo deploy --generate</span><br></pre></td></tr></table></figure>

<blockquote>
<p>简写</p>
<p>上面两个命令可以简写为<br>$ hexo g -d<br>$ hexo d -g</p>
</blockquote>
<h2 id="NexT"><a href="#NexT" class="headerlink" title="NexT"></a>NexT</h2><p>访问Hexo官网，下载喜欢的主题，此处下载主题为NexT，Next主题有非常多的自定义选项，网络上的美化教程也十分丰富，建议下载。</p>
<h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h4><p>如果您使用的是 Hexo 5.0 或更晚，安装最简单的方法是通过 npm：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd hexo-site</span><br><span class="line">$ npm install hexo-theme-next</span><br></pre></td></tr></table></figure>

<p>或者您可以克隆整个存储库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd hexo-site</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;next-theme&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>如果您需要任何其他变体，请参阅<a href="https://theme-next.js.org/docs/getting-started/installation.html">详细的安装说明</a>。</p>
<p>安装后，打开 Hexo 配置文件并设置变量。<code>theme``next</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>

<h4 id="2-配置"><a href="#2-配置" class="headerlink" title="2 配置"></a>2 配置</h4><p>目前，NexT 鼓励用户使用<a href="https://theme-next.js.org/docs/getting-started/configuration.html">备用主题配置</a>来配置 NexT。使用<a href="https://theme-next.js.org/docs/advanced-settings/custom-files.html">自定义文件</a>可以轻松地自定义 NexT 的布局或样式。</p>
<p>不建议直接修改 NexT 主题中的任何文件。因为这可能导致错误（例如合并冲突），修改后的文件在升级主题时可能会被丢弃。</p>
<p>但是，您可以绕过合并冲突（错误消息（如**”提交更改或在合并之前将其存放”），**使用本地更改的命令。请参阅<a href="https://stackoverflow.com/a/15745424/5861495">此处</a>如何做到这一点。<code>Commit``Stash``Reset</code></p>
<h4 id="3-插件"><a href="#3-插件" class="headerlink" title="3 插件"></a>3 插件</h4><p>插件扩展和扩展了 NexT 的功能。插件有两种类型：核心插件和第三方插件。核心插件由 NexT 的基本功能要求。第三方插件提供大量可选功能。</p>
<p>配置这些插件非常容易。例如，如果您想在您的网站上启用，只需设置为在NexT配置文件中：<code>pjax``pjax``true</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Easily enable fast Ajax navigation on your website.</span><br><span class="line"># For more information: https:&#x2F;&#x2F;github.com&#x2F;next-theme&#x2F;pjax</span><br><span class="line">pjax: true</span><br></pre></td></tr></table></figure>

<h4 id="4-配置-CDN"><a href="#4-配置-CDN" class="headerlink" title="4 配置 CDN"></a>4 配置 CDN</h4><p>默认情况下，第三方插件将从<a href="https://www.jsdelivr.com/">jsDelivr</a> CDN 加载。我们还提供其他可选的清洁发展机制，包括著名的<a href="https://unpkg.com/">联合国驻科特派团</a>和<a href="https://cdnjs.com/">CDNJS。</a></p>
<p>例如，如果您想使用而不是作为默认的 CDN 提供商，则需要编辑 NexT 配置文件中的以下设置：<code>unpkg``jsdelivr</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vendors:</span><br><span class="line">  # ...</span><br><span class="line">  # Some contents...</span><br><span class="line">  # ...</span><br><span class="line">  plugins: unpkg</span><br></pre></td></tr></table></figure>

<h4 id="5-更新"><a href="#5-更新" class="headerlink" title="5 更新"></a>5 更新</h4><p>NexT 的新版本将每月发布一次。请在更新主题之前阅读<a href="https://github.com/next-theme/hexo-theme-next/releases">发布说明</a>。您可以通过以下命令更新NexT。</p>
<p>安装最新版本的npm：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd hexo-site</span><br><span class="line">$ npm install hexo-theme-next@latest</span><br></pre></td></tr></table></figure>

<p>或更新到最新的主分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd themes&#x2F;next</span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure>

<p><strong>如果您想从v5.x/v7.x更新到最新版本，请阅读<a href="https://theme-next.js.org/docs/getting-started/upgrade.html">本文</a>。</strong></p>
<p>创建 Hexo 主题非常容易，您只要在 <code>themes</code> 文件夹内，新增一个任意名称的文件夹，并修改 <code>_config.yml</code> 内的 <code>theme</code> 设定，即可切换主题。一个主题可能会有以下的结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── languages</span><br><span class="line">├── layout</span><br><span class="line">├── scripts</span><br><span class="line">└── source</span><br></pre></td></tr></table></figure>

<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>在本教程中，我们将会使用 <a href="https://travis-ci.com/">Travis CI</a> 将 Hexo 博客部署到 GitHub Pages 上。Travis CI 对于开源 repository 是免费的，但是这意味着你的站点文件将会是公开的。如果你希望你的站点文件不被公开，请直接前往本文 [私有 Repository](#私有 Repository) 部分。</p>
<ol>
<li>新建一个 repository。如果你希望你的站点能通过 <code>&lt;你的 GitHub 用户名&gt;.github.io</code> 域名访问，你的 repository 应该直接命名为 <code>&lt;你的 GitHub 用户名&gt;.github.io</code>。</li>
<li>将你的 Hexo 站点文件夹推送到 repository 中。默认情况下不应该 <code>public</code> 目录将不会被推送到 repository 中，你应该检查 <code>.gitignore</code> 文件中是否包含 <code>public</code> 一行，如果没有请加上。</li>
<li>将 <a href="https://github.com/marketplace/travis-ci">Travis CI</a> 添加到你的 GitHub 账户中。</li>
<li>前往 GitHub 的 <a href="https://github.com/settings/installations">Applications settings</a>，配置 Travis CI 权限，使其能够访问你的 repository。</li>
<li>你应该会被重定向到 Travis CI 的页面。如果没有，请 <a href="https://travis-ci.com/">手动前往</a>。</li>
<li>在浏览器新建一个标签页，前往 GitHub <a href="https://github.com/settings/tokens">新建 Personal Access Token</a>，只勾选 <code>repo</code> 的权限并生成一个新的 Token。Token 生成后请复制并保存好。</li>
<li>回到 Travis CI，前往你的 repository 的设置页面，在 <strong>Environment Variables</strong> 下新建一个环境变量，<strong>Name</strong> 为 <code>GH_TOKEN</code>，<strong>Value</strong> 为刚才你在 GitHub 生成的 Token。确保 <strong>DISPLAY VALUE IN BUILD LOG</strong> 保持 <strong>不被勾选</strong> 避免你的 Token 泄漏。点击 <strong>Add</strong> 保存。</li>
<li>在你的 Hexo 站点文件夹中新建一个 <code>.travis.yml</code> 文件：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo: false</span><br><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - 10 # use nodejs v10 LTS</span><br><span class="line">cache: npm</span><br><span class="line">branches:</span><br><span class="line">  only:</span><br><span class="line">    - master # build master branch only</span><br><span class="line">script:</span><br><span class="line">  - hexo generate # generate static files</span><br><span class="line">deploy:</span><br><span class="line">  provider: pages</span><br><span class="line">  skip-cleanup: true</span><br><span class="line">  github-token: $GH_TOKEN</span><br><span class="line">  keep-history: true</span><br><span class="line">  on:</span><br><span class="line">    branch: master</span><br><span class="line">  local-dir: public</span><br></pre></td></tr></table></figure>

<ol>
<li>将 <code>.travis.yml</code> 推送到 repository 中。Travis CI 应该会自动开始运行，并将生成的文件推送到同一 repository 下的 <code>gh-pages</code> 分支下</li>
<li>在 GitHub 中前往你的 repository 的设置页面，修改 <code>GitHub Pages</code> 的部署分支为 <code>gh-pages</code>。</li>
<li>前往 <code>https://&lt;你的 GitHub 用户名&gt;.github.io</code> 查看你的站点是否可以访问。这可能需要一些时间。</li>
</ol>
<h4 id="Project-page"><a href="#Project-page" class="headerlink" title="Project page"></a>Project page</h4><p>如果你更希望你的站点部署在 <code>&lt;你的 GitHub 用户名&gt;.github.io</code> 的子目录中，你的 repository 需要直接命名为子目录的名字，这样你的站点可以通过 <code>https://&lt;你的 GitHub 用户名&gt;.github.io/&lt;repository 的名字&gt;</code> 访问。你需要检查你的 Hexo 配置文件，将 <code>url</code> 修改为 <code>https://&lt;你的 GitHub 用户名&gt;.github.io/&lt;repository 的名字&gt;</code>、将 <code>root</code> 的值修改为 <code>/&lt;repository 的名字&gt;/</code></p>
<h4 id="私有-Repository"><a href="#私有-Repository" class="headerlink" title="私有 Repository"></a>私有 Repository</h4><p>下面的指示基于 <a href="https://hexo.io/docs/one-command-deployment">一键部署</a> 编写。</p>
<ol>
<li><p>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>.</p>
</li>
<li><p>在 <strong>_config.yml</strong>（如果有已存在的请删除）添加如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;&lt;username&gt;&#x2F;&lt;project&gt;</span><br><span class="line">  # example, https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexojs.github.io</span><br><span class="line">  branch: gh-pages</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 <code>hexo clean &amp;&amp; hexo deploy</code> 。</p>
</li>
<li><p>查看 <em>username</em>.github.io 上的网页是否部署成功。</p>
</li>
</ol>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ul>
<li><a href="https://help.github.com/categories/github-pages-basics/">GitHub Pages 使用文档</a></li>
<li><a href="https://docs.travis-ci.com/user/tutorial/">Travis CI 使用文档</a></li>
<li><a href="https://github.com/hexojs/awesome-hexo">Awesome Hexo</a></li>
<li>[在百度上搜索 “Hexo GitHub”](<a href="https://www.baidu.com/s?wd=Hexo">https://www.baidu.com/s?wd=Hexo</a> GitHub)</li>
</ul>
]]></content>
      <categories>
        <category>办公技能</category>
      </categories>
      <tags>
        <tag>Hexo + Next + Github</tag>
      </tags>
  </entry>
  <entry>
    <title>02-Java基本语法（上）</title>
    <url>/2021/08/14/02-Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h2 id=""><a href="#" class="headerlink" title=""></a></h2><span id="more"></span>

<h3 id="02-Java基本语法（上）：变量与运算符"><a href="#02-Java基本语法（上）：变量与运算符" class="headerlink" title="02-Java基本语法（上）：变量与运算符"></a>02-Java基本语法（上）：变量与运算符</h3><h4 id="1-关键字和保留字"><a href="#1-关键字和保留字" class="headerlink" title="1. 关键字和保留字"></a>1. 关键字和保留字</h4><ul>
<li>关键字(keyword)的定义和特点 <ul>
<li>定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</li>
<li>特点：关键字中所有字母都为小写</li>
<li>官方地址： <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a></li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141129301.png" alt="image-20210814112941844" style="zoom:150%;" /></li>
<li>保留字(reserved word)<ul>
<li>Java保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使 用。自己命名标识符时要避免使用这些保留字 goto 、const</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-标识符"><a href="#2-标识符" class="headerlink" title="2. 标识符"></a>2. 标识符</h4><ul>
<li>标识符：<ul>
<li>Java 对各种==变量、方法和类==等要素命名时使用的字符序列称为标识符</li>
<li>==技巧：凡是自己可以起名字的地方都叫标识符。==</li>
</ul>
</li>
<li>定义合法标识符规则：<ul>
<li>由26个英文字母大小写，0-9 ，_或 $ 组成</li>
<li>数字不可以开头。</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字。</li>
<li>Java中严格区分大小写，长度无限制。</li>
<li>标识符不能包含空格。</li>
</ul>
</li>
<li>==Java中的名称规范==<ul>
<li>包名：多个单词组成时，所有字母都小写：xxxyyyzzz</li>
<li>类名、接口名：多单词组成时，所有单词的首字母都大写：XxxYyyZzz</li>
<li>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</li>
<li>常量名：所有字母都大写。多个单词时每个单词用下划线链接：XXX_YYY_ZZZ</li>
</ul>
</li>
</ul>
<h4 id="3-变量"><a href="#3-变量" class="headerlink" title="3. 变量"></a>3. 变量</h4><ul>
<li><p>变量的概念：</p>
<ul>
<li>内存中的一个存储区域</li>
<li>该区域的数据可以在同一类型范围内不断变化</li>
<li>变量是程序中最基本的存储单元。包含==变量类型、变量名和存储的值==</li>
</ul>
</li>
<li><p>变量的作用：</p>
<ul>
<li>用于在内存中保存数据</li>
</ul>
</li>
<li><p>使用变量注意：</p>
<ul>
<li>==Java中的每个变量必须先声明，后使用==</li>
<li>使用变量名来访问这块区域的数据</li>
<li>变量的作用域：其定义所在的一对{}内</li>
<li>变量只在其作用域内才有效</li>
<li>同一个作用域内不能定义重名的变量</li>
</ul>
</li>
<li><p>声明变量</p>
<ul>
<li>语法：&lt;数据类型&gt;&lt;变量名&gt;</li>
<li>例如：int var</li>
</ul>
</li>
<li><p>变量的赋值</p>
<ul>
<li>语法：&lt;变量名称&gt; = &lt;值&gt;</li>
<li>例如：var = 10;</li>
</ul>
</li>
<li><p>声明和赋值变量</p>
<ul>
<li>语法： &lt;数据类型&gt; &lt;变量名&gt; = &lt;初始化值&gt;</li>
<li>例如：int var = 10;</li>
</ul>
</li>
<li><p>变量的分类</p>
<ul>
<li><p>按数据类型：对于每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分 配了不同大小的内存空间。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141215072.png" alt="image-20210814121537925"></p>
</li>
<li><p>按声明的位置的不同</p>
<p>在方法体外，类体内声明的变量称为成员变量。在方法体内部声明的变量称为局部变量。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141217923.png" alt="image-20210814121706483"></p>
<p>注意：二者在初始化值方面的异同:同：都有生命周期 异：局部变量除形参外，需显式初始化。</p>
</li>
<li><p>整数类型：byte、short、int、long</p>
<ul>
<li><p>Java各整数类型有固定的表数范围和字段长度，不受具体OS的影响，以保 证java程序的可移植性。</p>
</li>
<li><p>java的整型常量默认为 int 型，声明long型常量须后加‘l’或‘L’</p>
</li>
<li><p>java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long</p>
<table>
<thead>
<tr>
<th>类 型</th>
<th>占用存储空间</th>
<th>表数范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1字节=8bit位</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>-2^15^ ~2^15^ -1</td>
</tr>
<tr>
<td>int</td>
<td>4字节</td>
<td>-2^31^ ~ 2^31^ -1 (约21亿)</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>-2^63^ ~ 2^63^ -1</td>
</tr>
</tbody></table>
<p>500MB 1MB = 1024KB 1KB= 1024B B= byte ? bit? bit: 计算机中的最小存储单位。byte:计算机中基本存储单元。</p>
</li>
</ul>
</li>
<li><p>浮点类型：float、double</p>
<ul>
<li><p>与整数类型类似，Java 浮点类型也有固定的表数范围和字段长度，不受具体操作 系统的影响。</p>
</li>
<li><p>浮点型常量有两种表示形式：</p>
<ul>
<li>十进制数形式：如：5.12 512.0f .512 (必须有小数点）</li>
<li>科学计数法形式:如：5.12e2 512E2 100E-2</li>
</ul>
</li>
<li><p>float:单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。 double:双精度，精度是float的两倍。通常采用此类型。</p>
</li>
<li><p>Java 的浮点型常量默认为double型，声明float型常量，须后加‘f’或‘F’。</p>
<table>
<thead>
<tr>
<th>类 型</th>
<th>占用存储空间</th>
<th>表数范围</th>
</tr>
</thead>
<tbody><tr>
<td>单精度float</td>
<td>4字节</td>
<td>-3.403E38 ~ 3.403E38</td>
</tr>
<tr>
<td>双精度double</td>
<td>8字节</td>
<td>-1.798E308 ~ 1.798E308</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>字符类型：char</p>
<ul>
<li><p>char 型数据用来表示通常意义上“字符”(2字节)</p>
</li>
<li><p>Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字 母，一个汉字，或其他书面语的一个字符。</p>
</li>
<li><p>字符型变量的三种表现形式：</p>
<ul>
<li><p>字符常量是用单引号(‘ ’)括起来的单个字符。例如：char c1 = ‘a’; char c2  = ‘中’; char c3 = ‘9’;</p>
</li>
<li><p>Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。 例如：char c3 = ‘\n’; // ‘\n’表示换行符</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\b</td>
<td>退格键</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\“</td>
<td>双引号</td>
</tr>
<tr>
<td>\‘</td>
<td>单引号</td>
</tr>
<tr>
<td>\\</td>
<td>反斜线</td>
</tr>
</tbody></table>
</li>
<li><p>直接使用 Unicode 值来表示字符型常量：‘\uXXXX’。其中，XXXX代表 一个十六进制整数。如：\u000a 表示 \n。</p>
</li>
<li><p>char类型是可以进行运算的。因为它都对应有Unicode码。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>布尔类型：boolean</p>
<ul>
<li>boolean 类型用来判断逻辑条件，一般用于程序流程控制：<ul>
<li>if条件控制语句；</li>
<li>while循环控制语句；</li>
<li>do-while循环控制语句；</li>
<li>for循环控制语句；</li>
</ul>
</li>
<li>boolean类型数据只允许取值true和false，无null。<ul>
<li>不可以使用0或非 0 的整数替代false和true，这点和C语言不同。</li>
<li>Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的 boolean值，在编译之后都使用java虚拟机中的int数据类型来代替：true用1表示，false 用0表示。———《java虚拟机规范 8版》</li>
</ul>
</li>
</ul>
</li>
<li><p>基本数据类型转换</p>
<ul>
<li><p>自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容 量大小排序为：</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141234328.png" alt="image-20210814123431947"></p>
</li>
<li><p>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的 那种数据类型，然后再进行计算。</p>
</li>
<li><p>byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型。</p>
</li>
<li><p>boolean类型不能与其它数据类型运算。</p>
</li>
<li><p>当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类 型的值将自动转化为字符串(String)类型。</p>
</li>
</ul>
</li>
<li><p>字符串类型：String</p>
<ul>
<li><p>String不是基本数据类型，属于引用数据类型</p>
</li>
<li><p>使用方式与基本数据类型一致。例如：String str = “abcd”;</p>
</li>
<li><p>一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">str = str + “xyz” ; </span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line">str = str + n;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>强制类型转换</p>
<ul>
<li>自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使 用时要加上强制转换符：()，但可能造成精度降低或溢出,格外要注意。</li>
<li>通常，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可 以实现把字符串转换成基本类型。</li>
<li>如： String a = “43”; int i = Integer.parseInt(a);</li>
<li>boolean类型不可以转换为其它的数据类型。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-运算符"><a href="#4-运算符" class="headerlink" title="4. 运算符"></a>4. 运算符</h4><ul>
<li><p>算数运算符<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141250720.png" alt="image-20210814125009358"></p>
<ul>
<li>算术运算符的注意问题<ul>
<li>如果对负数取模，可以把模数负号忽略不记，如：5%-2=1。 但被模数是 负数则不可忽略。此外，取模运算的结果不一定总是整数。</li>
<li>对于除号“/”，它的整数除和小数除是有区别的：整数之间做除法时，只 保留整数部分而舍弃小数部分。 例如：int x=3510;x=x/1000*1000; </li>
<li>“+”除字符串相加功能外，还能把非字符串转换成字符串.例如： System.out.println(“5+5=”+5+5); //打印结果是？ 5+5=55 ?</li>
</ul>
</li>
</ul>
</li>
<li><p>赋值运算符：=</p>
<ul>
<li>符号：=<ul>
<li>当“=”两侧数据类型不一致时，可以使用自动类型转换或使用强制 类型转换原则进行处理。</li>
<li>支持连续赋值。</li>
</ul>
</li>
<li>扩展赋值运算符： +=, -=, *=, /=, %=</li>
</ul>
</li>
<li><p>比较运算符<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141255040.png" alt="image-20210814125537627"></p>
<p>比较运算符的结果都是boolean型，也就是要么是true，要么是false。</p>
<p>比较运算符“==”不能误写成“=” 。</p>
</li>
<li><p>逻辑运算符</p>
<p>&amp;—逻辑与     | —逻辑或     ！—逻辑非     &amp;&amp; —短路与     || —短路或     ^ —逻辑异或</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141256722.png" alt="image-20210814125656753"></p>
<ul>
<li>逻辑运算符用于连接布尔型表达式，在Java中不可以写成3&lt;x&lt;3 ,应该写成x&gt;3 &amp; x&lt;6 。</li>
<li>“&amp;”和“&amp;&amp;”的区别：<ul>
<li>单&amp;时，左边无论真假，右边都进行运算；</li>
<li>双&amp;时，如果左边为真，右边参与运算，如果左边为假，那么右边不参与运算。</li>
</ul>
</li>
<li>“|”和“||”的区别同理，||表示：当左边为真，右边不参与运算。</li>
<li>异或( ^ )与或( | )的不同之处是：当左右都为true时，结果为false。</li>
</ul>
</li>
<li><p>位运算符<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141259463.png" alt="image-20210814125946801"></p>
<ul>
<li>位运算是直接对整数的二进制进行的运算</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141301684.png" alt="image-20210814130103547"></p>
</li>
<li><p>三元运算符</p>
<ul>
<li>格式：<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141302892.png" alt="image-20210814130208344"></li>
<li>表达式1和表达式2为同种类型</li>
<li>三元运算符与if-else的联系与区别：<ul>
<li>三元运算符可简化if-else语句</li>
<li>三元运算符要求必须返回一个结果。</li>
<li>if后的代码块可有多个语句</li>
</ul>
</li>
</ul>
</li>
<li><p>运算符优先级</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141507310.png" alt="image-20210814150746972"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>02-Java基本语法（下）</title>
    <url>/2021/08/14/02-Java%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="02—Java基本语法（下）：程序流程控制"><a href="#02—Java基本语法（下）：程序流程控制" class="headerlink" title="02—Java基本语法（下）：程序流程控制"></a>02—Java基本语法（下）：程序流程控制</h3><h4 id="1-程序流程控制"><a href="#1-程序流程控制" class="headerlink" title="1. 程序流程控制"></a>1. 程序流程控制</h4><ul>
<li>流程控制语句是用来控制程序中各语句执行顺序的语句，可以把语句组 合成能完成一定功能的小逻辑模块。</li>
<li>其流程控制方式采用结构化程序设计中规定的三种基本流程结构，即：<ul>
<li>顺序结构<ul>
<li>程序从上到下逐行地执行，中间没有任何判断和跳转。</li>
</ul>
</li>
<li>分支结构<ul>
<li>根据条件，选择性地执行某段代码。</li>
<li>有if…else和switch-case两种分支语句。</li>
</ul>
</li>
<li>循环结构<ul>
<li>根据循环条件，重复性的执行某段代码。</li>
<li>有while、do…while、for三种循环语句。</li>
<li>注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-顺序结构"><a href="#2-顺序结构" class="headerlink" title="2. 顺序结构"></a>2. 顺序结构</h4><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141315615.png" alt="image-20210814131528560"> </p>
<h4 id="3-分支结构"><a href="#3-分支结构" class="headerlink" title="3. 分支结构"></a>3. 分支结构</h4><h5 id="3-1-if-else结构"><a href="#3-1-if-else结构" class="headerlink" title="3.1 if-else结构"></a>3.1 if-else结构</h5><p>if语句三种格式：</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141316077.png" alt="image-20210814131652242"> <img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141318452.png" alt="屏幕截图 2021-08-14 131738" style="zoom:80%;" /></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141319828.png" alt="屏幕截图 2021-08-14 131909"></p>
<h5 id="3-2-switch-case结构"><a href="#3-2-switch-case结构" class="headerlink" title="3.2 switch-case结构"></a>3.2 switch-case结构</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">			语句<span class="number">1</span>;</span><br><span class="line">		<span class="comment">// break;</span></span><br><span class="line">	<span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">			语句<span class="number">2</span>;</span><br><span class="line">		<span class="comment">// break;</span></span><br><span class="line">		… …</span><br><span class="line">	<span class="keyword">case</span> 常量N:</span><br><span class="line">			语句N;</span><br><span class="line">		<span class="comment">// break;</span></span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		语句;</span><br><span class="line">		<span class="comment">// break;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141322212.png" alt="image-20210814132242055"></p>
<p>switch语句有关规则</p>
<ul>
<li>switch(表达式)中表达式的值必须是下述几种类型之一：byte，short， char，int，枚举 (jdk 5.0)，String (jdk 7.0)；</li>
<li>case子句中的值必须是常量，不能是变量名或不确定的表达式值；</li>
<li>同一个switch语句，所有case子句中的常量值互不相同；</li>
<li>break语句用来在执行完一个case分支后使程序跳出switch语句块；如 果没有break，程序会顺序执行到switch结尾</li>
<li>default子句是可任选的。同时，位置也是灵活的。当没有匹配的case时， 执行default</li>
</ul>
<h4 id="4-循环结构"><a href="#4-循环结构" class="headerlink" title="4.循环结构"></a>4.循环结构</h4><h5 id="4-1-for循环"><a href="#4-1-for循环" class="headerlink" title="4.1 for循环"></a>4.1 for循环</h5><ul>
<li><p>语法格式</p>
<p>for (①初始化部分; ②循环条件部分; ④迭代部分)｛ </p>
<p>​         ③循环体部分; </p>
<p>｝</p>
</li>
<li><p>执行过程：</p>
<p>①-②-③-④-②-③-④-②-③-④-…..-②</p>
</li>
<li><p>说明：</p>
<ul>
<li><p>②循环条件部分为boolean类型表达式，当值为false时，退出循环</p>
</li>
<li><p>①初始化部分可以声明多个变量，但必须是同一个类型，用逗号分隔</p>
</li>
<li><p>④可以有多个变量更新，用逗号分隔</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108141928696.png" alt="image-20210814192817184" style="zoom:80%;" />

</li>
</ul>
</li>
</ul>
<h5 id="4-2-while循环"><a href="#4-2-while循环" class="headerlink" title="4.2 while循环"></a>4.2 while循环</h5><ul>
<li><p>语法格式</p>
<p>①初始化部分 </p>
<p>while(②循环条件部分)｛ </p>
<p>​             ③循环体部分; </p>
<p>​             ④迭代部分;</p>
<p> }</p>
</li>
<li><p>执行过程：</p>
<p>①-②-③-④-②-③-④-②-③-④-…-②</p>
</li>
<li><p>说明：</p>
<ul>
<li>注意不要忘记声明④迭代部分。否则，循环将不能结束，变成死循环。</li>
<li>for循环和while循环可以相互转换</li>
</ul>
</li>
</ul>
<h5 id="4-3-do-while循环"><a href="#4-3-do-while循环" class="headerlink" title="4.3 do-while循环"></a>4.3 do-while循环</h5><ul>
<li><p>语法格式</p>
<p>①初始化部分; </p>
<p>do{ </p>
<p>​        ③循环体部分 </p>
<p>​        ④迭代部分 }while(②循环条件部分);</p>
</li>
<li><p>执行过程：①-==③-④==-②-③-④-②-③-④-…②</p>
</li>
<li><p>说明：do-while循环至少执行一次循环体。</p>
</li>
</ul>
<h4 id="5-特殊关键字的使用：-break、continue"><a href="#5-特殊关键字的使用：-break、continue" class="headerlink" title="5. 特殊关键字的使用： break、continue"></a>5. 特殊关键字的使用： break、continue</h4><h5 id="5-1-特殊流程控制语句1"><a href="#5-1-特殊流程控制语句1" class="headerlink" title="5.1 特殊流程控制语句1"></a>5.1 特殊流程控制语句1</h5><ul>
<li><p>break 语句</p>
<ul>
<li><p>break语句用于终止某个语句块的执行 </p>
<p>{ …… </p>
<p>​    break; </p>
<p>​    …… </p>
<p>}</p>
</li>
<li><p>break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是哪一层语句块</p>
<p>label1: { …… </p>
<p>label2:         { …… </p>
<p>label3:                 { …… </p>
<p>​                                    break label2; </p>
<p>​                                    …… </p>
<p>​                                }</p>
<p>​                         } </p>
<p>​                 }</p>
</li>
</ul>
</li>
</ul>
<h5 id="5-2-特殊流程控制语句2"><a href="#5-2-特殊流程控制语句2" class="headerlink" title="5.2 特殊流程控制语句2"></a>5.2 特殊流程控制语句2</h5><ul>
<li>continue 语句<ul>
<li>continue只能使用在循环结构中</li>
<li>continue语句用于跳过其所在循环语句块的一次执行，继续下一次循环</li>
<li>continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环</li>
</ul>
</li>
</ul>
<h5 id="5-3-特殊流程控制语句3"><a href="#5-3-特殊流程控制语句3" class="headerlink" title="5.3 特殊流程控制语句3"></a>5.3 特殊流程控制语句3</h5><ul>
<li>return：并非专门用于结束循环的，它的功能是结束一个方法。 当一个方法执行到一个return语句时，这个方法将被结束。</li>
<li>与break和continue不同的是，return直接结束整个方法，不管这个return处于多少层循环之内</li>
<li>break只能用于switch语句和循环语句中。</li>
<li>continue 只能用于循环语句中。</li>
<li>二者功能类似，但continue是终止本次循环，==break是终止本层循环。==</li>
<li>break、continue之后不能有其他的语句，因为程序永远不会执行其后的语句。</li>
<li>标号语句必须紧接在循环的头部。标号语句不能用在非循环语句的前面。</li>
<li>很多语言都有goto语句，goto语句可以随意将控制转移到程序中的任意一条 语句上，然后执行它。但使程序容易出错。Java中的break和continue是不同 于goto的。</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>03-数组</title>
    <url>/2021/08/14/03%E2%80%94%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="03—数组"><a href="#03—数组" class="headerlink" title="03—数组"></a>03—数组</h3><h4 id="1-数组的概述"><a href="#1-数组的概述" class="headerlink" title="1. 数组的概述"></a>1. 数组的概述</h4><ul>
<li>数组(Array)，是多个相同类型数据按一定顺序排列 的集合，并使用一个名字命名，并通过编号的方式 对这些数据进行统一管理。</li>
<li>数组的常见概念<ul>
<li>数组名</li>
<li>下标(或索引)</li>
<li>元素</li>
<li>数组的长度</li>
</ul>
</li>
<li>数组本身是==引用数据类型==，而数组中的元素可以是==任何数据类型==，包括 基本数据类型和引用数据类型。</li>
<li>创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址。</li>
<li>数组的==长度一旦确定，就不能修改。==</li>
<li>我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快。</li>
<li>数组的分类：<ul>
<li>按照维度：一维数组、二维数组、三维数组、…</li>
<li>按照元素的数据类型分：基本数据类型元素的数组、引用数据类型元素的数组(即对 象数组)</li>
</ul>
</li>
</ul>
<h4 id="2-一维数组"><a href="#2-一维数组" class="headerlink" title="2. 一维数组"></a>2. 一维数组</h4><h5 id="2-1-声明"><a href="#2-1-声明" class="headerlink" title="2.1 声明"></a>2.1 声明</h5><ul>
<li>一维数组的声明方式： type var[] 或 type[] var；<ul>
<li>例如<ul>
<li>int a[]; </li>
<li>int[] a1; </li>
<li>double b[]; </li>
<li>String[] c; //引用类型变量数组</li>
</ul>
</li>
</ul>
</li>
<li>Java语言中声明数组时不能指定其长度(数组中元素的数)， 例如： int a[5]; //非法</li>
</ul>
<h5 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h5><ul>
<li><p>动态初始化：数组声明且为数组元素分配空间与赋值的操作分开进行</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142020501.png" alt="image-20210814202012456"></p>
</li>
<li><p>静态初始化：在定义数组的同时就为数组元素分配空间并赋值。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142022292.png" alt="image-20210814202203908"></p>
</li>
</ul>
<h5 id="2-3-数组元素的引用"><a href="#2-3-数组元素的引用" class="headerlink" title="2.3 数组元素的引用"></a>2.3 数组元素的引用</h5><ul>
<li><p>定义并用运算符new为之分配空间后，才可以引用数组中的每个元素；</p>
</li>
<li><p>数组元素的引用方式：数组名[数组元素下标]</p>
<ul>
<li>数组元素下标可以是整型常量或==整型表达式==。如a[3] , b[i] , c[6*i];</li>
<li>数组元素下标从0开始；长度为n的数组合法下标取值范围: 0 —&gt;n-1；如int a[]=new  int[3]; 可引用的数组元素为a[0]、a[1]、a[2]</li>
</ul>
</li>
<li><p>每个数组都有一个属性length指明它的长度，例如：a.length 指明数组a的长度(元素个数)</p>
<ul>
<li>数组一旦初始化，其长度是不可变的</li>
</ul>
</li>
<li><p>数组是引用类型，它的元素相当于类的成员变量，因此数组一经 分配空间，其中的每个元素也被按照成员变量同样的方式被隐式 初始化。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a[]= <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">		System.out.println(a[<span class="number">3</span>]); <span class="comment">//a[3]的默认值为0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对于基本数据类型而言，默认初始化值各有不同</p>
</li>
<li><p>对于引用数据类型而言，默认初始化值为null(注意与0不同！)</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142045181.png" alt="image-20210814204510834"></p>
</li>
</ul>
</li>
</ul>
<h5 id="2-4-一维数组的使用"><a href="#2-4-一维数组的使用" class="headerlink" title="2.4 一维数组的使用"></a>2.4 一维数组的使用</h5><ul>
<li><p>Java中使用关键字new来创建数组</p>
</li>
<li><p>如下是创建基本数据类型元素的一维数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] s;<span class="comment">//⭐</span></span><br><span class="line">		s = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ ) &#123;</span><br><span class="line">			s[i] =<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">			System.out.println(s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142055841.png" alt="image-20210814205542408"> </p>
</li>
<li><p>创建基本数据类型数组 (2)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] s;</span><br><span class="line">		s = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];<span class="comment">//⭐</span></span><br><span class="line">		<span class="comment">//int[] s=new int[10];</span></span><br><span class="line">		<span class="comment">//基本数据类型数组在显式赋值之前，</span></span><br><span class="line">		<span class="comment">//Java会自动给他们赋默认值。</span></span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ ) &#123;</span><br><span class="line">			s[i] =<span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">			System.out.println(s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142101509.png" alt="image-20210814210132161"></p>
</li>
<li><p>创建基本数据类型数组 (3)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] s;</span><br><span class="line">		s = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> ( <span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++ ) &#123;</span><br><span class="line">			s[i] =<span class="number">2</span>*i+<span class="number">1</span>;<span class="comment">//⭐</span></span><br><span class="line">			System.out.println(s[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>内存结构</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142105646.png" alt="image-20210814210534290"></p>
<p><strong>一维数组内存解析</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142114758.png" alt="屏幕截图 2021-08-14 211401"></p>
</li>
</ul>
<h4 id="3-多维数组的使用"><a href="#3-多维数组的使用" class="headerlink" title="3. 多维数组的使用"></a>3. 多维数组的使用</h4><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142116543.png" alt="image-20210814211605498"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142116877.png" alt="image-20210814211632843"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142117692.png" alt="image-20210814211737151"></p>
<p><strong>二维数组内存解析</strong></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142118788.png" alt="image-20210814211812263"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142121628.png" alt="image-20210814212133388"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142121935.png" alt="image-20210814212153112"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142122194.png" alt="image-20210814212212578"></p>
<h4 id="4-Arrys工具类的使用"><a href="#4-Arrys工具类的使用" class="headerlink" title="4. Arrys工具类的使用"></a>4. Arrys工具类的使用</h4><p>java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比 如排序和搜索）的各种方法。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142140195.png" alt="image-20210814213814165"></p>
<ul>
<li><p>java.util.Arrays类的sort()方法提供了数组元素排序功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> [] numbers = &#123;<span class="number">5</span>,<span class="number">900</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">77</span>,<span class="number">30</span>,<span class="number">64</span>,<span class="number">700</span>&#125;;</span><br><span class="line">		Arrays.sort(numbers);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">			System.out.println(numbers[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-数组使用中的常见异常"><a href="#5-数组使用中的常见异常" class="headerlink" title="5. 数组使用中的常见异常"></a>5. 数组使用中的常见异常</h4><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108142148445.png" alt="image-20210814214839629"></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>05-面向对象编程（中）</title>
    <url>/2021/08/15/05%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="05—面向对象编程（中）"><a href="#05—面向对象编程（中）" class="headerlink" title="05—面向对象编程（中）"></a>05—面向对象编程（中）</h3><h4 id="1-OPP特征二：继承性"><a href="#1-OPP特征二：继承性" class="headerlink" title="1. OPP特征二：继承性"></a>1. OPP特征二：继承性</h4><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151517127.png" alt="image-20210815151705107"></p>
<ul>
<li><p>为什么要有继承？</p>
<ul>
<li>多个类中存在相同属性和行为时，将这些内容抽取到一个单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。</li>
</ul>
</li>
<li><p>此处的多个类称为子类(派生类)，单独的这个类称为父类(基类 或超类)。可以理解为:“子类 is a 父类”</p>
</li>
<li><p>类继承语法规则:</p>
<p>==class Subclass extends SuperClass{ }==</p>
</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151518835.png" alt="屏幕截图 2021-08-15 151823"></p>
<ul>
<li><p>作用：</p>
<ul>
<li>继承的出现减少了代码冗余，提高了代码的复用性。 </li>
<li>继承的出现，更有利于功能的扩展。 </li>
<li>==继承的出现让类与类之间产生了关系，提供了多态的前提==。</li>
</ul>
</li>
<li><p>注意：不要仅为了获取其他类中某个功能而去继承</p>
</li>
<li><p>子类继承了父类，就继承了父类的方法和属性。 </p>
</li>
<li><p> 在子类中，可以使用父类中定义的方法和属性，也可以创建新的数据和方法。 </p>
</li>
<li><p> 在Java 中，继承的关键字用的是“extends”，即子类不是父类的子集， 而是对父类的“扩展”。 </p>
</li>
<li><p>关于继承的规则： </p>
<ul>
<li>==子类不能直接访问父类中私有的(private)的成员变量和方法。==</li>
</ul>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151521356.png" alt="image-20210815152152978"></p>
</li>
<li><p>Java只支持==单继承和多层继承==，不允许多重继承</p>
<ul>
<li><p>一个子类只能有一个父类</p>
</li>
<li><p>一个父类可以派生出多个子类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubDemo</span> <span class="keyword">extends</span> <span class="title">Demo</span></span>&#123; &#125; <span class="comment">//ok</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubDemo</span> <span class="keyword">extends</span> <span class="title">Demo1</span>,<span class="title">Demo2</span>...//<span class="title">error</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>多层继承<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151525655.png" alt="image-20210815152555906"><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151523332.png" alt="image-20210815152332229"></p>
</li>
<li><p>多重继承(×)</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151524636.png" alt="image-20210815152406598"></p>
</li>
</ul>
</li>
</ul>
<h4 id="2-方法的重写（override）"><a href="#2-方法的重写（override）" class="headerlink" title="2. 方法的重写（override）"></a>2. 方法的重写（override）</h4><ul>
<li><p>定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。</p>
</li>
<li><p>要求：</p>
<ol>
<li>子类重写的方法必须和父类被重写的方法具有相同的==方法名称、参数列表==</li>
<li>子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型 </li>
<li>子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限 <ol>
<li>子类不能重写父类中声明为private权限的方法 </li>
</ol>
</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
</ol>
</li>
<li><p>注意： 子类与父类中同名同参数的方法必须同时声明为非static的(即为重写)，或者同时声明为 static的（不是重写）。==因为static方法是属于类的，子类无法覆盖父类的方法==</p>
</li>
<li><p>重写举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span>+ name + <span class="string">&quot;\n&quot;</span> +<span class="string">&quot;age: &quot;</span>+ age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> String school;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123; <span class="comment">//重写方法</span></span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span>+ name + <span class="string">&quot;\nage: &quot;</span>+ age + <span class="string">&quot;\nschool: &quot;</span>+ school;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">		Student s1=<span class="keyword">new</span> Student();</span><br><span class="line">		s1.name=<span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">		s1.age=<span class="number">20</span>;</span><br><span class="line">		s1.school=<span class="string">&quot;school2&quot;</span>;</span><br><span class="line">		System.out.println(s1.getInfo()); <span class="comment">//Name:Bob age:20 school:school2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1=<span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//调用Person类的getInfo()方法</span></span><br><span class="line">p1.getInfo();</span><br><span class="line">Student s1=<span class="keyword">new</span> Student();</span><br><span class="line"><span class="comment">//调用Student类的getInfo()方法</span></span><br><span class="line">s1.getInfo();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这是一种“多态性”：同名的方法，用不同的对</span></span><br><span class="line"><span class="comment">象来区分调用的是哪一个方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line"><span class="comment">//非法，子类中的method1()的访问权限private比被覆盖方法的访问权限public小</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="3-四种访问权限修饰符"><a href="#3-四种访问权限修饰符" class="headerlink" title="3. 四种访问权限修饰符"></a>3. 四种访问权限修饰符</h4><p>封装性的体现，需要权限修饰符来配合。</p>
<p>类的成员：可以用public、protected、 (缺省)、 private修饰</p>
<p>类：只可以用public和default(缺省)。</p>
<ol>
<li>public类可以在任意地方被访问。</li>
<li>default类只可以被同一个包内部的类访问。</li>
</ol>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210612235948.jpg" alt="微信图片编辑_20210612235925" style="zoom:67%;" /> 

<blockquote>
<p>其中Hello_son是Hello的子类</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210612234455.png" alt="image-20210612234446616" style="zoom: 67%;" /><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210613000341.png" alt="image-20210613000339972" style="zoom:50%;" /></p>
</blockquote>
<ul>
<li><p>Java规定的4种权限（从小到大排列）：private、缺省、protected、public</p>
<ul>
<li><table>
<thead>
<tr>
<th>修饰符</th>
<th>类内部</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>缺省</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
</li>
</ul>
<blockquote>
<p>对于class的权限修饰，只可以用public和缺省(default)</p>
<ul>
<li>public类可以在任意地方被访问</li>
<li>default类只可以被同一个包的内部类访问</li>
</ul>
</blockquote>
</li>
<li><p>4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类</p>
<p>具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</p>
<p>修饰类的话，只能使用：缺省、public</p>
</li>
</ul>
<h5 id="3-1在类为public时，对于属性和方法"><a href="#3-1在类为public时，对于属性和方法" class="headerlink" title="3.1在类为public时，对于属性和方法"></a>3.1在类为public时，对于属性和方法</h5><p>==在Test包下==</p>
<p><strong>在Hello.java文件里</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> helloPrivate;</span><br><span class="line">    <span class="keyword">int</span> helloDefault;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> helloProtected;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> helloPublic;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">methodProtected</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodPublic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在test_.java文件里</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test_</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Hello hello = <span class="keyword">new</span> Hello();<span class="comment">//通过类造对象，再去调用对象里的属性和方法</span></span><br><span class="line">        </span><br><span class="line">     <span class="comment">// hello.helloPrivate   = 1;//声明为private的属性只能在类内部被调用</span></span><br><span class="line">     <span class="comment">// The field Hello.helloPrivate is not visible （属性不可见）</span></span><br><span class="line">        hello.helloProtected = <span class="number">2</span>;<span class="comment">//赋值成功</span></span><br><span class="line">        hello.helloDefault   = <span class="number">3</span>;<span class="comment">//赋值成功</span></span><br><span class="line">        hello.helloPublic    = <span class="number">4</span>;<span class="comment">//赋值成功</span></span><br><span class="line">        </span><br><span class="line">     <span class="comment">// hello.methodPrivate();//声明为private的方法只能在类内部被调用</span></span><br><span class="line">     <span class="comment">// The method methodPrivate() from the type Hello is not visible</span></span><br><span class="line">        hello.methodProtected();<span class="comment">//成功调用</span></span><br><span class="line">        hello.methodDefault();<span class="comment">//成功调用</span></span><br><span class="line">        hello.methodPublic();<span class="comment">//成功调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==在test2包下==</p>
<p><strong>在test2.java文件下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test.Hello; <span class="comment">//将test包下的Hello导入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Hello hello = <span class="keyword">new</span> Hello();<span class="comment">//通过类造对象，再去调用对象里的属性和方法</span></span><br><span class="line">        </span><br><span class="line">     <span class="comment">// hello.helloPrivate   = 1;//声明为private的属性只能在类内部被调用</span></span><br><span class="line">     <span class="comment">// The field Hello.helloPrivate is not visible （属性不可见）</span></span><br><span class="line">     <span class="comment">// hello.helloDefault   = 2;//声明为Default的属性只能在包内部被调用</span></span><br><span class="line">     <span class="comment">// The field Hello.helloDefault is not visible （属性不可见） </span></span><br><span class="line">     <span class="comment">// hello.helloProtected = 3;</span></span><br><span class="line">        hello.helloPublic    = <span class="number">3</span>;<span class="comment">//赋值成功</span></span><br><span class="line">        </span><br><span class="line">     <span class="comment">// hello.methodPrivate();//声明为private的方法只能在类内部被调用</span></span><br><span class="line">     <span class="comment">// The method methodPrivate() from the type Hello is not visible</span></span><br><span class="line">     <span class="comment">// hello.methodDefault();//声明为Default的方法只能在包内部被调用</span></span><br><span class="line">     <span class="comment">// The method methodDefault() from the type Hello is not visible </span></span><br><span class="line">     <span class="comment">// hello.methodProtected();</span></span><br><span class="line">        hello.methodPublic();<span class="comment">//成功调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在Hello_son.java文件下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test.Hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello_son</span> <span class="keyword">extends</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">// helloPrivate   = 1;  //not visible</span></span><br><span class="line">     <span class="comment">// helloDefault   = 2;  //not visible</span></span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">4</span>;</span><br><span class="line">        </span><br><span class="line">     <span class="comment">// methodProivate();   //not visible</span></span><br><span class="line">     <span class="comment">// methodDefault();    //not visible</span></span><br><span class="line">        methodProtected();</span><br><span class="line">        methodPublic();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="3-2-在类为缺省时，对于属性和方法"><a href="#3-2-在类为缺省时，对于属性和方法" class="headerlink" title="3.2 在类为缺省时，对于属性和方法"></a>3.2 在类为缺省时，对于属性和方法</h5><p>==在Test包下==</p>
<p><strong>在Hello.java文件里</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> helloPrivate;</span><br><span class="line">    <span class="keyword">int</span> helloDefault;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> helloProtected;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> helloPublic;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">methodPrivate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodDefault</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodProtected</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodPublic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helloPrivate   = <span class="number">1</span>; <span class="comment">//即使最小的权限也能在类内部使用</span></span><br><span class="line">        helloDefault   = <span class="number">2</span>;</span><br><span class="line">        helloProtected = <span class="number">3</span>;</span><br><span class="line">        helloPublic    = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在test_.java文件里</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test_</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Hello hello = <span class="keyword">new</span> Hello();<span class="comment">//通过类造对象，再去调用对象里的属性和方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// hello.helloPrivate   = 1;//声明为private的属性只能在类内部被调用</span></span><br><span class="line">        <span class="comment">// The field Hello.helloPrivate is not visible （属性不可见）</span></span><br><span class="line">        hello.helloProtected = <span class="number">2</span>;<span class="comment">//赋值成功</span></span><br><span class="line">        hello.helloDefault   = <span class="number">3</span>;<span class="comment">//赋值成功</span></span><br><span class="line">        hello.helloPublic    = <span class="number">4</span>;<span class="comment">//赋值成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// hello.methodPrivate();//声明为private的方法只能在类内部被调用</span></span><br><span class="line">        <span class="comment">// The method methodPrivate() from the type Hello is not visible</span></span><br><span class="line">        hello.methodProtected();<span class="comment">//成功调用</span></span><br><span class="line">        hello.methodDefault();<span class="comment">//成功调用</span></span><br><span class="line">        hello.methodPublic();<span class="comment">//成功调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==在test2包下==</p>
<p><strong>在test2.java文件下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test.Hello; <span class="comment">//将test包下的Hello导入 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test2</span></span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Hello hello = <span class="keyword">new</span> Hello();<span class="comment">//报错，声明为缺省状态的类只能在包里面使用</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在Hello_son.java文件下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> test.Hello;<span class="comment">//报错 The type test.Hello is not visible</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello_son</span> <span class="keyword">extends</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="comment">//报错 Hello cannot be resolved to a type</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-关键字：super"><a href="#4-关键字：super" class="headerlink" title="4. 关键字：super"></a>4. 关键字：super</h4><ul>
<li><p>在Java类中使用super来调用父类中的指定操作： </p>
<ul>
<li>super可用于访问父类中定义的属性 </li>
<li>super可用于调用父类中定义的成员方法 </li>
<li>super可用于在子类构造器中调用父类的构造器</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员</li>
<li>super的追溯不仅限于直接父类</li>
<li>super和this的用法相像，this代表本类对象的引用，super代表父类的内存 空间的标识</li>
</ul>
</li>
<li><p>关键字super举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> String name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Name: &quot;</span> + name + <span class="string">&quot;\nage: &quot;</span> + age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> String name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">	<span class="keyword">private</span> String school = <span class="string">&quot;New Oriental&quot;</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSchool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> school;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getInfo() + <span class="string">&quot;\nschool: &quot;</span> + school;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Student st = <span class="keyword">new</span> Student();</span><br><span class="line">		System.out.println(st.getInfo());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Name: 张三<br>age: 0<br>school: New Oriental</p>
</blockquote>
</li>
</ul>
<h5 id="4-1-调用父类的构造器"><a href="#4-1-调用父类的构造器" class="headerlink" title="4.1 调用父类的构造器"></a>4.1 调用父类的构造器</h5><ul>
<li><p>子类中所有的构造器==默认==都会访问父类中==空参==的构造器</p>
</li>
<li><p>当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，只能”二选一” ，且必须放在构造器的首行</p>
</li>
<li><p>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则==编译出错==</p>
</li>
<li><p>调用父类构造器举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> Date birthDate;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Date d)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.birthDate = d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(name, age, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Date d)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(name, <span class="number">30</span>, d);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(name, <span class="number">30</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String school;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name, age);</span><br><span class="line">		school = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">		school = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 编译出错: no super(),系统将调用父类无参数的构造器。</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String s)</span> </span>&#123; </span><br><span class="line">		school = s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="4-2-this和super的区别"><a href="#4-2-this和super的区别" class="headerlink" title="4.2 this和super的区别"></a>4.2 this和super的区别</h5><table>
<thead>
<tr>
<th>No.</th>
<th>区别点</th>
<th>this</th>
<th>super</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>访问属性</td>
<td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td>
<td>直接访问父类中的属性</td>
</tr>
<tr>
<td>2</td>
<td>调用方法</td>
<td>访问本类中的方法，如果本类没有此方法则从父类中继续查找</td>
<td>直接访问父类中的方法</td>
</tr>
<tr>
<td>3</td>
<td>调用构造器</td>
<td>调用本类构造器，必须放在构造器的首行</td>
<td>调用父类构造器，必须 放在子类构造器的首行</td>
</tr>
</tbody></table>
<p>super(…)和this(…)调用语句不能同时在一个构造器中出现</p>
<h4 id="5-子类实例化过程"><a href="#5-子类实例化过程" class="headerlink" title="5. 子类实例化过程"></a>5. 子类实例化过程</h4><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151604286.png" alt="image-20210815160431840"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151607694.png" alt="image-20210815160659235"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151607563.png" alt="image-20210815160713809"></p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-15-15:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Creature</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Creature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Creature无参数的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">extends</span> <span class="title">Creature</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal带一个参数的构造器，该动物的name为&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal带两个参数的构造器，其age为&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wolf</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wolf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">&quot;灰太狼&quot;</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Wolf无参数的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Wolf();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Creature无参数的构造器<br>Animal带一个参数的构造器，该动物的name为灰太狼<br>Animal带两个参数的构造器，其age为3<br>Wolf无参数的构造器</p>
</blockquote>
<h4 id="6-OOP特征三：多态性"><a href="#6-OOP特征三：多态性" class="headerlink" title="6. OOP特征三：多态性"></a>6. OOP特征三：多态性</h4><ul>
<li><p>多态性，是面向对象中最重要的概念，在Java中的体现： </p>
<p>对象的多态性：==父类的引用指向子类的对象== </p>
<ul>
<li>==可以直接应用在抽象类和接口上==</li>
</ul>
</li>
<li><p>Java引用变量有两个类型：==编译时类型和运行时类型==。编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给该变量的对象决定。简 称：==编译时，看左边；运行时，看右边==。 </p>
<ul>
<li><p>若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism) </p>
</li>
<li><p>多态情况下， “看左边” ：看的是父类的引用（父类中不具备子类特有的方法）</p>
<p>​                              “看右边” ：看的是子类的对象（实际运行的是子类重写父类的方法）</p>
</li>
</ul>
</li>
<li><p>对象的多态 —在Java中,子类的对象可以替代父类的对象使用</p>
<ul>
<li><p>一个变量只能有一种确定的数据类型</p>
</li>
<li><p>一个引用类型变量可能指向(引用)多种不同类型的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">Object o = <span class="keyword">new</span> Person();<span class="comment">//Object类型的变量o，指向Person类型的对象</span></span><br><span class="line">o = <span class="keyword">new</span> Student(); <span class="comment">//Object类型的变量o，指向Student类型的对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向上转型(upcasting)。</p>
</li>
</ul>
</li>
<li><p>一个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就不能再访问子类中添加的属性和方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student m = <span class="keyword">new</span> Student();</span><br><span class="line">m.school = “pku”; <span class="comment">//合法,Student类有school成员变量</span></span><br><span class="line">Person e = <span class="keyword">new</span> Student(); </span><br><span class="line">e.school = “pku”; <span class="comment">//非法,Person类没有school成员变量</span></span><br></pre></td></tr></table></figure>

<p>属性是在编译时确定的，编译时e为Person类型，没有school成员变量，因而编译错误。</p>
</li>
<li><p>方法声明的形参类型为==父类==类型，可以==使用子类==的对象作为==实参调用==该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person e)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ……</span></span><br><span class="line">		e.getInfo();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(Stirng args[])</span> </span>&#123;</span><br><span class="line">		Test t = <span class="keyword">new</span> Test();</span><br><span class="line">		Student m = <span class="keyword">new</span> Student();</span><br><span class="line">		t.method(m); <span class="comment">// 子类的对象m传送给父类类型的参数e</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="5-1-虚拟方法调用"><a href="#5-1-虚拟方法调用" class="headerlink" title="5.1 虚拟方法调用"></a>5.1 虚拟方法调用</h5><ul>
<li><p>正常的方法调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person e = <span class="keyword">new</span> Person();</span><br><span class="line">e.getInfo();</span><br><span class="line">Student e = <span class="keyword">new</span> Student();</span><br><span class="line">e.getInfo();</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚拟方法调用(多态情况下)</p>
<p>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，==父类根据赋给它的不同子类对象，动态调用属于子类的该方法==。这样的方法调用在编译期是无法确定的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person e = <span class="keyword">new</span> Student();</span><br><span class="line">e.getInfo(); <span class="comment">//调用Student类的getInfo()方法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译时类型和运行时类型</p>
<p>编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类 的getInfo()方法。——动态绑定</p>
</li>
</ul>
<h5 id="5-2-方法的重载与重写"><a href="#5-2-方法的重载与重写" class="headerlink" title="5.2 方法的重载与重写"></a>5.2 方法的重载与重写</h5><p>​            从编译和运行的角度看： </p>
<p>​            ==重载==，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。==它们的调用地址在编译期就绑定了==。Java的重载是可以包括父类和子的，即子类可以重载父类的同名不同参数的方法。 所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法， 这称为==“早绑定”或“静态绑定”==；</p>
<pre><code>         而对于==多态==，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体 方法，这称为==“晚绑定”或“动态绑定”==。 引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”
</code></pre>
<h5 id="5-3-instanceof操作符"><a href="#5-3-instanceof操作符" class="headerlink" title="5.3 instanceof操作符"></a>5.3 instanceof操作符</h5><p>x instanceof A：检验x是否为类A的对象，返回值为boolean型。 </p>
<ul>
<li><p>要求x所属的类与类A必须是子类和父类的关系，否则编译错误。 </p>
</li>
<li><p>如果x属于类A的子类B，x instanceof A值也为true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;…&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;…&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graduate</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;…&#125;</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">(Person e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (e <span class="keyword">instanceof</span> Person) </span><br><span class="line">		<span class="comment">// 处理Person类及其子类对象</span></span><br><span class="line">	<span class="keyword">if</span> (e <span class="keyword">instanceof</span> Student) </span><br><span class="line">		<span class="comment">//处理Student类及其子类对象</span></span><br><span class="line">	<span class="keyword">if</span> (e <span class="keyword">instanceof</span> Graduate)</span><br><span class="line">		<span class="comment">//处理Graduate类及其子类对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="5-4-对象类型转换-Casting"><a href="#5-4-对象类型转换-Casting" class="headerlink" title="5.4 对象类型转换 (Casting )"></a>5.4 对象类型转换 (Casting )</h5><ul>
<li><p>基本数据类型的Casting：</p>
<ul>
<li><p>自动类型转换：小的数据类型可以自动转换成大的数据类型 </p>
<p>如long g=20; double d=12.0f</p>
</li>
<li><p>强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型 </p>
<p>如 float f=(float)12.0; int a=(int)1200L</p>
</li>
</ul>
</li>
<li><p>对Java对象的强制类型转换称为造型 </p>
<ul>
<li>从子类到父类的类型转换可以自动进行 </li>
<li>从父类到子类的类型转换必须通过造型(强制类型转换)实现 </li>
<li>无继承关系的引用类型间的转换是非法的 </li>
<li>在造型前可以使用instanceof操作符测试一个对象的类型</li>
</ul>
</li>
<li><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151643504.png" alt="image-20210815164314304"></p>
</li>
<li><p>继承成员变量和继承方法的区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count = <span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="keyword">this</span>.count);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldMethodTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Sub s = <span class="keyword">new</span> Sub();</span><br><span class="line">		System.out.println(s.count);</span><br><span class="line">		s.display();</span><br><span class="line">		Base b = s;</span><br><span class="line">		System.out.println(b == s);</span><br><span class="line">		System.out.println(b.count);</span><br><span class="line">		b.display();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>20<br>20<br>true<br>10<br>20</p>
</blockquote>
</li>
<li><p>子类继承父类</p>
<ul>
<li>若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。</li>
<li>对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量。</li>
</ul>
</li>
</ul>
<h4 id="7-Object类的使用"><a href="#7-Object类的使用" class="headerlink" title="7. Object类的使用"></a>7. Object类的使用</h4><p>Object类是所有Java类的根父类，如果在类的声明中未使用extends关键字指明其父类，则默认父类 为java.lang.Object类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-1-Object类中的主要结构"><a href="#7-1-Object类中的主要结构" class="headerlink" title="7.1 Object类中的主要结构"></a>7.1 Object类中的主要结构</h5><table>
<thead>
<tr>
<th>NO.</th>
<th>方法名称</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>public Object()</td>
<td>构造</td>
<td>构造器</td>
</tr>
<tr>
<td>2</td>
<td>public boolean equals(Object obj)</td>
<td>普通</td>
<td>对象比较</td>
</tr>
<tr>
<td>3</td>
<td>public int hashCode()</td>
<td>普通</td>
<td>取得Hash码</td>
</tr>
<tr>
<td>4</td>
<td>public String toString()</td>
<td>普通</td>
<td>对象打印时调用</td>
</tr>
</tbody></table>
<h5 id="7-2-操作符与equals方法"><a href="#7-2-操作符与equals方法" class="headerlink" title="7.2 ==操作符与equals方法"></a>7.2 ==操作符与equals方法</h5><ul>
<li><p>==</p>
<ul>
<li><p>基本类型比较值:只要两个变量的值相等，即为true。 </p>
<ul>
<li>int a=5; if(a==6){…}</li>
</ul>
</li>
<li><p>引用类型比较引用(是否指向同一个对象)：只有指向同一个对象时，==才 返回true。</p>
<p>Person p1=new Person(); </p>
<p>Person p2=new Person();</p>
<p> if (p1==p2){…}</p>
<ul>
<li>用“ == ” 进行比较时，符号两边的 ==数据类型必须兼容==(可自动转换的基本 数据类型除外)，否则编译出错</li>
</ul>
</li>
</ul>
</li>
<li><p>equals()：所有类都继承了Object，也就获得了equals()方法。还可以重写。如果该方法没有被重写过默认也 是  ==  ;</p>
<ul>
<li>只能比较引用类型，其作用与“==”相同,比较是否指向同一个对象。</li>
<li>格式:obj1.equals(obj2)</li>
</ul>
</li>
<li><p>特例：当用equals()方法进行比较时，对类File、String、Date及包装类 （Wrapper Class）来说，是比较类型及内容而不考虑引用的是否是同一个对 象；</p>
<ul>
<li>原因：在这些类中重写了Object类的equals()方法。</li>
</ul>
<p>当自定义使用equals()时，可以重写。用于比较两个对象的“内容”是否都相等</p>
</li>
</ul>
<h6 id="7-2-1-重写equals-方法的原则"><a href="#7-2-1-重写equals-方法的原则" class="headerlink" title="7.2.1 重写equals()方法的原则"></a>7.2.1 重写equals()方法的原则</h6><ul>
<li>对称性：如果x.equals(y)返回是“true” ，那么y.equals(x)也应该返回是 “true”。</li>
<li>自反性：x.equals(x)必须返回是“true”。</li>
<li>传递性：如果x.equals(y)返回是“true” ，而且y.equals(z)返回是“true” ， 那么z.equals(x)也应该返回是“true”。</li>
<li>一致性：如果x.equals(y)返回是“true” ，只要x和y内容一直不变，不管你 重复x.equals(y)多少次，返回都是“true”。</li>
<li>任何情况下，x.equals(null)，永远返回是“false” ； x.equals(和x不同类型的对象)永远返回是“false”。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> it = <span class="number">65</span>;</span><br><span class="line"><span class="keyword">float</span> fl = <span class="number">65.0f</span>;</span><br><span class="line">System.out.println(“<span class="number">65</span>和<span class="number">65.0f</span>是否相等？” + (it == fl)); <span class="comment">//true</span></span><br><span class="line"><span class="keyword">char</span> ch1 = <span class="string">&#x27;A&#x27;</span>; <span class="keyword">char</span> ch2 = <span class="number">12</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;65和&#x27;A&#x27;是否相等？&quot;</span> + (it == ch1));<span class="comment">//true</span></span><br><span class="line">System.out.println(“<span class="number">12</span>和ch2是否相等？<span class="string">&quot; + (12 == ch2));//true</span></span><br><span class="line"><span class="string">String str1 = new String(&quot;</span>hello<span class="string">&quot;);</span></span><br><span class="line"><span class="string">String str2 = new String(&quot;</span>hello<span class="string">&quot;);</span></span><br><span class="line"><span class="string">System.out.println(&quot;</span>str1和str2是否相等？<span class="string">&quot;+ (str1 == str2));//false</span></span><br><span class="line"><span class="string">System.out.println(&quot;</span>str1是否equals str2？<span class="string">&quot;+(str1.equals(str2)));//true</span></span><br><span class="line"><span class="string">System.out.println(“hello” == new java.util.Date()); //编译不通过</span></span><br></pre></td></tr></table></figure>

<h5 id="7-3-toString-方法"><a href="#7-3-toString-方法" class="headerlink" title="7.3 toString()方法"></a>7.3 toString()方法</h5><p>toString()方法在Object类中定义，其返回值是String类型，返回类名和它的引用地址。在进行String与其它类型数据的连接操作时，自动调用toString()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date now=<span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(“now=”+now); 相当于</span><br><span class="line">System.out.println(“now=”+now.toString());</span><br></pre></td></tr></table></figure>

<p>可以根据需要在用户自定义类型中重写toString()方法 如String 类重写了toString()方法，返回字符串的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">s1=“hello”;</span><br><span class="line">System.out.println(s1);<span class="comment">//相当于System.out.println(s1.toString());</span></span><br></pre></td></tr></table></figure>

<p>基本类型数据转换为String类型时，调用了对应包装类的toString()方法 </p>
<p>int a=10; System.out.println(“a=”+a)</p>
<h4 id="8-包装类-Wrapper-的使用"><a href="#8-包装类-Wrapper-的使用" class="headerlink" title="8. 包装类(Wrapper)的使用"></a>8. 包装类(Wrapper)的使用</h4><p>针对八种基本数据类型定义相应的引用类型—包装类（封装类）,有了类的特点，就可以调用类中的方法，Java才是真正的面向对象</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151712053.png" alt="image-20210815171252735"> </p>
<ul>
<li><p>基本数据类型包装成包装类的实例 —装箱</p>
<ul>
<li><p>通过包装类的构造器实现：</p>
<p> int i = 500; </p>
<p>Integer t = new Integer(i);</p>
</li>
<li><p>还可以通过字符串参数构造包装类对象：</p>
<p>Float f = new Float(“4.56”); </p>
<p>Long l = new Long(“asdf”); //NumberFormatException</p>
</li>
</ul>
</li>
<li><p>获得包装类对象中包装的基本类型变量 —拆箱</p>
<ul>
<li><p>调用包装类的.xxxValue()方法： </p>
<p>boolean b = bObj.booleanValue();</p>
<p>JDK1.5之后，支持自动装箱，自动拆箱。但类型必须匹配。</p>
</li>
</ul>
</li>
<li><p>字符串转换成基本数据类型 </p>
<ul>
<li><p>通过包装类的构造器实现： </p>
<p>int i = new Integer(“12”); </p>
</li>
<li><p>通过包装类的parseXxx(String s)静态方法： </p>
<p>Float f = Float.parseFloat(“12.1”);</p>
</li>
</ul>
</li>
<li><p>基本数据类型转换成字符串 </p>
<ul>
<li>调用字符串重载的valueOf()方法： String fstr = String.valueOf(2.34f); </li>
<li>更直接的方式： String intStr = 5 + “”</li>
</ul>
</li>
<li><p>基本类型、包装类与String类间的转换</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151719326.png" alt="image-20210815171942936"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>04-面向对象编程（上）</title>
    <url>/2021/08/15/04%E2%80%94%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="04—面向对象编程（上）"><a href="#04—面向对象编程（上）" class="headerlink" title="04—面向对象编程（上）"></a>04—面向对象编程（上）</h3><h4 id="1-面向过程与面向对象"><a href="#1-面向过程与面向对象" class="headerlink" title="1. 面向过程与面向对象"></a>1. 面向过程与面向对象</h4><ul>
<li><p>面向过程(POP) 与 面向对象(OOP)</p>
<ul>
<li>二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的 是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</li>
<li>面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。</li>
</ul>
</li>
<li><p>面向对象的三大特征</p>
<ul>
<li>封装 (Encapsulation)</li>
<li>继承 (Inheritance)</li>
<li>多态 (Polymorphism)</li>
</ul>
</li>
<li><p>例子：人把大象放进冰箱</p>
<ul>
<li><p>面向过程</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108150936761.png" alt="image-20210815093603375"> </p>
</li>
<li><p>面向对象</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108150939430.png" alt="屏幕截图 2021-08-15 093901" style="zoom:80%;" /> 



</li>
</ul>
</li>
</ul>
<h4 id="2-Java基本元素：类和对象"><a href="#2-Java基本元素：类和对象" class="headerlink" title="2. Java基本元素：类和对象"></a>2. Java基本元素：类和对象</h4><h5 id="2-1-面向对象的思想概述"><a href="#2-1-面向对象的思想概述" class="headerlink" title="2.1 面向对象的思想概述"></a>2.1 面向对象的思想概述</h5><ul>
<li>类(Class)和对象(Object)是面向对象的核心概念。<ul>
<li>类是对一类事物的描述，是抽象的、概念上的定义</li>
<li>对象是实际存在的该类事物的每个个体，因而也称为实例(instance)。</li>
</ul>
</li>
<li>“万事万物皆对象”</li>
<li><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108150943559.png" alt="image-20210815094356070"><ul>
<li>可以理解为：类 = 抽象概念的人；对象 = 实实在在的某个人</li>
<li>面向对象程序设计的重点是类的设计</li>
<li>类的设计，其实就是类的成员的设计</li>
</ul>
</li>
</ul>
<h5 id="2-2-Java类及类的成员"><a href="#2-2-Java类及类的成员" class="headerlink" title="2.2 Java类及类的成员"></a>2.2 Java类及类的成员</h5><ul>
<li><p>常见的类的成员有：</p>
<ul>
<li><p>属 性：对应类中的成员变量</p>
</li>
<li><p>行 为：对应类中的成员方法</p>
<p><code>Field = 属性 = 成员变量</code></p>
<p><code>Method = (成员)方法 = 函数</code></p>
</li>
</ul>
</li>
<li><p>类的语法格式</p>
<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108150947934.png" alt="image-20210815094719516" style="zoom:80%;" /> 

</li>
</ul>
<h4 id="3-对象的创建和使用"><a href="#3-对象的创建和使用" class="headerlink" title="3. 对象的创建和使用"></a>3. 对象的创建和使用</h4><ul>
<li><p>创建对象语法： 类名 对象名 = new 类名();</p>
</li>
<li><p>使用“对象名.对象成员”的方式访问对象成员（包括属性和方法）</p>
</li>
<li><p>Java中类与对象</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108150949686.png" alt="image-20210815094919592"></p>
</li>
<li><p>类的访问机制：</p>
<ul>
<li>在一个类中的访问机制：类中的方法可以直接访问类中的成员变量。 （例外：static方法访问非static，编译不通过。）</li>
<li>在不同类中的访问机制：先创建要访问类的对象，再用对象访问类中 定义的成员。</li>
</ul>
</li>
</ul>
<h5 id="3-1-对象的产生"><a href="#3-1-对象的产生" class="headerlink" title="3.1 对象的产生"></a>3.1 对象的产生</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(“oh,my god! I am ” + age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Person p1 = new Person();执行完后的内存状态。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108150952839.png" alt="image-20210815095240586"></p>
<h5 id="3-2-对象的使用"><a href="#3-2-对象的使用" class="headerlink" title="3.2 对象的使用"></a>3.2 对象的使用</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//程序运行的内存布局如下图</span></span><br><span class="line">		Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">		Person p2 =<span class="keyword">new</span> Person();</span><br><span class="line">		p1.age = -<span class="number">30</span>;</span><br><span class="line">		p1.shout();</span><br><span class="line">		p2.shout();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151015625.png" alt="image-20210815101522210"></p>
<h5 id="3-3-对象的生命周期"><a href="#3-3-对象的生命周期" class="headerlink" title="3.3 对象的生命周期"></a>3.3 对象的生命周期</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151020380.png" alt="屏幕截图 2021-08-15 101937"></p>
<h5 id="3-5-内存解析"><a href="#3-5-内存解析" class="headerlink" title="3.5 内存解析"></a>3.5 内存解析</h5><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151022640.png" alt="屏幕截图 2021-08-15 102212"  /> 

<ul>
<li><p>==堆（Heap）==，此内存区域的唯一目的就是==存放对象实例==，几乎所有的对象 实例都在这里分配内存。这一点在 Java虚拟机规范中的描述是：所有的 对象实例以及数组都要在堆上分配。</p>
</li>
<li><p>通常所说的==栈（Stack）==，是指虚拟机栈。虚拟机栈用于==存储局部变量==等。 局部变量表存放了编译期可知长度的 各种基本数据类型（boolean、byte、 char 、 short 、 int 、 float 、 long 、 double）、对象引用（reference类型， 它不等同于对象本身，是对象在堆内 存的首地址）。 方法执行完，自动释放。</p>
</li>
<li><p>==方法区（Method Area）==，用于存储已被虚拟机加载的==类信息、常量、静态 变量、即时编译器编译后的代码==等数据。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151028888.png" alt="屏幕截图 2021-08-15 102810"></p>
</li>
</ul>
<h5 id="3-6-匿名对象"><a href="#3-6-匿名对象" class="headerlink" title="3.6 匿名对象"></a>3.6 匿名对象</h5><ul>
<li>我们也可以不定义对象的句柄，而直接调用这个对象的方法。这样的对象叫做匿名对象。 如：new Person().shout();</li>
<li>使用情况<ul>
<li>如果对一个对象只需要进行一次方法调用，那么就可以使用匿名对象。</li>
<li>我们经常将匿名对象作为实参传递给一个方法调用。</li>
</ul>
</li>
</ul>
<h4 id="4-类的成员之一：属性"><a href="#4-类的成员之一：属性" class="headerlink" title="4. 类的成员之一：属性"></a>4. 类的成员之一：属性</h4><ul>
<li><p>语法格式：</p>
<p>修饰符 数据类型 属性名 = 初始化值 ; </p>
<ul>
<li>说明1: 修饰符<ul>
<li>常用的权限修饰符有：private、缺省、protected、public</li>
<li>其他修饰符：static、final (暂不考虑)</li>
</ul>
</li>
<li>说明2：数据类型 <ul>
<li> 任何基本数据类型(如int、Boolean) 或 任何引用数据类型。</li>
</ul>
</li>
<li>说明3：属性名<ul>
<li>属于标识符，符合命名规则和规范即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="4-1-变量的分类"><a href="#4-1-变量的分类" class="headerlink" title="4.1 变量的分类"></a>4.1 变量的分类</h5><ul>
<li><p>在方法体外，类体内声明的变量称为成员变量。</p>
</li>
<li><p>在方法体内部声明的变量称为局部变量。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151118952.png" alt="image-20210815111824780"></p>
</li>
<li><p>注意：二者在初始化值方面的异同:</p>
<ul>
<li>同：都有生命周期</li>
<li>异：局部变量除形参外，均需显式初始化。</li>
</ul>
</li>
<li><p>成员变量（属性）和局部变量的区别</p>
<table>
<thead>
<tr>
<th></th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>声明的位置</td>
<td>直接声名在类中</td>
<td>方法形参或内部、代码块内、构造器内</td>
</tr>
<tr>
<td>修饰符</td>
<td>private、public、static、final等</td>
<td>不能用权限修饰符修饰，可以用final修饰</td>
</tr>
<tr>
<td>初始化值</td>
<td>有默认话初始值</td>
<td>没有默认初始值，必须显示赋值，方可使用</td>
</tr>
<tr>
<td>内存加载位置</td>
<td>堆空间或静态域内</td>
<td>栈空间</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151124615.png" alt="屏幕截图 2021-08-15 112430"></p>
</li>
</ul>
<h4 id="5-类的成员之二：方法"><a href="#5-类的成员之二：方法" class="headerlink" title="5. 类的成员之二：方法"></a>5. 类的成员之二：方法</h4><h5 id="5-1-什么是方法-method、函数"><a href="#5-1-什么是方法-method、函数" class="headerlink" title="5.1 什么是方法(method、函数):"></a>5.1 什么是方法(method、函数):</h5><ul>
<li><p>方法是类或对象行为特征的抽象，用来完成某个功能操作。在某些语言中 也称为函数或过程。</p>
</li>
<li><p>将功能封装为方法的目的是，可以实现代码重用，简化代码</p>
</li>
<li><p>Java里的方法不能独立存在，所有的方法必须定义在类里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="comment">//声明方法getAge()</span></span><br><span class="line">		<span class="keyword">return</span> age; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">//声明方法setAge</span></span><br><span class="line">		age = i; <span class="comment">//将参数i的值赋给类的成员变量age</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="5-2-方法的声明格式："><a href="#5-2-方法的声明格式：" class="headerlink" title="5.2 方法的声明格式："></a>5.2 方法的声明格式：</h5><p>修饰符 返回值类型 方法名（参数类型 形参1, 参数类型 形参2, ….）｛ </p>
<p>​    方法体程序代码 </p>
<p>​    return 返回值; </p>
<p>｝</p>
<ul>
<li>其中： <ul>
<li>修饰符：public,缺省,private, protected等 </li>
<li>返回值类型：<ul>
<li>没有返回值：void。</li>
<li>有返回值，声明出返回值的类型。与方法体中“return 返回值”搭配使用</li>
</ul>
</li>
<li>方法名：<ul>
<li>属于标识符，命名时遵循标识符命名规则和规范，“见名知意” 形参列表：可以包含零个，一个或多个参数。多个参数时，中间用“,”隔开 返回值：方法在执行完毕后返还给调用它的程序的数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="5-3-方法的调用"><a href="#5-3-方法的调用" class="headerlink" title="5.3 方法的调用"></a>5.3 方法的调用</h5><p>方法通过方法名被调用，且只有被调用才会执行</p>
<ul>
<li><p>方法调用的过程分析</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151130960.png" alt="image-20210815113046780"></p>
</li>
<li><p>注意</p>
<ul>
<li>方法被调用一次，就会执行一次</li>
<li>没有具体返回值的情况，返回值类型用关键字void表示，那么方法体中可 以不必使用return语句。如果使用，仅用来结束方法。</li>
<li>定义方法时，方法的结果应该返回给调用者，交由调用者处理。</li>
<li>方法中只能调用方法或属性，不可以在方法内部定义方法。</li>
</ul>
</li>
</ul>
<h5 id="5-4-对象数组的内存解析"><a href="#5-4-对象数组的内存解析" class="headerlink" title="5.4 对象数组的内存解析"></a>5.4 对象数组的内存解析</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151132396.png" alt="image-20210815113221217"></p>
<h4 id="6-再谈方法"><a href="#6-再谈方法" class="headerlink" title="6. 再谈方法"></a>6. 再谈方法</h4><h5 id="6-1-方法的重载"><a href="#6-1-方法的重载" class="headerlink" title="6.1 方法的重载"></a>6.1 方法的重载</h5><ul>
<li><p>重载的概念</p>
<p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p>
</li>
<li><p>重载的特点：</p>
<p>与返回值类型无关，只看参数列表，且参数列表必须不同。(参数个数或参数类 型)。调用时，根据方法参数列表的不同来区别。</p>
</li>
<li><p>重载示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回两个整数的和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br><span class="line"><span class="comment">//返回三个整数的和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span>&#123;<span class="keyword">return</span> x+y+z;&#125;</span><br><span class="line"><span class="comment">//返回两个小数的和</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x+y;&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="6-2-可变个数的形参"><a href="#6-2-可变个数的形参" class="headerlink" title="==6.2 可变个数的形参=="></a>==<strong>6.2 可变个数的形参</strong>==</h5><p>JavaSE 5.0 中提供了Varargs(variable number of arguments)机制，允许直接定 义能和多个实参相匹配的形参。从而，可以用一种更简单的方式，来传递个数可 变的实参。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a ,String[] books)</span></span>;</span><br><span class="line"><span class="comment">//JDK5.0：采用可变个数形参来定义方法，传入多个同一类型变量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> a ,String…books)</span></span>;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>声明格式：==方法名(参数的类型名 …参数名)==</li>
<li> 可变参数：方法参数部分指定类型的参数个数是可变多个：0个，1个或多个</li>
<li>可变个数形参的方法与同名的方法之间，彼此构成重载</li>
<li>==可变参数方法的使用与方法参数部分使用数组是一致的==，所以二者不能同名</li>
<li>方法的参数部分有可变形参，需要放在形参声明的最后</li>
<li>在一个方法的形参位置，最多只能声明一个可变个数形参</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> First;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Xiong</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-08-15-11:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOverload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String[] msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;含字符串数组参数的test方法 &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(String book)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;****与可变形参方法构成重载的test1方法****&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(String ... books)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;****形参长度可变的test1方法****&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TestOverload to = <span class="keyword">new</span> TestOverload();</span><br><span class="line">        <span class="comment">//下面两次调用将执行第二个test方法</span></span><br><span class="line">        to.test1();</span><br><span class="line">        to.test1(<span class="string">&quot;aa&quot;</span> , <span class="string">&quot;bb&quot;</span>);</span><br><span class="line">        <span class="comment">//下面将执行第一个test方法</span></span><br><span class="line">        to.test(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;aa&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><strong>形参长度可变的test1方法</strong></strong><br><strong><strong>形参长度可变的test1方法</strong></strong><br>含字符串数组参数的test方法 </p>
</blockquote>
<h5 id="6-3-方法参数的值传递机制"><a href="#6-3-方法参数的值传递机制" class="headerlink" title="6.3 方法参数的值传递机制"></a>6.3 方法参数的值传递机制</h5><ul>
<li><p>方法，必须由其所在类或对象调用才有意义。若方法含有参数：</p>
<ul>
<li>形参：方法声明时的参数</li>
<li>实参：方法调用时实际传递给形参的参数值</li>
</ul>
</li>
<li><p>Java的实参值如何传入方法</p>
<p>Java里方法的参数传递方式只有一种：值传递。即将实际参数值的副本（复制品）传入方法内，而参数本身不受影响</p>
<ul>
<li><p>形参时基本数据类型：将实参基本数据类型变量的“数据值”传递给形参</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151200848.png" alt="image-20210815120004597"></p>
</li>
<li><p>形参是引用数据类型：将实参引用数据类型变量的“地址值”传递给形参</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151200796.png" alt="image-20210815120025890"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151200065.png" alt="image-20210815120039588"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151206781.png" alt="image-20210815120654063"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151207526.png" alt="image-20210815120718551"></p>
</li>
</ul>
</li>
</ul>
<h4 id="7-OOP特征一：封装与隐藏"><a href="#7-OOP特征一：封装与隐藏" class="headerlink" title="7. OOP特征一：封装与隐藏"></a>7. OOP特征一：封装与隐藏</h4><h5 id="7-1-信息的封装和隐藏"><a href="#7-1-信息的封装和隐藏" class="headerlink" title="7.1 信息的封装和隐藏"></a>7.1 信息的封装和隐藏</h5><p>Java中通过将数据声明为私有的(private)，再提供公共的（public） 方法:getXxx()和setXxx()实现对该属性的操作，以实现下述目的：</p>
<ul>
<li>隐藏一个类中不需要对外提供的实现细节；</li>
<li>使用者只能通过事先定制好的方法来访问数据，可以方便地加入控制逻辑， 限制对属性的不合理操作；</li>
<li>便于修改，增强代码的可维护性；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> legs;<span class="comment">// 将属性legs定义为private，只能被Animal类内部访问</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLegs</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">// 在这里定义方法 eat() 和 move()</span></span><br><span class="line">		<span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; i != <span class="number">2</span> &amp;&amp; i != <span class="number">4</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Wrong number of legs!&quot;</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		legs = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLegs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> legs;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zoo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">		Animal xb = <span class="keyword">new</span> Animal();</span><br><span class="line">		xb.setLegs(<span class="number">4</span>); <span class="comment">// xb.setLegs(-1000);</span></span><br><span class="line">		<span class="comment">//xb.legs = -1000; // 非法</span></span><br><span class="line">		System.out.println(xb.getLegs());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-2-四种访问权限修饰符"><a href="#7-2-四种访问权限修饰符" class="headerlink" title="7.2 四种访问权限修饰符"></a>7.2 四种访问权限修饰符</h5><p>Java权限修饰符public、protected、(缺省)、private置于类的成员定义前， 用来限定对象对该类成员的访问权限。</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>内部类</th>
<th>同一个包</th>
<th>不同包的子类</th>
<th>同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>Yes</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(缺省)</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>public</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
</tbody></table>
<p>对于class的权限修饰只可以用public和default(缺省)。 </p>
<p>public类可以在任意地方被访问。</p>
<p>default类只可以被同一个包内部的类访问。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151213718.png" alt="image-20210815121330304"></p>
<h4 id="8-类的成员之三：构造器"><a href="#8-类的成员之三：构造器" class="headerlink" title="8. 类的成员之三：构造器"></a>8. 类的成员之三：构造器</h4><h5 id="8-1-创建构造器"><a href="#8-1-创建构造器" class="headerlink" title="8.1 创建构造器"></a>8.1 创建构造器</h5><ul>
<li><p>构造器的特征</p>
<ul>
<li>它具有与类相同的名称</li>
<li>它不声明返回值类型。（与声明为void不同）</li>
<li>不能被static、final、synchronized、abstract、native修饰，不能有 return语句返回值</li>
</ul>
</li>
<li><p>构造器的作用：创建对象；给对象进行初始化</p>
<ul>
<li>如：Order o = new Order(); Person p = new Person(“Peter”,15)</li>
<li>如同我们规定每个“人”一出生就必须先洗澡，我们就可以在“人”的 构造器中加入完成“洗澡”的程序代码，于是每个“人”一出生就会自 动完成“洗澡”，程序就不必再在每个人刚出生时一个一个地告诉他们 要“洗澡”了。</li>
</ul>
</li>
<li><p>语法格式</p>
<p>修饰符 类名 (参数列表) { 初始化语句； }</p>
</li>
<li><pre><code class="java">public class Animal &#123;
    private int legs;
    // 构造器
    public Animal() &#123;
        legs = 4;
    &#125; 
    public void setLegs(int i) &#123;
        legs = i;
    &#125;
    public int getLegs() &#123;
        return legs;
    &#125;
&#125;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 创建Animal类的实例：Animal a &#x3D; new Animal(); 调用构造器，将legs初始化为4。</span><br><span class="line"></span><br><span class="line">* 根据参数不同，构造器可以分为如下两类：</span><br><span class="line"></span><br><span class="line">  * 隐式无参构造器（系统默认提供）</span><br><span class="line">  * 显式定义一个或多个构造器（无参、有参）</span><br><span class="line"></span><br><span class="line">* 注意</span><br><span class="line"></span><br><span class="line">  * Java语言中，每个类都至少有一个构造器</span><br><span class="line">  * 默认构造器的修饰符与所属类的修饰符一致</span><br><span class="line">  * 一旦显式定义了构造器，则系统不再提供默认构造器</span><br><span class="line">  * 一个类可以创建多个重载的构造器</span><br><span class="line">  * 父类的构造器不可被子类继承</span><br><span class="line"></span><br><span class="line">##### 8.2 构造器重载</span><br><span class="line"></span><br><span class="line">* 构造器一般用来创建对象的同时初始化对象。如</span><br><span class="line"></span><br><span class="line">  &#96;&#96;&#96;java</span><br><span class="line">  class Person&#123;</span><br><span class="line">  String name;</span><br><span class="line">  int age;</span><br><span class="line">  public Person(String n , int a)&#123; name&#x3D;n; age&#x3D;a;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>构造器重载使得对象的创建更加灵活，方便创建各种不同的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Date d)</span> </span>&#123;<span class="keyword">this</span>(name,age);…&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;…&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Date d)</span> </span>&#123;…&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;…&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造器重载，参数列表必须不同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; 构造器重载举例</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> Date birthDate;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n, <span class="keyword">int</span> a, Date d)</span> </span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		age = a;</span><br><span class="line">		birthDate = d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n, Date d)</span> </span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		birthDate = d;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">		age = <span class="number">30</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="8-3-属性赋值过程"><a href="#8-3-属性赋值过程" class="headerlink" title="8.3 属性赋值过程"></a>8.3 属性赋值过程</h5><ul>
<li><p>赋值的位置： </p>
<p>① 默认初始化 </p>
<p>② 显式初始化 </p>
<p>③ 构造器中初始化 </p>
<p>④ 通过“对象.属性“或“对象.方法”的方式赋值</p>
</li>
<li><p>赋值的先后顺序： ① - ② - ③ - ④</p>
</li>
</ul>
<h5 id="8-4-JavaBean"><a href="#8-4-JavaBean" class="headerlink" title="8.4 JavaBean"></a>8.4 JavaBean</h5><ul>
<li><p>JavaBean是一种Java语言写成的可重用组件。</p>
</li>
<li><p>所谓javaBean，是指符合如下标准的Java类： </p>
<ul>
<li>类是公共的 </li>
<li>有一个无参的公共的构造器 </li>
<li>有属性，且有对应的get、set方法</li>
</ul>
</li>
<li><p>用户可以使用JavaBean将功能、处理、值、数据库访问和其他任何可以 用Java代码创造的对象进行打包，并且其他的开发者可以通过内部的JSP 页面、Servlet、其他JavaBean、applet程序或者应用来使用这些对象。用 户可以认为JavaBean提供了一种随时随地的复制和粘贴的功能，而不用关 心任何改变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBean</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">// 属性一般定义为private</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">JavaBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">		age = a;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span> </span>&#123;</span><br><span class="line">		name = n;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="8-5-UML类图"><a href="#8-5-UML类图" class="headerlink" title="8.5 UML类图"></a>8.5 UML类图</h5><p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151227426.png" alt="image-20210815122714388"></p>
<ol>
<li>+ 表示 public 类型， - 表示 private 类型，#表示protected类型</li>
<li>方法的写法:  方法的类型(+、-) 方法名(参数名： 参数类型)：返回值类型</li>
</ol>
<h4 id="9-关键字：this"><a href="#9-关键字：this" class="headerlink" title="9. 关键字：this"></a>9. 关键字：this</h4><h5 id="9-1-this是什么"><a href="#9-1-this是什么" class="headerlink" title="9.1 this是什么?"></a>9.1 this是什么?</h5><ul>
<li><p>在Java中，this关键字比较难理解，它的作用和其词义很接近。</p>
<ul>
<li>它在方法内部使用，即这个方法所属对象的引用；</li>
<li>它在构造器内部使用，表示该构造器正在初始化的对象。</li>
</ul>
</li>
<li><p>this 可以调用类的属性、方法和构造器</p>
</li>
<li><p>什么时候使用this关键字呢？</p>
<ul>
<li>当在方法内需要用到调用该方法的对象时，就用this。 </li>
<li>具体的：我们可以用this来区分属性和局部变量。 比如：this.name = name;</li>
</ul>
</li>
<li><p>使用this，调用属性、方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; <span class="comment">// 定义Person类</span></span><br><span class="line">	<span class="keyword">private</span> String name ;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age ;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name ; </span><br><span class="line">		<span class="keyword">this</span>.age = age ; </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;姓名：&quot;</span> + name) ;</span><br><span class="line">		<span class="keyword">this</span>.speak();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(“年龄：” + <span class="keyword">this</span>.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><ol>
<li>在任意方法或构造器内，如 果使用当前类的成员变量或成 员方法可以在其前面添加this， 增强程序的阅读性。不过，通 常我们都习惯省略this。</li>
<li>当形参与成员变量同名时， 如果在方法内或构造器内需要 使用成员变量，必须添加this来 表明该变量是类的成员变量 </li>
<li>使用this访问属性和方法时， 如果在本类中未找到，会从父 类中查找 </li>
</ol>
</li>
</ul>
</li>
<li><p>使用this调用本类的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; <span class="comment">// 定义Person类</span></span><br><span class="line">	<span class="keyword">private</span> String name ;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age ;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123; <span class="comment">// 无参构造器</span></span><br><span class="line">		System.out.println(<span class="string">&quot;新对象实例化&quot;</span>) ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(); <span class="comment">// 调用本类中的无参构造器</span></span><br><span class="line">		<span class="keyword">this</span>.name = name ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>(name) ; <span class="comment">// 调用有一个参数的构造器</span></span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;姓名：&quot;</span> + name + <span class="string">&quot;，年龄：&quot;</span> + age ;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ol start="4">
<li>.this可以作为一个类中 构造器相互调用的特殊 格式</li>
</ol>
</li>
</ul>
</li>
<li><p>注意：</p>
<ul>
<li>可以在类的构造器中使用”this(形参列表)”的方式，调用本类中重载的其 他的构造器！</li>
<li>明确：构造器中不能通过”this(形参列表)”的方式调用自身构造器</li>
<li>如果一个类中声明了n个构造器，则最多有 n - 1个构造器中使用了 “this(形参列表)”</li>
<li>“this(形参列表)”必须声明在类的构造器的首行！</li>
<li>在类的一个构造器中，最多只能声明一个”this(形参列表)”</li>
</ul>
</li>
</ul>
<h4 id="10-关键字：package、import"><a href="#10-关键字：package、import" class="headerlink" title="10. 关键字：package、import"></a>10. 关键字：package、import</h4><h5 id="10-1-关键字—package"><a href="#10-1-关键字—package" class="headerlink" title="10.1 关键字—package"></a>10.1 关键字—package</h5><ul>
<li><p>package语句作为Java源文件的第一条语句，指明该文件中定义的类所在 的包。(若缺省该语句，则指定为无名包)。它的格式为： package 顶层包名.子包名 ;</p>
<p>举例：pack1\pack2\PackageTest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pack1.pack2; <span class="comment">//指定类PackageTest属于包pack1.pack2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;in method display()&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>包对应于文件系统的目录，package语句中，用 “.” 来指明包(目录)的层次；</p>
<p>包通常用小写单词标识。通常使用所在公司域名的倒置：com.baiduu.xxx</p>
</li>
<li><p>源文件布局：</p>
<ul>
<li><p>Java源文件基本语法</p>
<p>[&lt;包声明&gt;]</p>
<p>​    [&lt;导入声明&gt;]</p>
<p>​    &lt;类声明&gt;+</p>
</li>
<li><p>示例，VehicleCapacityReport.java文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> shipping.reports;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shipping.domain.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VehicleCapacityReport</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List vehicles;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateReport</span><span class="params">(Writer output)</span></span>&#123; ...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p><strong>包的作用：</strong></p>
<ul>
<li><p>包帮助管理大型软件系统：将功能相近的类划分到同一个包中。比如：MVC的设计模式</p>
</li>
<li><p>包可以包含类和子包，划分项目层次，便于管理</p>
</li>
<li><p>解决类命名冲突的问题</p>
</li>
<li><p>控制访问权限</p>
<p>例：某航运软件系统包括：一组域对象、GUI和reports子系统</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151242664.png" alt="image-20210815124245134"></p>
</li>
</ul>
<p><strong>MVC设计模式</strong></p>
<p>MVC是常用的设计模式之一，将整个程序分为三个层次：==视图模型层，控制器层，与数据模型层==。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式 使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程 序的耦合性。<img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151243920.png" alt="image-20210815124347443"></p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108151244461.png" alt="image-20210815124423340"> </p>
<p><strong>JDK中主要的包介绍</strong></p>
<ol>
<li>java.lang—-包含一些Java语言的核心类，如String、Math、Integer、 System和 Thread，提供常用功能</li>
<li>java.net—-包含执行与网络相关的操作的类和接口。</li>
<li>java.io —-包含能提供多种输入/输出功能的类。</li>
<li>java.util—-包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日 期日历相关的函数。</li>
<li>java.text—-包含了一些java格式化相关的类</li>
<li>java.sql—-包含了java进行JDBC数据库编程的相关类/接口</li>
<li>java.awt—-包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这 些类被用来构建和管理应用程序的图形用户界面(GUI)。 B/S C/S</li>
</ol>
<h5 id="10-2-关键字—import"><a href="#10-2-关键字—import" class="headerlink" title="10.2 关键字—import"></a>10.2 关键字—import</h5><ul>
<li>为使用定义在不同包中的Java类，需用import语句来引入指定包层次下所需要的类 或全部类(.*)。import语句告诉编译器到哪里去寻找类。</li>
<li>语法格式： import 包名. 类名;</li>
<li>注意<ol>
<li>在源文件中使用import显式的导入指定包下的类或接口 </li>
<li> 声明在包的声明和类的声明之间。 </li>
<li> 如果需要导入多个类或接口，那么就并列显式多个import语句即可 </li>
<li> 举例：可以使用java.util.*的方式，一次性导入util包下所有的类或接口。 </li>
<li> 如果导入的类或接口是java.lang包下的，或者是当前包下的，则可以省略此import语句。 </li>
<li> 如果在代码中使用不同包下的同名的类。那么就需要使用类的全类名的方式指明调用的 是哪个类。 </li>
<li> 如果已经导入java.a包下的类。那么如果需要使用a包的子包下的类的话，仍然需要导入。 </li>
<li> import static组合的使用：调用指定类或接口下的静态的属性或方法</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>06-面向对象编程（下）</title>
    <url>/2021/08/15/06-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<span id="more"></span>

<h3 id="06—面向对象编程（下）"><a href="#06—面向对象编程（下）" class="headerlink" title="06—面向对象编程（下）"></a>06—面向对象编程（下）</h3><h4 id="1-关键字：static"><a href="#1-关键字：static" class="headerlink" title="1. 关键字：static"></a>1. 关键字：static</h4><p>​          当我们编写一个类时，其实就是在描述其对象的属性和行为，而并没有产生实质上的对象，只有通过new关键字才会产生出对象，这时系统才会分配内存空间给对象， 其方法才可以供外部调用。我们有时候希望无论是否产生了对象或无论产生了多少 对象的情况下，某些特定的数据在内存空间里只有一份，例如所有的中国人都有个 国家名称，每一个中国人都共享这个国家名称，不必在每一个中国人的实例对象中 都单独分配一个用于代表国家名称的变量。</p>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210530224607.png" alt="image-20210530224606173" style="zoom:50%;" />

<ul>
<li>static：静态的</li>
<li>static可以用来修饰：==属性、方法、代码块、内部类==</li>
</ul>
<h5 id="1-1-static关键字的修饰属性"><a href="#1-1-static关键字的修饰属性" class="headerlink" title="1.1 static关键字的修饰属性"></a>1.1 static关键字的修饰属性</h5><ul>
<li><p>使用static修饰属性：静态变量（==类变量==）</p>
<ul>
<li><p>属性，按是否使用static修饰，又分为：静态属性 vs 非静态属性（实例变量）</p>
<ul>
<li>实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</li>
<li>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210628163408.png" alt="image-20210628163357103" style="zoom: 67%;" />
</li>
</ul>
</li>
<li><p>static修饰属性的其他说明：</p>
<ul>
<li><p>静态变量随着类的加载而加载。可以通过“类.静态变量”的方式进行调用   如：<code>System.out</code></p>
</li>
<li><p>静态变量的加载要早于对象的创建。</p>
</li>
<li><p>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</p>
<ul>
<li><table>
<thead>
<tr>
<th></th>
<th>类变量</th>
<th>实例变量</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>类.类变量</td>
<td>×</td>
</tr>
<tr>
<td>对象</td>
<td>对象.类变量</td>
<td>对象.实例变量</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</li>
<li><p>静态属性举例：System.out ; Math.PI ; </p>
</li>
</ul>
</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210628165522.png" alt="image-20210628165519723" style="zoom:80%;" />

</li>
</ul>
<h5 id="1-2-static关键字的修饰方法"><a href="#1-2-static关键字的修饰方法" class="headerlink" title="1.2 static关键字的修饰方法"></a>1.2 static关键字的修饰方法</h5><ul>
<li><p>使用static修饰方法：静态方法</p>
<ul>
<li><p>随着类的加载而加载，可以通过“类.静态方法”的方式进行调用</p>
<ul>
<li><table>
<thead>
<tr>
<th></th>
<th>静态方法</th>
<th>非静态方法</th>
</tr>
</thead>
<tbody><tr>
<td>类</td>
<td>类.静态方法</td>
<td>×</td>
</tr>
<tr>
<td>对象</td>
<td>对象.静态方法</td>
<td>对象.非静态方法</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>静态方法中，==只能==调用静态的方法或属性，非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210710133901.png" alt="image-20210710133850210"></p>
</li>
<li><p>static注意点：</p>
<ul>
<li>==在静态方法内，不能使用this关键字、super关键字==</li>
<li>关于静态属性和静态方法的使用，从生命周期的角度去理解（晚出生的可以调用早出生的，早出生的不能调晚出生的）</li>
</ul>
</li>
<li><p>开发中，如何确定一个属性是否要声明未static</p>
<p>​        属性是可以被多个对象所共享的，不回随着对象的不同而不同</p>
<p>开发中，如何确定一个方法是否要声明为static</p>
<p>​        操作静态属性的方法，通常设置为static的</p>
<p>​        工具类中的方法，习惯上声明为static。比如Math、Arrays、Collections</p>
</li>
</ul>
</li>
</ul>
<p><strong>注意</strong></p>
<p>​        静态方法可以被继承，但是，不能被覆盖，即重写。如果父类中定义的静态方法在子类中被重新定义，那么在父类中定义的静态方法将被隐藏。可以使用语法：父类名.静态方法调用隐藏的静态方法。 </p>
<p>​        如果父类中含有一个静态方法，且在子类中也含有一个返回类型、方法名、参数列表均与之相同的静态方法，那么该子类实际上只是将父类中的该同名方法进行了隐藏，而非重写。换句话说，父类和子类中含有的其实是两个没有关系的方法，它们的行为也并不具有多态性 </p>
<p>​        因此，通过一个指向子类对象的父类引用变量来调用父子同名的静态方法时，只会调用父类的静态方法。</p>
<h5 id="1-3-单例模式"><a href="#1-3-单例模式" class="headerlink" title="1.3 单例模式"></a>1.3 单例模式</h5><p><strong>设计模式</strong></p>
<p>在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式免去我们自己思考和摸索。</p>
<p><strong>单例设计模式</strong></p>
<p>采取一定的方法，保证在整个的软件系统中，对某个类==只能存在一个对象实例==，并且该类只提供一个取得其对象实例的方法。如果我们要让类在虚拟机中只能产生一个对象，我们首先必须将类的==构造器的访问权限设置为private==，这样，就不能用new操作符在类的外部产生类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始无法得到类的对象，只能==调用该类的某个静态方法==以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的==该类对象的变量也必须定义成静态的。==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单例饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//此时的bank1与bank2指向的是同一个对象</span></span><br><span class="line">        Bank bank1 = Bank.getInstance();</span><br><span class="line">        Bank bank2 = Bank.getInstance();</span><br><span class="line">        System.out.println(bank1 == bank2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.私有化类的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.内部创建类的对象，此对象也必须为静态的，否则静态方法里无法对其进行返回</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Bank instance = <span class="keyword">new</span> Bank();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.提供公共的静态方法，返回类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单例懒汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Order Order1 = Order.getInstance();</span><br><span class="line">        Order Order2 = Order.getInstance();</span><br><span class="line">        System.out.println(Order1 == Order2);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line">	<span class="comment">//1.私有化类的构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.声明对象，并不进行初始化，否则静态方法里无法对其进行初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Order instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">             instance = <span class="keyword">new</span> Order();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p><strong>饿汉式 vs 懒汉式</strong></p>
<ul>
<li><p>饿汉式：</p>
<ul>
<li>坏处：对象加载时间过长</li>
<li>好处：饿汉式是线程安全的</li>
</ul>
</li>
<li><p>懒汉式：</p>
<ul>
<li>好处：延迟对象创建</li>
<li>坏处：目前写法是不安全的<ul>
<li>例如，一个线程在调用getInstance()时，判断完if，准备新建对象，另一个线程也同样进行到if里，最后导致新建出两个对象。</li>
</ul>
</li>
</ul>
</li>
<li><p>单例模式的优点：：</p>
<ul>
<li>由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的 产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可 以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方 式来解决。</li>
</ul>
</li>
<li><p>举例 java.lang.Runtime</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108152054366.png" alt="image-20210815205450550"></p>
</li>
</ul>
<p><strong>应用场景</strong></p>
<ol>
<li>网站的计数器，一般也是单例模式实现，否则难以同步。</li>
<li>应用程序的日志应用，一般都使用单例模式实现，这一般是由于共享的日志 文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。</li>
<li>数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库 资源。</li>
<li>项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置 文件数据，都生成一个对象去读取。</li>
<li>Application 也是单例的典型应用</li>
<li>Windows的Task Manager (任务管理器)就是很典型的单例模式</li>
<li>Windows的Recycle Bin (回收站)也是典型的单例应用。在整个系统运行过程 中，回收站一直维护着仅有的一个实例。</li>
</ol>
<h4 id="2-理解main方法的语法"><a href="#2-理解main方法的语法" class="headerlink" title="2. 理解main方法的语法"></a>2. 理解main方法的语法</h4><p>​          由于Java虚拟机需要调用类的main()方法，所以该方法的访问权限必须是 public，又因为Java虚拟机在执行main()方法时不必创建对象，所以该方法必须 是static的，该方法接收一个String类型的数组参数，该数组中保存执行Java命令 时传递给所运行的类的参数。</p>
<p>​            又因为main() 方法是静态的，我们不能直接访问该类中的非静态成员，必须创 建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员，这种情 况，我们在之前的例子中多次碰到。</p>
<h5 id="2-1-命令行参数用法举例"><a href="#2-1-命令行参数用法举例" class="headerlink" title="2.1 命令行参数用法举例"></a>2.1 命令行参数用法举例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandPara</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;args[&quot;</span> + i + <span class="string">&quot;] = &quot;</span> + args[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//运行程序CommandPara.java java CommandPara “Tom” “Jerry”  </p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108152059228.png" alt="image-20210815205937678"> </p>
<p>输出结果：</p>
<blockquote>
<p>args[0] = Tom<br>args[1] = Jerry</p>
</blockquote>
<p><strong>面试题</strong></p>
<p>此处，Something类的文件名叫OtherThing.java </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] something_to_do)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Do something ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述程序是否可以正常编译、运行？</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108152107280.png" alt="image-20210815210742392"></p>
<h4 id="3-类的成员之四：代码块"><a href="#3-类的成员之四：代码块" class="headerlink" title="3. 类的成员之四：代码块"></a>3. 类的成员之四：代码块</h4><ul>
<li><p>代码块(或初始化块)的作用：</p>
<ul>
<li>对Java类或对象进行初始化</li>
</ul>
</li>
<li><p>代码块(或初始化块)的分类：</p>
<ul>
<li>一个类中代码块若有修饰符，则只能被static修饰，称为静态代码块 (static block)，没有使用static修饰的，为非静态代码块。</li>
</ul>
</li>
<li><p>static代码块通常用于初始化static的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> total;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		total = <span class="number">100</span>;<span class="comment">//为total赋初值</span></span><br><span class="line">	&#125;</span><br><span class="line">	…… <span class="comment">//其它属性或方法声明</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="3-1-静态代码块"><a href="#3-1-静态代码块" class="headerlink" title="3.1 静态代码块"></a>3.1 静态代码块</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//static的代码块</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello,static block&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部可以有输出语句，==随着类的加载而执行，而且只执行一次==，如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行。静态代码块的执行优先于非静态代码块的执行。静态代码块内只能调用静态的方法、静态的属性，不能调用非静态的结构</p>
<p>作用：初始化类的信息</p>
<h5 id="3-2-非静态代码块"><a href="#3-2-非静态代码块" class="headerlink" title="3.2 非静态代码块"></a>3.2 非静态代码块</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello,block&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部可以有输出语句，==随着对象的创建而执行==，每创建一个对象，就执行一次非静态的代码块.如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行。非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法。</p>
<p>作用：==可以在创建对象时，对对象的属性等进行初始化==</p>
<p>对属性可以赋值的位置以及先后顺序：</p>
<p>①默认初始化，②显式初始化；在代码块中赋值，③构造器中初始化，④有了对象以后，可以通过“对象.属性”或”对象.方法”的方式进行赋值</p>
<h5 id="3-3-代码块执行顺序测试"><a href="#3-3-代码块执行顺序测试" class="headerlink" title="3.3 代码块执行顺序测试"></a>3.3 代码块执行顺序测试</h5><p>LeafTest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Root</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mid</span> <span class="keyword">extends</span> <span class="title">Root</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mid</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">		<span class="comment">//通过this调用同一类中重载的构造器</span></span><br><span class="line">		<span class="keyword">this</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的带参数构造器，其参数值：&quot;</span>+ msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Mid</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//通过super调用父类中有一个字符串参数的构造器</span></span><br><span class="line">		<span class="keyword">super</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeafTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Leaf(); </span><br><span class="line">		System.out.println();</span><br><span class="line">		<span class="keyword">new</span> Leaf();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出结果：</p>
<p>Root的静态初始化块<br>Mid的静态初始化块<br>Leaf的静态初始化块<br>Root的普通初始化块<br>Root的无参数的构造器<br>Mid的普通初始化块<br>Mid的无参数的构造器<br>Mid的带参数构造器，其参数值：尚硅谷<br>Leaf的普通初始化块<br>Leaf的构造器</p>
<p>Root的普通初始化块<br>Root的无参数的构造器<br>Mid的普通初始化块<br>Mid的无参数的构造器<br>Mid的带参数构造器，其参数值：尚硅谷<br>Leaf的普通初始化块<br>Leaf的构造器</p>
</blockquote>
<p>==总结==：对于继承的的方法来讲，首先会加载父类，而静态代码块是在类加载时加载的，所以对于==新建子类对象时==，会==先从最高一级的父类静态代码块开始加载==。然后==再从最高一级的父类非静态代码块和无参构造器逐级加载==（因为对于没显式写有this()的方法，会隐式的调用super() ）。</p>
<p>Son.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;11111111111&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;22222222222&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;33333333333&quot;</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;44444444444&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;55555555555&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;66666666666&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// 由父及子 静态先行</span></span><br><span class="line">		System.out.println(<span class="string">&quot;77777777777&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;|++++++++++++++++++++++|&quot;</span>);</span><br><span class="line">		<span class="keyword">new</span> Son();</span><br><span class="line">		System.out.println(<span class="string">&quot;|++++++++++++++++++++++|&quot;</span>);</span><br><span class="line">		<span class="keyword">new</span> Son();</span><br><span class="line">		System.out.println(<span class="string">&quot;|++++++++++++++++++++++|&quot;</span>);</span><br><span class="line">		<span class="keyword">new</span> Father();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>11111111111<br>44444444444<br>77777777777<br>|++++++++++++++++++++++|<br>22222222222<br>33333333333<br>55555555555<br>66666666666<br>|++++++++++++++++++++++|<br>22222222222<br>33333333333<br>55555555555<br>66666666666<br>|++++++++++++++++++++++|<br>22222222222<br>33333333333</p>
</blockquote>
<h4 id="4-关键字：final"><a href="#4-关键字：final" class="headerlink" title="4. 关键字：final"></a>4. 关键字：final</h4><p><strong>final修饰变量</strong></p>
<p><strong>final修饰的变量究竟是怎么个不变性呢</strong></p>
<p>答案就是：==对于final修饰的变量来说，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的，也就是说在对其初始化之后便不能再让其指向另一个对象。==</p>
<h5 id="4-1-final修饰的实例变量"><a href="#4-1-final修饰的实例变量" class="headerlink" title="4.1 final修饰的实例变量"></a>4.1 final修饰的实例变量</h5><ol>
<li>被final修饰的实例变量必须==显示的指定初始值==</li>
<li>对于普通实例变量，Java程序可以对它执行默认的初始化，也就是将实例变量的值指定为默认的初始值0或null，但对于final修饰的实例变量，则必须由程序员显示的赋予初始值。</li>
<li>final实例变量必须显示地被赋初始值，而且本质上final实例变量只能在构造器中被赋初始值。在定义final实例变量时指定初始值，和在初始化块中为final实例变量指定初始值本质上是一样的。除此之外，final实例变量将不能被再次赋值。</li>
</ol>
<p>方法一：直接赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> f1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> String f2 = <span class="string">&quot;you&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二：构造器中赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> f1;</span><br><span class="line">    <span class="keyword">final</span> String f2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalTest</span><span class="params">(<span class="keyword">int</span> f1,String f2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.f1 =f1;</span><br><span class="line">        <span class="keyword">this</span>.f2 = f2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-final修饰的类变量"><a href="#4-2-final修饰的类变量" class="headerlink" title="4.2 final修饰的类变量"></a>4.2 final修饰的类变量</h5><p>对于final类变量而言，同样必须显示指定初始值，而且final类变量只能在2个地方指定初始值：</p>
<ol>
<li><p>定义final类变量时指定初始值；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> calss FinalTest&#123;</span><br><span class="line">    <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在静态初始化块中为final类变量指定初始值；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> calss FinalTest&#123;</span><br><span class="line">   <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两种方式都会被抽取到静态初始化块中赋初始值。定义final类变量时指定初始值和在静态初始化块中为final类变量指定初始值，本质是一样的。除此之外final类变量将不能被再次赋值。</p>
</li>
</ol>
<h5 id="4-3-final修饰局部变量"><a href="#4-3-final修饰局部变量" class="headerlink" title="4.3 final修饰局部变量"></a>4.3 final修饰局部变量</h5><p>final修饰的局部变量一样需要被显式地赋初始值，因为Java本来就要求局部变量必须被显式地赋初始值。与普通变量不同的是，final修饰的局部变量被==赋初始值之后，将不能再被重新赋值。==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> number = num;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> number2;</span><br><span class="line">        number2 = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-4-内部类中的局部变量"><a href="#4-4-内部类中的局部变量" class="headerlink" title="4.4 内部类中的局部变量"></a>4.4 内部类中的局部变量</h5><ol>
<li><p>这里不仅仅是匿名内部类，即使是普通内部类，在任何内部类中访问的局部变量都应该使用final修饰。</p>
</li>
<li><p>此处说的内部类指的是==局部内部类==，只有局部内部类（包括匿名内部类）才可以访问局部变量，普通静态内部类、非静态内部类不可能访问==方法体内的局部变量。==</p>
</li>
<li><p>Java要求所有被内部类访问的局部变量都使用final修饰，对于普通局部变量而言，它的作用域就是停留在该方法内，当方法执行结束，该局部变量也随之消失。但内部类则可能产生隐式的“闭包”闭包将使得局部变量脱离它所在的方法继续存在。</p>
</li>
<li><p>匿名内部类的实例生命周期没有结束的话，将一直可以访问局部变量的值，这就是内部类会扩大局部变量作用域的实例。</p>
</li>
<li><p>由于内部类可能扩大局部变量的作用域，如果再加上这个被内部类访问的局部变量没有使用final修饰，也就是说该变量的值可以随意改变，就会引起大乱。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;<span class="comment">//成员内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            num = <span class="number">100</span>;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m1;<span class="comment">//省略了final</span></span><br><span class="line">        <span class="keyword">int</span>[] m2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];<span class="comment">//省略了final</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">TestInner</span></span>&#123;<span class="comment">//局部内部类</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="comment">//      m1 = 10;//Variable &#x27;m1&#x27; is accessed from within inner class, needs to be final or effectively final</span></span><br><span class="line">                m2[<span class="number">0</span>] = <span class="number">100</span>;<span class="comment">//指向的对象没有变，但是对象里的内容可以更改</span></span><br><span class="line">                m2[<span class="number">0</span>] = <span class="number">1000</span>;<span class="comment">//指向的对象没有变，但是对象里的内容可以更改</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ol>
<p> <strong>因此Java编译器要求所有被内部类访问的局部变量必须使用final修饰</strong></p>
<p><strong>总而言之：</strong></p>
<ol>
<li><p>final修饰符的第一简单的功能就是一旦被赋初始值，将不可改变。</p>
</li>
<li><p>final的另一个简单的功能就是在定义了该final类变量时指定了初始值，且该初始值可以在编译时就被确定下来，系统将不会在静态初始化块中对该类变量赋初始值，而将是在类定义中直接使用该初始化值代替该final变量。</p>
</li>
<li><p>对于一个使用final修饰的变量而言，如果定义该final变量时就指定初始值，而且这个初始值可以在编译时就确定下来，那么这个final变量将不再是一个变量，系统会将其变成“宏变量”处理。所有出现该变量的地方，系统将直接把它当成对应的值处理。</p>
</li>
</ol>
<h4 id="5-抽象类与抽象方法"><a href="#5-抽象类与抽象方法" class="headerlink" title="5. 抽象类与抽象方法"></a>5. 抽象类与抽象方法</h4><h5 id="5-1-抽象类与抽象方法的概念"><a href="#5-1-抽象类与抽象方法的概念" class="headerlink" title="5.1 抽象类与抽象方法的概念"></a>5.1 抽象类与抽象方法的概念</h5><p>​          随着继承层次中一个个新子类的定义，类变得越来越具体，而父类则更一 般，更通用。类的设计应该保证父类和子类能够共享特征。有时将一个父 类设计得非常抽象，以至于它没有具体的实例，这样的类叫做抽象类。</p>
<p><img src="https://gitee.com/xiongzero/PicGo/raw/master/img/202108152152520.png" alt="image-20210815215240015"></p>
<ul>
<li><p>用abstract关键字来修饰一个类，这个类叫做抽象类。</p>
</li>
<li><p>用abstract来修饰一个方法，该方法叫做抽象方法。</p>
<ul>
<li><p>抽象方法：只有方法的声明，没有方法的实现。以分号结束： </p>
<p>比如：public abstract void talk();</p>
</li>
</ul>
</li>
<li><p>含有抽象方法的类必须被声明为抽象类。</p>
</li>
<li><p>抽象类不能被实例化。抽象类是用来被继承的，抽象类的子类必须重 写父类的抽象方法，并提供方法体。若没有重写全部的抽象方法，仍 为抽象类。</p>
</li>
<li><p>不能用abstract修饰变量、代码块、构造器；</p>
</li>
<li><p>不能用abstract修饰私有方法、静态方法、final的方法、final的类。</p>
</li>
</ul>
<h5 id="5-2-抽象类与抽象方法的使用"><a href="#5-2-抽象类与抽象方法的使用" class="headerlink" title="5.2 抽象类与抽象方法的使用"></a>5.2 抽象类与抽象方法的使用</h5><p>abstract关键字的使用</p>
<p>1.abstract可以用来修饰的结构：类、方法</p>
<p>2.abstract修饰类：抽象类</p>
<ul>
<li>此类不能实例化</li>
<li>抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</li>
<li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关操作</li>
</ul>
<p>3.abstract修饰方法：抽象方法</p>
<ul>
<li>抽象方法只有方法的声明，没有方法体</li>
<li>包含抽象方法的类，一定是个抽象类。反之抽象类不一定包含抽象方法</li>
<li>若子类重写了父类中的所有抽象方法后，此子类方可实例化，若子类没有重写父类中的==所有抽象方法==，则此子类也是一个抽象类，需要用abstract修饰。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//一旦Person类抽象了，就不可以实例化</span></span><br><span class="line">        <span class="comment">// Person p1 = new Person();</span></span><br><span class="line">        <span class="comment">// p1.walk();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人走路&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生应该多吃有营养的食物。&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-多态的应用：模板方法设计模式"><a href="#5-3-多态的应用：模板方法设计模式" class="headerlink" title="5.3 多态的应用：模板方法设计模式"></a>5.3 多态的应用：模板方法设计模式</h5><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。</p>
<p>解决的问题：</p>
<ul>
<li>当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</li>
<li>换句话说，在软件开发中实现一个算法时，整体步骤很容易固定、通用，这些步骤在父类写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</li>
</ul>
<p><strong>使用模板方法计算某个抽象方法执行所需时间</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SubTemplate subTemplate = <span class="keyword">new</span> SubTemplate();</span><br><span class="line">		subTemplate.spendTime();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Template</span></span>&#123;</span><br><span class="line">	<span class="comment">//计算某段代码执行所需花费的时间</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">spendTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">this</span>.code();<span class="comment">//不确定的部分，易变的部分</span></span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;花费时间是:&quot;</span>+(end - start));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubTemplate</span> <span class="keyword">extends</span> <span class="title">Template</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">boolean</span> isFlag = <span class="keyword">true</span> ;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= Math.sqrt(i); j++ ) &#123;</span><br><span class="line">				<span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">					isFlag = <span class="keyword">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(isFlag) &#123;</span><br><span class="line">				System.out.println(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-接口-interface"><a href="#6-接口-interface" class="headerlink" title="6. 接口(interface)"></a>6. 接口(interface)</h4><h5 id="6-1-接口概述"><a href="#6-1-接口概述" class="headerlink" title="6.1 接口概述"></a>6.1 接口概述</h5><ul>
<li>一方面，有时候必须从几个类中派生出一个子类，继承它们所有的属性和方法。但是，Java不支持多重继承。有了接口，就可以得到多重继承的效果。</li>
<li>另一方面，有时必须从几个类中抽取一些共同的特征行为，而它们之间又没有is-a的关系，仅仅是具有相同的行为特征而已。例如：鼠标、键盘、打印机……都支持USB连接。</li>
<li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是/要……则必须能……”的思想，==继承是一个“是不是”的关系，而接口实现的则是“能不能”的关系==</li>
<li>==接口的本质是契约，标准，规范==</li>
</ul>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210703195906.png" alt="image-20210703195856881" style="zoom:67%;" />

<h5 id="6-2-接口的使用"><a href="#6-2-接口的使用" class="headerlink" title="6.2 接口的使用"></a>6.2 接口的使用</h5><ol>
<li><p>接口使用interface来定义</p>
</li>
<li><p>Java中，接口和类是并列的两个结构</p>
</li>
<li><p>如何定义接口：定义接口中的成员</p>
<ol>
<li>JDK7及以前：只能定义全局常量和抽象方法<ol>
<li>全局常量：public static final的，但是书写时可以省略不写。</li>
<li>抽象方法：public abstract的，但是书写时可以省略不写</li>
<li><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210703202801.png" alt="image-20210703202800208" style="zoom:150%;" /></li>
</ol>
</li>
<li>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</li>
</ol>
</li>
<li><p>==接口中不能定义构造器==，此举意味着接口不可以实例化。</p>
</li>
<li><p>Java开发中，接口通过类去实现（implements）的方式来使用。</p>
<ol>
<li>如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化</li>
<li>如果实现类没有覆盖接口中的所有抽象方法，则此实现类仍为一个抽象类</li>
</ol>
</li>
<li><p>Java类可以实现多个接口—&gt;弥补了Java的多继承</p>
<ol>
<li><p>格式==class AA extends BB implements CC,DD,EE{==</p>
<p>​         ==}==</p>
</li>
</ol>
</li>
<li><p>==接口与接口之间可以继承，而且可以多继承==</p>
</li>
<li><p>接口的具体使用，体现多态性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USBTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        <span class="comment">//方式一：创建接口的非匿名实现类的非匿名对象</span></span><br><span class="line">        Flash flash = <span class="keyword">new</span> Flash();</span><br><span class="line">        computer.transferData(flash);</span><br><span class="line">        System.out.println(<span class="string">&quot;********************************&quot;</span>);</span><br><span class="line">        <span class="comment">//方式二：创建接口的非匿名实现类的匿名对象</span></span><br><span class="line">        computer.transferData(<span class="keyword">new</span> Flash());</span><br><span class="line">        System.out.println(<span class="string">&quot;********************************&quot;</span>);</span><br><span class="line">        <span class="comment">//方式三：创建接口的匿名实现类的非匿名对象</span></span><br><span class="line">        USB phone = <span class="keyword">new</span> USB()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;手机接入，开始工作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;手机结束传输&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        computer.transferData(phone);</span><br><span class="line">        System.out.println(<span class="string">&quot;********************************&quot;</span>);</span><br><span class="line">        <span class="comment">//方式四：创建接口的匿名实现类的匿名对象</span></span><br><span class="line">        computer.transferData(<span class="keyword">new</span> USB()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;未知设备接入，开始工作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;未知设备传输完成&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">USB</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flash</span> <span class="keyword">implements</span> <span class="title">USB</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Flash接入设备，传输准备&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Flash传输结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transferData</span><span class="params">(USB usb)</span></span>&#123;</span><br><span class="line">        usb.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;具体传输细节&quot;</span>);</span><br><span class="line">        usb.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210703213324.png" alt="image-20210703213322669" style="zoom:80%;" />
</li>
<li><p>接口，实际上可以看作一种规范，在开发中体现面向接口编程</p>
</li>
</ol>
<h5 id="6-3-接口应用：代理模式-amp-工厂模式"><a href="#6-3-接口应用：代理模式-amp-工厂模式" class="headerlink" title="6.3  接口应用：代理模式 &amp; 工厂模式"></a>6.3  接口应用：代理模式 &amp; 工厂模式</h5><p><strong>代理模式</strong></p>
<p>代理模式是Java开发中使用较多的一种设计模式。代理模式设计就是为其他对象提供一种代理，以控制这个对象的访问。</p>
<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210704125216.webp" alt="img" style="zoom: 40%;" /><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210704125145.webp" alt="img" style="zoom: 80%;" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetWorkTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Server server = <span class="keyword">new</span> Server();</span><br><span class="line">        ProxyServer proxyServer = <span class="keyword">new</span> ProxyServer(server);</span><br><span class="line"></span><br><span class="line">        proxyServer.browse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Server</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;真实的服务器访问网络&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyServer</span> <span class="keyword">implements</span> <span class="title">NetWork</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NetWork netWork;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyServer</span><span class="params">(NetWork netWork)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.netWork = netWork;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;启用网络服务前的检查工作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">browse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        check();</span><br><span class="line">        netWork.browse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<ul>
<li>安全代理：屏蔽对真实角色的直接访问</li>
<li>远程代理：通过代理类处理远程方法的调用(RMI)</li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对现象</li>
</ul>
<p>比如要开发一个大文档查看软件，大文档中有大得图片，有可能一个图片有100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用Proxy来进行大图片的打开</p>
<ul>
<li>分类<ul>
<li>静态代理（静态定义代理类）</li>
<li>动态代理（动态生成代理类）<ul>
<li>JDK自带的动态代理类，需要反射等知识</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="6-4-接口笔试题"><a href="#6-4-接口笔试题" class="headerlink" title="6.4 接口笔试题"></a>6.4 接口笔试题</h5><p>[面试题]排错</p>
<p>题目1.接口与类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pX</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">// System.out.println(x); 出现错误，不明确的x</span></span><br><span class="line">       System.out.println(<span class="keyword">super</span>.x);<span class="comment">//1</span></span><br><span class="line">       System.out.println(A.x);<span class="comment">//0 接口中的都为static,可以通过“接口名.属性&quot;进行调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> C().pX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>知识点：如果一个类需要调用父类中重名的属性，则可以使用”super.属性”进行调用，同时应该注意，不存在”super.super…”的用法，换言之，子类只能调用直接父类中的属性，而不能调用父类的父类的属性。（在开发中，尽量不要写重名的属性）</p>
<p>如果接口的实现类，要调用接口中的属性，可以使用”接口.属性”的方式进行调用，因为接口中的属性全部为static final </p>
</blockquote>
<p>题目2.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Playable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bounceable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Rollable</span> <span class="keyword">extends</span> <span class="title">Playable</span>,<span class="title">Bounceable</span> </span>&#123;</span><br><span class="line">    Ball ball = <span class="keyword">new</span> Ball(<span class="string">&quot;PingPang&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> <span class="keyword">implements</span> <span class="title">Rollable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Ball</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// ball = new Ball(&quot;Football&quot;);    接口中的ball是final的，无法对其进行改变</span></span><br><span class="line">        System.out.println(ball.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-5-抽象类与接口的问题"><a href="#6-5-抽象类与接口的问题" class="headerlink" title="6.5 抽象类与接口的问题"></a>6.5 抽象类与接口的问题</h5><ol>
<li><p>abstract 能修饰哪些结构？ 修饰以后，有什么特点？</p>
<p>类、方法。<br>类不能实例化，提供子类<br>抽象方法，只定义了一种功能的标准。具体的执行，需要子类去实现。</p>
</li>
<li><p>接口是否能继承接口? 抽象类是否能实现(implements)接口? 抽象类是否能继承非抽象的类? </p>
<p>能，能，能</p>
</li>
<li><p>声明抽象类，并包含抽象方法。测试类中创建一个继承抽象类的匿名子类的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方式一：</span></span><br><span class="line"><span class="keyword">abstract</span> AA&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">   	AA a = <span class="keyword">new</span> AA()&#123;</span><br><span class="line">    	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">	a.m();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二： </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"> String name;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">	Person p = <span class="keyword">new</span> Person()&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    p.eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象类和接口有哪些共同点和区别？ </p>
<p>相同点：不能实例化，都可以被继承<br>不同点：抽象类：有构造器。 接口：不能声明构造器<br>多继承vs 单继承 </p>
</li>
</ol>
<h4 id="7-类的成员只五：内部类"><a href="#7-类的成员只五：内部类" class="headerlink" title="7. 类的成员只五：内部类"></a>7. 类的成员只五：内部类</h4><ul>
<li><p>当一个事物的内部，还有一个部分需要一个完整的结构进行描述，而这个内部类的完整结构又只为外部事物提供服务，那么整个内部的完整结构最好使用内部类</p>
</li>
<li><p>在Java中，允许一个类的定义谓语另一个类的内部，前者称为==内部类==，后者称为==外部类==。</p>
</li>
<li><p>Inner class一般用在定义它的类或语句块之内，在外部引用它时，必须给出完整的名称</p>
<ul>
<li>==Inner class的名字不能与包含它的外部类类名相同；==</li>
</ul>
</li>
<li><p>分类：==成员内部类==（static成员内部类和非static成员内部类)</p>
<p>​           ==局部内部类==（不谈修饰符）、匿名内部类</p>
</li>
</ul>
<h5 id="7-1-成员内部类"><a href="#7-1-成员内部类" class="headerlink" title="7.1 成员内部类"></a>7.1 成员内部类</h5><ul>
<li><p>成员内部类作为类的成员的角色：</p>
<ul>
<li>和外部类不同，Inner class还可以声明为private或protected；</li>
<li>可以调用外部类的结构</li>
<li>Inner class 可以声明为static的，但此时就不能再使用外层类的非static的成员变量；</li>
</ul>
</li>
<li><p>成员内部类作为类的角色：</p>
<ul>
<li>可以在内部定义属性、方法、构造器等结构</li>
<li>可以声明为abstract类 ，因此可以被其它的内部类继承</li>
<li>可以声明为final的</li>
<li>编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员 内部类中才可声明static成员。</li>
<li>外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式</li>
<li>成员内部类可以直接使用外部类的所有成员，包括私有的数据</li>
<li>当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的</li>
</ul>
</li>
<li><p>举例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> s;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mb</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			s = <span class="number">100</span>;</span><br><span class="line">			System.out.println(<span class="string">&quot;在内部类Inner中s=&quot;</span> + s);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ma</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Inner i = <span class="keyword">new</span> Inner();</span><br><span class="line">		i.mb();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">		Outer o = <span class="keyword">new</span> Outer();</span><br><span class="line">		o.ma();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> s = <span class="number">111</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">int</span> s = <span class="number">222</span>;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mb</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">			System.out.println(s); <span class="comment">// 局部变量s</span></span><br><span class="line">			System.out.println(<span class="keyword">this</span>.s); <span class="comment">// 内部类对象的属性s</span></span><br><span class="line">			System.out.println(Outer.<span class="keyword">this</span>.s); <span class="comment">// 外部类对象属性s</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">		Outer a = <span class="keyword">new</span> Outer();</span><br><span class="line">		Outer.Inner b = a.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">		b.mb(<span class="number">333</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="7-2-局部内部类"><a href="#7-2-局部内部类" class="headerlink" title="7.2 局部内部类"></a>7.2 局部内部类</h5><ul>
<li><p>如何声明局部内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类</span>&#123;</span><br><span class="line">	方法()&#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> 局部内部类</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> 局部内部类</span>&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>如何使用局部内部类</p>
<ul>
<li>只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方 都不能使用该类</li>
<li>但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类 的父类或父接口类型</li>
</ul>
</li>
<li><p>局部内部类的特点</p>
<ul>
<li>内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但 是前面冠以外部类的类名和$符号，以及数字编号。</li>
<li>只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方 都不能使用该类。</li>
<li>局部内部类可以使用外部类的成员，包括私有的。</li>
<li>局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局 部变量的声明周期不同所致。</li>
<li> 局部内部类和局部变量地位类似，不能使用public,protected,缺省,private</li>
<li>局部内部类不能使用static修饰，因此也不能包含静态成员</li>
</ul>
</li>
</ul>
<h5 id="7-3-匿名内部类"><a href="#7-3-匿名内部类" class="headerlink" title="7.3 匿名内部类"></a>7.3 匿名内部类</h5><p>​          匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一 个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或 实现一个类。</p>
<ul>
<li><p>格式： </p>
<p>new 父类构造器（实参列表）|  实现接口(){ </p>
<p>​        //匿名内部类的类体部分</p>
<p>}</p>
</li>
<li><p>匿名内部类的特点</p>
<ul>
<li>匿名内部类必须继承父类或实现接口</li>
<li>匿名内部类只能有一个对象</li>
<li>匿名内部类对象只能使用多态形式引用</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Outer().callInner(<span class="keyword">new</span> A()&#123;</span><br><span class="line">			<span class="comment">//接口是不能new但此处比较特殊是子类对象实现接口，只不过没有为对象取名</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(“implement <span class="keyword">for</span> fun1<span class="string">&quot;);</span></span><br><span class="line"><span class="string">			&#125;</span></span><br><span class="line"><span class="string">		&#125;);// 两步写成一步了</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">	public void callInner(A a) &#123;</span></span><br><span class="line"><span class="string">		a.fun1();</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="7-4-内部类的使用"><a href="#7-4-内部类的使用" class="headerlink" title="7.4 内部类的使用"></a>7.4 内部类的使用</h5><p>成员内部类和局部内部类，在编译以后，都会生成字节码文件。</p>
<p>格式：成员内部类：外部类$内部类名.class</p>
<p>​            局部内部类：外部类$数字 局部内部类名.class （数字用来表示重名的局部内部类中的第几个 （因为为局部内部类，类名只在局部有效，所以可以定义多个相同的名字，数字只是用来做区分））</p>
<img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210705225526.png" alt="image-20210705225524602" style="zoom:150%;" />

<p><img src="https://gitee.com/xiongzero/alienware_-pic-go/raw/master/img/20210705180139.png" alt="image-20210705180138002"></p>
<p><strong>InnerClassTest.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 内部类;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">类的内部成员之五：内部类</span></span><br><span class="line"><span class="comment">1.Java中允许将一个类A声明在另一个类B里，则类A就是内部类，类B称为外部类</span></span><br><span class="line"><span class="comment">2.内部类分类：成员内部类（静态、非静态） vs 局部内部类</span></span><br><span class="line"><span class="comment">            成员内部类：定义在类里面，方法外面，构造器外面，代码块外面</span></span><br><span class="line"><span class="comment">            局部内部类：方法内，代码块内，构造器内</span></span><br><span class="line"><span class="comment">3.成员内部类</span></span><br><span class="line"><span class="comment">            一方面作为外部类的成员</span></span><br><span class="line"><span class="comment">                 调用外部内的结构</span></span><br><span class="line"><span class="comment">                 可以被static修饰</span></span><br><span class="line"><span class="comment">                 可以被4种不同的权限修饰符修饰</span></span><br><span class="line"><span class="comment">            另一方面，作为一个类：</span></span><br><span class="line"><span class="comment">                类内部可以定义属性、方法、构造器等</span></span><br><span class="line"><span class="comment">                可以被final修饰，表示此类不能被继承。不使用final就可以被继承</span></span><br><span class="line"><span class="comment">                可以被abstract修饰</span></span><br><span class="line"><span class="comment">4.关注如下的3个问题</span></span><br><span class="line"><span class="comment">    4.1 如何实例化成员内部类的对象</span></span><br><span class="line"><span class="comment">    4.2 如何在成员内部类中区分调节外部类的结构</span></span><br><span class="line"><span class="comment">    4.3 开发中局部内部类的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建Dog实例（静态成员内部类）</span></span><br><span class="line">        Person.Dog dog = <span class="keyword">new</span> Person.Dog();</span><br><span class="line">        dog.show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Bird实例（非静态的成员内部类）</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        Person.Bird bird = p.<span class="function">new <span class="title">Bird</span><span class="params">()</span></span>;</span><br><span class="line">        bird.sing();</span><br><span class="line">        bird.display(<span class="string">&quot;小鸟&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人：吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态成员内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;</span><br><span class="line">        String name = <span class="string">&quot;小狗&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;卡拉是条狗&quot;</span>);</span><br><span class="line">           <span class="comment">// eat();静态方法只能调用静态方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非静态成员内部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span>&#123;</span><br><span class="line">        String name = <span class="string">&quot;小猫&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Cat</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小猫抓老鼠&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Bird</span></span>&#123;</span><br><span class="line">        String name = <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是一只小小鸟&quot;</span>);</span><br><span class="line">            eat();<span class="comment">//完整写法应该为“Person.this.eat();&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;在Bird类里调用形参name：name:&quot;</span>+ name);</span><br><span class="line">            System.out.println(<span class="string">&quot;在Bird类里调用Bird类里面的name属性：this.name:&quot;</span>+<span class="keyword">this</span>.name);</span><br><span class="line">            System.out.println(<span class="string">&quot;在Bird类里调用外部类Person的name属性：Person.this.name:&quot;</span>+Person.<span class="keyword">this</span>.name);</span><br><span class="line">            System.out.println(<span class="string">&quot;在Bird类里调用外部类Person的静态Dog类里的name属性：new Dog.name:&quot;</span>+<span class="keyword">new</span> Dog().name);</span><br><span class="line">            System.out.println(<span class="string">&quot;在Bird类里调用外部类Person的非静态Cat类里的name属性：new Cat().name:&quot;</span>+<span class="keyword">new</span> Cat().name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">BB</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//局部内部类</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">CC</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>卡拉是条狗<br>我是一只小小鸟<br>人：吃饭<br>在Bird类里调用形参name：name:小鸟<br>在Bird类里调用Bird类里面的name属性：this.name:杜鹃<br>在Bird类里调用外部类Person的name属性：Person.this.name:小明<br>在Bird类里调用外部类Person的静态Dog类里的name属性：new Dog.name:小狗<br>在Bird类里调用外部类Person的非静态Cat类里的name属性：new Cat().name:小猫</p>
</blockquote>
<p><strong>InnerClassTest1.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> 内部类;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest1</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Comparable <span class="title">getComparable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个实现了Comparable接口的类：局部内部类</span></span><br><span class="line">        <span class="comment">//方式一</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyComparable</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyComparable();<span class="comment">//返回一个实现了接口的有名类的匿名对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        return new Comparable() &#123;  //返回一个实现了接口的匿名类的匿名对象</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public int compareTo(Object o) &#123;</span></span><br><span class="line"><span class="comment">                return 0;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="7-5-内部类使用注意事项"><a href="#7-5-内部类使用注意事项" class="headerlink" title="7.5 内部类使用注意事项"></a>7.5 内部类使用注意事项</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.java;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassTest</span> </span>&#123;	</span><br><span class="line"><span class="comment">//	public void onCreate()&#123;		</span></span><br><span class="line"><span class="comment">//		int number = 10;		</span></span><br><span class="line"><span class="comment">//		View.OnClickListern listener = new View.OnClickListener()&#123;		//			public void onClick()&#123;</span></span><br><span class="line"><span class="comment">//				System.out.println(&quot;hello!&quot;);</span></span><br><span class="line"><span class="comment">//				System.out.println(number);</span></span><br><span class="line"><span class="comment">//			&#125;	</span></span><br><span class="line"><span class="comment">//		&#125;		</span></span><br><span class="line"><span class="comment">//		button.setOnClickListener(listener);		</span></span><br><span class="line"><span class="comment">//	&#125;		</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 在局部内部类的方法中（比如：show）如果调用局部内部类所声明的方法(比如：method)中的局部变量(比如：num)的话,</span></span><br><span class="line"><span class="comment">* 要求此局部变量声明为final的。 </span></span><br><span class="line"><span class="comment">* jdk 7及之前版本：要求此局部变量显式的声明为final的</span></span><br><span class="line"><span class="comment">* jdk 8及之后的版本：可以省略final的声明</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//局部变量</span></span><br><span class="line">		<span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">AA</span></span>&#123;		</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//				num = 20;</span></span><br><span class="line">				System.out.println(num);	</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
